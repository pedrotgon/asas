"use strict";
"use client";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __restKey = (key) => typeof key === "symbol" ? key : key + "";
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.tsx
var src_exports = {};
__export(src_exports, {
  CopilotContext: () => CopilotContext,
  CopilotKit: () => CopilotKit,
  CopilotMessagesContext: () => CopilotMessagesContext,
  CopilotTask: () => CopilotTask,
  SUGGESTION_RETRY_CONFIG: () => SUGGESTION_RETRY_CONFIG,
  defaultCopilotContextCategories: () => defaultCopilotContextCategories,
  extract: () => extract,
  reloadSuggestions: () => reloadSuggestions,
  runAgent: () => runAgent,
  shouldShowDevConsole: () => shouldShowDevConsole,
  startAgent: () => startAgent,
  stopAgent: () => stopAgent,
  useCoAgent: () => useCoAgent,
  useCoAgentStateRender: () => useCoAgentStateRender,
  useCopilotAction: () => useCopilotAction,
  useCopilotAdditionalInstructions: () => useCopilotAdditionalInstructions,
  useCopilotAuthenticatedAction_c: () => useCopilotAuthenticatedAction_c,
  useCopilotChat: () => useCopilotChat2,
  useCopilotChatHeadless_c: () => useCopilotChatHeadless_c,
  useCopilotChatInternal: () => useCopilotChat,
  useCopilotContext: () => useCopilotContext,
  useCopilotMessagesContext: () => useCopilotMessagesContext,
  useCopilotReadable: () => useCopilotReadable,
  useCopilotRuntimeClient: () => useCopilotRuntimeClient,
  useDefaultTool: () => useDefaultTool,
  useFrontendTool: () => useFrontendTool,
  useHumanInTheLoop: () => useHumanInTheLoop,
  useLangGraphInterrupt: () => useLangGraphInterrupt,
  useLangGraphInterruptRender: () => useLangGraphInterruptRender,
  useMakeCopilotDocumentReadable: () => useMakeCopilotDocumentReadable,
  useRenderToolCall: () => useRenderToolCall
});
module.exports = __toCommonJS(src_exports);

// src/components/copilot-provider/copilotkit.tsx
var import_react12 = require("react");

// src/context/copilot-context.tsx
var import_react = __toESM(require("react"));
var emptyCopilotContext = {
  actions: {},
  setAction: () => {
  },
  removeAction: () => {
  },
  coAgentStateRenders: {},
  setCoAgentStateRender: () => {
  },
  removeCoAgentStateRender: () => {
  },
  chatComponentsCache: { current: { actions: {}, coAgentStateRenders: {} } },
  getContextString: (documents, categories) => returnAndThrowInDebug(""),
  addContext: () => "",
  removeContext: () => {
  },
  getAllContext: () => [],
  getFunctionCallHandler: () => returnAndThrowInDebug(() => __async(void 0, null, function* () {
  })),
  isLoading: false,
  setIsLoading: () => returnAndThrowInDebug(false),
  chatInstructions: "",
  setChatInstructions: () => returnAndThrowInDebug(""),
  additionalInstructions: [],
  setAdditionalInstructions: () => returnAndThrowInDebug([]),
  getDocumentsContext: (categories) => returnAndThrowInDebug([]),
  addDocumentContext: () => returnAndThrowInDebug(""),
  removeDocumentContext: () => {
  },
  runtimeClient: {},
  copilotApiConfig: new class {
    get chatApiEndpoint() {
      throw new Error("Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!");
    }
    get headers() {
      return {};
    }
    get body() {
      return {};
    }
  }(),
  chatSuggestionConfiguration: {},
  addChatSuggestionConfiguration: () => {
  },
  removeChatSuggestionConfiguration: () => {
  },
  showDevConsole: false,
  coagentStates: {},
  setCoagentStates: () => {
  },
  coagentStatesRef: { current: {} },
  setCoagentStatesWithRef: () => {
  },
  agentSession: null,
  setAgentSession: () => {
  },
  forwardedParameters: {},
  agentLock: null,
  threadId: "",
  setThreadId: () => {
  },
  runId: null,
  setRunId: () => {
  },
  chatAbortControllerRef: { current: null },
  availableAgents: [],
  extensions: {},
  setExtensions: () => {
  },
  langGraphInterruptAction: null,
  setLangGraphInterruptAction: () => {
  },
  removeLangGraphInterruptAction: () => {
  },
  onError: () => {
  },
  bannerError: null,
  setBannerError: () => {
  },
  internalErrorHandlers: {},
  setInternalErrorHandler: () => {
  },
  removeInternalErrorHandler: () => {
  }
};
var CopilotContext = import_react.default.createContext(emptyCopilotContext);
function useCopilotContext() {
  const context = import_react.default.useContext(CopilotContext);
  if (context === emptyCopilotContext) {
    throw new Error("Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!");
  }
  return context;
}
function returnAndThrowInDebug(_value) {
  throw new Error("Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!");
}

// src/hooks/use-tree.ts
var import_shared = require("@copilotkit/shared");
var import_react2 = require("react");
var removeNode = (nodes, id) => {
  return nodes.reduce((result, node) => {
    if (node.id !== id) {
      const newNode = __spreadProps(__spreadValues({}, node), { children: removeNode(node.children, id) });
      result.push(newNode);
    }
    return result;
  }, []);
};
var addNode = (nodes, newNode, parentId) => {
  if (!parentId) {
    return [...nodes, newNode];
  }
  return nodes.map((node) => {
    if (node.id === parentId) {
      return __spreadProps(__spreadValues({}, node), { children: [...node.children, newNode] });
    } else if (node.children.length) {
      return __spreadProps(__spreadValues({}, node), { children: addNode(node.children, newNode, parentId) });
    }
    return node;
  });
};
var treeIndentationRepresentation = (index, indentLevel) => {
  if (indentLevel === 0) {
    return (index + 1).toString();
  } else if (indentLevel === 1) {
    return String.fromCharCode(65 + index);
  } else if (indentLevel === 2) {
    return String.fromCharCode(97 + index);
  } else {
    return "-";
  }
};
var printNode = (node, prefix = "", indentLevel = 0) => {
  const indent = " ".repeat(3).repeat(indentLevel);
  const prefixPlusIndentLength = prefix.length + indent.length;
  const subsequentLinesPrefix = " ".repeat(prefixPlusIndentLength);
  const valueLines = node.value.split("\n");
  const outputFirstLine = `${indent}${prefix}${valueLines[0]}`;
  const outputSubsequentLines = valueLines.slice(1).map((line) => `${subsequentLinesPrefix}${line}`).join("\n");
  let output = `${outputFirstLine}
`;
  if (outputSubsequentLines) {
    output += `${outputSubsequentLines}
`;
  }
  const childPrePrefix = " ".repeat(prefix.length);
  node.children.forEach(
    (child, index) => output += printNode(
      child,
      `${childPrePrefix}${treeIndentationRepresentation(index, indentLevel + 1)}. `,
      indentLevel + 1
    )
  );
  return output;
};
function treeReducer(state, action) {
  switch (action.type) {
    case "ADD_NODE": {
      const { value, parentId, id: newNodeId } = action;
      const newNode = {
        id: newNodeId,
        value,
        children: [],
        categories: new Set(action.categories)
      };
      try {
        return addNode(state, newNode, parentId);
      } catch (error) {
        console.error(`Error while adding node with id ${newNodeId}: ${error}`);
        return state;
      }
    }
    case "REMOVE_NODE":
      return removeNode(state, action.id);
    default:
      return state;
  }
}
var useTree = () => {
  const [tree, dispatch] = (0, import_react2.useReducer)(treeReducer, []);
  const addElement = (0, import_react2.useCallback)(
    (value, categories, parentId) => {
      const newNodeId = (0, import_shared.randomId)();
      dispatch({
        type: "ADD_NODE",
        value,
        parentId,
        id: newNodeId,
        categories
      });
      return newNodeId;
    },
    []
  );
  const removeElement = (0, import_react2.useCallback)((id) => {
    dispatch({ type: "REMOVE_NODE", id });
  }, []);
  const getAllElements = (0, import_react2.useCallback)(() => {
    return tree;
  }, [tree]);
  const printTree = (0, import_react2.useCallback)(
    (categories) => {
      const categoriesSet = new Set(categories);
      let output = "";
      tree.forEach((node, index) => {
        if (!setsHaveIntersection(categoriesSet, node.categories)) {
          return;
        }
        if (index !== 0) {
          output += "\n";
        }
        output += printNode(node, `${treeIndentationRepresentation(index, 0)}. `);
      });
      return output;
    },
    [tree]
  );
  return { tree, addElement, printTree, removeElement, getAllElements };
};
var use_tree_default = useTree;
function setsHaveIntersection(setA, setB) {
  const [smallerSet, largerSet] = setA.size <= setB.size ? [setA, setB] : [setB, setA];
  for (let item of smallerSet) {
    if (largerSet.has(item)) {
      return true;
    }
  }
  return false;
}

// src/components/copilot-provider/copilotkit.tsx
var import_react_dom = require("react-dom");
var import_shared12 = require("@copilotkit/shared");

// src/hooks/use-flat-category-store.ts
var import_react3 = require("react");
var import_shared2 = require("@copilotkit/shared");
var useFlatCategoryStore = () => {
  const [elements, dispatch] = (0, import_react3.useReducer)(flatCategoryStoreReducer, /* @__PURE__ */ new Map());
  const addElement = (0, import_react3.useCallback)((value, categories) => {
    const newId = (0, import_shared2.randomId)();
    dispatch({
      type: "ADD_ELEMENT",
      value,
      id: newId,
      categories
    });
    return newId;
  }, []);
  const removeElement = (0, import_react3.useCallback)((id) => {
    dispatch({ type: "REMOVE_ELEMENT", id });
  }, []);
  const allElements = (0, import_react3.useCallback)(
    (categories) => {
      const categoriesSet = new Set(categories);
      const result = [];
      elements.forEach((element) => {
        if (setsHaveIntersection2(categoriesSet, element.categories)) {
          result.push(element.value);
        }
      });
      return result;
    },
    [elements]
  );
  return { addElement, removeElement, allElements };
};
var use_flat_category_store_default = useFlatCategoryStore;
function flatCategoryStoreReducer(state, action) {
  switch (action.type) {
    case "ADD_ELEMENT": {
      const { value, id, categories } = action;
      const newElement = {
        id,
        value,
        categories: new Set(categories)
      };
      const newState = new Map(state);
      newState.set(id, newElement);
      return newState;
    }
    case "REMOVE_ELEMENT": {
      const newState = new Map(state);
      newState.delete(action.id);
      return newState;
    }
    default:
      return state;
  }
}
function setsHaveIntersection2(setA, setB) {
  const [smallerSet, largerSet] = setA.size <= setB.size ? [setA, setB] : [setB, setA];
  for (let item of smallerSet) {
    if (largerSet.has(item)) {
      return true;
    }
  }
  return false;
}

// src/components/copilot-provider/copilot-messages.tsx
var import_react6 = require("react");

// src/context/copilot-messages-context.tsx
var import_react4 = __toESM(require("react"));
var emptyCopilotContext2 = {
  messages: [],
  setMessages: () => [],
  // suggestions state
  suggestions: [],
  setSuggestions: () => []
};
var CopilotMessagesContext = import_react4.default.createContext(emptyCopilotContext2);
function useCopilotMessagesContext() {
  const context = import_react4.default.useContext(CopilotMessagesContext);
  if (context === emptyCopilotContext2) {
    throw new Error(
      "A messages consuming component was not wrapped with `<CopilotMessages> {...} </CopilotMessages>`"
    );
  }
  return context;
}

// src/components/copilot-provider/copilot-messages.tsx
var import_runtime_client_gql = require("@copilotkit/runtime-client-gql");

// src/components/toast/toast-provider.tsx
var import_react5 = require("react");
var import_shared3 = require("@copilotkit/shared");
var import_jsx_runtime = require("react/jsx-runtime");
var ToastContext = (0, import_react5.createContext)(void 0);
function getErrorSeverity(error) {
  if (error.severity) {
    switch (error.severity) {
      case import_shared3.Severity.CRITICAL:
        return "critical";
      case import_shared3.Severity.WARNING:
        return "warning";
      case import_shared3.Severity.INFO:
        return "info";
      default:
        return "info";
    }
  }
  const message = error.message.toLowerCase();
  if (message.includes("api key") || message.includes("401") || message.includes("unauthorized") || message.includes("authentication") || message.includes("incorrect api key")) {
    return "critical";
  }
  return "info";
}
function getErrorColors(severity) {
  switch (severity) {
    case "critical":
      return {
        background: "#fee2e2",
        border: "#dc2626",
        text: "#7f1d1d",
        icon: "#dc2626"
      };
    case "warning":
      return {
        background: "#fef3c7",
        border: "#d97706",
        text: "#78350f",
        icon: "#d97706"
      };
    case "info":
      return {
        background: "#dbeafe",
        border: "#2563eb",
        text: "#1e3a8a",
        icon: "#2563eb"
      };
  }
}
function useToast() {
  const context = (0, import_react5.useContext)(ToastContext);
  if (!context) {
    throw new Error("useToast must be used within a ToastProvider");
  }
  return context;
}
function ToastProvider({
  enabled,
  children
}) {
  const [toasts, setToasts] = (0, import_react5.useState)([]);
  const [bannerError, setBannerErrorState] = (0, import_react5.useState)(null);
  const removeToast = (0, import_react5.useCallback)((id) => {
    setToasts((prev) => prev.filter((toast) => toast.id !== id));
  }, []);
  const addToast = (0, import_react5.useCallback)(
    (toast) => {
      var _a;
      if (!enabled) {
        return;
      }
      const id = (_a = toast.id) != null ? _a : Math.random().toString(36).substring(2, 9);
      setToasts((currentToasts) => {
        if (currentToasts.find((toast2) => toast2.id === id))
          return currentToasts;
        return [...currentToasts, __spreadProps(__spreadValues({}, toast), { id })];
      });
      if (toast.duration) {
        setTimeout(() => {
          removeToast(id);
        }, toast.duration);
      }
    },
    [enabled, removeToast]
  );
  const setBannerError = (0, import_react5.useCallback)(
    (error) => {
      if (!enabled && error !== null) {
        return;
      }
      setBannerErrorState(error);
    },
    [enabled]
  );
  const addGraphQLErrorsToast = (0, import_react5.useCallback)((errors) => {
    console.warn("addGraphQLErrorsToast is deprecated. All errors now show as banners.");
  }, []);
  const value = {
    toasts,
    addToast,
    addGraphQLErrorsToast,
    removeToast,
    enabled,
    bannerError,
    setBannerError
  };
  return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(ToastContext.Provider, { value, children: [
    bannerError && (() => {
      const severity = getErrorSeverity(bannerError);
      const colors = getErrorColors(severity);
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "div",
        {
          style: {
            position: "fixed",
            bottom: "20px",
            left: "50%",
            transform: "translateX(-50%)",
            zIndex: 9999,
            backgroundColor: colors.background,
            border: `1px solid ${colors.border}`,
            borderLeft: `4px solid ${colors.border}`,
            borderRadius: "8px",
            padding: "12px 16px",
            fontSize: "13px",
            boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
            backdropFilter: "blur(8px)",
            maxWidth: "min(90vw, 700px)",
            width: "100%",
            boxSizing: "border-box",
            overflow: "hidden"
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
            "div",
            {
              style: {
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                gap: "10px"
              },
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
                  "div",
                  {
                    style: {
                      display: "flex",
                      alignItems: "center",
                      gap: "8px",
                      flex: 1,
                      minWidth: 0
                    },
                    children: [
                      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                        "div",
                        {
                          style: {
                            width: "12px",
                            height: "12px",
                            borderRadius: "50%",
                            backgroundColor: colors.border,
                            flexShrink: 0
                          }
                        }
                      ),
                      /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
                        "div",
                        {
                          style: {
                            display: "flex",
                            alignItems: "center",
                            gap: "10px",
                            flex: 1,
                            minWidth: 0
                          },
                          children: [
                            /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                              "div",
                              {
                                style: {
                                  color: colors.text,
                                  lineHeight: "1.4",
                                  fontWeight: "400",
                                  fontSize: "13px",
                                  flex: 1,
                                  wordBreak: "break-all",
                                  overflowWrap: "break-word",
                                  maxWidth: "550px",
                                  overflow: "hidden",
                                  display: "-webkit-box",
                                  WebkitLineClamp: 10,
                                  WebkitBoxOrient: "vertical"
                                },
                                children: (() => {
                                  let message = bannerError.message;
                                  const jsonMatch = message.match(/'message':\s*'([^']+)'/);
                                  if (jsonMatch) {
                                    return jsonMatch[1];
                                  }
                                  message = message.split(" - ")[0];
                                  message = message.split(": Error code")[0];
                                  message = message.replace(/:\s*\d{3}$/, "");
                                  message = message.replace(/See more:.*$/g, "");
                                  message = message.trim();
                                  return message || "Configuration error occurred.";
                                })()
                              }
                            ),
                            (() => {
                              const message = bannerError.message;
                              const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
                              const plainUrlRegex = /(https?:\/\/[^\s)]+)/g;
                              let url = null;
                              let buttonText = "See More";
                              const markdownMatch = markdownLinkRegex.exec(message);
                              if (markdownMatch) {
                                url = markdownMatch[2];
                                buttonText = "See More";
                              } else {
                                const urlMatch = plainUrlRegex.exec(message);
                                if (urlMatch) {
                                  url = urlMatch[0].replace(/[.,;:'"]*$/, "");
                                  buttonText = "See More";
                                }
                              }
                              if (!url)
                                return null;
                              return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                                "button",
                                {
                                  onClick: () => window.open(url, "_blank", "noopener,noreferrer"),
                                  style: {
                                    background: colors.border,
                                    color: "white",
                                    border: "none",
                                    borderRadius: "5px",
                                    padding: "4px 10px",
                                    fontSize: "11px",
                                    fontWeight: "500",
                                    cursor: "pointer",
                                    transition: "all 0.2s ease",
                                    flexShrink: 0
                                  },
                                  onMouseEnter: (e) => {
                                    e.currentTarget.style.opacity = "0.9";
                                    e.currentTarget.style.transform = "translateY(-1px)";
                                  },
                                  onMouseLeave: (e) => {
                                    e.currentTarget.style.opacity = "1";
                                    e.currentTarget.style.transform = "translateY(0)";
                                  },
                                  children: buttonText
                                }
                              );
                            })()
                          ]
                        }
                      )
                    ]
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
                  "button",
                  {
                    onClick: () => setBannerError(null),
                    style: {
                      background: "transparent",
                      border: "none",
                      color: colors.text,
                      cursor: "pointer",
                      padding: "2px",
                      borderRadius: "3px",
                      fontSize: "14px",
                      lineHeight: "1",
                      opacity: 0.6,
                      transition: "all 0.2s ease",
                      flexShrink: 0
                    },
                    title: "Dismiss",
                    onMouseEnter: (e) => {
                      e.currentTarget.style.opacity = "1";
                      e.currentTarget.style.background = "rgba(0, 0, 0, 0.05)";
                    },
                    onMouseLeave: (e) => {
                      e.currentTarget.style.opacity = "0.6";
                      e.currentTarget.style.background = "transparent";
                    },
                    children: "\xD7"
                  }
                )
              ]
            }
          )
        }
      );
    })(),
    children
  ] });
}

// src/utils/dev-console.ts
function isLocalhost() {
  if (typeof window === "undefined")
    return false;
  return window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1" || window.location.hostname === "0.0.0.0";
}
function shouldShowDevConsole(showDevConsole) {
  if (showDevConsole !== void 0) {
    return showDevConsole;
  }
  return isLocalhost();
}

// src/components/copilot-provider/copilot-messages.tsx
var import_shared4 = require("@copilotkit/shared");
var import_jsx_runtime2 = require("react/jsx-runtime");
var MessagesTapContext = (0, import_react6.createContext)(null);
function useMessagesTap() {
  const tap = (0, import_react6.useContext)(MessagesTapContext);
  if (!tap)
    throw new Error("useMessagesTap must be used inside <MessagesTapProvider>");
  return tap;
}
function MessagesTapProvider({ children }) {
  const messagesRef = (0, import_react6.useRef)([]);
  const tapRef = (0, import_react6.useRef)({
    getMessagesFromTap: () => messagesRef.current,
    updateTapMessages: (messages) => {
      messagesRef.current = messages;
    }
  });
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(MessagesTapContext.Provider, { value: tapRef.current, children });
}
function CopilotMessages({ children }) {
  const [messages, setMessages] = (0, import_react6.useState)([]);
  const lastLoadedThreadId = (0, import_react6.useRef)();
  const lastLoadedAgentName = (0, import_react6.useRef)();
  const lastLoadedMessages = (0, import_react6.useRef)();
  const { updateTapMessages } = useMessagesTap();
  const { threadId, agentSession, runtimeClient, showDevConsole, onError, copilotApiConfig } = useCopilotContext();
  const { setBannerError } = useToast();
  const traceUIError = (0, import_react6.useCallback)(
    (error, originalError) => __async(this, null, function* () {
      if (!onError || !copilotApiConfig.publicApiKey)
        return;
      try {
        const traceEvent = {
          type: "error",
          timestamp: Date.now(),
          context: {
            source: "ui",
            request: {
              operation: "loadAgentState",
              url: copilotApiConfig.chatApiEndpoint,
              startTime: Date.now()
            },
            technical: {
              environment: "browser",
              userAgent: typeof navigator !== "undefined" ? navigator.userAgent : void 0,
              stackTrace: originalError instanceof Error ? originalError.stack : void 0
            }
          },
          error
        };
        yield onError(traceEvent);
      } catch (traceError) {
        console.error("Error in CopilotMessages onError handler:", traceError);
      }
    }),
    [onError, copilotApiConfig.publicApiKey, copilotApiConfig.chatApiEndpoint]
  );
  const createStructuredError2 = (gqlError) => {
    const extensions = gqlError.extensions;
    const originalError = extensions == null ? void 0 : extensions.originalError;
    if (originalError == null ? void 0 : originalError.stack) {
      if (originalError.stack.includes("CopilotApiDiscoveryError")) {
        return new import_shared4.CopilotKitApiDiscoveryError({ message: originalError.message });
      }
      if (originalError.stack.includes("CopilotKitRemoteEndpointDiscoveryError")) {
        return new import_shared4.CopilotKitRemoteEndpointDiscoveryError({ message: originalError.message });
      }
      if (originalError.stack.includes("CopilotKitAgentDiscoveryError")) {
        return new import_shared4.CopilotKitAgentDiscoveryError({
          agentName: "",
          availableAgents: []
        });
      }
    }
    const message = (originalError == null ? void 0 : originalError.message) || gqlError.message;
    const code = extensions == null ? void 0 : extensions.code;
    if (code) {
      return new import_shared4.CopilotKitError({ message, code });
    }
    return null;
  };
  const handleGraphQLErrors = (0, import_react6.useCallback)(
    (error) => {
      var _a;
      if ((_a = error.graphQLErrors) == null ? void 0 : _a.length) {
        const graphQLErrors = error.graphQLErrors;
        const routeError = (gqlError) => {
          const extensions = gqlError.extensions;
          const visibility = extensions == null ? void 0 : extensions.visibility;
          const isDev = shouldShowDevConsole(showDevConsole);
          if (!isDev) {
            console.error("CopilotKit Error (hidden in production):", gqlError.message);
            return;
          }
          if (visibility === import_shared4.ErrorVisibility.SILENT) {
            console.error("CopilotKit Silent Error:", gqlError.message);
            return;
          }
          const ckError = createStructuredError2(gqlError);
          if (ckError) {
            setBannerError(ckError);
            traceUIError(ckError, gqlError);
          } else {
            const fallbackError = new import_shared4.CopilotKitError({
              message: gqlError.message,
              code: import_shared4.CopilotKitErrorCode.UNKNOWN
            });
            setBannerError(fallbackError);
            traceUIError(fallbackError, gqlError);
          }
        };
        graphQLErrors.forEach(routeError);
      } else {
        const isDev = shouldShowDevConsole(showDevConsole);
        if (!isDev) {
          console.error("CopilotKit Error (hidden in production):", error);
        } else {
          const fallbackError = new import_shared4.CopilotKitError({
            message: (error == null ? void 0 : error.message) || String(error),
            code: import_shared4.CopilotKitErrorCode.UNKNOWN
          });
          setBannerError(fallbackError);
          traceUIError(fallbackError, error);
        }
      }
    },
    [setBannerError, showDevConsole, traceUIError]
  );
  (0, import_react6.useEffect)(() => {
    if (!threadId || threadId === lastLoadedThreadId.current)
      return;
    if (threadId === lastLoadedThreadId.current && (agentSession == null ? void 0 : agentSession.agentName) === lastLoadedAgentName.current) {
      return;
    }
    const fetchMessages = () => __async(this, null, function* () {
      var _a, _b, _c;
      if (!(agentSession == null ? void 0 : agentSession.agentName))
        return;
      const result = yield runtimeClient.loadAgentState({
        threadId,
        agentName: agentSession == null ? void 0 : agentSession.agentName
      });
      if (result.error) {
        lastLoadedThreadId.current = threadId;
        lastLoadedAgentName.current = agentSession == null ? void 0 : agentSession.agentName;
        handleGraphQLErrors(result.error);
        return;
      }
      const newMessages = (_b = (_a = result.data) == null ? void 0 : _a.loadAgentState) == null ? void 0 : _b.messages;
      if (newMessages === lastLoadedMessages.current)
        return;
      if ((_c = result.data) == null ? void 0 : _c.loadAgentState) {
        lastLoadedMessages.current = newMessages;
        lastLoadedThreadId.current = threadId;
        lastLoadedAgentName.current = agentSession == null ? void 0 : agentSession.agentName;
        const messages2 = (0, import_runtime_client_gql.loadMessagesFromJsonRepresentation)(JSON.parse(newMessages || "[]"));
        setMessages(messages2);
      }
    });
    void fetchMessages();
  }, [threadId, agentSession == null ? void 0 : agentSession.agentName]);
  (0, import_react6.useEffect)(() => {
    updateTapMessages(messages);
  }, [messages, updateTapMessages]);
  const memoizedChildren = (0, import_react6.useMemo)(() => children, [children]);
  const [suggestions, setSuggestions] = (0, import_react6.useState)([]);
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
    CopilotMessagesContext.Provider,
    {
      value: {
        messages,
        setMessages,
        suggestions,
        setSuggestions
      },
      children: memoizedChildren
    }
  );
}

// src/components/usage-banner.tsx
var import_shared5 = require("@copilotkit/shared");
var import_jsx_runtime3 = require("react/jsx-runtime");
function UsageBanner({
  severity = import_shared5.Severity.CRITICAL,
  message = "",
  onClose,
  actions
}) {
  if (!message || !severity) {
    return null;
  }
  const themes = {
    [import_shared5.Severity.INFO]: {
      bg: "#f8fafc",
      border: "#e2e8f0",
      text: "#475569",
      accent: "#3b82f6"
    },
    [import_shared5.Severity.WARNING]: {
      bg: "#fffbeb",
      border: "#fbbf24",
      text: "#92400e",
      accent: "#f59e0b"
    },
    [import_shared5.Severity.CRITICAL]: {
      bg: "#fef2f2",
      border: "#fecaca",
      text: "#dc2626",
      accent: "#ef4444"
    }
  };
  const theme = themes[severity];
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("style", { children: `
          @keyframes slideUp {
            from { opacity: 0; transform: translateX(-50%) translateY(8px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
          }
          
          .usage-banner {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            width: min(600px, calc(100vw - 32px));
            z-index: 10000;
            animation: slideUp 0.2s cubic-bezier(0.16, 1, 0.3, 1);
          }
          
          .banner-content {
            background: linear-gradient(135deg, ${theme.bg} 0%, ${theme.bg}f5 100%);
            border: 1px solid ${theme.border};
            border-radius: 12px;
            padding: 18px 20px;
            box-shadow: 
              0 4px 24px rgba(0, 0, 0, 0.08),
              0 2px 8px rgba(0, 0, 0, 0.04),
              inset 0 1px 0 rgba(255, 255, 255, 0.7);
            display: flex;
            align-items: center;
            gap: 16px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            backdrop-filter: blur(12px);
            position: relative;
            overflow: hidden;
          }
          
          .banner-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, ${theme.accent}40, transparent);
          }
          
          .banner-message {
            color: ${theme.text};
            font-size: 14px;
            line-height: 1.5;
            font-weight: 500;
            flex: 1;
            letter-spacing: -0.01em;
          }
          
          .close-btn {
            background: rgba(0, 0, 0, 0.05);
            border: none;
            color: ${theme.text};
            cursor: pointer;
            padding: 0;
            border-radius: 6px;
            opacity: 0.6;
            transition: all 0.15s cubic-bezier(0.16, 1, 0.3, 1);
            font-size: 14px;
            line-height: 1;
            flex-shrink: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
          }
          
          .close-btn:hover {
            opacity: 1;
            background: rgba(0, 0, 0, 0.08);
            transform: scale(1.05);
          }
          
          .btn-primary {
            background: linear-gradient(135deg, ${theme.accent} 0%, ${theme.accent}e6 100%);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 18px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s cubic-bezier(0.16, 1, 0.3, 1);
            font-family: inherit;
            flex-shrink: 0;
            box-shadow: 
              0 2px 8px ${theme.accent}30,
              inset 0 1px 0 rgba(255, 255, 255, 0.2);
            letter-spacing: -0.01em;
          }
          
          .btn-primary:hover {
            transform: translateY(-1px) scale(1.02);
            box-shadow: 
              0 4px 12px ${theme.accent}40,
              inset 0 1px 0 rgba(255, 255, 255, 0.25);
          }
          
          .btn-primary:active {
            transform: translateY(0) scale(0.98);
            transition: all 0.08s cubic-bezier(0.16, 1, 0.3, 1);
          }
          
          @media (max-width: 640px) {
            .usage-banner {
              width: calc(100vw - 24px);
            }
            
            .banner-content {
              padding: 16px;
              gap: 12px;
            }
            
            .banner-message {
              font-size: 13px;
              line-height: 1.45;
            }
            
            .btn-primary {
              padding: 8px 14px;
              font-size: 12px;
            }
            
            .close-btn {
              width: 22px;
              height: 22px;
              font-size: 12px;
            }
          }
        ` }),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "usage-banner", children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "banner-content", children: [
      /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("div", { className: "banner-message", children: message }),
      (actions == null ? void 0 : actions.primary) && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("button", { className: "btn-primary", onClick: actions.primary.onClick, children: actions.primary.label }),
      onClose && /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("button", { className: "close-btn", onClick: onClose, title: "Close", children: "\xD7" })
    ] }) })
  ] });
}
var getErrorActions = (error) => {
  switch (error.code) {
    case import_shared5.CopilotKitErrorCode.MISSING_PUBLIC_API_KEY_ERROR:
      return {
        primary: {
          label: "Show me how",
          onClick: () => window.open(
            "https://docs.copilotkit.ai/premium#how-do-i-get-access-to-premium-features",
            "_blank",
            "noopener,noreferrer"
          )
        }
      };
    case import_shared5.CopilotKitErrorCode.UPGRADE_REQUIRED_ERROR:
      return {
        primary: {
          label: "Upgrade",
          onClick: () => window.open("https://cloud.copilotkit.ai", "_blank", "noopener,noreferrer")
        }
      };
    default:
      return void 0;
  }
};

// src/hooks/use-copilot-runtime-client.ts
var import_runtime_client_gql2 = require("@copilotkit/runtime-client-gql");
var import_react7 = require("react");
var import_shared6 = require("@copilotkit/shared");
var useCopilotRuntimeClient = (options) => {
  const { setBannerError } = useToast();
  const _a = options, { showDevConsole, onError } = _a, runtimeOptions = __objRest(_a, ["showDevConsole", "onError"]);
  const lastStructuredErrorRef = (0, import_react7.useRef)(null);
  const traceUIError = (error, originalError) => __async(void 0, null, function* () {
    try {
      const errorEvent = {
        type: "error",
        timestamp: Date.now(),
        context: {
          source: "ui",
          request: {
            operation: "runtimeClient",
            url: runtimeOptions.url,
            startTime: Date.now()
          },
          technical: {
            environment: "browser",
            userAgent: typeof navigator !== "undefined" ? navigator.userAgent : void 0,
            stackTrace: originalError instanceof Error ? originalError.stack : void 0
          }
        },
        error
      };
      yield onError(errorEvent);
    } catch (error2) {
      console.error("Error in onError handler:", error2);
    }
  });
  const runtimeClient = (0, import_react7.useMemo)(() => {
    return new import_runtime_client_gql2.CopilotRuntimeClient(__spreadProps(__spreadValues({}, runtimeOptions), {
      handleGQLErrors: (error) => {
        var _a2;
        if ((_a2 = error.graphQLErrors) == null ? void 0 : _a2.length) {
          const graphQLErrors = error.graphQLErrors;
          const routeError = (gqlError) => {
            const extensions = gqlError.extensions;
            const visibility = extensions == null ? void 0 : extensions.visibility;
            if (visibility === import_shared6.ErrorVisibility.SILENT) {
              console.error("CopilotKit Silent Error:", gqlError.message);
              return;
            }
            const now = Date.now();
            const errorMessage = gqlError.message;
            if (lastStructuredErrorRef.current && lastStructuredErrorRef.current.message === errorMessage && now - lastStructuredErrorRef.current.timestamp < 150) {
              return;
            }
            lastStructuredErrorRef.current = { message: errorMessage, timestamp: now };
            const ckError = createStructuredError(gqlError);
            if (ckError) {
              setBannerError(ckError);
              traceUIError(ckError, gqlError);
            } else {
              const fallbackError = new import_shared6.CopilotKitError({
                message: gqlError.message,
                code: import_shared6.CopilotKitErrorCode.UNKNOWN
              });
              setBannerError(fallbackError);
              traceUIError(fallbackError, gqlError);
            }
          };
          graphQLErrors.forEach(routeError);
        } else {
          const fallbackError = new import_shared6.CopilotKitError({
            message: (error == null ? void 0 : error.message) || String(error),
            code: import_shared6.CopilotKitErrorCode.UNKNOWN
          });
          setBannerError(fallbackError);
          traceUIError(fallbackError, error);
        }
      },
      handleGQLWarning: (message) => {
        console.warn(message);
        const warningError = new import_shared6.CopilotKitError({
          message,
          code: import_shared6.CopilotKitErrorCode.UNKNOWN
        });
        setBannerError(warningError);
      }
    }));
  }, [runtimeOptions, setBannerError, onError]);
  return runtimeClient;
};
function createStructuredError(gqlError) {
  var _a, _b, _c;
  const extensions = gqlError.extensions;
  const originalError = extensions == null ? void 0 : extensions.originalError;
  const message = (originalError == null ? void 0 : originalError.message) || gqlError.message;
  const code = extensions == null ? void 0 : extensions.code;
  if (code) {
    return new import_shared6.CopilotKitError({ message, code });
  }
  if ((_a = originalError == null ? void 0 : originalError.stack) == null ? void 0 : _a.includes("CopilotApiDiscoveryError")) {
    return new import_shared6.CopilotKitApiDiscoveryError({ message });
  }
  if ((_b = originalError == null ? void 0 : originalError.stack) == null ? void 0 : _b.includes("CopilotKitRemoteEndpointDiscoveryError")) {
    return new import_shared6.CopilotKitRemoteEndpointDiscoveryError({ message });
  }
  if ((_c = originalError == null ? void 0 : originalError.stack) == null ? void 0 : _c.includes("CopilotKitAgentDiscoveryError")) {
    return new import_shared6.CopilotKitAgentDiscoveryError({
      agentName: "",
      availableAgents: []
    });
  }
  return null;
}

// src/utils/extract.ts
var import_shared7 = require("@copilotkit/shared");
var import_runtime_client_gql3 = require("@copilotkit/runtime-client-gql");
var import_runtime_client_gql4 = require("@copilotkit/runtime-client-gql");
function extract(_0) {
  return __async(this, arguments, function* ({
    context,
    instructions,
    parameters,
    include,
    data,
    abortSignal,
    stream,
    requestType = import_runtime_client_gql3.CopilotRequestType.Task,
    forwardedParameters
  }) {
    var _a, _b;
    const { messages } = context;
    const action = {
      name: "extract",
      description: instructions,
      parameters,
      handler: (args) => {
      }
    };
    const includeReadable = (_a = include == null ? void 0 : include.readable) != null ? _a : false;
    const includeMessages = (_b = include == null ? void 0 : include.messages) != null ? _b : false;
    let contextString = "";
    if (data) {
      contextString = (typeof data === "string" ? data : JSON.stringify(data)) + "\n\n";
    }
    if (includeReadable) {
      contextString += context.getContextString([], defaultCopilotContextCategories);
    }
    const systemMessage = new import_runtime_client_gql3.TextMessage({
      content: makeSystemMessage(contextString, instructions),
      role: import_runtime_client_gql3.Role.System
    });
    const instructionsMessage = new import_runtime_client_gql3.TextMessage({
      content: makeInstructionsMessage(instructions),
      role: import_runtime_client_gql3.Role.User
    });
    const response = context.runtimeClient.asStream(
      context.runtimeClient.generateCopilotResponse({
        data: {
          frontend: {
            actions: [
              {
                name: action.name,
                description: action.description || "",
                jsonSchema: JSON.stringify((0, import_shared7.actionParametersToJsonSchema)(action.parameters || []))
              }
            ],
            url: window.location.href
          },
          messages: (0, import_runtime_client_gql4.convertMessagesToGqlInput)(
            includeMessages ? [systemMessage, instructionsMessage, ...(0, import_runtime_client_gql4.filterAgentStateMessages)(messages)] : [systemMessage, instructionsMessage]
          ),
          metadata: {
            requestType
          },
          forwardedParameters: __spreadProps(__spreadValues({}, forwardedParameters != null ? forwardedParameters : {}), {
            toolChoice: "function",
            toolChoiceFunctionName: action.name
          })
        },
        properties: context.copilotApiConfig.properties,
        signal: abortSignal
      })
    );
    const reader = response.getReader();
    let isInitial = true;
    let actionExecutionMessage = void 0;
    while (true) {
      const { done, value } = yield reader.read();
      if (done) {
        break;
      }
      if (abortSignal == null ? void 0 : abortSignal.aborted) {
        throw new Error("Aborted");
      }
      actionExecutionMessage = (0, import_runtime_client_gql3.convertGqlOutputToMessages)(
        value.generateCopilotResponse.messages
      ).find((msg) => msg.isActionExecutionMessage());
      if (!actionExecutionMessage) {
        continue;
      }
      stream == null ? void 0 : stream({
        status: isInitial ? "initial" : "inProgress",
        args: actionExecutionMessage.arguments
      });
      isInitial = false;
    }
    if (!actionExecutionMessage) {
      throw new Error("extract() failed: No function call occurred");
    }
    stream == null ? void 0 : stream({
      status: "complete",
      args: actionExecutionMessage.arguments
    });
    return actionExecutionMessage.arguments;
  });
}
function makeInstructionsMessage(instructions) {
  return `
The user has given you the following task to complete:

\`\`\`
${instructions}
\`\`\`

Any additional messages provided are for providing context only and should not be used to ask questions or engage in conversation.
`;
}
function makeSystemMessage(contextString, instructions) {
  return `
Please act as an efficient, competent, conscientious, and industrious professional assistant.

Help the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.
Always be polite and respectful, and prefer brevity over verbosity.

The user has provided you with the following context:
\`\`\`
${contextString}
\`\`\`

They have also provided you with a function called extract you MUST call to initiate actions on their behalf.

Please assist them as best you can.

This is not a conversation, so please do not ask questions. Just call the function without saying anything else.
`;
}

// src/utils/suggestions.ts
var import_shared8 = require("@copilotkit/shared");
var import_runtime_client_gql5 = require("@copilotkit/runtime-client-gql");
var reloadSuggestions = (context, chatSuggestionConfiguration, setCurrentSuggestions, abortControllerRef) => __async(void 0, null, function* () {
  const abortController = abortControllerRef.current;
  if (abortController == null ? void 0 : abortController.signal.aborted) {
    return;
  }
  const setSuggestionsIfNotAborted = (suggestions) => {
    if (!(abortController == null ? void 0 : abortController.signal.aborted) && abortControllerRef.current === abortController) {
      setCurrentSuggestions(suggestions);
    }
  };
  try {
    const tools = JSON.stringify(
      Object.values(context.actions).map((action) => ({
        name: action.name,
        description: action.description,
        jsonSchema: JSON.stringify((0, import_shared8.actionParametersToJsonSchema)(action.parameters))
      }))
    );
    const allSuggestions = [];
    let hasSuccessfulSuggestions = false;
    let hasErrors = false;
    let lastError = null;
    const enabledConfigs = Object.values(chatSuggestionConfiguration).filter(
      (config) => config.instructions && config.instructions.trim().length > 0
    );
    if (enabledConfigs.length === 0) {
      return;
    }
    setSuggestionsIfNotAborted([]);
    for (const config of enabledConfigs) {
      if (abortController == null ? void 0 : abortController.signal.aborted) {
        setSuggestionsIfNotAborted([]);
        return;
      }
      try {
        const result = yield extract({
          context,
          instructions: "Suggest what the user could say next. Provide clear, highly relevant suggestions. Do not literally suggest function calls. ",
          data: `${config.instructions}

Available tools: ${tools}

`,
          requestType: import_runtime_client_gql5.CopilotRequestType.Task,
          parameters: [
            {
              name: "suggestions",
              type: "object[]",
              attributes: [
                {
                  name: "title",
                  description: "The title of the suggestion. This is shown as a button and should be short.",
                  type: "string"
                },
                {
                  name: "message",
                  description: "The message to send when the suggestion is clicked. This should be a clear, complete sentence and will be sent as an instruction to the AI.",
                  type: "string"
                }
              ]
            }
          ],
          include: {
            messages: true,
            readable: true
          },
          abortSignal: abortController == null ? void 0 : abortController.signal,
          stream: ({ status, args }) => {
            if (abortController == null ? void 0 : abortController.signal.aborted) {
              return;
            }
            const suggestions = args.suggestions || [];
            const newSuggestions = [];
            for (let i = 0; i < suggestions.length; i++) {
              if (config.maxSuggestions !== void 0 && i >= config.maxSuggestions) {
                break;
              }
              const suggestion = suggestions[i];
              if (!suggestion || typeof suggestion !== "object") {
                continue;
              }
              const { title, message } = suggestion;
              const hasValidTitle = title && typeof title === "string" && title.trim().length > 0;
              const hasValidMessage = message && typeof message === "string" && message.trim().length > 0;
              if (!hasValidTitle) {
                continue;
              }
              const partial = i === suggestions.length - 1 && status !== "complete";
              newSuggestions.push({
                title: title.trim(),
                message: hasValidMessage ? message.trim() : "",
                // Use title as fallback
                partial,
                className: config.className
              });
            }
            setSuggestionsIfNotAborted([...allSuggestions, ...newSuggestions]);
          }
        });
        if ((result == null ? void 0 : result.suggestions) && Array.isArray(result.suggestions)) {
          const validSuggestions = result.suggestions.filter(
            (suggestion) => suggestion && typeof suggestion.title === "string" && suggestion.title.trim().length > 0
          ).map((suggestion) => ({
            title: suggestion.title.trim(),
            message: suggestion.message && typeof suggestion.message === "string" && suggestion.message.trim() ? suggestion.message.trim() : suggestion.title.trim()
          }));
          if (validSuggestions.length > 0) {
            allSuggestions.push(...validSuggestions);
            hasSuccessfulSuggestions = true;
          }
        }
      } catch (error) {
        hasErrors = true;
        lastError = error instanceof Error ? error : new Error(String(error));
      }
    }
    if (hasSuccessfulSuggestions && allSuggestions.length > 0) {
      const uniqueSuggestions = allSuggestions.filter(
        (suggestion, index, self) => index === self.findIndex((s) => s.message === suggestion.message)
      );
      setSuggestionsIfNotAborted(uniqueSuggestions);
    } else if (hasErrors) {
      const errorMessage = lastError ? lastError.message : "Failed to generate suggestions due to API errors";
      throw new Error(errorMessage);
    }
  } catch (error) {
    throw error;
  }
});

// src/utils/suggestions-constants.ts
var SUGGESTION_RETRY_CONFIG = {
  MAX_RETRIES: 3,
  COOLDOWN_MS: 5e3
  // 5 seconds
};

// src/components/error-boundary/error-boundary.tsx
var import_react9 = __toESM(require("react"));
var import_shared10 = require("@copilotkit/shared");

// src/lib/status-checker.ts
var import_shared9 = require("@copilotkit/shared");
var STATUS_CHECK_INTERVAL = 1e3 * 60 * 5;
var StatusChecker = class {
  constructor() {
    this.activeKey = null;
    this.intervalId = null;
    this.instanceCount = 0;
    this.lastResponse = null;
  }
  start(publicApiKey, onUpdate) {
    return __async(this, null, function* () {
      this.instanceCount++;
      if (this.activeKey === publicApiKey)
        return;
      if (this.intervalId)
        clearInterval(this.intervalId);
      const checkStatus = () => __async(this, null, function* () {
        try {
          const response = yield fetch(`${import_shared9.COPILOT_CLOUD_API_URL}/ciu`, {
            method: "GET",
            headers: {
              [import_shared9.COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: publicApiKey
            }
          }).then((response2) => response2.json());
          this.lastResponse = response;
          onUpdate == null ? void 0 : onUpdate(response);
          return response;
        } catch (error) {
          return null;
        }
      });
      const initialResponse = yield checkStatus();
      this.intervalId = setInterval(checkStatus, STATUS_CHECK_INTERVAL);
      this.activeKey = publicApiKey;
      return initialResponse;
    });
  }
  getLastResponse() {
    return this.lastResponse;
  }
  stop() {
    this.instanceCount--;
    if (this.instanceCount === 0) {
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
        this.activeKey = null;
        this.lastResponse = null;
      }
    }
  }
};

// src/components/error-boundary/error-utils.tsx
var import_react8 = require("react");

// src/components/toast/exclamation-mark-icon.tsx
var import_jsx_runtime4 = require("react/jsx-runtime");
var ExclamationMarkIcon = ({
  className,
  style
}) => /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    className: `lucide lucide-circle-alert ${className ? className : ""}`,
    style,
    children: [
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("circle", { cx: "12", cy: "12", r: "10" }),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("line", { x1: "12", x2: "12", y1: "8", y2: "12" }),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("line", { x1: "12", x2: "12.01", y1: "16", y2: "16" })
    ]
  }
);

// src/components/error-boundary/error-utils.tsx
var import_react_markdown = __toESM(require("react-markdown"));
var import_jsx_runtime5 = require("react/jsx-runtime");
function ErrorToast({ errors }) {
  const errorsToRender = errors.map((error, idx) => {
    var _a, _b, _c;
    const originalError = "extensions" in error ? (_a = error.extensions) == null ? void 0 : _a.originalError : {};
    const message = (_b = originalError == null ? void 0 : originalError.message) != null ? _b : error.message;
    const code = "extensions" in error ? (_c = error.extensions) == null ? void 0 : _c.code : null;
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(
      "div",
      {
        style: {
          marginTop: idx === 0 ? 0 : 10,
          marginBottom: 14
        },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(ExclamationMarkIcon, { style: { marginBottom: 4 } }),
          code && /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(
            "div",
            {
              style: {
                fontWeight: "600",
                marginBottom: 4
              },
              children: [
                "Copilot Runtime Error:",
                " ",
                /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("span", { style: { fontFamily: "monospace", fontWeight: "normal" }, children: code })
              ]
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(import_react_markdown.default, { children: message })
        ]
      },
      idx
    );
  });
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsxs)(
    "div",
    {
      style: {
        fontSize: "13px",
        maxWidth: "600px"
      },
      children: [
        errorsToRender,
        /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", { style: { fontSize: "11px", opacity: 0.75 }, children: "NOTE: This error only displays during local development." })
      ]
    }
  );
}
function useErrorToast() {
  const { addToast } = useToast();
  return (0, import_react8.useCallback)(
    (error) => {
      const errorId = error.map((err) => {
        var _a, _b;
        const message = "extensions" in err ? ((_b = (_a = err.extensions) == null ? void 0 : _a.originalError) == null ? void 0 : _b.message) || err.message : err.message;
        const stack = err.stack || "";
        return btoa(message + stack).slice(0, 32);
      }).join("|");
      addToast({
        type: "error",
        id: errorId,
        // Toast libraries typically dedupe by id
        message: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(ErrorToast, { errors: error })
      });
    },
    [addToast]
  );
}
function useAsyncCallback(callback, deps) {
  const addErrorToast = useErrorToast();
  return (0, import_react8.useCallback)((...args) => __async(this, null, function* () {
    try {
      return yield callback(...args);
    } catch (error) {
      console.error("Error in async callback:", error);
      addErrorToast([error]);
      throw error;
    }
  }), deps);
}

// src/components/error-boundary/error-boundary.tsx
var import_jsx_runtime6 = require("react/jsx-runtime");
var statusChecker = new StatusChecker();
var CopilotErrorBoundary = class extends import_react9.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false
    };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  componentDidMount() {
    if (this.props.publicApiKey) {
      statusChecker.start(this.props.publicApiKey, (newStatus) => {
        this.setState((prevState) => {
          var _a;
          if ((newStatus == null ? void 0 : newStatus.severity) !== ((_a = prevState.status) == null ? void 0 : _a.severity)) {
            return { status: newStatus != null ? newStatus : void 0 };
          }
          return null;
        });
      });
    }
  }
  componentWillUnmount() {
    statusChecker.stop();
  }
  componentDidCatch(error, errorInfo) {
    console.error("CopilotKit Error:", error, errorInfo);
  }
  render() {
    var _a, _b, _c, _d;
    if (this.state.hasError) {
      if (this.state.error instanceof import_shared10.CopilotKitError) {
        return /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [
          this.props.children,
          this.props.showUsageBanner && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
            UsageBanner,
            {
              severity: (_b = (_a = this.state.status) == null ? void 0 : _a.severity) != null ? _b : this.state.error.severity,
              message: (_d = (_c = this.state.status) == null ? void 0 : _c.message) != null ? _d : this.state.error.message,
              actions: getErrorActions(this.state.error)
            }
          )
        ] });
      }
      throw this.state.error;
    }
    return this.props.children;
  }
};

// src/components/dev-console/console-trigger.tsx
var import_react11 = require("react");

// src/components/dev-console/icons.tsx
var import_jsx_runtime7 = require("react/jsx-runtime");
var ExclamationMarkTriangleIcon = () => /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
  "svg",
  {
    width: "13.3967723px",
    height: "12px",
    viewBox: "0 0 13.3967723 12",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("g", { id: "Page-1", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("g", { id: "exclamation-triangle", fill: "#CD2121", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
      "path",
      {
        d: "M5.39935802,0.75 C5.97670802,-0.25 7.42007802,-0.25 7.99742802,0.75 L13.193588,9.75 C13.770888,10.75 13.049288,12 11.894588,12 L1.50223802,12 C0.34753802,12 -0.37414898,10.75 0.20319802,9.75 L5.39935802,0.75 Z M6.69838802,2.5 C7.11260802,2.5 7.44838802,2.83579 7.44838802,3.25 L7.44838802,6.25 C7.44838802,6.66421 7.11260802,7 6.69838802,7 C6.28417802,7 5.94838802,6.66421 5.94838802,6.25 L5.94838802,3.25 C5.94838802,2.83579 6.28417802,2.5 6.69838802,2.5 Z M6.69838802,10.5 C7.25067802,10.5 7.69838802,10.0523 7.69838802,9.5 C7.69838802,8.9477 7.25067802,8.5 6.69838802,8.5 C6.14610802,8.5 5.69838802,8.9477 5.69838802,9.5 C5.69838802,10.0523 6.14610802,10.5 6.69838802,10.5 Z",
        id: "Shape"
      }
    ) }) })
  }
);
var CheckIcon = () => /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
  "svg",
  {
    width: "14px",
    height: "14px",
    viewBox: "0 0 14 14",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("g", { id: "Page-1", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("g", { id: "Group-2", transform: "translate(-118, 0)", fill: "#1BC030", fillRule: "nonzero", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("g", { id: "Group", transform: "translate(118, 0)", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
      "path",
      {
        d: "M0,7 C0,3.13384615 3.13384615,0 7,0 C10.8661538,0 14,3.13384615 14,7 C14,10.8661538 10.8661538,14 7,14 C3.13384615,14 0,10.8661538 0,7 Z M9.59179487,5.69764103 C9.70905818,5.54139023 9.73249341,5.33388318 9.65303227,5.15541491 C9.57357113,4.97694665 9.40367989,4.85551619 9.20909814,4.83811118 C9.01451638,4.82070616 8.82577109,4.91005717 8.71589744,5.07158974 L6.39261538,8.32389744 L5.22666667,7.15794872 C5.01450582,6.96025518 4.68389046,6.9660885 4.47883563,7.17114332 C4.27378081,7.37619815 4.26794748,7.70681351 4.46564103,7.91897436 L6.08102564,9.53435897 C6.19289944,9.64614839 6.3482622,9.70310251 6.50588106,9.69010587 C6.66349993,9.67710922 6.80743532,9.59547613 6.89948718,9.46687179 L9.59179487,5.69764103 L9.59179487,5.69764103 Z",
        id: "Shape"
      }
    ) }) }) })
  }
);
var CopilotKitIcon = () => /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(
  "svg",
  {
    width: "33px",
    height: "35px",
    viewBox: "0 0 33 35",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    children: [
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("title", { children: "bd5c9079-929b-4d55-bdc9-16d1c8181b71" }),
      /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("g", { id: "Page-1", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd", children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
        "image",
        {
          x: "0",
          y: "0",
          width: "33",
          height: "35",
          xlinkHref: "data:image/png;base64,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"
        }
      ) })
    ]
  }
);

// src/components/dev-console/developer-console-modal.tsx
var import_shared11 = require("@copilotkit/shared");
var import_react10 = require("react");
var import_jsx_runtime8 = require("react/jsx-runtime");
function DeveloperConsoleModal({ isOpen, onClose, hasApiKey }) {
  const context = useCopilotContext();
  const messagesContext = useCopilotMessagesContext();
  const [activeTab, setActiveTab] = (0, import_react10.useState)("actions");
  (0, import_react10.useEffect)(() => {
    const handleEscape = (e) => {
      if (e.key === "Escape") {
        onClose();
      }
    };
    if (isOpen) {
      document.addEventListener("keydown", handleEscape);
      document.body.style.overflow = "hidden";
    }
    return () => {
      document.removeEventListener("keydown", handleEscape);
      document.body.style.overflow = "unset";
    };
  }, [isOpen, onClose]);
  if (!isOpen)
    return null;
  const displayContext = hasApiKey ? context : {
    actions: {
      search_web: { name: "search_web", description: "Search the web for information" },
      send_email: { name: "send_email", description: "Send an email to a contact" },
      create_document: { name: "create_document", description: "Create a new document" },
      analyze_code: {
        name: "analyze_code",
        description: "Analyze code for issues and improvements"
      },
      generate_tests: {
        name: "generate_tests",
        description: "Generate unit tests for functions"
      }
    },
    getAllContext: () => [
      {
        content: "User preferences: dark mode enabled, TypeScript preferred",
        metadata: { source: "settings" }
      },
      {
        content: "Current project: Building a React application with CopilotKit",
        metadata: { source: "project" }
      },
      {
        content: "Recent activity: Implemented authentication system",
        metadata: { source: "activity" }
      },
      {
        content: "Development environment: VS Code, Node.js 18, React 18",
        metadata: { source: "environment" }
      }
    ],
    coagentStates: {
      "main-agent": { status: "active", lastUpdate: Date.now() },
      "code-assistant": { status: "active", lastUpdate: Date.now() - 15e3 },
      "search-agent": { status: "idle", lastUpdate: Date.now() - 6e4 }
    },
    getDocumentsContext: () => [
      {
        content: "README.md: Project setup and installation instructions",
        metadata: { type: "documentation" }
      },
      {
        content: "API Documentation: CopilotKit integration guide",
        metadata: { type: "documentation" }
      },
      {
        content: "package.json: Project dependencies and scripts",
        metadata: { type: "configuration" }
      }
    ]
  };
  const displayMessagesContext = hasApiKey ? messagesContext : {
    messages: [
      {
        id: "1",
        role: "user",
        content: "Help me implement a todo list with drag and drop functionality"
      },
      {
        id: "2",
        role: "assistant",
        content: "I'll help you create a todo list with drag and drop. Let me start by setting up the basic components and then add the drag and drop functionality using React DnD."
      },
      { id: "3", role: "user", content: "Can you also add priority levels and due dates?" },
      {
        id: "4",
        role: "assistant",
        content: "Absolutely! I'll enhance the todo items with priority levels (high, medium, low) and due date functionality. This will make your todo list much more powerful for task management."
      },
      { id: "5", role: "user", content: "Perfect! How about adding categories or tags?" }
    ]
  };
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
    "div",
    {
      style: {
        position: "fixed",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        zIndex: 9999,
        backgroundColor: "rgba(0, 0, 0, 0.3)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        padding: "16px"
      },
      onClick: onClose,
      children: /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
        "div",
        {
          style: {
            width: "1152px",
            maxWidth: "95vw",
            height: "80vh",
            backgroundColor: "white",
            borderRadius: "12px",
            boxShadow: "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
            display: "flex",
            flexDirection: "column",
            overflow: "hidden",
            position: "relative"
          },
          onClick: (e) => e.stopPropagation(),
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
              "div",
              {
                style: {
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "space-between",
                  padding: "24px",
                  borderBottom: "1px solid #e5e7eb",
                  minHeight: "73px",
                  flexShrink: 0,
                  filter: !hasApiKey ? "blur(0.3px)" : "none",
                  opacity: !hasApiKey ? 0.95 : 1
                },
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: "12px" }, children: [
                    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(CopilotKitIcon, {}),
                    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
                      "h1",
                      {
                        style: {
                          fontWeight: "bold",
                          fontSize: "20px",
                          color: "#1f2937",
                          margin: 0
                        },
                        children: "Inspector"
                      }
                    ),
                    /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
                      "span",
                      {
                        style: {
                          fontSize: "14px",
                          color: "#6b7280",
                          backgroundColor: "#f3f4f6",
                          padding: "4px 8px",
                          borderRadius: "4px"
                        },
                        children: [
                          "v",
                          import_shared11.COPILOTKIT_VERSION
                        ]
                      }
                    )
                  ] }),
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
                    "button",
                    {
                      onClick: onClose,
                      style: {
                        color: "#9ca3af",
                        fontSize: "24px",
                        fontWeight: "300",
                        border: "none",
                        background: "none",
                        cursor: "pointer",
                        padding: "4px"
                      },
                      onMouseEnter: (e) => e.currentTarget.style.color = "#4b5563",
                      onMouseLeave: (e) => e.currentTarget.style.color = "#9ca3af",
                      children: "\xD7"
                    }
                  )
                ]
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
              "div",
              {
                style: {
                  display: "flex",
                  borderBottom: "1px solid #e5e7eb",
                  backgroundColor: "#f9fafb",
                  minHeight: "50px",
                  flexShrink: 0,
                  filter: !hasApiKey ? "blur(0.3px)" : "none",
                  opacity: !hasApiKey ? 0.9 : 1
                },
                children: [
                  { id: "actions", label: "Actions", count: Object.keys(displayContext.actions).length },
                  { id: "readables", label: "Readables", count: displayContext.getAllContext().length },
                  {
                    id: "agent",
                    label: "Agent Status",
                    count: Object.keys(displayContext.coagentStates).length
                  },
                  { id: "messages", label: "Messages", count: displayMessagesContext.messages.length },
                  {
                    id: "context",
                    label: "Context",
                    count: displayContext.getDocumentsContext([]).length
                  }
                ].map((tab) => /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
                  "button",
                  {
                    onClick: () => setActiveTab(tab.id),
                    style: {
                      padding: "12px 24px",
                      fontSize: "14px",
                      fontWeight: "500",
                      border: "none",
                      cursor: "pointer",
                      backgroundColor: activeTab === tab.id ? "white" : "transparent",
                      color: activeTab === tab.id ? "#2563eb" : "#6b7280",
                      borderBottom: activeTab === tab.id ? "2px solid #2563eb" : "none",
                      transition: "all 0.2s"
                    },
                    onMouseEnter: (e) => {
                      if (activeTab !== tab.id) {
                        e.currentTarget.style.color = "#1f2937";
                        e.currentTarget.style.backgroundColor = "#f3f4f6";
                      }
                    },
                    onMouseLeave: (e) => {
                      if (activeTab !== tab.id) {
                        e.currentTarget.style.color = "#6b7280";
                        e.currentTarget.style.backgroundColor = "transparent";
                      }
                    },
                    children: [
                      tab.label,
                      tab.count > 0 && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
                        "span",
                        {
                          style: {
                            marginLeft: "8px",
                            backgroundColor: "#e5e7eb",
                            color: "#374151",
                            padding: "2px 8px",
                            borderRadius: "9999px",
                            fontSize: "12px"
                          },
                          children: tab.count
                        }
                      )
                    ]
                  },
                  tab.id
                ))
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
              "div",
              {
                style: {
                  height: "calc(100% - 142px)",
                  overflow: "auto",
                  padding: "24px",
                  backgroundColor: "#f9fafb",
                  filter: !hasApiKey ? "blur(0.3px)" : "none",
                  opacity: !hasApiKey ? 0.85 : 1
                },
                children: [
                  activeTab === "actions" && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(ActionsTab, { context: displayContext }),
                  activeTab === "readables" && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(ReadablesTab, { context: displayContext }),
                  activeTab === "agent" && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(AgentStatusTab, { context: displayContext }),
                  activeTab === "messages" && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(MessagesTab, { messagesContext: displayMessagesContext }),
                  activeTab === "context" && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(ContextTab, { context: displayContext })
                ]
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
              "div",
              {
                style: {
                  padding: "16px 24px",
                  borderTop: "1px solid #e5e7eb",
                  backgroundColor: "white",
                  display: "flex",
                  justifyContent: "space-between",
                  alignItems: "center",
                  minHeight: "57px",
                  flexShrink: 0,
                  filter: !hasApiKey ? "blur(0.3px)" : "none",
                  opacity: !hasApiKey ? 0.9 : 1
                },
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { style: { fontSize: "14px", color: "#6b7280" }, children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
                    "a",
                    {
                      href: "https://github.com/CopilotKit/CopilotKit/issues",
                      target: "_blank",
                      rel: "noopener noreferrer",
                      style: { color: "#2563eb", textDecoration: "none" },
                      onMouseEnter: (e) => e.currentTarget.style.textDecoration = "underline",
                      onMouseLeave: (e) => e.currentTarget.style.textDecoration = "none",
                      children: "Report an issue"
                    }
                  ) }),
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { style: { fontSize: "14px", color: "#6b7280" }, children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
                    "a",
                    {
                      href: "https://mcp.copilotkit.ai/",
                      target: "_blank",
                      rel: "noopener noreferrer",
                      style: { color: "#2563eb", textDecoration: "none" },
                      onMouseEnter: (e) => e.currentTarget.style.textDecoration = "underline",
                      onMouseLeave: (e) => e.currentTarget.style.textDecoration = "none",
                      children: "Add MCP Server \u2192"
                    }
                  ) })
                ]
              }
            ),
            !hasApiKey && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
              "div",
              {
                style: {
                  position: "absolute",
                  top: 0,
                  left: 0,
                  right: 0,
                  bottom: 0,
                  backgroundColor: "rgba(255, 255, 255, 0.2)",
                  backdropFilter: "blur(2px)",
                  WebkitBackdropFilter: "blur(2px)",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  borderRadius: "12px",
                  zIndex: 10
                },
                onClick: (e) => e.stopPropagation(),
                children: /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
                  "button",
                  {
                    onClick: () => window.open("https://cloud.copilotkit.ai/sign-in", "_blank"),
                    style: {
                      // Following button system specifications
                      height: "48px",
                      padding: "12px 24px",
                      backgroundColor: "#030507",
                      // textPrimary token
                      color: "#FFFFFF",
                      borderRadius: "12px",
                      // Medium radius token
                      border: "none",
                      cursor: "pointer",
                      fontSize: "14px",
                      // Medium Semi Bold typography
                      fontWeight: "600",
                      fontFamily: "'Plus Jakarta Sans', -apple-system, BlinkMacSystemFont, sans-serif",
                      lineHeight: "22px",
                      boxShadow: "0 4px 16px rgba(3, 5, 7, 0.2), 0 1px 3px rgba(3, 5, 7, 0.1)",
                      transition: "all 200ms ease",
                      // 200ms ease as per specs
                      display: "inline-flex",
                      alignItems: "center",
                      gap: "8px",
                      textTransform: "uppercase",
                      letterSpacing: "0.5px"
                    },
                    onMouseEnter: (e) => {
                      e.currentTarget.style.backgroundColor = "#575758";
                      e.currentTarget.style.transform = "translateY(-1px)";
                      e.currentTarget.style.boxShadow = "0 6px 20px rgba(3, 5, 7, 0.25), 0 2px 4px rgba(3, 5, 7, 0.15)";
                    },
                    onMouseLeave: (e) => {
                      e.currentTarget.style.backgroundColor = "#030507";
                      e.currentTarget.style.transform = "translateY(0)";
                      e.currentTarget.style.boxShadow = "0 4px 16px rgba(3, 5, 7, 0.2), 0 1px 3px rgba(3, 5, 7, 0.1)";
                    },
                    onMouseDown: (e) => {
                      e.currentTarget.style.backgroundColor = "#858589";
                      e.currentTarget.style.transform = "translateY(0)";
                    },
                    onMouseUp: (e) => {
                      e.currentTarget.style.backgroundColor = "#575758";
                      e.currentTarget.style.transform = "translateY(-1px)";
                    },
                    onFocus: (e) => {
                      e.currentTarget.style.outline = "2px solid #BEC9FF";
                      e.currentTarget.style.outlineOffset = "2px";
                    },
                    onBlur: (e) => {
                      e.currentTarget.style.outline = "none";
                    },
                    children: [
                      "Get License Key",
                      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { style: { fontSize: "16px", marginLeft: "-4px" }, children: "\u2192" })
                    ]
                  }
                )
              }
            )
          ]
        }
      )
    }
  );
}
function ActionsTab({ context }) {
  const actions = Object.values(context.actions);
  if (actions.length === 0) {
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { style: { textAlign: "center", padding: "48px 0", color: "#6b7280" }, children: [
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "18px", margin: "0 0 8px 0" }, children: "No actions available" }),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "14px", margin: 0 }, children: "Actions will appear here when registered" })
    ] });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { style: { display: "flex", flexDirection: "column", gap: "16px" }, children: actions.map((action, index) => /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
    "div",
    {
      style: {
        backgroundColor: "white",
        padding: "16px",
        borderRadius: "8px",
        boxShadow: "0 1px 3px 0 rgba(0, 0, 0, 0.1)",
        border: "1px solid #e5e7eb"
      },
      children: /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
        "div",
        {
          style: { display: "flex", alignItems: "flex-start", justifyContent: "space-between" },
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { style: { flex: 1 }, children: [
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("h3", { style: { fontWeight: "600", color: "#1f2937", margin: "0 0 4px 0" }, children: action.name }),
              action.description && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "14px", color: "#4b5563", margin: "0 0 12px 0" }, children: action.description }),
              action.parameters && action.parameters.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { style: { marginTop: "12px" }, children: [
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
                  "p",
                  {
                    style: {
                      fontSize: "12px",
                      fontWeight: "500",
                      color: "#6b7280",
                      textTransform: "uppercase",
                      margin: "0 0 4px 0"
                    },
                    children: "Parameters:"
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { style: { display: "flex", flexDirection: "column", gap: "4px" }, children: action.parameters.map((param, pIndex) => /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { style: { fontSize: "14px" }, children: [
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { style: { fontFamily: "monospace", color: "#374151" }, children: param.name }),
                  param.required && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { style: { marginLeft: "4px", fontSize: "12px", color: "#ef4444" }, children: "*required" }),
                  param.type && /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("span", { style: { marginLeft: "8px", fontSize: "12px", color: "#6b7280" }, children: [
                    "(",
                    param.type,
                    ")"
                  ] })
                ] }, pIndex)) })
              ] })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { style: { marginLeft: "16px" }, children: action.status === "available" ? /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(CheckIcon, {}) : /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(ExclamationMarkTriangleIcon, {}) })
          ]
        }
      )
    },
    index
  )) });
}
function ReadablesTab({ context }) {
  const readables = context.getAllContext();
  if (readables.length === 0) {
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { style: { textAlign: "center", padding: "48px 0", color: "#6b7280" }, children: [
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "18px", margin: "0 0 8px 0" }, children: "No readable context available" }),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "14px", margin: 0 }, children: "Readable context will appear here when provided" })
    ] });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { style: { display: "flex", flexDirection: "column", gap: "16px" }, children: readables.map((readable, index) => /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
    "div",
    {
      style: {
        backgroundColor: "white",
        padding: "16px",
        borderRadius: "8px",
        boxShadow: "0 1px 3px 0 rgba(0, 0, 0, 0.1)",
        border: "1px solid #e5e7eb"
      },
      children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
        "div",
        {
          style: { display: "flex", alignItems: "flex-start", justifyContent: "space-between" },
          children: /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { style: { flex: 1 }, children: [
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("h3", { style: { fontWeight: "600", color: "#1f2937", margin: "0 0 4px 0" }, children: readable.name || `Readable ${index + 1}` }),
            readable.description && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "14px", color: "#4b5563", margin: "0 0 12px 0" }, children: readable.description }),
            readable.value && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
              "pre",
              {
                style: {
                  marginTop: "12px",
                  padding: "8px",
                  backgroundColor: "#f9fafb",
                  borderRadius: "4px",
                  fontSize: "12px",
                  overflowX: "auto",
                  margin: "12px 0 0 0"
                },
                children: JSON.stringify(readable.value, null, 2)
              }
            )
          ] })
        }
      )
    },
    index
  )) });
}
function AgentStatusTab({ context }) {
  const agentStates = context.coagentStates || {};
  const agentStateEntries = Object.entries(agentStates);
  if (agentStateEntries.length === 0) {
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { style: { textAlign: "center", padding: "48px 0", color: "#6b7280" }, children: [
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "18px", margin: "0 0 8px 0" }, children: "No agent states available" }),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "14px", margin: 0 }, children: "Agent states will appear here when agents are active" })
    ] });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { style: { display: "flex", flexDirection: "column", gap: "24px" }, children: agentStateEntries.map(([agentName, state]) => /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
    "div",
    {
      style: {
        backgroundColor: "white",
        padding: "24px",
        borderRadius: "8px",
        boxShadow: "0 1px 3px 0 rgba(0, 0, 0, 0.1)",
        border: "1px solid #e5e7eb"
      },
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
          "div",
          {
            style: {
              display: "flex",
              alignItems: "center",
              justifyContent: "space-between",
              marginBottom: "16px"
            },
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("h3", { style: { fontWeight: "600", fontSize: "18px", color: "#1f2937", margin: 0 }, children: agentName }),
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
                "span",
                {
                  style: {
                    padding: "4px 12px",
                    borderRadius: "9999px",
                    fontSize: "12px",
                    fontWeight: "500",
                    backgroundColor: state.status === "running" ? "#dcfce7" : state.status === "complete" ? "#dbeafe" : "#f3f4f6",
                    color: state.status === "running" ? "#166534" : state.status === "complete" ? "#1e40af" : "#1f2937"
                  },
                  children: state.status || "idle"
                }
              )
            ]
          }
        ),
        state.state && /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { style: { marginBottom: "12px" }, children: [
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
            "p",
            {
              style: {
                fontSize: "12px",
                fontWeight: "500",
                color: "#6b7280",
                textTransform: "uppercase",
                margin: "0 0 4px 0"
              },
              children: "Current State:"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
            "pre",
            {
              style: {
                padding: "12px",
                backgroundColor: "#f9fafb",
                borderRadius: "4px",
                fontSize: "12px",
                overflowX: "auto",
                margin: 0
              },
              children: JSON.stringify(state.state, null, 2)
            }
          )
        ] }),
        state.running && /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
          "div",
          {
            style: {
              marginTop: "16px",
              display: "flex",
              alignItems: "center",
              fontSize: "14px",
              color: "#4b5563"
            },
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { style: { marginRight: "8px" }, children: /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
                "svg",
                {
                  width: "16",
                  height: "16",
                  viewBox: "0 0 16 16",
                  style: { animation: "spin 1s linear infinite" },
                  children: [
                    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("style", { children: `@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }` }),
                    /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
                      "circle",
                      {
                        cx: "8",
                        cy: "8",
                        r: "6",
                        fill: "none",
                        stroke: "#4b5563",
                        strokeWidth: "2",
                        strokeDasharray: "9 3"
                      }
                    )
                  ]
                }
              ) }),
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { children: "Agent is currently running..." })
            ]
          }
        )
      ]
    },
    agentName
  )) });
}
function MessagesTab({ messagesContext }) {
  const messages = messagesContext.messages || [];
  if (messages.length === 0) {
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { style: { textAlign: "center", padding: "48px 0", color: "#6b7280" }, children: [
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "18px", margin: "0 0 8px 0" }, children: "No messages yet" }),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "14px", margin: 0 }, children: "Messages will appear here as the conversation progresses" })
    ] });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { style: { display: "flex", flexDirection: "column", gap: "16px" }, children: messages.map((message, index) => /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
    "div",
    {
      style: {
        padding: "16px",
        borderRadius: "8px",
        backgroundColor: message.role === "user" ? "#eff6ff" : message.role === "assistant" ? "#f9fafb" : "#fefce8",
        border: `1px solid ${message.role === "user" ? "#c7d2fe" : message.role === "assistant" ? "#e5e7eb" : "#fde047"}`,
        marginLeft: message.role === "user" ? "48px" : "0",
        marginRight: message.role === "assistant" ? "48px" : "0"
      },
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
          "div",
          {
            style: {
              display: "flex",
              alignItems: "flex-start",
              justifyContent: "space-between",
              marginBottom: "8px"
            },
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
                "span",
                {
                  style: {
                    fontWeight: "500",
                    fontSize: "14px",
                    color: "#374151",
                    textTransform: "capitalize"
                  },
                  children: message.role || "system"
                }
              ),
              message.timestamp && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("span", { style: { fontSize: "12px", color: "#6b7280" }, children: new Date(message.timestamp).toLocaleTimeString() })
            ]
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { style: { fontSize: "14px", color: "#1f2937", whiteSpace: "pre-wrap" }, children: message.content || "" })
      ]
    },
    index
  )) });
}
function ContextTab({ context }) {
  const documents = context.getDocumentsContext([]);
  if (documents.length === 0) {
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("div", { style: { textAlign: "center", padding: "48px 0", color: "#6b7280" }, children: [
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "18px", margin: "0 0 8px 0" }, children: "No document context available" }),
      /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "14px", margin: 0 }, children: "Document context will appear here when provided" })
    ] });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("div", { style: { display: "flex", flexDirection: "column", gap: "16px" }, children: documents.map((doc, index) => /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
    "div",
    {
      style: {
        backgroundColor: "white",
        padding: "16px",
        borderRadius: "8px",
        boxShadow: "0 1px 3px 0 rgba(0, 0, 0, 0.1)",
        border: "1px solid #e5e7eb"
      },
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("h3", { style: { fontWeight: "600", color: "#1f2937", margin: "0 0 8px 0" }, children: doc.name || `Document ${index + 1}` }),
        doc.content && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
          "pre",
          {
            style: {
              padding: "12px",
              backgroundColor: "#f9fafb",
              borderRadius: "4px",
              fontSize: "12px",
              overflowX: "auto",
              margin: 0
            },
            children: doc.content
          }
        )
      ]
    },
    index
  )) });
}

// src/components/dev-console/console-trigger.tsx
var import_jsx_runtime9 = require("react/jsx-runtime");
var INSPECTOR_HIDE_KEY = "cpk:inspector:hidden";
function ConsoleTrigger({ position = "bottom-right" }) {
  const context = useCopilotContext();
  const hasApiKey = Boolean(context.copilotApiConfig.publicApiKey);
  const [isModalOpen, setIsModalOpen] = (0, import_react11.useState)(false);
  const [isHovered, setIsHovered] = (0, import_react11.useState)(false);
  const [isDragging, setIsDragging] = (0, import_react11.useState)(false);
  const [buttonPosition, setButtonPosition] = (0, import_react11.useState)(null);
  const [mounted, setMounted] = (0, import_react11.useState)(false);
  const [isHidden, setIsHidden] = (0, import_react11.useState)(false);
  const dragRef = (0, import_react11.useRef)(null);
  const buttonRef = (0, import_react11.useRef)(null);
  (0, import_react11.useEffect)(() => {
    setMounted(true);
    try {
      const hidden = typeof window !== "undefined" ? localStorage.getItem(INSPECTOR_HIDE_KEY) : null;
      if (hidden === "1" || hidden === "true") {
        setIsHidden(true);
      }
    } catch (e) {
    }
    if (typeof window !== "undefined" && !buttonPosition) {
      const buttonSize = 60;
      const margin = 24;
      const initialPosition = {
        x: margin,
        y: window.innerHeight - buttonSize - margin
      };
      setButtonPosition(initialPosition);
    }
  }, [position]);
  const handleMouseDown = (e) => {
    e.preventDefault();
    if (!buttonPosition)
      return;
    dragRef.current = {
      startX: e.clientX,
      startY: e.clientY,
      buttonX: buttonPosition.x,
      buttonY: buttonPosition.y
    };
    setIsDragging(true);
  };
  (0, import_react11.useEffect)(() => {
    if (!isDragging)
      return;
    const handleMouseMove = (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!dragRef.current)
        return;
      const deltaX = e.clientX - dragRef.current.startX;
      const deltaY = e.clientY - dragRef.current.startY;
      let newX = dragRef.current.buttonX + deltaX;
      let newY = dragRef.current.buttonY + deltaY;
      newX = Math.max(0, Math.min(newX, window.innerWidth - 60));
      newY = Math.max(0, Math.min(newY, window.innerHeight - 60));
      setButtonPosition({ x: newX, y: newY });
    };
    const handleMouseUp = (e) => {
      e.preventDefault();
      e.stopPropagation();
      setIsDragging(false);
      dragRef.current = null;
    };
    document.addEventListener("mousemove", handleMouseMove, { capture: true, passive: false });
    document.addEventListener("mouseup", handleMouseUp, { capture: true, passive: false });
    return () => {
      document.removeEventListener("mousemove", handleMouseMove, { capture: true });
      document.removeEventListener("mouseup", handleMouseUp, { capture: true });
    };
  }, [isDragging]);
  if (!mounted || !buttonPosition || isHidden) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(
      "button",
      {
        ref: buttonRef,
        onClick: (e) => {
          if (!isDragging) {
            if (e.metaKey || e.altKey) {
              try {
                localStorage.setItem(INSPECTOR_HIDE_KEY, "1");
              } catch (e2) {
              }
              setIsHidden(true);
              return;
            }
            setIsModalOpen(true);
          }
        },
        onContextMenu: (e) => {
          e.preventDefault();
          try {
            localStorage.setItem(INSPECTOR_HIDE_KEY, "1");
          } catch (e2) {
          }
          setIsHidden(true);
        },
        onMouseDown: handleMouseDown,
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
        style: {
          position: "fixed",
          left: `${buttonPosition.x}px`,
          top: `${buttonPosition.y}px`,
          zIndex: 2147483647,
          width: "60px",
          height: "60px",
          background: isDragging ? "#000000" : isHovered ? "#111111" : "#000000",
          color: "white",
          borderRadius: "50%",
          boxShadow: isDragging ? "0 8px 32px rgba(0, 0, 0, 0.6), 0 4px 16px rgba(0, 0, 0, 0.4)" : isHovered ? "0 12px 40px rgba(0, 0, 0, 0.7), 0 6px 20px rgba(0, 0, 0, 0.5)" : "0 6px 20px rgba(0, 0, 0, 0.5), 0 3px 10px rgba(0, 0, 0, 0.3)",
          transition: isDragging ? "none" : "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          border: "none",
          cursor: isDragging ? "grabbing" : "grab",
          opacity: 1,
          userSelect: "none",
          transform: isDragging ? "scale(1.05)" : isHovered ? "scale(1.1)" : "scale(1)",
          backdropFilter: "blur(10px)",
          pointerEvents: "auto",
          isolation: "isolate"
        },
        title: hasApiKey ? "Open Inspector (Drag to move)" : "Inspector (License Key Required, Drag to move)",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
            "div",
            {
              onClick: (e) => {
                e.preventDefault();
                e.stopPropagation();
                try {
                  localStorage.setItem(INSPECTOR_HIDE_KEY, "1");
                } catch (e2) {
                }
                setIsHidden(true);
              },
              style: {
                position: "absolute",
                bottom: "2px",
                right: "2px",
                width: "20px",
                height: "20px",
                borderRadius: "50%",
                background: "#ffffff",
                color: "#ef4444",
                fontSize: "14px",
                lineHeight: "18px",
                textAlign: "center",
                boxShadow: "0 2px 6px rgba(0,0,0,0.35)",
                cursor: "pointer",
                border: "1px solid #e5e7eb",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                zIndex: 1
              },
              title: "Hide Inspector",
              children: "\xD7"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
            "div",
            {
              style: {
                width: "28px",
                height: "28px",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                filter: "drop-shadow(0 2px 4px rgba(0,0,0,0.2))"
              },
              children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(CopilotKitIcon, {})
            }
          ),
          !hasApiKey && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
            "div",
            {
              style: {
                position: "absolute",
                top: "-2px",
                right: "-2px",
                width: "18px",
                height: "18px",
                background: "linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%)",
                borderRadius: "50%",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                boxShadow: "0 2px 8px rgba(255, 107, 107, 0.4)",
                border: "2px solid white"
              },
              children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("span", { style: { fontSize: "10px", color: "white", fontWeight: "bold" }, children: "!" })
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
      DeveloperConsoleModal,
      {
        isOpen: isModalOpen,
        onClose: () => setIsModalOpen(false),
        hasApiKey
      }
    )
  ] });
}

// src/components/copilot-provider/copilotkit.tsx
var import_jsx_runtime10 = require("react/jsx-runtime");
function CopilotKit(_a) {
  var _b = _a, { children } = _b, props = __objRest(_b, ["children"]);
  const enabled = shouldShowDevConsole(props.showDevConsole);
  const publicApiKey = props.publicApiKey || props.publicLicenseKey;
  return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(ToastProvider, { enabled, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(CopilotErrorBoundary, { publicApiKey, showUsageBanner: enabled, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(CopilotKitInternal, __spreadProps(__spreadValues({}, props), { children })) }) });
}
function CopilotKitInternal(cpkProps) {
  var _b;
  const _a = cpkProps, { children } = _a, props = __objRest(_a, ["children"]);
  validateProps(cpkProps);
  const publicApiKey = props.publicLicenseKey || props.publicApiKey;
  const chatApiEndpoint = props.runtimeUrl || import_shared12.COPILOT_CLOUD_CHAT_URL;
  const [actions, setActions] = (0, import_react12.useState)({});
  const [coAgentStateRenders, setCoAgentStateRenders] = (0, import_react12.useState)({});
  const chatComponentsCache = (0, import_react12.useRef)({
    actions: {},
    coAgentStateRenders: {}
  });
  const { addElement, removeElement, printTree, getAllElements } = use_tree_default();
  const [isLoading, setIsLoading] = (0, import_react12.useState)(false);
  const [chatInstructions, setChatInstructions] = (0, import_react12.useState)("");
  const [authStates, setAuthStates] = (0, import_react12.useState)({});
  const [extensions, setExtensions] = (0, import_react12.useState)({});
  const [additionalInstructions, setAdditionalInstructions] = (0, import_react12.useState)([]);
  const {
    addElement: addDocument,
    removeElement: removeDocument,
    allElements: allDocuments
  } = use_flat_category_store_default();
  const setAction = (0, import_react12.useCallback)((id, action) => {
    setActions((prevPoints) => {
      return __spreadProps(__spreadValues({}, prevPoints), {
        [id]: action
      });
    });
  }, []);
  const removeAction = (0, import_react12.useCallback)((id) => {
    setActions((prevPoints) => {
      const newPoints = __spreadValues({}, prevPoints);
      delete newPoints[id];
      return newPoints;
    });
  }, []);
  const setCoAgentStateRender = (0, import_react12.useCallback)((id, stateRender) => {
    setCoAgentStateRenders((prevPoints) => {
      return __spreadProps(__spreadValues({}, prevPoints), {
        [id]: stateRender
      });
    });
  }, []);
  const removeCoAgentStateRender = (0, import_react12.useCallback)((id) => {
    setCoAgentStateRenders((prevPoints) => {
      const newPoints = __spreadValues({}, prevPoints);
      delete newPoints[id];
      return newPoints;
    });
  }, []);
  const getContextString = (0, import_react12.useCallback)(
    (documents, categories) => {
      const documentsString = documents.map((document2) => {
        return `${document2.name} (${document2.sourceApplication}):
${document2.getContents()}`;
      }).join("\n\n");
      const nonDocumentStrings = printTree(categories);
      return `${documentsString}

${nonDocumentStrings}`;
    },
    [printTree]
  );
  const addContext = (0, import_react12.useCallback)(
    (context, parentId, categories = defaultCopilotContextCategories) => {
      return addElement(context, categories, parentId);
    },
    [addElement]
  );
  const removeContext = (0, import_react12.useCallback)(
    (id) => {
      removeElement(id);
    },
    [removeElement]
  );
  const getAllContext = (0, import_react12.useCallback)(() => {
    return getAllElements();
  }, [getAllElements]);
  const getFunctionCallHandler = (0, import_react12.useCallback)(
    (customEntryPoints) => {
      return entryPointsToFunctionCallHandler(Object.values(customEntryPoints || actions));
    },
    [actions]
  );
  const getDocumentsContext = (0, import_react12.useCallback)(
    (categories) => {
      return allDocuments(categories);
    },
    [allDocuments]
  );
  const addDocumentContext = (0, import_react12.useCallback)(
    (documentPointer, categories = defaultCopilotContextCategories) => {
      return addDocument(documentPointer, categories);
    },
    [addDocument]
  );
  const removeDocumentContext = (0, import_react12.useCallback)(
    (documentId) => {
      removeDocument(documentId);
    },
    [removeDocument]
  );
  const copilotApiConfig = (0, import_react12.useMemo)(() => {
    var _a2, _b2;
    let cloud = void 0;
    if (publicApiKey) {
      cloud = {
        guardrails: {
          input: {
            restrictToTopic: {
              enabled: Boolean(props.guardrails_c),
              validTopics: ((_a2 = props.guardrails_c) == null ? void 0 : _a2.validTopics) || [],
              invalidTopics: ((_b2 = props.guardrails_c) == null ? void 0 : _b2.invalidTopics) || []
            }
          }
        }
      };
    }
    return __spreadProps(__spreadValues({
      publicApiKey
    }, cloud ? { cloud } : {}), {
      chatApiEndpoint,
      headers: props.headers || {},
      properties: props.properties || {},
      transcribeAudioUrl: props.transcribeAudioUrl,
      textToSpeechUrl: props.textToSpeechUrl,
      credentials: props.credentials
    });
  }, [
    publicApiKey,
    props.headers,
    props.properties,
    props.transcribeAudioUrl,
    props.textToSpeechUrl,
    props.credentials,
    props.cloudRestrictToTopic,
    props.guardrails_c
  ]);
  const headers = (0, import_react12.useMemo)(() => {
    const authHeaders = Object.values(authStates || {}).reduce((acc, state) => {
      if (state.status === "authenticated" && state.authHeaders) {
        return __spreadValues(__spreadValues({}, acc), Object.entries(state.authHeaders).reduce(
          (headers2, [key, value]) => __spreadProps(__spreadValues({}, headers2), {
            [key.startsWith("X-Custom-") ? key : `X-Custom-${key}`]: value
          }),
          {}
        ));
      }
      return acc;
    }, {});
    return __spreadValues(__spreadValues(__spreadValues({}, copilotApiConfig.headers || {}), copilotApiConfig.publicApiKey ? { [import_shared12.COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: copilotApiConfig.publicApiKey } : {}), authHeaders);
  }, [copilotApiConfig.headers, copilotApiConfig.publicApiKey, authStates]);
  const [internalErrorHandlers, _setInternalErrorHandler] = (0, import_react12.useState)({});
  const setInternalErrorHandler = (0, import_react12.useCallback)((handler) => {
    _setInternalErrorHandler((prev) => __spreadValues(__spreadValues({}, prev), handler));
  }, []);
  const removeInternalErrorHandler = (0, import_react12.useCallback)((key) => {
    _setInternalErrorHandler((prev) => {
      const _a2 = prev, { [key]: _removed } = _a2, rest = __objRest(_a2, [__restKey(key)]);
      return rest;
    });
  }, []);
  const onErrorRef = (0, import_react12.useRef)(props.onError);
  (0, import_react12.useEffect)(() => {
    onErrorRef.current = props.onError;
  }, [props.onError]);
  const internalHandlersRef = (0, import_react12.useRef)({});
  (0, import_react12.useEffect)(() => {
    internalHandlersRef.current = internalErrorHandlers;
  }, [internalErrorHandlers]);
  const handleErrors = (0, import_react12.useCallback)(
    (error) => __async(this, null, function* () {
      if (copilotApiConfig.publicApiKey && onErrorRef.current) {
        try {
          yield onErrorRef.current(error);
        } catch (e) {
          console.error("Error in public onError handler:", e);
        }
      }
      const handlers = Object.values(internalHandlersRef.current);
      yield Promise.all(
        handlers.map(
          (h) => Promise.resolve(h(error)).catch(
            (e) => console.error("Error in internal error handler:", e)
          )
        )
      );
    }),
    [copilotApiConfig.publicApiKey]
  );
  const runtimeClient = useCopilotRuntimeClient({
    url: copilotApiConfig.chatApiEndpoint,
    publicApiKey,
    headers,
    credentials: copilotApiConfig.credentials,
    showDevConsole: shouldShowDevConsole(props.showDevConsole),
    onError: handleErrors
  });
  const [chatSuggestionConfiguration, setChatSuggestionConfiguration] = (0, import_react12.useState)({});
  const addChatSuggestionConfiguration = (0, import_react12.useCallback)(
    (id, suggestion) => {
      setChatSuggestionConfiguration((prev) => __spreadProps(__spreadValues({}, prev), { [id]: suggestion }));
    },
    [setChatSuggestionConfiguration]
  );
  const removeChatSuggestionConfiguration = (0, import_react12.useCallback)(
    (id) => {
      setChatSuggestionConfiguration((prev) => {
        const _a2 = prev, { [id]: _ } = _a2, rest = __objRest(_a2, [__restKey(id)]);
        return rest;
      });
    },
    [setChatSuggestionConfiguration]
  );
  const [availableAgents, setAvailableAgents] = (0, import_react12.useState)([]);
  const [coagentStates, setCoagentStates] = (0, import_react12.useState)({});
  const coagentStatesRef = (0, import_react12.useRef)({});
  const setCoagentStatesWithRef = (0, import_react12.useCallback)(
    (value) => {
      const newValue = typeof value === "function" ? value(coagentStatesRef.current) : value;
      coagentStatesRef.current = newValue;
      setCoagentStates((prev) => {
        return newValue;
      });
    },
    []
  );
  const hasLoadedAgents = (0, import_react12.useRef)(false);
  (0, import_react12.useEffect)(() => {
    if (hasLoadedAgents.current)
      return;
    const fetchData = () => __async(this, null, function* () {
      var _a2;
      const result = yield runtimeClient.availableAgents();
      if ((_a2 = result.data) == null ? void 0 : _a2.availableAgents) {
        setAvailableAgents(result.data.availableAgents.agents);
      }
      hasLoadedAgents.current = true;
    });
    void fetchData();
  }, []);
  let initialAgentSession = null;
  if (props.agent) {
    initialAgentSession = {
      agentName: props.agent
    };
  }
  const [agentSession, setAgentSession] = (0, import_react12.useState)(initialAgentSession);
  (0, import_react12.useEffect)(() => {
    if (props.agent) {
      setAgentSession({
        agentName: props.agent
      });
    } else {
      setAgentSession(null);
    }
  }, [props.agent]);
  const [internalThreadId, setInternalThreadId] = (0, import_react12.useState)(props.threadId || (0, import_shared12.randomUUID)());
  const setThreadId = (0, import_react12.useCallback)(
    (value) => {
      if (props.threadId) {
        throw new Error("Cannot call setThreadId() when threadId is provided via props.");
      }
      setInternalThreadId(value);
    },
    [props.threadId]
  );
  (0, import_react12.useEffect)(() => {
    if (props.threadId !== void 0) {
      setInternalThreadId(props.threadId);
    }
  }, [props.threadId]);
  const [runId, setRunId] = (0, import_react12.useState)(null);
  const chatAbortControllerRef = (0, import_react12.useRef)(null);
  const showDevConsole = shouldShowDevConsole(props.showDevConsole);
  const [langGraphInterruptActions, _setLangGraphInterruptAction] = (0, import_react12.useState)({});
  const setLangGraphInterruptAction = (0, import_react12.useCallback)(
    (threadId, action) => {
      _setLangGraphInterruptAction((prev) => {
        var _a2, _b2, _c;
        if (action == null)
          return __spreadProps(__spreadValues({}, prev), {
            [threadId]: null
          });
        let event = (_a2 = prev[threadId]) == null ? void 0 : _a2.event;
        if (action.event) {
          event = __spreadValues(__spreadValues({}, ((_b2 = prev[threadId]) == null ? void 0 : _b2.event) || {}), action.event);
        }
        return __spreadProps(__spreadValues({}, prev), {
          [threadId]: __spreadProps(__spreadValues(__spreadValues({}, (_c = prev[threadId]) != null ? _c : {}), action), { event })
        });
      });
    },
    []
  );
  const removeLangGraphInterruptAction = (0, import_react12.useCallback)((threadId) => {
    setLangGraphInterruptAction(threadId, null);
  }, []);
  const memoizedChildren = (0, import_react12.useMemo)(() => children, [children]);
  const [bannerError, setBannerError] = (0, import_react12.useState)(null);
  const agentLock = (0, import_react12.useMemo)(() => {
    var _a2;
    return (_a2 = props.agent) != null ? _a2 : null;
  }, [props.agent]);
  const forwardedParameters = (0, import_react12.useMemo)(
    () => {
      var _a2;
      return (_a2 = props.forwardedParameters) != null ? _a2 : {};
    },
    [props.forwardedParameters]
  );
  const updateExtensions = (0, import_react12.useCallback)(
    (newExtensions) => {
      setExtensions((prev) => {
        const resolved = typeof newExtensions === "function" ? newExtensions(prev) : newExtensions;
        const isSameLength = Object.keys(resolved).length === Object.keys(prev).length;
        const isEqual = isSameLength && // @ts-ignore
        Object.entries(resolved).every(([key, value]) => prev[key] === value);
        return isEqual ? prev : resolved;
      });
    },
    [setExtensions]
  );
  const updateAuthStates = (0, import_react12.useCallback)(
    (newAuthStates) => {
      setAuthStates((prev) => {
        const resolved = typeof newAuthStates === "function" ? newAuthStates(prev) : newAuthStates;
        const isSameLength = Object.keys(resolved).length === Object.keys(prev).length;
        const isEqual = isSameLength && // @ts-ignore
        Object.entries(resolved).every(([key, value]) => prev[key] === value);
        return isEqual ? prev : resolved;
      });
    },
    [setAuthStates]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(
    CopilotContext.Provider,
    {
      value: {
        actions,
        chatComponentsCache,
        getFunctionCallHandler,
        setAction,
        removeAction,
        coAgentStateRenders,
        setCoAgentStateRender,
        removeCoAgentStateRender,
        getContextString,
        addContext,
        removeContext,
        getAllContext,
        getDocumentsContext,
        addDocumentContext,
        removeDocumentContext,
        copilotApiConfig,
        isLoading,
        setIsLoading,
        chatSuggestionConfiguration,
        addChatSuggestionConfiguration,
        removeChatSuggestionConfiguration,
        chatInstructions,
        setChatInstructions,
        additionalInstructions,
        setAdditionalInstructions,
        showDevConsole,
        coagentStates,
        setCoagentStates,
        coagentStatesRef,
        setCoagentStatesWithRef,
        agentSession,
        setAgentSession,
        runtimeClient,
        forwardedParameters,
        agentLock,
        threadId: internalThreadId,
        setThreadId,
        runId,
        setRunId,
        chatAbortControllerRef,
        availableAgents,
        authConfig_c: props.authConfig_c,
        authStates_c: authStates,
        setAuthStates_c: updateAuthStates,
        extensions,
        setExtensions: updateExtensions,
        langGraphInterruptAction: (_b = langGraphInterruptActions[internalThreadId]) != null ? _b : null,
        setLangGraphInterruptAction,
        removeLangGraphInterruptAction,
        bannerError,
        setBannerError,
        onError: handleErrors,
        internalErrorHandlers,
        setInternalErrorHandler,
        removeInternalErrorHandler
      },
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(MessagesTapProvider, { children: /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(CopilotMessages, { children: [
          memoizedChildren,
          showDevConsole && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(ConsoleTrigger, {})
        ] }) }),
        bannerError && showDevConsole && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
          UsageBanner,
          {
            severity: bannerError.severity,
            message: bannerError.message,
            onClose: () => setBannerError(null),
            actions: getErrorActions(bannerError)
          }
        )
      ]
    }
  );
}
var defaultCopilotContextCategories = ["global"];
function entryPointsToFunctionCallHandler(actions) {
  return (_0) => __async(this, [_0], function* ({ name, args }) {
    let actionsByFunctionName = {};
    for (let action2 of actions) {
      actionsByFunctionName[action2.name] = action2;
    }
    const action = actionsByFunctionName[name];
    let result = void 0;
    if (action) {
      yield new Promise((resolve, reject) => {
        (0, import_react_dom.flushSync)(() => __async(this, null, function* () {
          var _a;
          try {
            result = yield (_a = action.handler) == null ? void 0 : _a.call(action, args);
            resolve();
          } catch (error) {
            reject(error);
          }
        }));
      });
      yield new Promise((resolve) => setTimeout(resolve, 20));
    }
    return result;
  });
}
function formatFeatureName(featureName) {
  return featureName.replace(/_c$/, "").split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(" ");
}
function validateProps(props) {
  const cloudFeatures = Object.keys(props).filter((key) => key.endsWith("_c"));
  const hasApiKey = props.publicApiKey || props.publicLicenseKey;
  if (!props.runtimeUrl && !hasApiKey) {
    throw new import_shared12.ConfigurationError(
      "Missing required prop: 'runtimeUrl' or 'publicApiKey' or 'publicLicenseKey'"
    );
  }
  if (cloudFeatures.length > 0 && !hasApiKey) {
    throw new import_shared12.MissingPublicApiKeyError(
      `Missing required prop: 'publicApiKey' or 'publicLicenseKey' to use cloud features: ${cloudFeatures.map(formatFeatureName).join(", ")}`
    );
  }
}

// src/hooks/use-copilot-chat_internal.ts
var import_react15 = require("react");

// src/hooks/use-chat.ts
var import_react13 = require("react");
var import_react_dom2 = require("react-dom");
var import_shared14 = require("@copilotkit/shared");
var import_runtime_client_gql7 = require("@copilotkit/runtime-client-gql");

// src/types/frontend-action.ts
var import_runtime_client_gql6 = require("@copilotkit/runtime-client-gql");
var import_shared13 = require("@copilotkit/shared");
function processActionsForRuntimeRequest(actions) {
  const filteredActions = actions.filter(
    (action) => action.available !== import_runtime_client_gql6.ActionInputAvailability.Disabled && action.disabled !== true && action.name !== "*" && action.available != "frontend" && !action.pairedAction
  ).map((action) => {
    let available = import_runtime_client_gql6.ActionInputAvailability.Enabled;
    if (action.disabled) {
      available = import_runtime_client_gql6.ActionInputAvailability.Disabled;
    } else if (action.available === "disabled") {
      available = import_runtime_client_gql6.ActionInputAvailability.Disabled;
    } else if (action.available === "remote") {
      available = import_runtime_client_gql6.ActionInputAvailability.Remote;
    }
    return {
      name: action.name,
      description: action.description || "",
      jsonSchema: JSON.stringify((0, import_shared13.actionParametersToJsonSchema)(action.parameters || [])),
      available
    };
  });
  return filteredActions;
}

// src/hooks/use-chat.ts
function useChat(options) {
  const {
    messages,
    setMessages,
    makeSystemMessageCallback,
    copilotConfig,
    setIsLoading,
    initialMessages,
    isLoading,
    actions,
    onFunctionCall,
    onCoAgentStateRender,
    setCoagentStatesWithRef,
    coagentStatesRef,
    agentSession,
    setAgentSession,
    threadId,
    setThreadId,
    runId,
    setRunId,
    chatAbortControllerRef,
    agentLock,
    extensions,
    setExtensions,
    langGraphInterruptAction,
    setLangGraphInterruptAction,
    disableSystemMessage = false
  } = options;
  const runChatCompletionRef = (0, import_react13.useRef)();
  const addErrorToast = useErrorToast();
  const { setBannerError } = useToast();
  const { onError, showDevConsole, getAllContext } = useCopilotContext();
  const copilotReadableContext = getAllContext();
  const context = (0, import_react13.useMemo)(
    () => copilotReadableContext.map((contextItem) => {
      const [description, ...valueParts] = contextItem.value.split(":");
      return {
        description: description.trim(),
        value: valueParts.join(":").trim()
      };
    }),
    [copilotReadableContext]
  );
  const traceUIError = (error, originalError) => __async(this, null, function* () {
    try {
      const traceEvent = {
        type: "error",
        timestamp: Date.now(),
        context: {
          source: "ui",
          request: {
            operation: "useChatCompletion",
            url: copilotConfig.chatApiEndpoint,
            startTime: Date.now()
          },
          technical: {
            environment: "browser",
            userAgent: typeof navigator !== "undefined" ? navigator.userAgent : void 0,
            stackTrace: originalError instanceof Error ? originalError.stack : void 0
          }
        },
        error
      };
      yield onError(traceEvent);
    } catch (traceError) {
      console.error("Error in use-chat onError handler:", traceError);
    }
  });
  const agentSessionRef = (0, import_react13.useRef)(agentSession);
  agentSessionRef.current = agentSession;
  const runIdRef = (0, import_react13.useRef)(runId);
  runIdRef.current = runId;
  const extensionsRef = (0, import_react13.useRef)(extensions);
  extensionsRef.current = extensions;
  const publicApiKey = copilotConfig.publicApiKey;
  const headers = __spreadValues(__spreadValues({}, copilotConfig.headers || {}), publicApiKey ? { [import_shared14.COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: publicApiKey } : {});
  const runtimeClient = useCopilotRuntimeClient({
    url: copilotConfig.chatApiEndpoint,
    publicApiKey: copilotConfig.publicApiKey,
    headers,
    credentials: copilotConfig.credentials,
    showDevConsole,
    onError
  });
  const pendingAppendsRef = (0, import_react13.useRef)([]);
  const runChatCompletion = useAsyncCallback(
    (previousMessages) => __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;
      setIsLoading(true);
      const interruptEvent = langGraphInterruptAction == null ? void 0 : langGraphInterruptAction.event;
      if ((interruptEvent == null ? void 0 : interruptEvent.name) === import_runtime_client_gql7.MetaEventName.LangGraphInterruptEvent && (interruptEvent == null ? void 0 : interruptEvent.value) && !(interruptEvent == null ? void 0 : interruptEvent.response) && agentSessionRef.current) {
        addErrorToast([
          new Error(
            "A message was sent while interrupt is active. This will cause failure on the agent side"
          )
        ]);
      }
      let newMessages = [
        new import_runtime_client_gql7.TextMessage({
          content: "",
          role: import_runtime_client_gql7.Role.Assistant
        })
      ];
      chatAbortControllerRef.current = new AbortController();
      setMessages([...previousMessages, ...newMessages]);
      const messagesWithContext = disableSystemMessage ? [...initialMessages || [], ...previousMessages] : [makeSystemMessageCallback(), ...initialMessages || [], ...previousMessages];
      const finalProperties = __spreadValues({}, copilotConfig.properties || {});
      let mcpServersToUse = null;
      if (copilotConfig.mcpServers && Array.isArray(copilotConfig.mcpServers) && copilotConfig.mcpServers.length > 0) {
        mcpServersToUse = copilotConfig.mcpServers;
      } else if (((_a = copilotConfig.properties) == null ? void 0 : _a.mcpServers) && Array.isArray(copilotConfig.properties.mcpServers) && copilotConfig.properties.mcpServers.length > 0) {
        mcpServersToUse = copilotConfig.properties.mcpServers;
      }
      if (mcpServersToUse) {
        finalProperties.mcpServers = mcpServersToUse;
        copilotConfig.mcpServers = mcpServersToUse;
      }
      const isAgentRun = agentSessionRef.current !== null;
      const stream = runtimeClient.asStream(
        runtimeClient.generateCopilotResponse({
          data: __spreadProps(__spreadValues(__spreadProps(__spreadValues({
            frontend: {
              actions: processActionsForRuntimeRequest(actions),
              url: window.location.href
            },
            threadId,
            runId: runIdRef.current,
            extensions: extensionsRef.current,
            metaEvents: composeAndFlushMetaEventsInput([langGraphInterruptAction == null ? void 0 : langGraphInterruptAction.event]),
            messages: (0, import_runtime_client_gql7.convertMessagesToGqlInput)((0, import_runtime_client_gql7.filterAgentStateMessages)(messagesWithContext))
          }, copilotConfig.cloud ? {
            cloud: __spreadValues({}, ((_d = (_c = (_b = copilotConfig.cloud.guardrails) == null ? void 0 : _b.input) == null ? void 0 : _c.restrictToTopic) == null ? void 0 : _d.enabled) ? {
              guardrails: {
                inputValidationRules: {
                  allowList: copilotConfig.cloud.guardrails.input.restrictToTopic.validTopics,
                  denyList: copilotConfig.cloud.guardrails.input.restrictToTopic.invalidTopics
                }
              }
            } : {})
          } : {}), {
            metadata: {
              requestType: import_runtime_client_gql7.CopilotRequestType.Chat
            }
          }), agentSessionRef.current ? {
            agentSession: agentSessionRef.current
          } : {}), {
            agentStates: Object.values(coagentStatesRef.current).map((state) => {
              const stateObject = {
                agentName: state.name,
                state: JSON.stringify(state.state)
              };
              if (state.config !== void 0) {
                stateObject.config = JSON.stringify(state.config);
              }
              return stateObject;
            }),
            forwardedParameters: options.forwardedParameters || {},
            context
          }),
          properties: finalProperties,
          signal: (_e = chatAbortControllerRef.current) == null ? void 0 : _e.signal
        })
      );
      const guardrailsEnabled = ((_h = (_g = (_f = copilotConfig.cloud) == null ? void 0 : _f.guardrails) == null ? void 0 : _g.input) == null ? void 0 : _h.restrictToTopic.enabled) || false;
      const reader = stream.getReader();
      let executedCoAgentStateRenders = [];
      let followUp = void 0;
      let messages2 = [];
      let syncedMessages = [];
      let interruptMessages = [];
      try {
        while (true) {
          let done, value;
          try {
            const readResult = yield reader.read();
            done = readResult.done;
            value = readResult.value;
          } catch (readError) {
            break;
          }
          if (done) {
            if (chatAbortControllerRef.current.signal.aborted) {
              return [];
            }
            break;
          }
          if (!(value == null ? void 0 : value.generateCopilotResponse)) {
            continue;
          }
          runIdRef.current = value.generateCopilotResponse.runId || null;
          extensionsRef.current = import_runtime_client_gql7.CopilotRuntimeClient.removeGraphQLTypename(
            value.generateCopilotResponse.extensions || {}
          );
          setRunId(runIdRef.current);
          setExtensions(extensionsRef.current);
          let rawMessagesResponse = value.generateCopilotResponse.messages;
          const metaEvents = (_j = (_i = value.generateCopilotResponse) == null ? void 0 : _i.metaEvents) != null ? _j : [];
          (metaEvents != null ? metaEvents : []).forEach((ev) => {
            if (ev.name === import_runtime_client_gql7.MetaEventName.LangGraphInterruptEvent) {
              let eventValue = (0, import_runtime_client_gql7.langGraphInterruptEvent)(ev).value;
              eventValue = (0, import_shared14.parseJson)(eventValue, eventValue);
              setLangGraphInterruptAction(threadId, {
                event: __spreadProps(__spreadValues({}, (0, import_runtime_client_gql7.langGraphInterruptEvent)(ev)), {
                  value: eventValue
                })
              });
            }
            if (ev.name === import_runtime_client_gql7.MetaEventName.CopilotKitLangGraphInterruptEvent) {
              const data = ev.data;
              rawMessagesResponse = [...rawMessagesResponse, ...data.messages];
              interruptMessages = (0, import_runtime_client_gql7.convertGqlOutputToMessages)(
                // @ts-ignore
                (0, import_runtime_client_gql7.filterAdjacentAgentStateMessages)(data.messages)
              );
            }
          });
          messages2 = (0, import_runtime_client_gql7.convertGqlOutputToMessages)(
            (0, import_runtime_client_gql7.filterAdjacentAgentStateMessages)(rawMessagesResponse)
          );
          newMessages = [];
          if (((_k = value.generateCopilotResponse.status) == null ? void 0 : _k.__typename) === "FailedResponseStatus" && value.generateCopilotResponse.status.reason === "GUARDRAILS_VALIDATION_FAILED") {
            const guardrailsReason = ((_l = value.generateCopilotResponse.status.details) == null ? void 0 : _l.guardrailsReason) || "";
            newMessages = [
              new import_runtime_client_gql7.TextMessage({
                role: import_runtime_client_gql7.MessageRole.Assistant,
                content: guardrailsReason
              })
            ];
            const guardrailsError = new import_shared14.CopilotKitError({
              message: `Guardrails validation failed: ${guardrailsReason}`,
              code: import_shared14.CopilotKitErrorCode.MISUSE
            });
            yield traceUIError(guardrailsError, {
              statusReason: value.generateCopilotResponse.status.reason,
              statusDetails: value.generateCopilotResponse.status.details
            });
            setMessages([...previousMessages, ...newMessages]);
            break;
          }
          if (((_m = value.generateCopilotResponse.status) == null ? void 0 : _m.__typename) === "FailedResponseStatus" && value.generateCopilotResponse.status.reason === "UNKNOWN_ERROR") {
            const errorMessage = ((_n = value.generateCopilotResponse.status.details) == null ? void 0 : _n.description) || "An unknown error occurred";
            const statusDetails = value.generateCopilotResponse.status.details;
            const originalError = (statusDetails == null ? void 0 : statusDetails.originalError) || (statusDetails == null ? void 0 : statusDetails.error);
            const originalCode = (originalError == null ? void 0 : originalError.code) || ((_o = originalError == null ? void 0 : originalError.extensions) == null ? void 0 : _o.code);
            const originalSeverity = (originalError == null ? void 0 : originalError.severity) || ((_p = originalError == null ? void 0 : originalError.extensions) == null ? void 0 : _p.severity);
            const originalVisibility = (originalError == null ? void 0 : originalError.visibility) || ((_q = originalError == null ? void 0 : originalError.extensions) == null ? void 0 : _q.visibility);
            let errorCode = import_shared14.CopilotKitErrorCode.NETWORK_ERROR;
            if (originalCode && Object.values(import_shared14.CopilotKitErrorCode).includes(originalCode)) {
              errorCode = originalCode;
            }
            const structuredError = new import_shared14.CopilotKitError({
              message: errorMessage,
              code: errorCode,
              severity: originalSeverity,
              visibility: originalVisibility
            });
            setBannerError(structuredError);
            yield traceUIError(structuredError, {
              statusReason: value.generateCopilotResponse.status.reason,
              statusDetails: value.generateCopilotResponse.status.details,
              originalErrorCode: originalCode,
              preservedStructure: !!originalCode
            });
            setIsLoading(false);
            throw new Error(structuredError.message);
          } else if (messages2.length > 0) {
            newMessages = [...messages2];
            for (const message of messages2) {
              if (message.isAgentStateMessage() && !message.active && !executedCoAgentStateRenders.includes(message.id) && onCoAgentStateRender) {
                if (guardrailsEnabled && value.generateCopilotResponse.status === void 0) {
                  break;
                }
                yield onCoAgentStateRender({
                  name: message.agentName,
                  nodeName: message.nodeName,
                  state: message.state
                });
                executedCoAgentStateRenders.push(message.id);
              }
            }
            const lastAgentStateMessage = [...messages2].reverse().find((message) => message.isAgentStateMessage());
            if (lastAgentStateMessage) {
              if (lastAgentStateMessage.state.messages && lastAgentStateMessage.state.messages.length > 0) {
                syncedMessages = (0, import_runtime_client_gql7.loadMessagesFromJsonRepresentation)(
                  lastAgentStateMessage.state.messages
                );
              }
              setCoagentStatesWithRef((prevAgentStates) => {
                var _a2;
                return __spreadProps(__spreadValues({}, prevAgentStates), {
                  [lastAgentStateMessage.agentName]: {
                    name: lastAgentStateMessage.agentName,
                    state: lastAgentStateMessage.state,
                    running: lastAgentStateMessage.running,
                    active: lastAgentStateMessage.active,
                    threadId: lastAgentStateMessage.threadId,
                    nodeName: lastAgentStateMessage.nodeName,
                    runId: lastAgentStateMessage.runId,
                    // Preserve existing config from previous state
                    config: (_a2 = prevAgentStates[lastAgentStateMessage.agentName]) == null ? void 0 : _a2.config
                  }
                });
              });
              if (lastAgentStateMessage.running) {
                setAgentSession({
                  threadId: lastAgentStateMessage.threadId,
                  agentName: lastAgentStateMessage.agentName,
                  nodeName: lastAgentStateMessage.nodeName
                });
              } else {
                if (agentLock) {
                  setAgentSession({
                    threadId: (0, import_shared14.randomId)(),
                    agentName: agentLock,
                    nodeName: void 0
                  });
                } else {
                  setAgentSession(null);
                }
              }
            }
          }
          if (newMessages.length > 0) {
            setMessages([...previousMessages, ...newMessages]);
          }
        }
        let finalMessages = constructFinalMessages(
          [...syncedMessages, ...interruptMessages],
          previousMessages,
          newMessages
        );
        let didExecuteAction = false;
        const executeActionFromMessage = (currentAction, actionMessage) => __async(this, null, function* () {
          var _a2;
          const isInterruptAction = interruptMessages.find((m) => m.id === actionMessage.id);
          followUp = (_a2 = currentAction == null ? void 0 : currentAction.followUp) != null ? _a2 : !isInterruptAction;
          if (currentAction == null ? void 0 : currentAction._setActivatingMessageId) {
            currentAction._setActivatingMessageId(actionMessage.id);
          }
          const resultMessage = yield executeAction({
            onFunctionCall,
            message: actionMessage,
            chatAbortControllerRef,
            onError: (error) => {
              addErrorToast([error]);
              console.error(`Failed to execute action ${actionMessage.name}: ${error}`);
            },
            setMessages,
            getFinalMessages: () => finalMessages,
            isRenderAndWait: (currentAction == null ? void 0 : currentAction._isRenderAndWait) || false
          });
          didExecuteAction = true;
          const messageIndex = finalMessages.findIndex((msg) => msg.id === actionMessage.id);
          finalMessages.splice(messageIndex + 1, 0, resultMessage);
          if (currentAction == null ? void 0 : currentAction._isRenderAndWait) {
            const messagesForImmediateUpdate = [...finalMessages];
            (0, import_react_dom2.flushSync)(() => {
              setMessages(messagesForImmediateUpdate);
            });
          }
          if (currentAction == null ? void 0 : currentAction._setActivatingMessageId) {
            currentAction._setActivatingMessageId(null);
          }
          return resultMessage;
        });
        if (onFunctionCall) {
          const lastMessages = [];
          for (let i = finalMessages.length - 1; i >= 0; i--) {
            const message = finalMessages[i];
            if ((message.isActionExecutionMessage() || message.isResultMessage()) && message.status.code !== import_runtime_client_gql7.MessageStatusCode.Pending) {
              lastMessages.unshift(message);
            } else if (!message.isAgentStateMessage()) {
              break;
            }
          }
          for (const message of lastMessages) {
            setMessages(finalMessages);
            const action = actions.find(
              (action2) => action2.name === message.name
            );
            if (action && action.available === "frontend") {
              continue;
            }
            const currentResultMessagePairedFeAction = message.isResultMessage() ? getPairedFeAction(actions, message) : null;
            if (action && message.isActionExecutionMessage()) {
              const isRenderAndWaitAction = (action == null ? void 0 : action._isRenderAndWait) || false;
              const alreadyProcessed = isRenderAndWaitAction && finalMessages.some(
                (fm) => fm.isResultMessage() && fm.actionExecutionId === message.id
              );
              if (alreadyProcessed) {
              } else {
                const resultMessage = yield executeActionFromMessage(
                  action,
                  message
                );
                const pairedFeAction = getPairedFeAction(actions, resultMessage);
                if (pairedFeAction) {
                  const newExecutionMessage = new import_runtime_client_gql7.ActionExecutionMessage({
                    name: pairedFeAction.name,
                    arguments: (0, import_shared14.parseJson)(resultMessage.result, resultMessage.result),
                    status: message.status,
                    createdAt: message.createdAt,
                    parentMessageId: message.parentMessageId
                  });
                  yield executeActionFromMessage(pairedFeAction, newExecutionMessage);
                }
              }
            } else if (message.isResultMessage() && currentResultMessagePairedFeAction) {
              const newExecutionMessage = new import_runtime_client_gql7.ActionExecutionMessage({
                name: currentResultMessagePairedFeAction.name,
                arguments: (0, import_shared14.parseJson)(message.result, message.result),
                status: message.status,
                createdAt: message.createdAt
              });
              finalMessages.push(newExecutionMessage);
              yield executeActionFromMessage(
                currentResultMessagePairedFeAction,
                newExecutionMessage
              );
            }
          }
          setMessages(finalMessages);
        }
        if (followUp !== false && (didExecuteAction || // the last message is a server side result
        !isAgentRun && finalMessages.length && finalMessages[finalMessages.length - 1].isResultMessage()) && // the user did not stop generation
        !((_r = chatAbortControllerRef.current) == null ? void 0 : _r.signal.aborted)) {
          yield new Promise((resolve) => setTimeout(resolve, 10));
          return yield runChatCompletionRef.current(finalMessages);
        } else if ((_s = chatAbortControllerRef.current) == null ? void 0 : _s.signal.aborted) {
          const repairedMessages = finalMessages.filter((message, actionExecutionIndex) => {
            if (message.isActionExecutionMessage()) {
              return finalMessages.find(
                (msg, resultIndex) => msg.isResultMessage() && msg.actionExecutionId === message.id && resultIndex === actionExecutionIndex + 1
              );
            }
            return true;
          });
          const repairedMessageIds = repairedMessages.map((message) => message.id);
          setMessages(repairedMessages);
          if ((_t = agentSessionRef.current) == null ? void 0 : _t.nodeName) {
            setAgentSession({
              threadId: agentSessionRef.current.threadId,
              agentName: agentSessionRef.current.agentName,
              nodeName: "__end__"
            });
          }
          return newMessages.filter((message) => repairedMessageIds.includes(message.id));
        } else {
          return newMessages.slice();
        }
      } finally {
        setIsLoading(false);
      }
    }),
    [
      messages,
      setMessages,
      makeSystemMessageCallback,
      copilotConfig,
      setIsLoading,
      initialMessages,
      isLoading,
      actions,
      onFunctionCall,
      onCoAgentStateRender,
      setCoagentStatesWithRef,
      coagentStatesRef,
      agentSession,
      setAgentSession,
      disableSystemMessage,
      context
    ]
  );
  runChatCompletionRef.current = runChatCompletion;
  const runChatCompletionAndHandleFunctionCall = useAsyncCallback(
    (messages2) => __async(this, null, function* () {
      yield runChatCompletionRef.current(messages2);
    }),
    [messages]
  );
  (0, import_react13.useEffect)(() => {
    if (!isLoading && pendingAppendsRef.current.length > 0) {
      const pending = pendingAppendsRef.current.splice(0);
      const followUp = pending.some((p) => p.followUp);
      const newMessages = [...messages, ...pending.map((p) => p.message)];
      setMessages(newMessages);
      if (followUp) {
        runChatCompletionAndHandleFunctionCall(newMessages);
      }
    }
  }, [isLoading, messages, setMessages, runChatCompletionAndHandleFunctionCall]);
  const composeAndFlushMetaEventsInput = (0, import_react13.useCallback)(
    (metaEvents) => {
      return metaEvents.reduce((acc, event) => {
        if (!event)
          return acc;
        switch (event.name) {
          case import_runtime_client_gql7.MetaEventName.LangGraphInterruptEvent:
            if (event.response) {
              setLangGraphInterruptAction(threadId, null);
              const value = event.value;
              return [
                ...acc,
                {
                  name: event.name,
                  value: typeof value === "string" ? value : JSON.stringify(value),
                  response: typeof event.response === "string" ? event.response : JSON.stringify(event.response)
                }
              ];
            }
            return acc;
          default:
            return acc;
        }
      }, []);
    },
    [setLangGraphInterruptAction]
  );
  const append = useAsyncCallback(
    (message, options2) => __async(this, null, function* () {
      var _a;
      const followUp = (_a = options2 == null ? void 0 : options2.followUp) != null ? _a : true;
      if (isLoading) {
        pendingAppendsRef.current.push({ message, followUp });
        return;
      }
      const newMessages = [...messages, message];
      setMessages(newMessages);
      if (followUp) {
        return runChatCompletionAndHandleFunctionCall(newMessages);
      }
    }),
    [isLoading, messages, setMessages, runChatCompletionAndHandleFunctionCall]
  );
  const reload = useAsyncCallback(
    (reloadMessageId) => __async(this, null, function* () {
      if (isLoading || messages.length === 0) {
        return;
      }
      const reloadMessageIndex = messages.findIndex((msg) => msg.id === reloadMessageId);
      if (reloadMessageIndex === -1) {
        console.warn(`Message with id ${reloadMessageId} not found`);
        return;
      }
      const reloadMessageRole = messages[reloadMessageIndex].role;
      if (reloadMessageRole !== import_runtime_client_gql7.MessageRole.Assistant) {
        console.warn(`Regenerate cannot be performed on ${reloadMessageRole} role`);
        return;
      }
      let historyCutoff = [messages[0]];
      if (messages.length > 2 && reloadMessageIndex !== 0) {
        const lastUserMessageBeforeRegenerate = messages.slice(0, reloadMessageIndex).reverse().find(
          (msg) => (
            // @ts-expect-error -- message has role
            msg.role === import_runtime_client_gql7.MessageRole.User
          )
        );
        const indexOfLastUserMessageBeforeRegenerate = messages.findIndex(
          (msg) => msg.id === lastUserMessageBeforeRegenerate.id
        );
        historyCutoff = messages.slice(0, indexOfLastUserMessageBeforeRegenerate + 1);
      } else if (messages.length > 2 && reloadMessageIndex === 0) {
        historyCutoff = [messages[0], messages[1]];
      }
      setMessages(historyCutoff);
      return runChatCompletionAndHandleFunctionCall(historyCutoff);
    }),
    [isLoading, messages, setMessages, runChatCompletionAndHandleFunctionCall]
  );
  const stop = () => {
    var _a;
    (_a = chatAbortControllerRef.current) == null ? void 0 : _a.abort("Stop was called");
  };
  return {
    append,
    reload,
    stop,
    runChatCompletion: () => runChatCompletionRef.current(messages)
  };
}
function constructFinalMessages(syncedMessages, previousMessages, newMessages) {
  const finalMessages = syncedMessages.length > 0 ? [...syncedMessages] : [...previousMessages, ...newMessages];
  if (syncedMessages.length > 0) {
    const messagesWithAgentState = [...previousMessages, ...newMessages];
    let previousMessageId = void 0;
    for (const message of messagesWithAgentState) {
      if (message.isAgentStateMessage()) {
        const index = finalMessages.findIndex((msg) => msg.id === previousMessageId);
        if (index !== -1) {
          finalMessages.splice(index + 1, 0, message);
        }
      }
      previousMessageId = message.id;
    }
  }
  return finalMessages;
}
function executeAction(_0) {
  return __async(this, arguments, function* ({
    onFunctionCall,
    message,
    chatAbortControllerRef,
    onError,
    setMessages,
    getFinalMessages,
    isRenderAndWait
  }) {
    let result;
    let error = null;
    const currentMessagesForHandler = getFinalMessages();
    const handlerReturnedPromise = onFunctionCall({
      messages: currentMessagesForHandler,
      name: message.name,
      args: message.arguments
    });
    if (isRenderAndWait) {
      const currentMessagesForRender = getFinalMessages();
      (0, import_react_dom2.flushSync)(() => {
        setMessages([...currentMessagesForRender]);
      });
    }
    try {
      result = yield Promise.race([
        handlerReturnedPromise,
        // Await the promise returned by the handler
        new Promise(
          (resolve) => {
            var _a;
            return (_a = chatAbortControllerRef.current) == null ? void 0 : _a.signal.addEventListener(
              "abort",
              () => resolve("Operation was aborted by the user")
            );
          }
        ),
        // if the user stopped generation, we also abort consecutive actions
        new Promise((resolve) => {
          var _a;
          if ((_a = chatAbortControllerRef.current) == null ? void 0 : _a.signal.aborted) {
            resolve("Operation was aborted by the user");
          }
        })
      ]);
    } catch (e) {
      onError(e);
    }
    return new import_runtime_client_gql7.ResultMessage({
      id: "result-" + message.id,
      result: import_runtime_client_gql7.ResultMessage.encodeResult(
        error ? {
          content: result,
          error: JSON.parse(JSON.stringify(error, Object.getOwnPropertyNames(error)))
        } : result
      ),
      actionExecutionId: message.id,
      actionName: message.name
    });
  });
}
function getPairedFeAction(actions, message) {
  let actionName = null;
  if (message.isActionExecutionMessage()) {
    actionName = message.name;
  } else if (message.isResultMessage()) {
    actionName = message.actionName;
  }
  return actions.find(
    (action) => action.name === actionName && action.available === "frontend" || action.pairedAction === actionName
  );
}

// src/hooks/use-copilot-chat_internal.ts
var import_runtime_client_gql8 = require("@copilotkit/runtime-client-gql");

// src/hooks/use-langgraph-interrupt-render.ts
var import_react14 = __toESM(require("react"));
var InterruptRenderer = ({ event, result, render, resolve }) => {
  return render({ event, result, resolve });
};
function useLangGraphInterruptRender() {
  const { langGraphInterruptAction, setLangGraphInterruptAction, agentSession, threadId } = useCopilotContext();
  const responseRef = import_react14.default.useRef();
  const resolveInterrupt = (0, import_react14.useCallback)(
    (response) => {
      responseRef.current = response;
      setTimeout(() => {
        setLangGraphInterruptAction(threadId, { event: { response } });
      }, 0);
    },
    [setLangGraphInterruptAction, threadId]
  );
  if (!langGraphInterruptAction || !langGraphInterruptAction.event || !langGraphInterruptAction.render)
    return null;
  const { render, handler, event, enabled } = langGraphInterruptAction;
  const conditionsMet = !agentSession || !enabled ? true : enabled({ eventValue: event.value, agentMetadata: agentSession });
  if (!conditionsMet) {
    return null;
  }
  let result = null;
  if (handler) {
    result = handler({
      event,
      resolve: resolveInterrupt
    });
  }
  return import_react14.default.createElement(InterruptRenderer, {
    event,
    result,
    render,
    resolve: resolveInterrupt
  });
}

// src/hooks/use-copilot-chat_internal.ts
var globalSuggestionPromise = null;
function useCopilotChat(options = {}) {
  var _a;
  const makeSystemMessage2 = (_a = options.makeSystemMessage) != null ? _a : defaultSystemMessage;
  const {
    getContextString,
    getFunctionCallHandler,
    copilotApiConfig,
    isLoading,
    setIsLoading,
    chatInstructions,
    actions,
    coagentStatesRef,
    setCoagentStatesWithRef,
    coAgentStateRenders,
    agentSession,
    setAgentSession,
    forwardedParameters,
    agentLock,
    threadId,
    setThreadId,
    runId,
    setRunId,
    chatAbortControllerRef,
    extensions,
    setExtensions,
    langGraphInterruptAction,
    setLangGraphInterruptAction,
    chatSuggestionConfiguration,
    runtimeClient
  } = useCopilotContext();
  const { messages, setMessages, suggestions, setSuggestions } = useCopilotMessagesContext();
  const [mcpServers, setLocalMcpServers] = (0, import_react15.useState)([]);
  const suggestionsAbortControllerRef = (0, import_react15.useRef)(null);
  const isLoadingSuggestionsRef = (0, import_react15.useRef)(false);
  const abortSuggestions = (0, import_react15.useCallback)(
    (clear = true) => {
      var _a2;
      (_a2 = suggestionsAbortControllerRef.current) == null ? void 0 : _a2.abort("suggestions aborted by user");
      suggestionsAbortControllerRef.current = null;
      if (clear) {
        setSuggestions([]);
      }
    },
    [setSuggestions]
  );
  const stableContext = (0, import_react15.useMemo)(() => {
    return {
      actions,
      copilotApiConfig,
      chatSuggestionConfiguration,
      messages,
      setMessages,
      getContextString,
      runtimeClient
    };
  }, [
    JSON.stringify(Object.keys(actions)),
    copilotApiConfig.chatApiEndpoint,
    messages.length,
    Object.keys(chatSuggestionConfiguration).length
  ]);
  const generateSuggestionsFunc = (0, import_react15.useCallback)(() => __async(this, null, function* () {
    if (globalSuggestionPromise) {
      return globalSuggestionPromise;
    }
    globalSuggestionPromise = (() => __async(this, null, function* () {
      try {
        abortSuggestions();
        isLoadingSuggestionsRef.current = true;
        suggestionsAbortControllerRef.current = new AbortController();
        setSuggestions([]);
        yield reloadSuggestions(
          stableContext,
          chatSuggestionConfiguration,
          setSuggestions,
          suggestionsAbortControllerRef
        );
      } catch (error) {
        throw error;
      } finally {
        isLoadingSuggestionsRef.current = false;
        globalSuggestionPromise = null;
      }
    }))();
    return globalSuggestionPromise;
  }), [stableContext, chatSuggestionConfiguration, setSuggestions, abortSuggestions]);
  const resetSuggestions = (0, import_react15.useCallback)(() => {
    setSuggestions([]);
  }, [setSuggestions]);
  (0, import_react15.useEffect)(() => {
    if (mcpServers.length > 0) {
      const serversCopy = [...mcpServers];
      copilotApiConfig.mcpServers = serversCopy;
      if (!copilotApiConfig.properties) {
        copilotApiConfig.properties = {};
      }
      copilotApiConfig.properties.mcpServers = serversCopy;
    }
  }, [mcpServers, copilotApiConfig]);
  const setMcpServers = (0, import_react15.useCallback)((servers) => {
    setLocalMcpServers(servers);
  }, []);
  const onCoAgentStateRender = useAsyncCallback(
    (args) => __async(this, null, function* () {
      var _a2;
      const { name, nodeName, state } = args;
      let action = Object.values(coAgentStateRenders).find(
        (action2) => action2.name === name && action2.nodeName === nodeName
      );
      if (!action) {
        action = Object.values(coAgentStateRenders).find(
          (action2) => action2.name === name && !action2.nodeName
        );
      }
      if (action) {
        yield (_a2 = action.handler) == null ? void 0 : _a2.call(action, { state, nodeName });
      }
    }),
    [coAgentStateRenders]
  );
  const makeSystemMessageCallback = (0, import_react15.useCallback)(() => {
    const systemMessageMaker = makeSystemMessage2 || defaultSystemMessage;
    const contextString = getContextString([], defaultCopilotContextCategories);
    return new import_runtime_client_gql8.TextMessage({
      content: systemMessageMaker(contextString, chatInstructions),
      role: import_runtime_client_gql8.Role.System
    });
  }, [getContextString, makeSystemMessage2, chatInstructions]);
  const deleteMessage = (0, import_react15.useCallback)(
    (messageId) => {
      setMessages((prev) => prev.filter((message) => message.id !== messageId));
    },
    [setMessages]
  );
  const { append, reload, stop, runChatCompletion } = useChat(__spreadProps(__spreadValues({}, options), {
    actions: Object.values(actions),
    copilotConfig: copilotApiConfig,
    initialMessages: (0, import_runtime_client_gql8.aguiToGQL)(options.initialMessages || []),
    onFunctionCall: getFunctionCallHandler(),
    onCoAgentStateRender,
    messages,
    setMessages,
    makeSystemMessageCallback,
    isLoading,
    setIsLoading,
    coagentStatesRef,
    setCoagentStatesWithRef,
    agentSession,
    setAgentSession,
    forwardedParameters,
    threadId,
    setThreadId,
    runId,
    setRunId,
    chatAbortControllerRef,
    agentLock,
    extensions,
    setExtensions,
    langGraphInterruptAction,
    setLangGraphInterruptAction,
    disableSystemMessage: options.disableSystemMessage
  }));
  const latestAppend = useUpdatedRef(append);
  const latestAppendFunc = useAsyncCallback(
    (message, options2) => __async(this, null, function* () {
      abortSuggestions(options2 == null ? void 0 : options2.clearSuggestions);
      return yield latestAppend.current(message, options2);
    }),
    [latestAppend]
  );
  const latestSendMessageFunc = useAsyncCallback(
    (message, options2) => __async(this, null, function* () {
      abortSuggestions(options2 == null ? void 0 : options2.clearSuggestions);
      return yield latestAppend.current((0, import_runtime_client_gql8.aguiToGQL)([message])[0], options2);
    }),
    [latestAppend]
  );
  const latestReload = useUpdatedRef(reload);
  const latestReloadFunc = useAsyncCallback(
    (messageId) => __async(this, null, function* () {
      return yield latestReload.current(messageId);
    }),
    [latestReload]
  );
  const latestStop = useUpdatedRef(stop);
  const latestStopFunc = (0, import_react15.useCallback)(() => {
    return latestStop.current();
  }, [latestStop]);
  const latestDelete = useUpdatedRef(deleteMessage);
  const latestDeleteFunc = (0, import_react15.useCallback)(
    (messageId) => {
      return latestDelete.current(messageId);
    },
    [latestDelete]
  );
  const latestSetMessages = useUpdatedRef(setMessages);
  const latestSetMessagesFunc = (0, import_react15.useCallback)(
    (messages2) => {
      if (messages2.every((message) => message instanceof import_runtime_client_gql8.Message)) {
        return latestSetMessages.current(messages2);
      }
      return latestSetMessages.current((0, import_runtime_client_gql8.aguiToGQL)(messages2));
    },
    [latestSetMessages]
  );
  const latestRunChatCompletion = useUpdatedRef(runChatCompletion);
  const latestRunChatCompletionFunc = useAsyncCallback(() => __async(this, null, function* () {
    return yield latestRunChatCompletion.current();
  }), [latestRunChatCompletion]);
  const reset = (0, import_react15.useCallback)(() => {
    latestStopFunc();
    setMessages([]);
    setRunId(null);
    setCoagentStatesWithRef({});
    let initialAgentSession = null;
    if (agentLock) {
      initialAgentSession = {
        agentName: agentLock
      };
    }
    setAgentSession(initialAgentSession);
    resetSuggestions();
  }, [
    latestStopFunc,
    setMessages,
    setThreadId,
    setCoagentStatesWithRef,
    setAgentSession,
    agentLock,
    resetSuggestions
  ]);
  const latestReset = useUpdatedRef(reset);
  const latestResetFunc = (0, import_react15.useCallback)(() => {
    return latestReset.current();
  }, [latestReset]);
  const interrupt = useLangGraphInterruptRender();
  return {
    visibleMessages: messages,
    messages: (0, import_runtime_client_gql8.gqlToAGUI)(messages, actions, coAgentStateRenders),
    sendMessage: latestSendMessageFunc,
    appendMessage: latestAppendFunc,
    setMessages: latestSetMessagesFunc,
    reloadMessages: latestReloadFunc,
    stopGeneration: latestStopFunc,
    reset: latestResetFunc,
    deleteMessage: latestDeleteFunc,
    runChatCompletion: latestRunChatCompletionFunc,
    isLoading,
    mcpServers,
    setMcpServers,
    suggestions,
    setSuggestions,
    generateSuggestions: generateSuggestionsFunc,
    resetSuggestions,
    isLoadingSuggestions: isLoadingSuggestionsRef.current,
    interrupt
  };
}
function useUpdatedRef(value) {
  const ref = (0, import_react15.useRef)(value);
  (0, import_react15.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref;
}
function defaultSystemMessage(contextString, additionalInstructions) {
  return `
Please act as an efficient, competent, conscientious, and industrious professional assistant.

Help the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.
Always be polite and respectful, and prefer brevity over verbosity.

The user has provided you with the following context:
\`\`\`
${contextString}
\`\`\`

They have also provided you with functions you can call to initiate actions on their behalf, or functions you can call to receive more information.

Please assist them as best you can.

You can ask them for clarifying questions if needed, but don't be annoying about it. If you can reasonably 'fill in the blanks' yourself, do so.

If you would like to call a function, call it without saying anything else.
In case of a function error:
- If this error stems from incorrect function parameters or syntax, you may retry with corrected arguments.
- If the error's source is unclear or seems unrelated to your input, do not attempt further retries.
` + (additionalInstructions ? `

${additionalInstructions}` : "");
}

// src/hooks/use-copilot-chat.ts
function useCopilotChat2(options = {}) {
  const {
    visibleMessages,
    appendMessage,
    reloadMessages,
    stopGeneration,
    reset,
    isLoading,
    runChatCompletion,
    mcpServers,
    setMcpServers
  } = useCopilotChat(options);
  return {
    visibleMessages,
    appendMessage,
    reloadMessages,
    stopGeneration,
    reset,
    isLoading,
    runChatCompletion,
    mcpServers,
    setMcpServers
  };
}

// src/hooks/use-copilot-chat-headless_c.ts
var import_react16 = require("react");
var import_shared15 = require("@copilotkit/shared");
var createNonFunctionalReturn = () => ({
  visibleMessages: [],
  messages: [],
  sendMessage: () => __async(void 0, null, function* () {
  }),
  appendMessage: () => __async(void 0, null, function* () {
  }),
  setMessages: () => {
  },
  deleteMessage: () => {
  },
  reloadMessages: () => __async(void 0, null, function* () {
  }),
  stopGeneration: () => {
  },
  reset: () => {
  },
  isLoading: false,
  runChatCompletion: () => __async(void 0, null, function* () {
    return [];
  }),
  mcpServers: [],
  setMcpServers: () => {
  },
  suggestions: [],
  setSuggestions: () => {
  },
  generateSuggestions: () => __async(void 0, null, function* () {
  }),
  resetSuggestions: () => {
  },
  isLoadingSuggestions: false,
  interrupt: null
});
function useCopilotChatHeadless_c(options = {}) {
  const { copilotApiConfig, setBannerError } = useCopilotContext();
  const hasPublicApiKey = Boolean(copilotApiConfig.publicApiKey);
  const internalResult = useCopilotChat(options);
  (0, import_react16.useEffect)(() => {
    if (!hasPublicApiKey) {
      setBannerError(
        new import_shared15.CopilotKitError({
          message: (
            // add link to documentation here
            "You're using useCopilotChatHeadless_c, a premium-only feature, which offers extensive headless chat capabilities. To continue, you'll need to provide a free public license key."
          ),
          code: import_shared15.CopilotKitErrorCode.MISSING_PUBLIC_API_KEY_ERROR,
          severity: import_shared15.Severity.WARNING,
          visibility: import_shared15.ErrorVisibility.BANNER
        })
      );
      import_shared15.styledConsole.logCopilotKitPlatformMessage();
    } else {
      setBannerError(null);
    }
  }, [hasPublicApiKey]);
  if (hasPublicApiKey) {
    return internalResult;
  }
  return createNonFunctionalReturn();
}

// src/hooks/use-copilot-action.ts
var import_shared16 = require("@copilotkit/shared");
var import_react17 = require("react");
function useCopilotAction(action, dependencies) {
  const { setAction, removeAction, actions, chatComponentsCache } = useCopilotContext();
  const idRef = (0, import_react17.useRef)((0, import_shared16.randomId)());
  const renderAndWaitRef = (0, import_react17.useRef)(null);
  const activatingMessageIdRef = (0, import_react17.useRef)(null);
  const { addToast } = useToast();
  action = __spreadValues({}, action);
  if (
    // renderAndWaitForResponse is not available for catch all actions
    isFrontendAction(action) && // check if renderAndWaitForResponse is set
    (action.renderAndWait || action.renderAndWaitForResponse)
  ) {
    action._isRenderAndWait = true;
    const renderAndWait = action.renderAndWait || action.renderAndWaitForResponse;
    action.renderAndWait = void 0;
    action.renderAndWaitForResponse = void 0;
    action._setActivatingMessageId = (id) => {
      activatingMessageIdRef.current = id;
    };
    action.handler = useAsyncCallback(() => __async(this, null, function* () {
      const currentActivatingId = activatingMessageIdRef.current;
      let resolve;
      let reject;
      const promise = new Promise((resolvePromise, rejectPromise) => {
        resolve = resolvePromise;
        reject = rejectPromise;
      });
      renderAndWaitRef.current = {
        promise,
        resolve,
        reject,
        messageId: currentActivatingId
      };
      const result = yield promise;
      return result;
    }), []);
    action.render = (props) => {
      const currentRenderMessageId = props.messageId;
      let status = props.status;
      if (props.status === "executing") {
        if (!renderAndWaitRef.current || !renderAndWaitRef.current.promise) {
          status = "inProgress";
        } else if (renderAndWaitRef.current.messageId !== currentRenderMessageId && activatingMessageIdRef.current !== currentRenderMessageId) {
          status = "inProgress";
        }
      }
      const waitProps = {
        status,
        args: props.args,
        result: props.result,
        // handler and respond should only be provided if this is the truly active instance
        // and its promise infrastructure is ready.
        handler: status === "executing" && renderAndWaitRef.current && renderAndWaitRef.current.messageId === currentRenderMessageId ? renderAndWaitRef.current.resolve : void 0,
        respond: status === "executing" && renderAndWaitRef.current && renderAndWaitRef.current.messageId === currentRenderMessageId ? renderAndWaitRef.current.resolve : void 0
      };
      const isNoArgsRenderWait = (_fn) => {
        var _a;
        return ((_a = action.parameters) == null ? void 0 : _a.length) === 0;
      };
      if (renderAndWait) {
        if (isNoArgsRenderWait(renderAndWait)) {
          return renderAndWait(waitProps);
        } else {
          return renderAndWait(waitProps);
        }
      }
      return (0, import_react17.createElement)(import_react17.Fragment);
    };
  }
  if (dependencies === void 0) {
    if (actions[idRef.current]) {
      if (isFrontendAction(action)) {
        actions[idRef.current].handler = action.handler;
      }
      if (typeof action.render === "function") {
        if (chatComponentsCache.current !== null) {
          chatComponentsCache.current.actions[action.name] = action.render;
        }
      }
    }
  }
  (0, import_react17.useEffect)(() => {
    const hasDuplicate = Object.values(actions).some(
      (otherAction) => otherAction.name === action.name && otherAction !== actions[idRef.current]
    );
    if (hasDuplicate) {
      addToast({
        type: "warning",
        message: `Found an already registered action with name ${action.name}.`,
        id: `dup-action-${action.name}`
      });
    }
  }, [actions]);
  (0, import_react17.useEffect)(() => {
    setAction(idRef.current, action);
    if (chatComponentsCache.current !== null && action.render !== void 0) {
      chatComponentsCache.current.actions[action.name] = action.render;
    }
    return () => {
      removeAction(idRef.current);
    };
  }, [
    setAction,
    removeAction,
    isFrontendAction(action) ? action.description : void 0,
    action.name,
    isFrontendAction(action) ? action.disabled : void 0,
    isFrontendAction(action) ? action.available : void 0,
    // This should be faster than deep equality checking
    // In addition, all major JS engines guarantee the order of object keys
    JSON.stringify(isFrontendAction(action) ? action.parameters : []),
    // include render only if it's a string
    typeof action.render === "string" ? action.render : void 0,
    // dependencies set by the developer
    ...dependencies || []
  ]);
}
function isFrontendAction(action) {
  return action.name !== "*";
}

// src/hooks/use-coagent-state-render.ts
var import_react18 = require("react");
var import_shared17 = require("@copilotkit/shared");
function useCoAgentStateRender(action, dependencies) {
  const {
    setCoAgentStateRender,
    removeCoAgentStateRender,
    coAgentStateRenders,
    chatComponentsCache,
    availableAgents
  } = (0, import_react18.useContext)(CopilotContext);
  const idRef = (0, import_react18.useRef)((0, import_shared17.randomId)());
  const { setBannerError, addToast } = useToast();
  (0, import_react18.useEffect)(() => {
    if ((availableAgents == null ? void 0 : availableAgents.length) && !availableAgents.some((a) => a.name === action.name)) {
      const message = `(useCoAgentStateRender): Agent "${action.name}" not found. Make sure the agent exists and is properly configured.`;
      const agentError = new import_shared17.CopilotKitAgentDiscoveryError({
        agentName: action.name,
        availableAgents: availableAgents.map((a) => ({ name: a.name, id: a.id }))
      });
      setBannerError(agentError);
    }
  }, [availableAgents]);
  const key = `${action.name}-${action.nodeName || "global"}`;
  if (dependencies === void 0) {
    if (coAgentStateRenders[idRef.current]) {
      coAgentStateRenders[idRef.current].handler = action.handler;
      if (typeof action.render === "function") {
        if (chatComponentsCache.current !== null) {
          chatComponentsCache.current.coAgentStateRenders[key] = action.render;
        }
      }
    }
  }
  (0, import_react18.useEffect)(() => {
    const currentId = idRef.current;
    const hasDuplicate = Object.entries(coAgentStateRenders).some(([id, otherAction]) => {
      if (id === currentId)
        return false;
      if (otherAction.name !== action.name)
        return false;
      const hasNodeName = !!action.nodeName;
      const hasOtherNodeName = !!otherAction.nodeName;
      if (!hasNodeName && !hasOtherNodeName)
        return true;
      if (hasNodeName !== hasOtherNodeName)
        return false;
      return action.nodeName === otherAction.nodeName;
    });
    if (hasDuplicate) {
      const message = action.nodeName ? `Found multiple state renders for agent ${action.name} and node ${action.nodeName}. State renders might get overridden` : `Found multiple state renders for agent ${action.name}. State renders might get overridden`;
      addToast({
        type: "warning",
        message,
        id: `dup-action-${action.name}`
      });
    }
  }, [coAgentStateRenders]);
  (0, import_react18.useEffect)(() => {
    setCoAgentStateRender(idRef.current, action);
    if (chatComponentsCache.current !== null && action.render !== void 0) {
      chatComponentsCache.current.coAgentStateRenders[key] = action.render;
    }
    return () => {
      removeCoAgentStateRender(idRef.current);
    };
  }, [
    setCoAgentStateRender,
    removeCoAgentStateRender,
    action.name,
    // include render only if it's a string
    typeof action.render === "string" ? action.render : void 0,
    // dependencies set by the developer
    ...dependencies || []
  ]);
}

// src/hooks/use-make-copilot-document-readable.ts
var import_react19 = require("react");
function useMakeCopilotDocumentReadable(document2, categories, dependencies = []) {
  const { addDocumentContext, removeDocumentContext } = useCopilotContext();
  const idRef = (0, import_react19.useRef)();
  (0, import_react19.useEffect)(() => {
    const id = addDocumentContext(document2, categories);
    idRef.current = id;
    return () => {
      removeDocumentContext(id);
    };
  }, [addDocumentContext, removeDocumentContext, ...dependencies]);
  return idRef.current;
}

// src/hooks/use-copilot-readable.ts
var import_react20 = require("react");
function convertToJSON(description, value) {
  return `${description}: ${typeof value === "string" ? value : JSON.stringify(value)}`;
}
function useCopilotReadable({
  description,
  value,
  parentId,
  categories,
  convert,
  available = "enabled"
}, dependencies) {
  const { addContext, removeContext } = useCopilotContext();
  const idRef = (0, import_react20.useRef)();
  convert = convert || convertToJSON;
  const information = convert(description, value);
  (0, import_react20.useEffect)(() => {
    if (available === "disabled")
      return;
    const id = addContext(information, parentId, categories);
    idRef.current = id;
    return () => {
      removeContext(id);
    };
  }, [available, information, parentId, addContext, removeContext, ...dependencies || []]);
  return idRef.current;
}

// src/hooks/use-coagent.ts
var import_react21 = require("react");
var import_shared18 = require("@copilotkit/shared");
function useCoAgent(options) {
  const context = useCopilotContext();
  const { availableAgents, onError } = context;
  const { setBannerError } = useToast();
  const lastLoadedThreadId = (0, import_react21.useRef)();
  const lastLoadedState = (0, import_react21.useRef)();
  const { name } = options;
  (0, import_react21.useEffect)(() => {
    if ((availableAgents == null ? void 0 : availableAgents.length) && !availableAgents.some((a) => a.name === name)) {
      const message = `(useCoAgent): Agent "${name}" not found. Make sure the agent exists and is properly configured.`;
      console.warn(message);
      const agentError = new import_shared18.CopilotKitAgentDiscoveryError({
        agentName: name,
        availableAgents: availableAgents.map((a) => ({ name: a.name, id: a.id }))
      });
      setBannerError(agentError);
    }
  }, [availableAgents]);
  const { getMessagesFromTap } = useMessagesTap();
  const { coagentStates, coagentStatesRef, setCoagentStatesWithRef, threadId, copilotApiConfig } = context;
  const { sendMessage, runChatCompletion } = useCopilotChat();
  const headers = __spreadValues({}, copilotApiConfig.headers || {});
  const runtimeClient = useCopilotRuntimeClient({
    url: copilotApiConfig.chatApiEndpoint,
    publicApiKey: copilotApiConfig.publicApiKey,
    headers,
    credentials: copilotApiConfig.credentials,
    showDevConsole: context.showDevConsole,
    onError
  });
  const setState = (0, import_react21.useCallback)(
    (newState) => {
      let coagentState = getCoagentState({ coagentStates, name, options });
      const updatedState = typeof newState === "function" ? newState(coagentState.state) : newState;
      setCoagentStatesWithRef(__spreadProps(__spreadValues({}, coagentStatesRef.current), {
        [name]: __spreadProps(__spreadValues({}, coagentState), {
          state: updatedState
        })
      }));
    },
    [coagentStates, name]
  );
  (0, import_react21.useEffect)(() => {
    const fetchAgentState = () => __async(this, null, function* () {
      var _a, _b, _c, _d;
      if (!threadId || threadId === lastLoadedThreadId.current)
        return;
      const result = yield runtimeClient.loadAgentState({
        threadId,
        agentName: name
      });
      if (result.error) {
        return;
      }
      const newState = (_b = (_a = result.data) == null ? void 0 : _a.loadAgentState) == null ? void 0 : _b.state;
      if (newState === lastLoadedState.current)
        return;
      if (((_d = (_c = result.data) == null ? void 0 : _c.loadAgentState) == null ? void 0 : _d.threadExists) && newState && newState != "{}") {
        lastLoadedState.current = newState;
        lastLoadedThreadId.current = threadId;
        const fetchedState = (0, import_shared18.parseJson)(newState, {});
        isExternalStateManagement(options) ? options.setState(fetchedState) : setState(fetchedState);
      }
    });
    void fetchAgentState();
  }, [threadId]);
  (0, import_react21.useEffect)(() => {
    if (isExternalStateManagement(options)) {
      setState(options.state);
    } else if (coagentStates[name] === void 0) {
      setState(options.initialState === void 0 ? {} : options.initialState);
    }
  }, [
    isExternalStateManagement(options) ? JSON.stringify(options.state) : void 0,
    // reset initialstate on reset
    coagentStates[name] === void 0
  ]);
  (0, import_react21.useEffect)(() => {
    const newConfig = options.config ? options.config : options.configurable ? { configurable: options.configurable } : void 0;
    if (newConfig === void 0)
      return;
    setCoagentStatesWithRef((prev) => {
      var _a;
      const existing = (_a = prev[name]) != null ? _a : {
        name,
        state: isInternalStateManagementWithInitial(options) ? options.initialState : {},
        config: {},
        running: false,
        active: false,
        threadId: void 0,
        nodeName: void 0,
        runId: void 0
      };
      if (JSON.stringify(existing.config) === JSON.stringify(newConfig)) {
        return prev;
      }
      return __spreadProps(__spreadValues({}, prev), {
        [name]: __spreadProps(__spreadValues({}, existing), {
          config: newConfig
        })
      });
    });
  }, [JSON.stringify(options.config), JSON.stringify(options.configurable)]);
  const runAgentCallback = useAsyncCallback(
    (hint) => __async(this, null, function* () {
      yield runAgent(name, context, getMessagesFromTap(), sendMessage, runChatCompletion, hint);
    }),
    [name, context, sendMessage, runChatCompletion]
  );
  return (0, import_react21.useMemo)(() => {
    const coagentState = getCoagentState({ coagentStates, name, options });
    return {
      name,
      nodeName: coagentState.nodeName,
      threadId: coagentState.threadId,
      running: coagentState.running,
      state: coagentState.state,
      setState: isExternalStateManagement(options) ? options.setState : setState,
      start: () => startAgent(name, context),
      stop: () => stopAgent(name, context),
      run: runAgentCallback
    };
  }, [name, coagentStates, options, setState, runAgentCallback]);
}
function startAgent(name, context) {
  const { setAgentSession } = context;
  setAgentSession({
    agentName: name
  });
}
function stopAgent(name, context) {
  const { agentSession, setAgentSession } = context;
  if (agentSession && agentSession.agentName === name) {
    setAgentSession(null);
    context.setCoagentStates((prevAgentStates) => {
      return __spreadProps(__spreadValues({}, prevAgentStates), {
        [name]: __spreadProps(__spreadValues({}, prevAgentStates[name]), {
          running: false,
          active: false,
          threadId: void 0,
          nodeName: void 0,
          runId: void 0
        })
      });
    });
  } else {
    console.warn(`No agent session found for ${name}`);
  }
}
function runAgent(name, context, messages, sendMessage, runChatCompletion, hint) {
  return __async(this, null, function* () {
    var _a, _b;
    const { agentSession, setAgentSession } = context;
    if (!agentSession || agentSession.agentName !== name) {
      setAgentSession({
        agentName: name
      });
    }
    let previousState = null;
    for (let i = messages.length - 1; i >= 0; i--) {
      const message = messages[i];
      if (message.isAgentStateMessage() && message.agentName === name) {
        previousState = message.state;
      }
    }
    let state = ((_b = (_a = context.coagentStatesRef.current) == null ? void 0 : _a[name]) == null ? void 0 : _b.state) || {};
    if (hint) {
      const hintMessage = hint({ previousState, currentState: state });
      if (hintMessage) {
        yield sendMessage(hintMessage);
      } else {
        yield runChatCompletion();
      }
    } else {
      yield runChatCompletion();
    }
  });
}
var isExternalStateManagement = (options) => {
  return "state" in options && "setState" in options;
};
var isInternalStateManagementWithInitial = (options) => {
  return "initialState" in options;
};
var getCoagentState = ({
  coagentStates,
  name,
  options
}) => {
  if (coagentStates[name]) {
    return coagentStates[name];
  } else {
    return {
      name,
      state: isInternalStateManagementWithInitial(options) ? options.initialState : {},
      config: options.config ? options.config : options.configurable ? { configurable: options.configurable } : {},
      running: false,
      active: false,
      threadId: void 0,
      nodeName: void 0,
      runId: void 0
    };
  }
};

// src/hooks/use-copilot-authenticated-action.ts
var import_react22 = require("react");
var import_react23 = __toESM(require("react"));
function useCopilotAuthenticatedAction_c(action, dependencies) {
  const { authConfig_c, authStates_c, setAuthStates_c } = useCopilotContext();
  const pendingActionRef = (0, import_react22.useRef)(null);
  const executeAction2 = (0, import_react22.useCallback)(
    (props) => {
      if (typeof action.render === "function") {
        return action.render(props);
      }
      return action.render || import_react23.default.createElement(import_react22.Fragment);
    },
    [action]
  );
  const wrappedRender = (0, import_react22.useCallback)(
    (props) => {
      const isAuthenticated = Object.values(authStates_c || {}).some(
        (state) => state.status === "authenticated"
      );
      if (!isAuthenticated) {
        pendingActionRef.current = props;
        return (authConfig_c == null ? void 0 : authConfig_c.SignInComponent) ? import_react23.default.createElement(authConfig_c.SignInComponent, {
          onSignInComplete: (authState) => {
            setAuthStates_c == null ? void 0 : setAuthStates_c((prev) => __spreadProps(__spreadValues({}, prev), { [action.name]: authState }));
            if (pendingActionRef.current) {
              executeAction2(pendingActionRef.current);
              pendingActionRef.current = null;
            }
          }
        }) : import_react23.default.createElement(import_react22.Fragment);
      }
      return executeAction2(props);
    },
    [action, authStates_c, setAuthStates_c]
  );
  useCopilotAction(
    __spreadProps(__spreadValues({}, action), {
      render: wrappedRender
    }),
    dependencies
  );
}

// src/hooks/use-langgraph-interrupt.ts
var import_react24 = require("react");
var import_shared19 = require("@copilotkit/shared");
function useLangGraphInterrupt(action, dependencies) {
  var _a;
  const {
    setLangGraphInterruptAction,
    removeLangGraphInterruptAction,
    langGraphInterruptAction,
    threadId
  } = (0, import_react24.useContext)(CopilotContext);
  const { runChatCompletion } = useCopilotChat();
  const { addToast } = useToast();
  const actionId = (0, import_shared19.dataToUUID)(JSON.stringify(action), "lgAction");
  const hasAction = (0, import_react24.useMemo)(
    () => Boolean(langGraphInterruptAction == null ? void 0 : langGraphInterruptAction.id),
    [langGraphInterruptAction]
  );
  const isCurrentAction = (0, import_react24.useMemo)(
    () => (langGraphInterruptAction == null ? void 0 : langGraphInterruptAction.id) && (langGraphInterruptAction == null ? void 0 : langGraphInterruptAction.id) === actionId,
    [langGraphInterruptAction]
  );
  (0, import_react24.useEffect)(() => {
    var _a2;
    if (hasAction && isCurrentAction && ((_a2 = langGraphInterruptAction == null ? void 0 : langGraphInterruptAction.event) == null ? void 0 : _a2.response)) {
      runChatCompletion();
    }
  }, [(_a = langGraphInterruptAction == null ? void 0 : langGraphInterruptAction.event) == null ? void 0 : _a.response, runChatCompletion, hasAction, isCurrentAction]);
  (0, import_react24.useEffect)(() => {
    if (!action)
      return;
    if (hasAction && !isCurrentAction && !action.enabled) {
      addToast({
        type: "warning",
        message: "An action is already registered for the interrupt event"
      });
      return;
    }
    if (hasAction && isCurrentAction) {
      return;
    }
    setLangGraphInterruptAction(threadId, __spreadProps(__spreadValues({}, action), { id: actionId }));
  }, [
    action,
    hasAction,
    isCurrentAction,
    setLangGraphInterruptAction,
    removeLangGraphInterruptAction,
    threadId,
    ...dependencies || []
  ]);
}

// src/hooks/use-copilot-additional-instructions.ts
var import_react25 = require("react");
function useCopilotAdditionalInstructions({ instructions, available = "enabled" }, dependencies) {
  const { setAdditionalInstructions } = useCopilotContext();
  (0, import_react25.useEffect)(() => {
    if (available === "disabled")
      return;
    setAdditionalInstructions((prevInstructions) => [...prevInstructions || [], instructions]);
    return () => {
      setAdditionalInstructions(
        (prevInstructions) => (prevInstructions == null ? void 0 : prevInstructions.filter((instruction) => instruction !== instructions)) || []
      );
    };
  }, [available, instructions, setAdditionalInstructions, ...dependencies || []]);
}

// src/hooks/use-frontend-tool.ts
function useFrontendTool(tool, dependencies) {
  useCopilotAction(tool, dependencies);
}

// src/hooks/use-human-in-the-loop.ts
function useHumanInTheLoop(tool, dependencies) {
  const _a = tool, { render } = _a, toolRest = __objRest(_a, ["render"]);
  useCopilotAction(
    __spreadProps(__spreadValues({}, toolRest), {
      available: tool.available === "disabled" ? tool.available : "remote",
      renderAndWaitForResponse: render
    }),
    dependencies
  );
}

// src/hooks/use-render-tool-call.ts
function useRenderToolCall(tool, dependencies) {
  useCopilotAction(
    __spreadProps(__spreadValues({}, tool), {
      available: tool.available === "disabled" ? tool.available : "frontend"
    }),
    dependencies
  );
}

// src/hooks/use-default-tool.ts
function useDefaultTool(tool, dependencies) {
  useCopilotAction(__spreadProps(__spreadValues({}, tool), { name: "*" }), dependencies);
}

// src/lib/copilot-task.ts
var import_runtime_client_gql9 = require("@copilotkit/runtime-client-gql");
var CopilotTask = class {
  constructor(config) {
    this.instructions = config.instructions;
    this.actions = config.actions || [];
    this.includeCopilotReadable = config.includeCopilotReadable !== false;
    this.includeCopilotActions = config.includeCopilotActions !== false;
    this.forwardedParameters = config.forwardedParameters;
  }
  /**
   * Run the task.
   * @param context The CopilotContext to use for the task. Use `useCopilotContext` to obtain the current context.
   * @param data The data to use for the task.
   */
  run(context, data) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      const actions = this.includeCopilotActions ? Object.assign({}, context.actions) : {};
      for (const fn of this.actions) {
        actions[fn.name] = fn;
      }
      let contextString = "";
      if (data) {
        contextString = (typeof data === "string" ? data : JSON.stringify(data)) + "\n\n";
      }
      if (this.includeCopilotReadable) {
        contextString += context.getContextString([], defaultCopilotContextCategories);
      }
      const systemMessage = new import_runtime_client_gql9.TextMessage({
        content: taskSystemMessage(contextString, this.instructions),
        role: import_runtime_client_gql9.Role.System
      });
      const messages = [systemMessage];
      const runtimeClient = new import_runtime_client_gql9.CopilotRuntimeClient({
        url: context.copilotApiConfig.chatApiEndpoint,
        publicApiKey: context.copilotApiConfig.publicApiKey,
        headers: context.copilotApiConfig.headers,
        credentials: context.copilotApiConfig.credentials
      });
      const response = yield runtimeClient.generateCopilotResponse({
        data: {
          frontend: {
            actions: processActionsForRuntimeRequest(Object.values(actions)),
            url: window.location.href
          },
          messages: (0, import_runtime_client_gql9.convertMessagesToGqlInput)((0, import_runtime_client_gql9.filterAgentStateMessages)(messages)),
          metadata: {
            requestType: import_runtime_client_gql9.CopilotRequestType.Task
          },
          forwardedParameters: __spreadValues({
            // if forwardedParameters is provided, use it
            toolChoice: "required"
          }, (_a = this.forwardedParameters) != null ? _a : {})
        },
        properties: context.copilotApiConfig.properties
      }).toPromise();
      const functionCallHandler = context.getFunctionCallHandler(actions);
      const functionCalls = (0, import_runtime_client_gql9.convertGqlOutputToMessages)(
        ((_c = (_b = response.data) == null ? void 0 : _b.generateCopilotResponse) == null ? void 0 : _c.messages) || []
      ).filter((m) => m.isActionExecutionMessage());
      for (const functionCall of functionCalls) {
        yield functionCallHandler({
          messages,
          name: functionCall.name,
          args: functionCall.arguments
        });
      }
    });
  }
};
function taskSystemMessage(contextString, instructions) {
  return `
Please act as an efficient, competent, conscientious, and industrious professional assistant.

Help the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.
Always be polite and respectful, and prefer brevity over verbosity.

The user has provided you with the following context:
\`\`\`
${contextString}
\`\`\`

They have also provided you with functions you can call to initiate actions on their behalf.

Please assist them as best you can.

This is not a conversation, so please do not ask questions. Just call a function without saying anything else.

The user has given you the following task to complete:

\`\`\`
${instructions}
\`\`\`
`;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CopilotContext,
  CopilotKit,
  CopilotMessagesContext,
  CopilotTask,
  SUGGESTION_RETRY_CONFIG,
  defaultCopilotContextCategories,
  extract,
  reloadSuggestions,
  runAgent,
  shouldShowDevConsole,
  startAgent,
  stopAgent,
  useCoAgent,
  useCoAgentStateRender,
  useCopilotAction,
  useCopilotAdditionalInstructions,
  useCopilotAuthenticatedAction_c,
  useCopilotChat,
  useCopilotChatHeadless_c,
  useCopilotChatInternal,
  useCopilotContext,
  useCopilotMessagesContext,
  useCopilotReadable,
  useCopilotRuntimeClient,
  useDefaultTool,
  useFrontendTool,
  useHumanInTheLoop,
  useLangGraphInterrupt,
  useLangGraphInterruptRender,
  useMakeCopilotDocumentReadable,
  useRenderToolCall
});
//# sourceMappingURL=index.js.map