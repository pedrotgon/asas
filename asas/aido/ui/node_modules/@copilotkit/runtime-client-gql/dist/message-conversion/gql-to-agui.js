"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/message-conversion/gql-to-agui.ts
var gql_to_agui_exports = {};
__export(gql_to_agui_exports, {
  gqlActionExecutionMessageToAGUIMessage: () => gqlActionExecutionMessageToAGUIMessage,
  gqlImageMessageToAGUIMessage: () => gqlImageMessageToAGUIMessage,
  gqlResultMessageToAGUIMessage: () => gqlResultMessageToAGUIMessage,
  gqlTextMessageToAGUIMessage: () => gqlTextMessageToAGUIMessage,
  gqlToAGUI: () => gqlToAGUI
});
module.exports = __toCommonJS(gql_to_agui_exports);

// src/graphql/@generated/graphql.ts
var MessageRole = /* @__PURE__ */ ((MessageRole2) => {
  MessageRole2["Assistant"] = "assistant";
  MessageRole2["Developer"] = "developer";
  MessageRole2["System"] = "system";
  MessageRole2["Tool"] = "tool";
  MessageRole2["User"] = "user";
  return MessageRole2;
})(MessageRole || {});

// src/client/types.ts
var import_shared = require("@copilotkit/shared");
var import_shared2 = require("@copilotkit/shared");
var Role = MessageRole;

// src/message-conversion/gql-to-agui.ts
var VALID_IMAGE_FORMATS = ["jpeg", "png", "webp", "gif"];
function validateImageFormat(format) {
  return VALID_IMAGE_FORMATS.includes(format);
}
function gqlToAGUI(messages, actions, coAgentStateRenders) {
  let aguiMessages = [];
  messages = Array.isArray(messages) ? messages : [messages];
  const actionResults = /* @__PURE__ */ new Map();
  for (const message of messages) {
    if (message.isResultMessage()) {
      actionResults.set(message.actionExecutionId, message.result);
    }
  }
  for (const message of messages) {
    if (message.isTextMessage()) {
      aguiMessages.push(gqlTextMessageToAGUIMessage(message));
    } else if (message.isResultMessage()) {
      aguiMessages.push(gqlResultMessageToAGUIMessage(message));
    } else if (message.isActionExecutionMessage()) {
      aguiMessages.push(gqlActionExecutionMessageToAGUIMessage(message, actions, actionResults));
    } else if (message.isAgentStateMessage()) {
      aguiMessages.push(gqlAgentStateMessageToAGUIMessage(message, coAgentStateRenders));
    } else if (message.isImageMessage()) {
      aguiMessages.push(gqlImageMessageToAGUIMessage(message));
    } else {
      throw new Error("Unknown message type");
    }
  }
  return aguiMessages;
}
function gqlActionExecutionMessageToAGUIMessage(message, actions, actionResults) {
  const hasSpecificAction = actions && Object.values(actions).some((action2) => action2.name === message.name);
  const hasWildcardAction = actions && Object.values(actions).some((action2) => action2.name === "*");
  if (!actions || !hasSpecificAction && !hasWildcardAction) {
    return {
      id: message.id,
      role: "assistant",
      toolCalls: [actionExecutionMessageToAGUIMessage(message)],
      name: message.name
    };
  }
  const action = Object.values(actions).find((action2) => action2.name === message.name) || Object.values(actions).find((action2) => action2.name === "*");
  const createRenderWrapper = (originalRender) => {
    if (!originalRender)
      return void 0;
    return (props) => {
      var _a;
      let actionResult = actionResults == null ? void 0 : actionResults.get(message.id);
      let status = "inProgress";
      if (actionResult !== void 0) {
        status = "complete";
      } else if (((_a = message.status) == null ? void 0 : _a.code) !== "Pending" /* Pending */) {
        status = "executing";
      }
      if (typeof (props == null ? void 0 : props.result) === "string") {
        try {
          props.result = JSON.parse(props.result);
        } catch (e) {
        }
      }
      if (typeof actionResult === "string") {
        try {
          actionResult = JSON.parse(actionResult);
        } catch (e) {
        }
      }
      const baseProps = {
        status: (props == null ? void 0 : props.status) || status,
        args: message.arguments || {},
        result: (props == null ? void 0 : props.result) || actionResult || void 0,
        messageId: message.id
      };
      if (action.name === "*") {
        return originalRender({
          ...baseProps,
          ...props,
          name: message.name
        });
      } else {
        const respond = (props == null ? void 0 : props.respond) ?? (() => {
        });
        return originalRender({
          ...baseProps,
          ...props,
          respond
        });
      }
    };
  };
  return {
    id: message.id,
    role: "assistant",
    content: "",
    toolCalls: [actionExecutionMessageToAGUIMessage(message)],
    generativeUI: createRenderWrapper(action.render),
    name: message.name
  };
}
function gqlAgentStateMessageToAGUIMessage(message, coAgentStateRenders) {
  if (coAgentStateRenders && Object.values(coAgentStateRenders).some((render) => render.name === message.agentName)) {
    const render = Object.values(coAgentStateRenders).find(
      (render2) => render2.name === message.agentName
    );
    const createRenderWrapper = (originalRender) => {
      if (!originalRender)
        return void 0;
      return (props) => {
        const state = message.state;
        const renderProps = {
          state
        };
        return originalRender(renderProps);
      };
    };
    return {
      id: message.id,
      role: "assistant",
      generativeUI: createRenderWrapper(render.render),
      agentName: message.agentName,
      state: message.state
    };
  }
  return {
    id: message.id,
    role: "assistant",
    agentName: message.agentName,
    state: message.state
  };
}
function actionExecutionMessageToAGUIMessage(actionExecutionMessage) {
  return {
    id: actionExecutionMessage.id,
    function: {
      name: actionExecutionMessage.name,
      arguments: JSON.stringify(actionExecutionMessage.arguments)
    },
    type: "function"
  };
}
function gqlTextMessageToAGUIMessage(message) {
  switch (message.role) {
    case Role.Developer:
      return {
        id: message.id,
        role: "developer",
        content: message.content
      };
    case Role.System:
      return {
        id: message.id,
        role: "system",
        content: message.content
      };
    case Role.Assistant:
      return {
        id: message.id,
        role: "assistant",
        content: message.content
      };
    case Role.User:
      return {
        id: message.id,
        role: "user",
        content: message.content
      };
    default:
      throw new Error("Unknown message role");
  }
}
function gqlResultMessageToAGUIMessage(message) {
  return {
    id: message.id,
    role: "tool",
    content: message.result,
    toolCallId: message.actionExecutionId,
    toolName: message.actionName
  };
}
function gqlImageMessageToAGUIMessage(message) {
  if (!validateImageFormat(message.format)) {
    throw new Error(
      `Invalid image format: ${message.format}. Supported formats are: ${VALID_IMAGE_FORMATS.join(", ")}`
    );
  }
  if (!message.bytes || typeof message.bytes !== "string" || message.bytes.trim() === "") {
    throw new Error("Image bytes must be a non-empty string");
  }
  const role = message.role === Role.Assistant ? "assistant" : "user";
  const imageMessage = {
    id: message.id,
    role,
    content: "",
    image: {
      format: message.format,
      bytes: message.bytes
    }
  };
  return imageMessage;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  gqlActionExecutionMessageToAGUIMessage,
  gqlImageMessageToAGUIMessage,
  gqlResultMessageToAGUIMessage,
  gqlTextMessageToAGUIMessage,
  gqlToAGUI
});
//# sourceMappingURL=gql-to-agui.js.map