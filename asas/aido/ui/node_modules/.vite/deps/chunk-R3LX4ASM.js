import {
  require_jsx_runtime
} from "./chunk-OT5EQO2H.js";
import {
  require_react_dom
} from "./chunk-WRD5HZVH.js";
import {
  require_react
} from "./chunk-OU5AQDZK.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports, module) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert2 = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module.exports = convert2;
    for (const model of Object.keys(convert2)) {
      if (!("channels" in convert2[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert2[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert2[model].labels.length !== convert2[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert2[model];
      delete convert2[model].channels;
      delete convert2[model].labels;
      Object.defineProperty(convert2[model], "channels", { value: channels });
      Object.defineProperty(convert2[model], "labels", { value: labels });
    }
    convert2.rgb.hsl = function(rgb) {
      const r2 = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r2, g, b);
      const max = Math.max(r2, g, b);
      const delta = max - min;
      let h2;
      let s;
      if (max === min) {
        h2 = 0;
      } else if (r2 === max) {
        h2 = (g - b) / delta;
      } else if (g === max) {
        h2 = 2 + (b - r2) / delta;
      } else if (b === max) {
        h2 = 4 + (r2 - g) / delta;
      }
      h2 = Math.min(h2 * 60, 360);
      if (h2 < 0) {
        h2 += 360;
      }
      const l2 = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l2 <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h2, s * 100, l2 * 100];
    };
    convert2.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h2;
      let s;
      const r2 = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v2 = Math.max(r2, g, b);
      const diff2 = v2 - Math.min(r2, g, b);
      const diffc = function(c2) {
        return (v2 - c2) / 6 / diff2 + 1 / 2;
      };
      if (diff2 === 0) {
        h2 = 0;
        s = 0;
      } else {
        s = diff2 / v2;
        rdif = diffc(r2);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r2 === v2) {
          h2 = bdif - gdif;
        } else if (g === v2) {
          h2 = 1 / 3 + rdif - bdif;
        } else if (b === v2) {
          h2 = 2 / 3 + gdif - rdif;
        }
        if (h2 < 0) {
          h2 += 1;
        } else if (h2 > 1) {
          h2 -= 1;
        }
      }
      return [
        h2 * 360,
        s * 100,
        v2 * 100
      ];
    };
    convert2.rgb.hwb = function(rgb) {
      const r2 = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h2 = convert2.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r2, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r2, Math.max(g, b));
      return [h2, w * 100, b * 100];
    };
    convert2.rgb.cmyk = function(rgb) {
      const r2 = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r2, 1 - g, 1 - b);
      const c2 = (1 - r2 - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y2 = (1 - b - k) / (1 - k) || 0;
      return [c2 * 100, m * 100, y2 * 100, k * 100];
    };
    function comparativeDistance(x, y2) {
      return (x[0] - y2[0]) ** 2 + (x[1] - y2[1]) ** 2 + (x[2] - y2[2]) ** 2;
    }
    convert2.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value2 = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value2);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert2.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert2.rgb.xyz = function(rgb) {
      let r2 = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r2 * 0.4124 + g * 0.3576 + b * 0.1805;
      const y2 = r2 * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r2 * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y2 * 100, z * 100];
    };
    convert2.rgb.lab = function(rgb) {
      const xyz = convert2.rgb.xyz(rgb);
      let x = xyz[0];
      let y2 = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y2 /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l2 = 116 * y2 - 16;
      const a2 = 500 * (x - y2);
      const b = 200 * (y2 - z);
      return [l2, a2, b];
    };
    convert2.hsl.rgb = function(hsl) {
      const h2 = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l2 = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l2 * 255;
        return [val, val, val];
      }
      if (l2 < 0.5) {
        t2 = l2 * (1 + s);
      } else {
        t2 = l2 + s - l2 * s;
      }
      const t1 = 2 * l2 - t2;
      const rgb = [0, 0, 0];
      for (let i3 = 0; i3 < 3; i3++) {
        t3 = h2 + 1 / 3 * -(i3 - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i3] = val * 255;
      }
      return rgb;
    };
    convert2.hsl.hsv = function(hsl) {
      const h2 = hsl[0];
      let s = hsl[1] / 100;
      let l2 = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l2, 0.01);
      l2 *= 2;
      s *= l2 <= 1 ? l2 : 2 - l2;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v2 = (l2 + s) / 2;
      const sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l2 + s);
      return [h2, sv * 100, v2 * 100];
    };
    convert2.hsv.rgb = function(hsv) {
      const h2 = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v2 = hsv[2] / 100;
      const hi = Math.floor(h2) % 6;
      const f3 = h2 - Math.floor(h2);
      const p2 = 255 * v2 * (1 - s);
      const q = 255 * v2 * (1 - s * f3);
      const t2 = 255 * v2 * (1 - s * (1 - f3));
      v2 *= 255;
      switch (hi) {
        case 0:
          return [v2, t2, p2];
        case 1:
          return [q, v2, p2];
        case 2:
          return [p2, v2, t2];
        case 3:
          return [p2, q, v2];
        case 4:
          return [t2, p2, v2];
        case 5:
          return [v2, p2, q];
      }
    };
    convert2.hsv.hsl = function(hsv) {
      const h2 = hsv[0];
      const s = hsv[1] / 100;
      const v2 = hsv[2] / 100;
      const vmin = Math.max(v2, 0.01);
      let sl;
      let l2;
      l2 = (2 - s) * v2;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l2 /= 2;
      return [h2, sl * 100, l2 * 100];
    };
    convert2.hwb.rgb = function(hwb) {
      const h2 = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f3;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i3 = Math.floor(6 * h2);
      const v2 = 1 - bl;
      f3 = 6 * h2 - i3;
      if ((i3 & 1) !== 0) {
        f3 = 1 - f3;
      }
      const n2 = wh + f3 * (v2 - wh);
      let r2;
      let g;
      let b;
      switch (i3) {
        default:
        case 6:
        case 0:
          r2 = v2;
          g = n2;
          b = wh;
          break;
        case 1:
          r2 = n2;
          g = v2;
          b = wh;
          break;
        case 2:
          r2 = wh;
          g = v2;
          b = n2;
          break;
        case 3:
          r2 = wh;
          g = n2;
          b = v2;
          break;
        case 4:
          r2 = n2;
          g = wh;
          b = v2;
          break;
        case 5:
          r2 = v2;
          g = wh;
          b = n2;
          break;
      }
      return [r2 * 255, g * 255, b * 255];
    };
    convert2.cmyk.rgb = function(cmyk) {
      const c2 = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y2 = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r2 = 1 - Math.min(1, c2 * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y2 * (1 - k) + k);
      return [r2 * 255, g * 255, b * 255];
    };
    convert2.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y2 = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r2;
      let g;
      let b;
      r2 = x * 3.2406 + y2 * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y2 * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y2 * -0.204 + z * 1.057;
      r2 = r2 > 31308e-7 ? 1.055 * r2 ** (1 / 2.4) - 0.055 : r2 * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r2 = Math.min(Math.max(0, r2), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r2 * 255, g * 255, b * 255];
    };
    convert2.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y2 = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y2 /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l2 = 116 * y2 - 16;
      const a2 = 500 * (x - y2);
      const b = 200 * (y2 - z);
      return [l2, a2, b];
    };
    convert2.lab.xyz = function(lab) {
      const l2 = lab[0];
      const a2 = lab[1];
      const b = lab[2];
      let x;
      let y2;
      let z;
      y2 = (l2 + 16) / 116;
      x = a2 / 500 + y2;
      z = y2 - b / 200;
      const y22 = y2 ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y2 *= 100;
      z *= 108.883;
      return [x, y2, z];
    };
    convert2.lab.lch = function(lab) {
      const l2 = lab[0];
      const a2 = lab[1];
      const b = lab[2];
      let h2;
      const hr = Math.atan2(b, a2);
      h2 = hr * 360 / 2 / Math.PI;
      if (h2 < 0) {
        h2 += 360;
      }
      const c2 = Math.sqrt(a2 * a2 + b * b);
      return [l2, c2, h2];
    };
    convert2.lch.lab = function(lch) {
      const l2 = lch[0];
      const c2 = lch[1];
      const h2 = lch[2];
      const hr = h2 / 360 * 2 * Math.PI;
      const a2 = c2 * Math.cos(hr);
      const b = c2 * Math.sin(hr);
      return [l2, a2, b];
    };
    convert2.rgb.ansi16 = function(args, saturation = null) {
      const [r2, g, b] = args;
      let value2 = saturation === null ? convert2.rgb.hsv(args)[2] : saturation;
      value2 = Math.round(value2 / 50);
      if (value2 === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r2 / 255));
      if (value2 === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert2.hsv.ansi16 = function(args) {
      return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
    };
    convert2.rgb.ansi256 = function(args) {
      const r2 = args[0];
      const g = args[1];
      const b = args[2];
      if (r2 === g && g === b) {
        if (r2 < 8) {
          return 16;
        }
        if (r2 > 248) {
          return 231;
        }
        return Math.round((r2 - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert2.ansi16.rgb = function(args) {
      let color2 = args % 10;
      if (color2 === 0 || color2 === 7) {
        if (args > 50) {
          color2 += 3.5;
        }
        color2 = color2 / 10.5 * 255;
        return [color2, color2, color2];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r2 = (color2 & 1) * mult * 255;
      const g = (color2 >> 1 & 1) * mult * 255;
      const b = (color2 >> 2 & 1) * mult * 255;
      return [r2, g, b];
    };
    convert2.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c2 = (args - 232) * 10 + 8;
        return [c2, c2, c2];
      }
      args -= 16;
      let rem;
      const r2 = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r2, g, b];
    };
    convert2.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string3 = integer.toString(16).toUpperCase();
      return "000000".substring(string3.length) + string3;
    };
    convert2.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r2 = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r2, g, b];
    };
    convert2.rgb.hcg = function(rgb) {
      const r2 = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r2, g), b);
      const min = Math.min(Math.min(r2, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r2) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r2) / chroma;
      } else {
        hue = 4 + (r2 - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert2.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l2 = hsl[2] / 100;
      const c2 = l2 < 0.5 ? 2 * s * l2 : 2 * s * (1 - l2);
      let f3 = 0;
      if (c2 < 1) {
        f3 = (l2 - 0.5 * c2) / (1 - c2);
      }
      return [hsl[0], c2 * 100, f3 * 100];
    };
    convert2.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v2 = hsv[2] / 100;
      const c2 = s * v2;
      let f3 = 0;
      if (c2 < 1) {
        f3 = (v2 - c2) / (1 - c2);
      }
      return [hsv[0], c2 * 100, f3 * 100];
    };
    convert2.hcg.rgb = function(hcg) {
      const h2 = hcg[0] / 360;
      const c2 = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c2 === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h2 % 1 * 6;
      const v2 = hi % 1;
      const w = 1 - v2;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v2;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v2;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v2;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c2) * g;
      return [
        (c2 * pure[0] + mg) * 255,
        (c2 * pure[1] + mg) * 255,
        (c2 * pure[2] + mg) * 255
      ];
    };
    convert2.hcg.hsv = function(hcg) {
      const c2 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v2 = c2 + g * (1 - c2);
      let f3 = 0;
      if (v2 > 0) {
        f3 = c2 / v2;
      }
      return [hcg[0], f3 * 100, v2 * 100];
    };
    convert2.hcg.hsl = function(hcg) {
      const c2 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l2 = g * (1 - c2) + 0.5 * c2;
      let s = 0;
      if (l2 > 0 && l2 < 0.5) {
        s = c2 / (2 * l2);
      } else if (l2 >= 0.5 && l2 < 1) {
        s = c2 / (2 * (1 - l2));
      }
      return [hcg[0], s * 100, l2 * 100];
    };
    convert2.hcg.hwb = function(hcg) {
      const c2 = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v2 = c2 + g * (1 - c2);
      return [hcg[0], (v2 - c2) * 100, (1 - v2) * 100];
    };
    convert2.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v2 = 1 - b;
      const c2 = v2 - w;
      let g = 0;
      if (c2 < 1) {
        g = (v2 - c2) / (1 - c2);
      }
      return [hwb[0], c2 * 100, g * 100];
    };
    convert2.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert2.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert2.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert2.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert2.gray.hsv = convert2.gray.hsl;
    convert2.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert2.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert2.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert2.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string3 = integer.toString(16).toUpperCase();
      return "000000".substring(string3.length) + string3;
    };
    convert2.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports, module) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i3 = 0; i3 < len; i3++) {
        graph[models[i3]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i3 = 0; i3 < len; i3++) {
          const adjacent = adjacents[i3];
          const node2 = graph[adjacent];
          if (node2.distance === -1) {
            node2.distance = graph[current].distance + 1;
            node2.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link2(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path2 = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path2.unshift(graph[cur].parent);
        fn = link2(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path2;
      return fn;
    }
    module.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i3 = 0; i3 < len; i3++) {
        const toModel = models[i3];
        const node2 = graph[toModel];
        if (node2.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports, module) {
    var conversions = require_conversions();
    var route = require_route();
    var convert2 = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i3 = 0; i3 < len; i3++) {
            result[i3] = Math.round(result[i3]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert2[fromModel] = {};
      Object.defineProperty(convert2[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert2[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert2[fromModel][toModel] = wrapRounded(fn);
        convert2[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module.exports = convert2;
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ansi-styles/index.js"(exports, module) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code2 = fn(...args);
      return `\x1B[${code2 + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code2 = fn(...args);
      return `\x1B[${38 + offset};5;${code2}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n2) => n2;
    var rgb2rgb = (r2, g, b) => [r2, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value2 = get();
          Object.defineProperty(object, property, {
            value: value2,
            enumerable: true,
            configurable: true
          });
          return value2;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap6, targetSpace, identity2, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name2 = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name2] = wrap6(identity2, offset);
        } else if (typeof suite === "object") {
          styles[name2] = wrap6(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes3 = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes3.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes3,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/supports-color/browser.js
var require_browser = __commonJS({
  "node_modules/supports-color/browser.js"(exports, module) {
    "use strict";
    module.exports = {
      stdout: false,
      stderr: false
    };
  }
});

// node_modules/chalk/source/util.js
var require_util = __commonJS({
  "node_modules/chalk/source/util.js"(exports, module) {
    "use strict";
    var stringReplaceAll = (string3, substring, replacer) => {
      let index3 = string3.indexOf(substring);
      if (index3 === -1) {
        return string3;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string3.substr(endIndex, index3 - endIndex) + substring + replacer;
        endIndex = index3 + substringLength;
        index3 = string3.indexOf(substring, endIndex);
      } while (index3 !== -1);
      returnValue += string3.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string3, prefix, postfix, index3) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string3[index3 - 1] === "\r";
        returnValue += string3.substr(endIndex, (gotCR ? index3 - 1 : index3) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index3 + 1;
        index3 = string3.indexOf("\n", endIndex);
      } while (index3 !== -1);
      returnValue += string3.substr(endIndex);
      return returnValue;
    };
    module.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  "node_modules/chalk/source/templates.js"(exports, module) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape2(c2) {
      const u3 = c2[0] === "u";
      const bracket = c2[1] === "{";
      if (u3 && !bracket && c2.length === 5 || c2[0] === "x" && c2.length === 3) {
        return String.fromCharCode(parseInt(c2.slice(1), 16));
      }
      if (u3 && bracket) {
        return String.fromCodePoint(parseInt(c2.slice(2, -1), 16));
      }
      return ESCAPES.get(c2) || c2;
    }
    function parseArguments(name2, arguments_2) {
      const results = [];
      const chunks = arguments_2.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number2 = Number(chunk);
        if (!Number.isNaN(number2)) {
          results.push(number2);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape2(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name2}')`);
        }
      }
      return results;
    }
    function parseStyle2(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name2 = matches[1];
        if (matches[2]) {
          const args = parseArguments(name2, matches[2]);
          results.push([name2].concat(args));
        } else {
          results.push([name2]);
        }
      }
      return results;
    }
    function buildStyle(chalk2, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk2;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module.exports = (chalk2, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape2(escapeCharacter));
        } else if (style) {
          const string3 = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string3 : buildStyle(chalk2, styles)(string3));
          styles.push({ inverse, styles: parseStyle2(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk2, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// node_modules/chalk/source/index.js
var require_source = __commonJS({
  "node_modules/chalk/source/index.js"(exports, module) {
    "use strict";
    var ansiStyles = require_ansi_styles();
    var { stdout: stdoutColor, stderr: stderrColor } = require_browser();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = /* @__PURE__ */ Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk3 = {};
      applyOptions(chalk3, options);
      chalk3.template = (...arguments_2) => chalkTag(chalk3.template, ...arguments_2);
      Object.setPrototypeOf(chalk3, Chalk.prototype);
      Object.setPrototypeOf(chalk3.template, chalk3);
      chalk3.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk3.template.Instance = ChalkClass;
      return chalk3.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_2) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_2), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_2) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_2), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self, _styler, _isEmpty) => {
      const builder = (...arguments_2) => {
        if (isArray(arguments_2[0]) && isArray(arguments_2[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_2));
        }
        return applyStyle(builder, arguments_2.length === 1 ? "" + arguments_2[0] : arguments_2.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self, string3) => {
      if (self.level <= 0 || !string3) {
        return self._isEmpty ? "" : string3;
      }
      let styler = self._styler;
      if (styler === void 0) {
        return string3;
      }
      const { openAll, closeAll } = styler;
      if (string3.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string3 = stringReplaceAll(string3, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string3.indexOf("\n");
      if (lfIndex !== -1) {
        string3 = stringEncaseCRLFWithFirstIndex(string3, closeAll, openAll, lfIndex);
      }
      return openAll + string3 + closeAll;
    };
    var template;
    var chalkTag = (chalk3, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_2 = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i3 = 1; i3 < firstString.length; i3++) {
        parts.push(
          String(arguments_2[i3 - 1]).replace(/[{}\\]/g, "\\$&"),
          String(firstString.raw[i3])
        );
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk3, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk2 = Chalk();
    chalk2.supportsColor = stdoutColor;
    chalk2.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk2.stderr.supportsColor = stderrColor;
    module.exports = chalk2;
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/is-buffer/index.js"(exports, module) {
    module.exports = function isBuffer2(obj) {
      return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    };
  }
});

// node_modules/extend/index.js
var require_extend = __commonJS({
  "node_modules/extend/index.js"(exports, module) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject3 = function isPlainObject4(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name2) {
      if (name2 === "__proto__") {
        if (!hasOwn.call(obj, name2)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name2).value;
        }
      }
      return obj[name2];
    };
    module.exports = function extend2() {
      var options, name2, src, copy, copyIsArray, clone;
      var target = arguments[0];
      var i3 = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i3 = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i3 < length; ++i3) {
        options = arguments[i3];
        if (options != null) {
          for (name2 in options) {
            src = getProperty(target, name2);
            copy = getProperty(options, name2);
            if (target !== copy) {
              if (deep && copy && (isPlainObject3(copy) || (copyIsArray = isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && isArray(src) ? src : [];
                } else {
                  clone = src && isPlainObject3(src) ? src : {};
                }
                setProperty(target, { name: name2, newValue: extend2(deep, clone, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name: name2, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h2 = m * 60;
    var d3 = h2 * 24;
    var w = d3 * 7;
    var y2 = d3 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type2 = typeof val;
      if (type2 === "string" && val.length > 0) {
        return parse7(val);
      } else if (type2 === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse7(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n2 = parseFloat(match[1]);
      var type2 = (match[2] || "ms").toLowerCase();
      switch (type2) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y2;
        case "weeks":
        case "week":
        case "w":
          return n2 * w;
        case "days":
        case "day":
        case "d":
          return n2 * d3;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d3) {
        return Math.round(ms / d3) + "d";
      }
      if (msAbs >= h2) {
        return Math.round(ms / h2) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d3) {
        return plural(ms, msAbs, d3, "day");
      }
      if (msAbs >= h2) {
        return plural(ms, msAbs, h2, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n2, name2) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms / n2) + " " + name2 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug2.debug = createDebug2;
      createDebug2.default = createDebug2;
      createDebug2.coerce = coerce;
      createDebug2.disable = disable2;
      createDebug2.enable = enable;
      createDebug2.enabled = enabled;
      createDebug2.humanize = require_ms();
      createDebug2.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug2[key] = env[key];
      });
      createDebug2.names = [];
      createDebug2.skips = [];
      createDebug2.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i3 = 0; i3 < namespace.length; i3++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i3);
          hash |= 0;
        }
        return createDebug2.colors[Math.abs(hash) % createDebug2.colors.length];
      }
      createDebug2.selectColor = selectColor;
      function createDebug2(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug2.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index3 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index3++;
            const formatter = createDebug2.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index3];
              match = formatter.call(self, val);
              args.splice(index3, 1);
              index3--;
            }
            return match;
          });
          createDebug2.formatArgs.call(self, args);
          const logFn = self.log || createDebug2.log;
          logFn.apply(self, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug2.useColors();
        debug2.color = createDebug2.selectColor(namespace);
        debug2.extend = extend2;
        debug2.destroy = createDebug2.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug2.namespaces) {
              namespacesCache = createDebug2.namespaces;
              enabledCache = createDebug2.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v2) => {
            enableOverride = v2;
          }
        });
        if (typeof createDebug2.init === "function") {
          createDebug2.init(debug2);
        }
        return debug2;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug2(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug2.save(namespaces);
        createDebug2.namespaces = namespaces;
        createDebug2.names = [];
        createDebug2.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug2.skips.push(ns.slice(1));
          } else {
            createDebug2.names.push(ns);
          }
        }
      }
      function matchesTemplate(search2, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search2.length) {
          if (templateIndex < template.length && (template[templateIndex] === search2[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable2() {
        const namespaces = [
          ...createDebug2.names,
          ...createDebug2.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug2.enable("");
        return namespaces;
      }
      function enabled(name2) {
        for (const skip of createDebug2.skips) {
          if (matchesTemplate(name2, skip)) {
            return false;
          }
        }
        for (const ns of createDebug2.names) {
          if (matchesTemplate(name2, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug2.enable(createDebug2.load());
      return createDebug2;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index3 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index3++;
        if (match === "%c") {
          lastC = index3;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load() {
      let r2;
      try {
        r2 = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error2) {
      }
      if (!r2 && typeof process !== "undefined" && "env" in process) {
        r2 = process.env.DEBUG;
      }
      return r2;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  }
});

// node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type2) {
          return typeof type2 === "string" || typeof type2 === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type2 === REACT_FRAGMENT_TYPE || type2 === REACT_CONCURRENT_MODE_TYPE || type2 === REACT_PROFILER_TYPE || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || typeof type2 === "object" && type2 !== null && (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_FUNDAMENTAL_TYPE || type2.$$typeof === REACT_RESPONDER_TYPE || type2.$$typeof === REACT_SCOPE_TYPE || type2.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type2 = object.type;
                switch (type2) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type2;
                  default:
                    var $$typeofType = type2 && type2.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment6 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment6;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/prop-types/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/prop-types/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty3 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i3 = 0; i3 < 10; i3++) {
          test2["_" + String.fromCharCode(i3)] = i3;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
          return test2[n2];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty3.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i3 = 0; i3 < symbols.length; i3++) {
            if (propIsEnumerable.call(from, symbols[i3])) {
              to[symbols[i3]] = from[symbols[i3]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has2 = require_has();
      printWarning = function(text4) {
        var message2 = "Warning: " + text4;
        if (typeof console !== "undefined") {
          console.error(message2);
        }
        try {
          throw new Error(message2);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has2;
    function checkPropTypes(typeSpecs, values3, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has2(typeSpecs, typeSpecName)) {
            var error2;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error2 = typeSpecs[typeSpecName](values3, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error2 = ex;
            }
            if (error2 && !(error2 instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error2 + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error2 instanceof Error && !(error2.message in loggedTypeFailures)) {
              loggedTypeFailures[error2.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error2.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs2 = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has2 = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text4) {
        var message2 = "Warning: " + text4;
        if (typeof console !== "undefined") {
          console.error(message2);
        }
        try {
          throw new Error(message2);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is3(x, y2) {
        if (x === y2) {
          return x !== 0 || 1 / x === 1 / y2;
        } else {
          return x !== x && y2 !== y2;
        }
      }
      function PropTypeError(message2, data) {
        this.message = message2;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate3) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate3(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate3(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate3(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i3 = 0; i3 < propValue.length; i3++) {
            var error2 = typeChecker(propValue, i3, componentName, location, propFullName + "[" + i3 + "]", ReactPropTypesSecret);
            if (error2 instanceof Error) {
              return error2;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createElementTypeChecker() {
        function validate3(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createElementTypeTypeChecker() {
        function validate3(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs2.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate3(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate3(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i3 = 0; i3 < expectedValues.length; i3++) {
            if (is3(propValue, expectedValues[i3])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value2) {
            var type2 = getPreciseType(value2);
            if (type2 === "symbol") {
              return String(value2);
            }
            return value2;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate3);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate3(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has2(propValue, key)) {
              var error2 = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error2 instanceof Error) {
                return error2;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i3 = 0; i3 < arrayOfTypeCheckers.length; i3++) {
          var checker = arrayOfTypeCheckers[i3];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i3 + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate3(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i4 = 0; i4 < arrayOfTypeCheckers.length; i4++) {
            var checker2 = arrayOfTypeCheckers[i4];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has2(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate3);
      }
      function createNodeChecker() {
        function validate3(props, propName, componentName, location, propFullName) {
          if (!isNode2(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type2) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type2 + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate3(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error2 = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error2) {
              return error2;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate3(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has2(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error2 = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error2) {
              return error2;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function isNode2(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode2);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode2(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode2(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value2) {
        var type2 = getPreciseType(value2);
        switch (type2) {
          case "array":
          case "object":
            return "an " + type2;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type2;
          default:
            return type2;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs2 = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs2.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs2;
    var throwOnDirectAccess;
  }
});

// node_modules/react-markdown/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development2 = __commonJS({
  "node_modules/react-markdown/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type2) {
          if (typeof type2 === "string" || typeof type2 === "function") {
            return true;
          }
          if (type2 === REACT_FRAGMENT_TYPE || type2 === REACT_PROFILER_TYPE || enableDebugTracing || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type2 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type2 === "object" && type2 !== null) {
            if (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type2.$$typeof === REACT_MODULE_REFERENCE || type2.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type2 = object.type;
                switch (type2) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type2;
                  default:
                    var $$typeofType = type2 && type2.$$typeof;
                    switch ($$typeofType) {
                      case REACT_SERVER_CONTEXT_TYPE:
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment6 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        function isSuspenseList(object) {
          return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment6;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.SuspenseList = SuspenseList;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isSuspenseList = isSuspenseList;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-markdown/node_modules/react-is/index.js
var require_react_is2 = __commonJS({
  "node_modules/react-markdown/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development2();
    }
  }
});

// node_modules/inline-style-parser/index.js
var require_inline_style_parser = __commonJS({
  "node_modules/inline-style-parser/index.js"(exports, module) {
    var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
    var NEWLINE_REGEX = /\n/g;
    var WHITESPACE_REGEX = /^\s*/;
    var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
    var COLON_REGEX = /^:\s*/;
    var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
    var SEMICOLON_REGEX = /^[;\s]*/;
    var TRIM_REGEX = /^\s+|\s+$/g;
    var NEWLINE = "\n";
    var FORWARD_SLASH = "/";
    var ASTERISK = "*";
    var EMPTY_STRING = "";
    var TYPE_COMMENT = "comment";
    var TYPE_DECLARATION = "declaration";
    module.exports = function(style, options) {
      if (typeof style !== "string") {
        throw new TypeError("First argument must be a string");
      }
      if (!style) return [];
      options = options || {};
      var lineno = 1;
      var column = 1;
      function updatePosition(str) {
        var lines2 = str.match(NEWLINE_REGEX);
        if (lines2) lineno += lines2.length;
        var i3 = str.lastIndexOf(NEWLINE);
        column = ~i3 ? str.length - i3 : column + str.length;
      }
      function position4() {
        var start2 = { line: lineno, column };
        return function(node2) {
          node2.position = new Position(start2);
          whitespace2();
          return node2;
        };
      }
      function Position(start2) {
        this.start = start2;
        this.end = { line: lineno, column };
        this.source = options.source;
      }
      Position.prototype.content = style;
      var errorsList = [];
      function error2(msg) {
        var err = new Error(
          options.source + ":" + lineno + ":" + column + ": " + msg
        );
        err.reason = msg;
        err.filename = options.source;
        err.line = lineno;
        err.column = column;
        err.source = style;
        if (options.silent) {
          errorsList.push(err);
        } else {
          throw err;
        }
      }
      function match(re) {
        var m = re.exec(style);
        if (!m) return;
        var str = m[0];
        updatePosition(str);
        style = style.slice(str.length);
        return m;
      }
      function whitespace2() {
        match(WHITESPACE_REGEX);
      }
      function comments(rules) {
        var c2;
        rules = rules || [];
        while (c2 = comment()) {
          if (c2 !== false) {
            rules.push(c2);
          }
        }
        return rules;
      }
      function comment() {
        var pos = position4();
        if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;
        var i3 = 2;
        while (EMPTY_STRING != style.charAt(i3) && (ASTERISK != style.charAt(i3) || FORWARD_SLASH != style.charAt(i3 + 1))) {
          ++i3;
        }
        i3 += 2;
        if (EMPTY_STRING === style.charAt(i3 - 1)) {
          return error2("End of comment missing");
        }
        var str = style.slice(2, i3 - 2);
        column += 2;
        updatePosition(str);
        style = style.slice(i3);
        column += 2;
        return pos({
          type: TYPE_COMMENT,
          comment: str
        });
      }
      function declaration() {
        var pos = position4();
        var prop = match(PROPERTY_REGEX);
        if (!prop) return;
        comment();
        if (!match(COLON_REGEX)) return error2("property missing ':'");
        var val = match(VALUE_REGEX);
        var ret = pos({
          type: TYPE_DECLARATION,
          property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
          value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
        });
        match(SEMICOLON_REGEX);
        return ret;
      }
      function declarations() {
        var decls = [];
        comments(decls);
        var decl;
        while (decl = declaration()) {
          if (decl !== false) {
            decls.push(decl);
            comments(decls);
          }
        }
        return decls;
      }
      whitespace2();
      return declarations();
    };
    function trim(str) {
      return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
    }
  }
});

// node_modules/style-to-object/index.js
var require_style_to_object = __commonJS({
  "node_modules/style-to-object/index.js"(exports, module) {
    var parse7 = require_inline_style_parser();
    function StyleToObject2(style, iterator) {
      var output = null;
      if (!style || typeof style !== "string") {
        return output;
      }
      var declaration;
      var declarations = parse7(style);
      var hasIterator = typeof iterator === "function";
      var property;
      var value2;
      for (var i3 = 0, len = declarations.length; i3 < len; i3++) {
        declaration = declarations[i3];
        property = declaration.property;
        value2 = declaration.value;
        if (hasIterator) {
          iterator(property, value2, declaration);
        } else if (value2) {
          output || (output = {});
          output[property] = value2;
        }
      }
      return output;
    }
    module.exports = StyleToObject2;
    module.exports.default = StyleToObject2;
  }
});

// node_modules/@copilotkit/runtime-client-gql/dist/chunk-OBDQ5BWD.mjs
var ActionInputAvailability = ((ActionInputAvailability2) => {
  ActionInputAvailability2["Disabled"] = "disabled";
  ActionInputAvailability2["Enabled"] = "enabled";
  ActionInputAvailability2["Remote"] = "remote";
  return ActionInputAvailability2;
})(ActionInputAvailability || {});
var CopilotRequestType = ((CopilotRequestType2) => {
  CopilotRequestType2["Chat"] = "Chat";
  CopilotRequestType2["Suggestion"] = "Suggestion";
  CopilotRequestType2["Task"] = "Task";
  CopilotRequestType2["TextareaCompletion"] = "TextareaCompletion";
  CopilotRequestType2["TextareaPopover"] = "TextareaPopover";
  return CopilotRequestType2;
})(CopilotRequestType || {});
var FailedResponseStatusReason = ((FailedResponseStatusReason2) => {
  FailedResponseStatusReason2["GuardrailsValidationFailed"] = "GUARDRAILS_VALIDATION_FAILED";
  FailedResponseStatusReason2["MessageStreamInterrupted"] = "MESSAGE_STREAM_INTERRUPTED";
  FailedResponseStatusReason2["UnknownError"] = "UNKNOWN_ERROR";
  return FailedResponseStatusReason2;
})(FailedResponseStatusReason || {});
var MessageRole = ((MessageRole2) => {
  MessageRole2["Assistant"] = "assistant";
  MessageRole2["Developer"] = "developer";
  MessageRole2["System"] = "system";
  MessageRole2["Tool"] = "tool";
  MessageRole2["User"] = "user";
  return MessageRole2;
})(MessageRole || {});
var MessageStatusCode = ((MessageStatusCode2) => {
  MessageStatusCode2["Failed"] = "Failed";
  MessageStatusCode2["Pending"] = "Pending";
  MessageStatusCode2["Success"] = "Success";
  return MessageStatusCode2;
})(MessageStatusCode || {});
var MetaEventName = ((MetaEventName2) => {
  MetaEventName2["CopilotKitLangGraphInterruptEvent"] = "CopilotKitLangGraphInterruptEvent";
  MetaEventName2["LangGraphInterruptEvent"] = "LangGraphInterruptEvent";
  return MetaEventName2;
})(MetaEventName || {});
var ResponseStatusCode = ((ResponseStatusCode2) => {
  ResponseStatusCode2["Failed"] = "Failed";
  ResponseStatusCode2["Pending"] = "Pending";
  ResponseStatusCode2["Success"] = "Success";
  return ResponseStatusCode2;
})(ResponseStatusCode || {});
var GenerateCopilotResponseDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "mutation", "name": { "kind": "Name", "value": "generateCopilotResponse" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "data" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "GenerateCopilotResponseInput" } } } }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "properties" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JSONObject" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "generateCopilotResponse" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "data" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "data" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "properties" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "properties" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "threadId" } }, { "kind": "Field", "name": { "kind": "Name", "value": "runId" } }, { "kind": "Field", "name": { "kind": "Name", "value": "extensions" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "openaiAssistantAPI" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "runId" } }, { "kind": "Field", "name": { "kind": "Name", "value": "threadId" } }] } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "CopilotResponse" } }, "directives": [{ "kind": "Directive", "name": { "kind": "Name", "value": "defer" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "status" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "BaseResponseStatus" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "code" } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "FailedResponseStatus" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "reason" } }, { "kind": "Field", "name": { "kind": "Name", "value": "details" } }] } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "messages" }, "directives": [{ "kind": "Directive", "name": { "kind": "Name", "value": "stream" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "__typename" } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "BaseMessageOutput" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "createdAt" } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "BaseMessageOutput" } }, "directives": [{ "kind": "Directive", "name": { "kind": "Name", "value": "defer" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "status" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessMessageStatus" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "code" } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "FailedMessageStatus" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "code" } }, { "kind": "Field", "name": { "kind": "Name", "value": "reason" } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "PendingMessageStatus" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "code" } }] } }] } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "TextMessageOutput" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "content" }, "directives": [{ "kind": "Directive", "name": { "kind": "Name", "value": "stream" } }] }, { "kind": "Field", "name": { "kind": "Name", "value": "role" } }, { "kind": "Field", "name": { "kind": "Name", "value": "parentMessageId" } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "ImageMessageOutput" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "format" } }, { "kind": "Field", "name": { "kind": "Name", "value": "bytes" } }, { "kind": "Field", "name": { "kind": "Name", "value": "role" } }, { "kind": "Field", "name": { "kind": "Name", "value": "parentMessageId" } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "ActionExecutionMessageOutput" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "arguments" }, "directives": [{ "kind": "Directive", "name": { "kind": "Name", "value": "stream" } }] }, { "kind": "Field", "name": { "kind": "Name", "value": "parentMessageId" } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "ResultMessageOutput" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "result" } }, { "kind": "Field", "name": { "kind": "Name", "value": "actionExecutionId" } }, { "kind": "Field", "name": { "kind": "Name", "value": "actionName" } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "AgentStateMessageOutput" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "threadId" } }, { "kind": "Field", "name": { "kind": "Name", "value": "state" } }, { "kind": "Field", "name": { "kind": "Name", "value": "running" } }, { "kind": "Field", "name": { "kind": "Name", "value": "agentName" } }, { "kind": "Field", "name": { "kind": "Name", "value": "nodeName" } }, { "kind": "Field", "name": { "kind": "Name", "value": "runId" } }, { "kind": "Field", "name": { "kind": "Name", "value": "active" } }, { "kind": "Field", "name": { "kind": "Name", "value": "role" } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "metaEvents" }, "directives": [{ "kind": "Directive", "name": { "kind": "Name", "value": "stream" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "LangGraphInterruptEvent" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "type" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "value" } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "CopilotKitLangGraphInterruptEvent" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "type" } }, { "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "data" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "messages" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "__typename" } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "BaseMessageOutput" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "createdAt" } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "BaseMessageOutput" } }, "directives": [{ "kind": "Directive", "name": { "kind": "Name", "value": "defer" } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "status" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessMessageStatus" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "code" } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "FailedMessageStatus" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "code" } }, { "kind": "Field", "name": { "kind": "Name", "value": "reason" } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "PendingMessageStatus" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "code" } }] } }] } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "TextMessageOutput" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "content" } }, { "kind": "Field", "name": { "kind": "Name", "value": "role" } }, { "kind": "Field", "name": { "kind": "Name", "value": "parentMessageId" } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "ActionExecutionMessageOutput" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "arguments" } }, { "kind": "Field", "name": { "kind": "Name", "value": "parentMessageId" } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "ResultMessageOutput" } }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "result" } }, { "kind": "Field", "name": { "kind": "Name", "value": "actionExecutionId" } }, { "kind": "Field", "name": { "kind": "Name", "value": "actionName" } }] } }] } }, { "kind": "Field", "name": { "kind": "Name", "value": "value" } }] } }] } }] } }] } }] } }] };
var AvailableAgentsDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "availableAgents" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "availableAgents" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "agents" }, "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "name" } }, { "kind": "Field", "name": { "kind": "Name", "value": "id" } }, { "kind": "Field", "name": { "kind": "Name", "value": "description" } }] } }] } }] } }] };
var LoadAgentStateDocument = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "loadAgentState" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "data" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "LoadAgentStateInput" } } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "loadAgentState" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "data" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "data" } } }], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "name": { "kind": "Name", "value": "threadId" } }, { "kind": "Field", "name": { "kind": "Name", "value": "threadExists" } }, { "kind": "Field", "name": { "kind": "Name", "value": "state" } }, { "kind": "Field", "name": { "kind": "Name", "value": "messages" } }] } }] } }] };

// node_modules/@copilotkit/shared/dist/chunk-RFXI5UPJ.mjs
var version = "1.10.6";
var SCARF_BASE_URL = `https://copilotkit.gateway.scarf.sh/${version}`;
var ScarfClient = class {
  constructor() {
  }
  async logEvent(properties) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 3e3);
      const queryParams = new URLSearchParams();
      Object.entries(properties).forEach(([key, value2]) => {
        if (value2 !== null && value2 !== void 0) {
          queryParams.append(key, String(value2));
        }
      });
      const url = `${SCARF_BASE_URL}?${queryParams.toString()}`;
      const response = await fetch(url, {
        method: "GET",
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
    } catch {
    }
  }
};
var scarf_client_default = new ScarfClient();

// node_modules/graphql/version.mjs
var versionInfo = Object.freeze({
  major: 16,
  minor: 11,
  patch: 0,
  preReleaseTag: null
});

// node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message2) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message2);
  }
}

// node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value2) {
  return typeof value2 == "object" && value2 !== null;
}

// node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message2) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message2 != null ? message2 : "Unexpected invariant triggered."
    );
  }
}

// node_modules/graphql/language/location.mjs
var LineRegExp = /\r\n|[\n\r]/g;
function getLocation(source, position4) {
  let lastLineStart = 0;
  let line2 = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position4) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line2 += 1;
  }
  return {
    line: line2,
    column: position4 + 1 - lastLineStart
  };
}

// node_modules/graphql/language/printLocation.mjs
function printLocation(location) {
  return printSourceLocation(
    location.source,
    getLocation(location.source, location.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines2 = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines2[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i3 = 0; i3 < locationLine.length; i3 += 80) {
      subLines.push(locationLine.slice(i3, i3 + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    [`${lineNum - 1} |`, lines2[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines2[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines2) {
  const existingLines = lines2.filter(([_, line2]) => line2 !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line2]) => prefix.padStart(padLen) + (line2 ? " " + line2 : "")).join("\n");
}

// node_modules/graphql/error/GraphQLError.mjs
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
var GraphQLError = class _GraphQLError extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(message2, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path: path2, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message2);
    this.name = "GraphQLError";
    this.path = path2 !== null && path2 !== void 0 ? path2 : void 0;
    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    this.nodes = undefinedIfEmpty(
      Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
    );
    const nodeLocations = undefinedIfEmpty(
      (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node2) => node2.loc).filter((loc) => loc != null)
    );
    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(
      originalError === null || originalError === void 0 ? void 0 : originalError.extensions
    ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node2 of this.nodes) {
        if (node2.loc) {
          output += "\n\n" + printLocation(node2.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
};
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}

// node_modules/graphql/language/ast.mjs
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));

// node_modules/graphql/language/kinds.mjs
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));

// node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code2) {
  return code2 === 9 || code2 === 32;
}
function isDigit(code2) {
  return code2 >= 48 && code2 <= 57;
}
function isLetter(code2) {
  return code2 >= 97 && code2 <= 122 || // A-Z
  code2 >= 65 && code2 <= 90;
}
function isNameStart(code2) {
  return isLetter(code2) || code2 === 95;
}
function isNameContinue(code2) {
  return isLetter(code2) || isDigit(code2) || code2 === 95;
}

// node_modules/graphql/language/blockString.mjs
function printBlockString(value2, options) {
  const escapedValue = value2.replace(/"""/g, '\\"""');
  const lines2 = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines2.length === 1;
  const forceLeadingNewLine = lines2.length > 1 && lines2.slice(1).every((line2) => line2.length === 0 || isWhiteSpace(line2.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value2.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value2.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value2.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value2.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// node_modules/graphql/language/tokenKind.mjs
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));

// node_modules/graphql/jsutils/inspect.mjs
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect(value2) {
  return formatValue(value2, []);
}
function formatValue(value2, seenValues) {
  switch (typeof value2) {
    case "string":
      return JSON.stringify(value2);
    case "function":
      return value2.name ? `[function ${value2.name}]` : "[function]";
    case "object":
      return formatObjectValue(value2, seenValues);
    default:
      return String(value2);
  }
}
function formatObjectValue(value2, previouslySeenValues) {
  if (value2 === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value2)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value2];
  if (isJSONable(value2)) {
    const jsonValue = value2.toJSON();
    if (jsonValue !== value2) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value2)) {
    return formatArray(value2, seenValues);
  }
  return formatObject(value2, seenValues);
}
function isJSONable(value2) {
  return typeof value2.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(
    ([key, value2]) => key + ": " + formatValue(value2, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i3 = 0; i3 < len; ++i3) {
    items.push(formatValue(array[i3], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag2 = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag2 === "Object" && typeof object.constructor === "function") {
    const name2 = object.constructor.name;
    if (typeof name2 === "string" && name2 !== "") {
      return name2;
    }
  }
  return tag2;
}

// node_modules/graphql/jsutils/instanceOf.mjs
var isProduction = globalThis.process && // eslint-disable-next-line no-undef
false;
var instanceOf = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  isProduction ? function instanceOf2(value2, constructor) {
    return value2 instanceof constructor;
  } : function instanceOf3(value2, constructor) {
    if (value2 instanceof constructor) {
      return true;
    }
    if (typeof value2 === "object" && value2 !== null) {
      var _value$constructor;
      const className = constructor.prototype[Symbol.toStringTag];
      const valueClassName = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in value2 ? value2[Symbol.toStringTag] : (_value$constructor = value2.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
      );
      if (className === valueClassName) {
        const stringifiedValue = inspect(value2);
        throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return false;
  }
);

// node_modules/graphql/jsutils/didYouMean.mjs
var MAX_SUGGESTIONS = 5;
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
  let message2 = " Did you mean ";
  if (subMessage) {
    message2 += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x) => `"${x}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message2 + suggestions[0] + "?";
    case 2:
      return message2 + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message2 + selected.join(", ") + ", or " + lastItem + "?";
}

// node_modules/graphql/jsutils/identityFunc.mjs
function identityFunc(x) {
  return x;
}

// node_modules/graphql/jsutils/keyMap.mjs
function keyMap(list3, keyFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list3) {
    result[keyFn(item)] = item;
  }
  return result;
}

// node_modules/graphql/jsutils/keyValMap.mjs
function keyValMap(list3, keyFn, valFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list3) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}

// node_modules/graphql/jsutils/mapValue.mjs
function mapValue(map2, fn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map2)) {
    result[key] = fn(map2[key], key);
  }
  return result;
}

// node_modules/graphql/jsutils/naturalCompare.mjs
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
var DIGIT_0 = 48;
var DIGIT_9 = 57;
function isDigit2(code2) {
  return !isNaN(code2) && DIGIT_0 <= code2 && code2 <= DIGIT_9;
}

// node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  const optionsByDistance = /* @__PURE__ */ Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== void 0) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a2, b) => {
    const distanceDiff = optionsByDistance[a2] - optionsByDistance[b];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a2, b);
  });
}
var LexicalDistance = class {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option, threshold) {
    if (this._input === option) {
      return 0;
    }
    const optionLowerCase = option.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a2 = stringToArray(optionLowerCase);
    let b = this._inputArray;
    if (a2.length < b.length) {
      const tmp = a2;
      a2 = b;
      b = tmp;
    }
    const aLength = a2.length;
    const bLength = b.length;
    if (aLength - bLength > threshold) {
      return void 0;
    }
    const rows = this._rows;
    for (let j = 0; j <= bLength; j++) {
      rows[0][j] = j;
    }
    for (let i3 = 1; i3 <= aLength; i3++) {
      const upRow = rows[(i3 - 1) % 3];
      const currentRow = rows[i3 % 3];
      let smallestCell = currentRow[0] = i3;
      for (let j = 1; j <= bLength; j++) {
        const cost = a2[i3 - 1] === b[j - 1] ? 0 : 1;
        let currentCell = Math.min(
          upRow[j] + 1,
          // delete
          currentRow[j - 1] + 1,
          // insert
          upRow[j - 1] + cost
          // substitute
        );
        if (i3 > 1 && j > 1 && a2[i3 - 1] === b[j - 2] && a2[i3 - 2] === b[j - 1]) {
          const doubleDiagonalCell = rows[(i3 - 2) % 3][j - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j] = currentCell;
      }
      if (smallestCell > threshold) {
        return void 0;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : void 0;
  }
};
function stringToArray(str) {
  const strLength = str.length;
  const array = new Array(strLength);
  for (let i3 = 0; i3 < strLength; ++i3) {
    array[i3] = str.charCodeAt(i3);
  }
  return array;
}

// node_modules/graphql/jsutils/toObjMap.mjs
function toObjMap(obj) {
  if (obj == null) {
    return /* @__PURE__ */ Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map2 = /* @__PURE__ */ Object.create(null);
  for (const [key, value2] of Object.entries(obj)) {
    map2[key] = value2;
  }
  return map2;
}

// node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// node_modules/graphql/language/visitor.mjs
var BREAK = Object.freeze({});
function visit(root2, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root2);
  let keys2 = [root2];
  let index3 = -1;
  let edits = [];
  let node2 = root2;
  let key = void 0;
  let parent = void 0;
  const path2 = [];
  const ancestors = [];
  do {
    index3++;
    const isLeaving = index3 === keys2.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path2[path2.length - 1];
      node2 = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node2 = node2.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node2.splice(arrayKey, 1);
              editOffset++;
            } else {
              node2[arrayKey] = editValue;
            }
          }
        } else {
          node2 = { ...node2 };
          for (const [editKey, editValue] of edits) {
            node2[editKey] = editValue;
          }
        }
      }
      index3 = stack.index;
      keys2 = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index3 : keys2[index3];
      node2 = parent[key];
      if (node2 === null || node2 === void 0) {
        continue;
      }
      path2.push(key);
    }
    let result;
    if (!Array.isArray(node2)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node2) || devAssert(false, `Invalid AST Node: ${inspect(node2)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node2.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node2.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node2, key, parent, path2, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path2.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node2 = result;
          } else {
            path2.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node2]);
    }
    if (isLeaving) {
      path2.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index: index3,
        keys: keys2,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node2);
      keys2 = inArray ? node2 : (_node$kind = visitorKeys[node2.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index3 = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node2;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root2;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}

// node_modules/graphql/language/printer.mjs
function print(ast) {
  return visit(ast, printDocASTReducer);
}
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node2) => node2.value
  },
  Variable: {
    leave: (node2) => "$" + node2.name
  },
  // Document
  Document: {
    leave: (node2) => join(node2.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node2) {
      const varDefs = wrap("(", join(node2.variableDefinitions, ", "), ")");
      const prefix = join(
        [
          node2.operation,
          join([node2.name, varDefs]),
          join(node2.directives, " ")
        ],
        " "
      );
      return (prefix === "query" ? "" : prefix + " ") + node2.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type: type2, defaultValue, directives: directives2 }) => variable + ": " + type2 + wrap(" = ", defaultValue) + wrap(" ", join(directives2, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name: name2, arguments: args, directives: directives2, selectionSet: selectionSet2 }) {
      const prefix = wrap("", alias, ": ") + name2;
      let argsLine = prefix + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives2, " "), selectionSet2], " ");
    }
  },
  Argument: {
    leave: ({ name: name2, value: value2 }) => name2 + ": " + value2
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: name2, directives: directives2 }) => "..." + name2 + wrap(" ", join(directives2, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives: directives2, selectionSet: selectionSet2 }) => join(
      [
        "...",
        wrap("on ", typeCondition),
        join(directives2, " "),
        selectionSet2
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: name2, typeCondition, variableDefinitions: variableDefinitions2, directives: directives2, selectionSet: selectionSet2 }) => (
      // or removed in the future.
      `fragment ${name2}${wrap("(", join(variableDefinitions2, ", "), ")")} on ${typeCondition} ${wrap("", join(directives2, " "), " ")}` + selectionSet2
    )
  },
  // Value
  IntValue: {
    leave: ({ value: value2 }) => value2
  },
  FloatValue: {
    leave: ({ value: value2 }) => value2
  },
  StringValue: {
    leave: ({ value: value2, block: isBlockString }) => isBlockString ? printBlockString(value2) : printString(value2)
  },
  BooleanValue: {
    leave: ({ value: value2 }) => value2 ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: value2 }) => value2
  },
  ListValue: {
    leave: ({ values: values3 }) => "[" + join(values3, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: name2, value: value2 }) => name2 + ": " + value2
  },
  // Directive
  Directive: {
    leave: ({ name: name2, arguments: args }) => "@" + name2 + wrap("(", join(args, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: name2 }) => name2
  },
  ListType: {
    leave: ({ type: type2 }) => "[" + type2 + "]"
  },
  NonNullType: {
    leave: ({ type: type2 }) => type2 + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description, directives: directives2, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives2, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type: type2 }) => operation + ": " + type2
  },
  ScalarTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2 }) => wrap("", description, "\n") + join(["scalar", name2, join(directives2, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name: name2, interfaces, directives: directives2, fields }) => wrap("", description, "\n") + join(
      [
        "type",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description, name: name2, arguments: args, type: type2, directives: directives2 }) => wrap("", description, "\n") + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type2 + wrap(" ", join(directives2, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name: name2, type: type2, defaultValue, directives: directives2 }) => wrap("", description, "\n") + join(
      [name2 + ": " + type2, wrap("= ", defaultValue), join(directives2, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name: name2, interfaces, directives: directives2, fields }) => wrap("", description, "\n") + join(
      [
        "interface",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2, types: types3 }) => wrap("", description, "\n") + join(
      ["union", name2, join(directives2, " "), wrap("= ", join(types3, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2, values: values3 }) => wrap("", description, "\n") + join(["enum", name2, join(directives2, " "), block(values3)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name: name2, directives: directives2 }) => wrap("", description, "\n") + join([name2, join(directives2, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name: name2, directives: directives2, fields }) => wrap("", description, "\n") + join(["input", name2, join(directives2, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name: name2, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: directives2, operationTypes }) => join(
      ["extend schema", join(directives2, " "), block(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: name2, directives: directives2 }) => join(["extend scalar", name2, join(directives2, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: name2, interfaces, directives: directives2, fields }) => join(
      [
        "extend type",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: name2, interfaces, directives: directives2, fields }) => join(
      [
        "extend interface",
        name2,
        wrap("implements ", join(interfaces, " & ")),
        join(directives2, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: name2, directives: directives2, types: types3 }) => join(
      [
        "extend union",
        name2,
        join(directives2, " "),
        wrap("= ", join(types3, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: name2, directives: directives2, values: values3 }) => join(["extend enum", name2, join(directives2, " "), block(values3)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: name2, directives: directives2, fields }) => join(["extend input", name2, join(directives2, " "), block(fields)], " ")
  }
};
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
}
function wrap(start2, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start2 + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}

// node_modules/graphql/utilities/valueFromASTUntyped.mjs
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map(
        (node2) => valueFromASTUntyped(node2, variables)
      );
    case Kind.OBJECT:
      return keyValMap(
        valueNode.fields,
        (field) => field.name.value,
        (field) => valueFromASTUntyped(field.value, variables)
      );
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
}

// node_modules/graphql/type/assertName.mjs
function assertName(name2) {
  name2 != null || devAssert(false, "Must provide name.");
  typeof name2 === "string" || devAssert(false, "Expected name to be a string.");
  if (name2.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i3 = 1; i3 < name2.length; ++i3) {
    if (!isNameContinue(name2.charCodeAt(i3))) {
      throw new GraphQLError(
        `Names must only contain [_a-zA-Z0-9] but "${name2}" does not.`
      );
    }
  }
  if (!isNameStart(name2.charCodeAt(0))) {
    throw new GraphQLError(
      `Names must start with [_a-zA-Z] but "${name2}" does not.`
    );
  }
  return name2;
}
function assertEnumValueName(name2) {
  if (name2 === "true" || name2 === "false" || name2 === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name2}`);
  }
  return assertName(name2);
}

// node_modules/graphql/type/definition.mjs
function isType(type2) {
  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2) || isListType(type2) || isNonNullType(type2);
}
function isScalarType(type2) {
  return instanceOf(type2, GraphQLScalarType);
}
function isObjectType(type2) {
  return instanceOf(type2, GraphQLObjectType);
}
function isInterfaceType(type2) {
  return instanceOf(type2, GraphQLInterfaceType);
}
function isUnionType(type2) {
  return instanceOf(type2, GraphQLUnionType);
}
function isEnumType(type2) {
  return instanceOf(type2, GraphQLEnumType);
}
function isInputObjectType(type2) {
  return instanceOf(type2, GraphQLInputObjectType);
}
function isListType(type2) {
  return instanceOf(type2, GraphQLList);
}
function isNonNullType(type2) {
  return instanceOf(type2, GraphQLNonNull);
}
function isInputType(type2) {
  return isScalarType(type2) || isEnumType(type2) || isInputObjectType(type2) || isWrappingType(type2) && isInputType(type2.ofType);
}
function isLeafType(type2) {
  return isScalarType(type2) || isEnumType(type2);
}
function isCompositeType(type2) {
  return isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2);
}
function isAbstractType(type2) {
  return isInterfaceType(type2) || isUnionType(type2);
}
var GraphQLList = class {
  constructor(ofType) {
    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLNonNull = class {
  constructor(ofType) {
    isNullableType(ofType) || devAssert(
      false,
      `Expected ${inspect(ofType)} to be a GraphQL nullable type.`
    );
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
};
function isWrappingType(type2) {
  return isListType(type2) || isNonNullType(type2);
}
function isNullableType(type2) {
  return isType(type2) && !isNonNullType(type2);
}
function getNullableType(type2) {
  if (type2) {
    return isNonNullType(type2) ? type2.ofType : type2;
  }
}
function getNamedType(type2) {
  if (type2) {
    let unwrappedType = type2;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
var GraphQLScalarType = class {
  constructor(config) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue2 = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
    this.name = assertName(config.name);
    this.description = config.description;
    this.specifiedByURL = config.specifiedByURL;
    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
    this.parseValue = parseValue2;
    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node2, variables) => parseValue2(valueFromASTUntyped(node2, variables));
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(
      false,
      `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config.specifiedByURL)}.`
    );
    config.serialize == null || typeof config.serialize === "function" || devAssert(
      false,
      `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
    );
    if (config.parseLiteral) {
      typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(
        false,
        `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
      );
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLObjectType = class {
  constructor(config) {
    var _config$extensionASTN2;
    this.name = assertName(config.name);
    this.description = config.description;
    this.isTypeOf = config.isTypeOf;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config);
    this._interfaces = () => defineInterfaces(config);
    config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(
      false,
      `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config.isTypeOf)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInterfaces(config) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk(
    (_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
  );
  Array.isArray(interfaces) || devAssert(
    false,
    `${config.name} interfaces must be an Array or a function which returns an Array.`
  );
  return interfaces;
}
function defineFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field config must be an object.`
    );
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(
      false,
      `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`
    );
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(
      false,
      `${config.name}.${fieldName} args must be an object with argument names as keys.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
}
function argsToArgsConfig(args) {
  return keyValMap(
    args,
    (arg) => arg.name,
    (arg) => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    })
  );
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
var GraphQLInterfaceType = class {
  constructor(config) {
    var _config$extensionASTN3;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(void 0, config);
    this._interfaces = defineInterfaces.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLUnionType = class {
  constructor(config) {
    var _config$extensionASTN4;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineTypes(config) {
  const types3 = resolveReadonlyArrayThunk(config.types);
  Array.isArray(types3) || devAssert(
    false,
    `Must provide Array of types or a function which returns such an array for Union ${config.name}.`
  );
  return types3;
}
var GraphQLEnumType = class {
  /* <T> */
  constructor(config) {
    var _config$extensionASTN5;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
    this._values = typeof config.values === "function" ? config.values : defineEnumValues(this.name, config.values);
    this._valueLookup = null;
    this._nameLookup = null;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    if (typeof this._values === "function") {
      this._values = defineEnumValues(this.name, this._values());
    }
    return this._values;
  }
  getValue(name2) {
    if (this._nameLookup === null) {
      this._nameLookup = keyMap(this.getValues(), (value2) => value2.name);
    }
    return this._nameLookup[name2];
  }
  serialize(outputValue) {
    if (this._valueLookup === null) {
      this._valueLookup = new Map(
        this.getValues().map((enumValue2) => [enumValue2.value, enumValue2])
      );
    }
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === void 0) {
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`
      );
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect(inputValue);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
      );
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(
        `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
      );
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    return enumValue.value;
  }
  toConfig() {
    const values3 = keyValMap(
      this.getValues(),
      (value2) => value2.name,
      (value2) => ({
        description: value2.description,
        value: value2.value,
        deprecationReason: value2.deprecationReason,
        extensions: value2.extensions,
        astNode: value2.astNode
      })
    );
    return {
      name: this.name,
      description: this.description,
      values: values3,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function didYouMeanEnumValue(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value2) => value2.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(
    false,
    `${typeName} values must be an object with value names as keys.`
  );
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(
      false,
      `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`
    );
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
var GraphQLInputObjectType = class {
  constructor(config) {
    var _config$extensionASTN6, _config$isOneOf;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
    this.isOneOf = (_config$isOneOf = config.isOneOf) !== null && _config$isOneOf !== void 0 ? _config$isOneOf : false;
    this._fields = defineInputFieldMap.bind(void 0, config);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field) => ({
      description: field.description,
      type: field.type,
      defaultValue: field.defaultValue,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      isOneOf: this.isOneOf
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInputFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === void 0;
}

// node_modules/graphql/utilities/typeComparators.mjs
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type2) => schema.isSubType(typeB, type2));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}

// node_modules/graphql/type/scalars.mjs
var GRAPHQL_MAX_INT = 2147483647;
var GRAPHQL_MIN_INT = -2147483648;
var GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isInteger(num)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(coercedValue)}`
      );
    }
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        "Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue)
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(inputValue)}`
      );
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${inputValue}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    const num = parseInt(valueNode.value, 10);
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
        {
          nodes: valueNode
        }
      );
    }
    return num;
  }
});
var GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isFinite(num)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(coercedValue)}`
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${print(valueNode)}`,
        valueNode
      );
    }
    return parseFloat(valueNode.value);
  }
});
var GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(
      `String cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(
        `String cannot represent a non string value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING) {
      throw new GraphQLError(
        `String cannot represent a non string value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(
      `Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.BOOLEAN) {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(
      `ID cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        "ID cannot represent a non-string and non-integer value: " + print(valueNode),
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var specifiedScalarTypes = Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}

// node_modules/graphql/type/directives.mjs
var GraphQLDirective = class {
  constructor(config) {
    var _config$isRepeatable, _config$args;
    this.name = assertName(config.name);
    this.description = config.description;
    this.locations = config.locations;
    this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
    const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
    isObjectLike(args) && !Array.isArray(args) || devAssert(
      false,
      `@${config.name} args must be an object with argument names as keys.`
    );
    this.args = defineArguments(args);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
var GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
var DEFAULT_DEPRECATION_REASON = "No longer supported";
var GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    DirectiveLocation.FIELD_DEFINITION,
    DirectiveLocation.ARGUMENT_DEFINITION,
    DirectiveLocation.INPUT_FIELD_DEFINITION,
    DirectiveLocation.ENUM_VALUE
  ],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
var GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});
var GraphQLOneOfDirective = new GraphQLDirective({
  name: "oneOf",
  description: "Indicates exactly one field must be supplied and this field must not be `null`.",
  locations: [DirectiveLocation.INPUT_OBJECT],
  args: {}
});
var specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective,
  GraphQLOneOfDirective
]);

// node_modules/graphql/jsutils/isIterableObject.mjs
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}

// node_modules/graphql/utilities/astFromValue.mjs
function astFromValue(value2, type2) {
  if (isNonNullType(type2)) {
    const astValue = astFromValue(value2, type2.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value2 === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value2 === void 0) {
    return null;
  }
  if (isListType(type2)) {
    const itemType = type2.ofType;
    if (isIterableObject(value2)) {
      const valuesNodes = [];
      for (const item of value2) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value2, itemType);
  }
  if (isInputObjectType(type2)) {
    if (!isObjectLike(value2)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type2.getFields())) {
      const fieldValue = astFromValue(value2[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type2)) {
    const serialized = type2.serialize(value2);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type2)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type2 === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type2));
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// node_modules/graphql/type/introspection.mjs
var __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema) => schema.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema) {
        return Object.values(schema.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema) => schema.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__Directive))
      ),
      resolve: (schema) => schema.getDirectives()
    }
  })
});
var __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive) => directive.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive) => directive.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive) => directive.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__DirectiveLocation))
      ),
      resolve: (directive) => directive.locations
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
var __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
var __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type2) {
        if (isScalarType(type2)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type2)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type2)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type2)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type2)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type2)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type2)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type2)) {
          return TypeKind.NON_NULL;
        }
        invariant(false, `Unexpected type: "${inspect(type2)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type2) => "name" in type2 ? type2.name : void 0
    },
    description: {
      type: GraphQLString,
      resolve: (type2) => (
        /* c8 ignore next */
        "description" in type2 ? type2.description : void 0
      )
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isObjectType(type2) || isInterfaceType(type2)) {
          const fields = Object.values(type2.getFields());
          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type2) {
        if (isObjectType(type2) || isInterfaceType(type2)) {
          return type2.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type2, _args, _context, { schema }) {
        if (isAbstractType(type2)) {
          return schema.getPossibleTypes(type2);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isEnumType(type2)) {
          const values3 = type2.getValues();
          return includeDeprecated ? values3 : values3.filter((field) => field.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isInputObjectType(type2)) {
          const values3 = Object.values(type2.getFields());
          return includeDeprecated ? values3 : values3.filter((field) => field.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type2) => "ofType" in type2 ? type2.ofType : void 0
    },
    isOneOf: {
      type: GraphQLBoolean,
      resolve: (type2) => {
        if (isInputObjectType(type2)) {
          return type2.isOneOf;
        }
      }
    }
  })
});
var __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field) => field.name
    },
    description: {
      type: GraphQLString,
      resolve: (field) => field.description
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field) => field.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field) => field.deprecationReason
    }
  })
});
var __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type: type2, defaultValue } = inputValue;
        const valueAST = astFromValue(defaultValue, type2);
        return valueAST ? print(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
var __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
var TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
var __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
var SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema }) => schema,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: void 0,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: void 0,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    }
  ],
  resolve: (_source, { name: name2 }, _context, { schema }) => schema.getType(name2),
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var introspectionTypes = Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);

// node_modules/graphql/utilities/typeFromAST.mjs
function typeFromAST(schema, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema.getType(typeNode.name.value);
  }
}

// node_modules/graphql/language/predicates.mjs
function isExecutableDefinitionNode(node2) {
  return node2.kind === Kind.OPERATION_DEFINITION || node2.kind === Kind.FRAGMENT_DEFINITION;
}
function isTypeSystemDefinitionNode(node2) {
  return node2.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node2) || node2.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node2) {
  return node2.kind === Kind.SCALAR_TYPE_DEFINITION || node2.kind === Kind.OBJECT_TYPE_DEFINITION || node2.kind === Kind.INTERFACE_TYPE_DEFINITION || node2.kind === Kind.UNION_TYPE_DEFINITION || node2.kind === Kind.ENUM_TYPE_DEFINITION || node2.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node2) {
  return node2.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node2);
}
function isTypeExtensionNode(node2) {
  return node2.kind === Kind.SCALAR_TYPE_EXTENSION || node2.kind === Kind.OBJECT_TYPE_EXTENSION || node2.kind === Kind.INTERFACE_TYPE_EXTENSION || node2.kind === Kind.UNION_TYPE_EXTENSION || node2.kind === Kind.ENUM_TYPE_EXTENSION || node2.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}

// node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document(node2) {
      for (const definition2 of node2.definitions) {
        if (!isExecutableDefinitionNode(definition2)) {
          const defName = definition2.kind === Kind.SCHEMA_DEFINITION || definition2.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition2.name.value + '"';
          context.reportError(
            new GraphQLError(`The ${defName} definition is not executable.`, {
              nodes: definition2
            })
          );
        }
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node2) {
      const type2 = context.getParentType();
      if (type2) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema = context.getSchema();
          const fieldName = node2.name.value;
          let suggestion = didYouMean(
            "to use an inline fragment on",
            getSuggestedTypeNames(schema, type2, fieldName)
          );
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type2, fieldName));
          }
          context.reportError(
            new GraphQLError(
              `Cannot query field "${fieldName}" on type "${type2.name}".` + suggestion,
              {
                nodes: node2
              }
            )
          );
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema, type2, fieldName) {
  if (!isAbstractType(type2)) {
    return [];
  }
  const suggestedTypes = /* @__PURE__ */ new Set();
  const usageCount = /* @__PURE__ */ Object.create(null);
  for (const possibleType of schema.getPossibleTypes(type2)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x) => x.name);
}
function getSuggestedFieldNames(type2, fieldName) {
  if (isObjectType(type2) || isInterfaceType(type2)) {
    const possibleFieldNames = Object.keys(type2.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}

// node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node2) {
      const typeCondition = node2.typeCondition;
      if (typeCondition) {
        const type2 = typeFromAST(context.getSchema(), typeCondition);
        if (type2 && !isCompositeType(type2)) {
          const typeStr = print(typeCondition);
          context.reportError(
            new GraphQLError(
              `Fragment cannot condition on non composite type "${typeStr}".`,
              {
                nodes: typeCondition
              }
            )
          );
        }
      }
    },
    FragmentDefinition(node2) {
      const type2 = typeFromAST(context.getSchema(), node2.typeCondition);
      if (type2 && !isCompositeType(type2)) {
        const typeStr = print(node2.typeCondition);
        context.reportError(
          new GraphQLError(
            `Fragment "${node2.name.value}" cannot condition on non composite type "${typeStr}".`,
            {
              nodes: node2.typeCondition
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
function KnownArgumentNamesRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(
          new GraphQLError(
            `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
            {
              nodes: argNode
            }
          )
        );
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(
              new GraphQLError(
                `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
function KnownDirectivesRule(context) {
  const locationsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name2) => name2.value);
    }
  }
  return {
    Directive(node2, _key, _parent, _path, ancestors) {
      const name2 = node2.name.value;
      const locations = locationsMap[name2];
      if (!locations) {
        context.reportError(
          new GraphQLError(`Unknown directive "@${name2}".`, {
            nodes: node2
          })
        );
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${name2}" may not be used on ${candidateLocation}.`,
            {
              nodes: node2
            }
          )
        );
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
}

// node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node2) {
      const fragmentName = node2.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(
          new GraphQLError(`Unknown fragment "${fragmentName}".`, {
            nodes: node2.name
          })
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
function KnownTypeNamesRule(context) {
  const schema = context.getSchema();
  const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node2, _1, parent, _2, ancestors) {
      const typeName = node2.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(
          typeName,
          isSDL ? standardTypeNames.concat(typeNames) : typeNames
        );
        context.reportError(
          new GraphQLError(
            `Unknown type "${typeName}".` + didYouMean(suggestedTypes),
            {
              nodes: node2
            }
          )
        );
      }
    }
  };
}
var standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(
  (type2) => type2.name
);
function isSDLNode(value2) {
  return "kind" in value2 && (isTypeSystemDefinitionNode(value2) || isTypeSystemExtensionNode(value2));
}

// node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node2) {
      operationCount = node2.definitions.filter(
        (definition2) => definition2.kind === Kind.OPERATION_DEFINITION
      ).length;
    },
    OperationDefinition(node2) {
      if (!node2.name && operationCount > 1) {
        context.reportError(
          new GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: node2
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node2) {
      if (alreadyDefined) {
        context.reportError(
          new GraphQLError(
            "Cannot define a new schema within a schema extension.",
            {
              nodes: node2
            }
          )
        );
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(
          new GraphQLError("Must provide only one schema definition.", {
            nodes: node2
          })
        );
      }
      ++schemaDefinitionsCount;
    }
  };
}

// node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.mjs
var MAX_LISTS_DEPTH = 3;
function MaxIntrospectionDepthRule(context) {
  function checkDepth(node2, visitedFragments = /* @__PURE__ */ Object.create(null), depth = 0) {
    if (node2.kind === Kind.FRAGMENT_SPREAD) {
      const fragmentName = node2.name.value;
      if (visitedFragments[fragmentName] === true) {
        return false;
      }
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        return false;
      }
      try {
        visitedFragments[fragmentName] = true;
        return checkDepth(fragment, visitedFragments, depth);
      } finally {
        visitedFragments[fragmentName] = void 0;
      }
    }
    if (node2.kind === Kind.FIELD && // check all introspection lists
    (node2.name.value === "fields" || node2.name.value === "interfaces" || node2.name.value === "possibleTypes" || node2.name.value === "inputFields")) {
      depth++;
      if (depth >= MAX_LISTS_DEPTH) {
        return true;
      }
    }
    if ("selectionSet" in node2 && node2.selectionSet) {
      for (const child of node2.selectionSet.selections) {
        if (checkDepth(child, visitedFragments, depth)) {
          return true;
        }
      }
    }
    return false;
  }
  return {
    Field(node2) {
      if (node2.name.value === "__schema" || node2.name.value === "__type") {
        if (checkDepth(node2)) {
          context.reportError(
            new GraphQLError("Maximum introspection depth exceeded", {
              nodes: [node2]
            })
          );
          return false;
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
function NoFragmentCyclesRule(context) {
  const visitedFrags = /* @__PURE__ */ Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node2) {
      detectCycleRecursive(node2);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
        context.reportError(
          new GraphQLError(
            `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
            {
              nodes: cyclePath
            }
          )
        );
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}

// node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node: node2 } of usages) {
          const varName = node2.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                {
                  nodes: [node2, operation]
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(node2) {
      variableNameDefined[node2.variable.name.value] = true;
    }
  };
}

// node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node2) {
      operationDefs.push(node2);
      return false;
    },
    FragmentDefinition(node2) {
      fragmentDefs.push(node2);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(
            operation
          )) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(
              new GraphQLError(`Fragment "${fragName}" is never used.`, {
                nodes: fragmentDef
              })
            );
          }
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = /* @__PURE__ */ Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node: node2 } of usages) {
          variableNameUsed[node2.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                {
                  nodes: variableDef
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}

// node_modules/graphql/utilities/sortValueNode.mjs
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
function sortFields(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort(
    (fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value)
  );
}

// node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(
      ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
    ).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFieldsAndFragmentPairs = new OrderedPairSet();
  const comparedFragmentPairs = new PairSet();
  const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
  return {
    SelectionSet(selectionSet2) {
      const conflicts = findConflictsWithinSelectionSet(
        context,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        context.getParentType(),
        selectionSet2
      );
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(
          new GraphQLError(
            `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
            {
              nodes: fields1.concat(fields2)
            }
          )
        );
      }
    }
  };
}
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentType, selectionSet2) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType,
    selectionSet2
  );
  collectConflictsWithin(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    fieldMap
  );
  if (fragmentNames.length !== 0) {
    for (let i3 = 0; i3 < fragmentNames.length; i3++) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        false,
        fieldMap,
        fragmentNames[i3]
      );
      for (let j = i3 + 1; j < fragmentNames.length; j++) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFieldsAndFragmentPairs,
          comparedFragmentPairs,
          false,
          fragmentNames[i3],
          fragmentNames[j]
        );
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  if (comparedFieldsAndFragmentPairs.has(
    fieldMap,
    fragmentName,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFieldsAndFragmentPairs.add(
    fieldMap,
    fragmentName,
    areMutuallyExclusive
  );
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment
  );
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap,
    fieldMap2
  );
  for (const referencedFragmentName of referencedFragmentNames) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      referencedFragmentName
    );
  }
}
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(
    fragmentName1,
    fragmentName2,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment1
  );
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fragmentName1,
      referencedFragmentName2
    );
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      referencedFragmentName1,
      fragmentName2
    );
  }
}
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType1,
    selectionSet1
  );
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType2,
    selectionSet2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFieldsAndFragmentPairs,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fragmentName2
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap2,
      fragmentName1
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFieldsAndFragmentPairs,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        fragmentName2
      );
    }
  }
  return conflicts;
}
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i3 = 0; i3 < fields.length; i3++) {
        for (let j = i3 + 1; j < fields.length; j++) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            false,
            // within one collection is never mutually exclusive
            responseName,
            fields[i3],
            fields[j]
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFieldsAndFragmentPairs,
            comparedFragmentPairs,
            parentFieldsAreMutuallyExclusive,
            responseName,
            field1,
            field2
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context, cachedFieldsAndFragmentNames, comparedFieldsAndFragmentPairs, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (!sameArguments(node1, node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(
          type2
        )}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(
      context,
      cachedFieldsAndFragmentNames,
      comparedFieldsAndFragmentPairs,
      comparedFragmentPairs,
      areMutuallyExclusive,
      getNamedType(type1),
      selectionSet1,
      getNamedType(type2),
      selectionSet2
    );
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
}
function sameArguments(node1, node2) {
  const args1 = node1.arguments;
  const args2 = node2.arguments;
  if (args1 === void 0 || args1.length === 0) {
    return args2 === void 0 || args2.length === 0;
  }
  if (args2 === void 0 || args2.length === 0) {
    return false;
  }
  if (args1.length !== args2.length) {
    return false;
  }
  const values22 = new Map(args2.map(({ name: name2, value: value2 }) => [name2.value, value2]));
  return args1.every((arg1) => {
    const value1 = arg1.value;
    const value2 = values22.get(arg1.name.value);
    if (value2 === void 0) {
      return false;
    }
    return stringifyValue(value1) === stringifyValue(value2);
  });
}
function stringifyValue(value2) {
  return print(sortValueNode(value2));
}
function doTypesConflict(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
}
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet2) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet2);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = /* @__PURE__ */ Object.create(null);
  const fragmentNames = /* @__PURE__ */ Object.create(null);
  _collectFieldsAndFragmentNames(
    context,
    parentType,
    selectionSet2,
    nodeAndDefs,
    fragmentNames
  );
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet2, result);
  return result;
}
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragmentType,
    fragment.selectionSet
  );
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet2, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet2.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(
          context,
          inlineFragmentType,
          selection.selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
}
var OrderedPairSet = class {
  constructor() {
    this._data = /* @__PURE__ */ new Map();
  }
  has(a2, b, weaklyPresent) {
    var _this$_data$get;
    const result = (_this$_data$get = this._data.get(a2)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(b);
    if (result === void 0) {
      return false;
    }
    return weaklyPresent ? true : weaklyPresent === result;
  }
  add(a2, b, weaklyPresent) {
    const map2 = this._data.get(a2);
    if (map2 === void 0) {
      this._data.set(a2, /* @__PURE__ */ new Map([[b, weaklyPresent]]));
    } else {
      map2.set(b, weaklyPresent);
    }
  }
};
var PairSet = class {
  constructor() {
    this._orderedPairSet = new OrderedPairSet();
  }
  has(a2, b, weaklyPresent) {
    return a2 < b ? this._orderedPairSet.has(a2, b, weaklyPresent) : this._orderedPairSet.has(b, a2, weaklyPresent);
  }
  add(a2, b, weaklyPresent) {
    if (a2 < b) {
      this._orderedPairSet.add(a2, b, weaklyPresent);
    } else {
      this._orderedPairSet.add(b, a2, weaklyPresent);
    }
  }
};

// node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node2) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node2
            }
          )
        );
      }
    },
    FragmentSpread(node2) {
      const fragName = node2.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node2
            }
          )
        );
      }
    }
  };
}
function getFragmentType(context, name2) {
  const frag = context.getFragment(name2);
  if (frag) {
    const type2 = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type2)) {
      return type2;
    }
  }
}

// node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
function PossibleTypeExtensionsRule(context) {
  const schema = context.getSchema();
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node2) {
    const typeName = node2.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node2.kind) {
        const kindStr = extensionKindToTypeName(node2.kind);
        context.reportError(
          new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node2] : node2
          })
        );
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(
        new GraphQLError(
          `Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes),
          {
            nodes: node2.name
          }
        )
      );
    }
  }
}
var defKindToExtKind = {
  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
};
function typeToExtKind(type2) {
  if (isScalarType(type2)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type2)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type2)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type2)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type2)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type2)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type2));
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
}

// node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
function ProvidedRequiredArgumentsRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          /* c8 ignore next */
          (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
        );
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                {
                  nodes: fieldNode
                }
              )
            );
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(
      directive.args.filter(isRequiredArgument),
      (arg) => arg.name
    );
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(
        argNodes.filter(isRequiredArgumentNode),
        (arg) => arg.name.value
      );
    }
  }
  return {
    Directive: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
              context.reportError(
                new GraphQLError(
                  `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                  {
                    nodes: directiveNode
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
}

// node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
function ScalarLeafsRule(context) {
  return {
    Field(node2) {
      const type2 = context.getType();
      const selectionSet2 = node2.selectionSet;
      if (type2) {
        if (isLeafType(getNamedType(type2))) {
          if (selectionSet2) {
            const fieldName = node2.name.value;
            const typeStr = inspect(type2);
            context.reportError(
              new GraphQLError(
                `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                {
                  nodes: selectionSet2
                }
              )
            );
          }
        } else if (!selectionSet2) {
          const fieldName = node2.name.value;
          const typeStr = inspect(type2);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
              {
                nodes: node2
              }
            )
          );
        } else if (selectionSet2.selections.length === 0) {
          const fieldName = node2.name.value;
          const typeStr = inspect(type2);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have at least one field selected.`,
              {
                nodes: node2
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/graphql/utilities/valueFromAST.mjs
function valueFromAST(valueNode, type2, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type2)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type2)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type2.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type2)) {
    const itemType = type2.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type2)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = /* @__PURE__ */ Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type2.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== void 0) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    if (type2.isOneOf) {
      const keys2 = Object.keys(coercedObj);
      if (keys2.length !== 1) {
        return;
      }
      if (coercedObj[keys2[0]] === null) {
        return;
      }
    }
    return coercedObj;
  }
  if (isLeafType(type2)) {
    let result;
    try {
      result = type2.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === void 0) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type2));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}

// node_modules/graphql/execution/values.mjs
function getArgumentValues(def, node2, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node2.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name2 = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name2];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name2] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(
          `Argument "${name2}" of required type "${inspect(argType)}" was not provided.`,
          {
            nodes: node2
          }
        );
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name2] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name2}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
            {
              nodes: valueNode
            }
          );
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError(
        `Argument "${name2}" of non-null type "${inspect(argType)}" must not be null.`,
        {
          nodes: valueNode
        }
      );
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError(
        `Argument "${name2}" has invalid value ${print(valueNode)}.`,
        {
          nodes: valueNode
        }
      );
    }
    coercedValues[name2] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node2, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node2.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
    (directive) => directive.name.value === directiveDef.name
  );
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// node_modules/graphql/execution/collectFields.mjs
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet2) {
  const fields = /* @__PURE__ */ new Map();
  collectFieldsImpl(
    schema,
    fragments,
    variableValues,
    runtimeType,
    selectionSet2,
    fields,
    /* @__PURE__ */ new Set()
  );
  return fields;
}
function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = /* @__PURE__ */ new Map();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  for (const node2 of fieldNodes) {
    if (node2.selectionSet) {
      collectFieldsImpl(
        schema,
        fragments,
        variableValues,
        returnType,
        node2.selectionSet,
        subFieldNodes,
        visitedFragmentNames
      );
    }
  }
  return subFieldNodes;
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet2, fields, visitedFragmentNames) {
  for (const selection of selectionSet2.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name2 = getFieldEntryKey(selection);
        const fieldList = fields.get(name2);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name2, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selection.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          fragment.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
    }
  }
}
function shouldIncludeNode(variableValues, node2) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node2, variableValues);
  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(
    GraphQLIncludeDirective,
    node2,
    variableValues
  );
  if ((include === null || include === void 0 ? void 0 : include.if) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type2) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema, typeConditionNode);
  if (conditionalType === type2) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema.isSubType(conditionalType, type2);
  }
  return false;
}
function getFieldEntryKey(node2) {
  return node2.alias ? node2.alias.value : node2.name.value;
}

// node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node2) {
      if (node2.operation === "subscription") {
        const schema = context.getSchema();
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node2.name ? node2.name.value : null;
          const variableValues = /* @__PURE__ */ Object.create(null);
          const document4 = context.getDocument();
          const fragments = /* @__PURE__ */ Object.create(null);
          for (const definition2 of document4.definitions) {
            if (definition2.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition2.name.value] = definition2;
            }
          }
          const fields = collectFields(
            schema,
            fragments,
            variableValues,
            subscriptionType,
            node2.selectionSet
          );
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(
              new GraphQLError(
                operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                {
                  nodes: extraFieldSelections
                }
              )
            );
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(
                new GraphQLError(
                  operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: fieldNodes
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}

// node_modules/graphql/jsutils/groupBy.mjs
function groupBy(list3, keyFn) {
  const result = /* @__PURE__ */ new Map();
  for (const item of list3) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group === void 0) {
      result.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result;
}

// node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `Argument "${parentName}(${argName}:)" can only be defined once.`,
            {
              nodes: argNodes.map((node2) => node2.name)
            }
          )
        );
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `There can be only one argument named "${argName}".`,
            {
              nodes: argNodes.map((node2) => node2.name)
            }
          )
        );
      }
    }
  }
}

// node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    DirectiveDefinition(node2) {
      const directiveName = node2.name.value;
      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
            {
              nodes: node2.name
            }
          )
        );
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one directive named "@${directiveName}".`,
            {
              nodes: [knownDirectiveNames[directiveName], node2.name]
            }
          )
        );
      } else {
        knownDirectiveNames[directiveName] = node2.name;
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = /* @__PURE__ */ Object.create(null);
  const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
  return {
    // Many different AST nodes may contain directives. Rather than listing
    // them all, just listen for entering any node, and check to see if it
    // defines any directives.
    enter(node2) {
      if (!("directives" in node2) || !node2.directives) {
        return;
      }
      let seenDirectives;
      if (node2.kind === Kind.SCHEMA_DEFINITION || node2.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node2) || isTypeExtensionNode(node2)) {
        const typeName = node2.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
        }
      } else {
        seenDirectives = /* @__PURE__ */ Object.create(null);
      }
      for (const directive of node2.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(
              new GraphQLError(
                `The directive "@${directiveName}" can only be used once at this location.`,
                {
                  nodes: [seenDirectives[directiveName], directive]
                }
              )
            );
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
function UniqueEnumValueNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownValueNames = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node2) {
    var _node$values;
    const typeName = node2.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const valueNodes = (_node$values = node2.values) !== null && _node$values !== void 0 ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: valueDef.name
            }
          )
        );
      } else if (valueNames[valueName]) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" can only be defined once.`,
            {
              nodes: [valueNames[valueName], valueDef.name]
            }
          )
        );
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
function UniqueFieldDefinitionNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownFieldNames = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node2) {
    var _node$fields;
    const typeName = node2.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const fieldNodes = (_node$fields = node2.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: fieldDef.name
            }
          )
        );
      } else if (fieldNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" can only be defined once.`,
            {
              nodes: [fieldNames[fieldName], fieldDef.name]
            }
          )
        );
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type2, fieldName) {
  if (isObjectType(type2) || isInterfaceType(type2) || isInputObjectType(type2)) {
    return type2.getFields()[fieldName] != null;
  }
  return false;
}

// node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node2) {
      const fragmentName = node2.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one fragment named "${fragmentName}".`,
            {
              nodes: [knownFragmentNames[fragmentName], node2.name]
            }
          )
        );
      } else {
        knownFragmentNames[fragmentName] = node2.name;
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = /* @__PURE__ */ Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node2) {
      const fieldName = node2.name.value;
      if (knownNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one input field named "${fieldName}".`,
            {
              nodes: [knownNames[fieldName], node2.name]
            }
          )
        );
      } else {
        knownNames[fieldName] = node2.name;
      }
    }
  };
}

// node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
function UniqueOperationNamesRule(context) {
  const knownOperationNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition(node2) {
      const operationName = node2.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(
            new GraphQLError(
              `There can be only one operation named "${operationName.value}".`,
              {
                nodes: [
                  knownOperationNames[operationName.value],
                  operationName
                ]
              }
            )
          );
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}

// node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
function UniqueOperationTypesRule(context) {
  const schema = context.getSchema();
  const definedOperationTypes = /* @__PURE__ */ Object.create(null);
  const existingOperationTypes = schema ? {
    query: schema.getQueryType(),
    mutation: schema.getMutationType(),
    subscription: schema.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node2) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node2.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(
          new GraphQLError(
            `Type for ${operation} already defined in the schema. It cannot be redefined.`,
            {
              nodes: operationType
            }
          )
        );
      } else if (alreadyDefinedOperationType) {
        context.reportError(
          new GraphQLError(
            `There can be only one ${operation} type in schema.`,
            {
              nodes: [alreadyDefinedOperationType, operationType]
            }
          )
        );
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
function UniqueTypeNamesRule(context) {
  const knownTypeNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node2) {
    const typeName = node2.name.value;
    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
      context.reportError(
        new GraphQLError(
          `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
          {
            nodes: node2.name
          }
        )
      );
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(
        new GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node2.name]
        })
      );
    } else {
      knownTypeNames[typeName] = node2.name;
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions2 = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(
        variableDefinitions2,
        (node2) => node2.variable.name.value
      );
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `There can be only one variable named "$${variableName}".`,
              {
                nodes: variableNodes.map((node2) => node2.variable.name)
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
function ValuesOfCorrectTypeRule(context) {
  let variableDefinitions2 = {};
  return {
    OperationDefinition: {
      enter() {
        variableDefinitions2 = {};
      }
    },
    VariableDefinition(definition2) {
      variableDefinitions2[definition2.variable.name.value] = definition2;
    },
    ListValue(node2) {
      const type2 = getNullableType(context.getParentInputType());
      if (!isListType(type2)) {
        isValidValueNode(context, node2);
        return false;
      }
    },
    ObjectValue(node2) {
      const type2 = getNamedType(context.getInputType());
      if (!isInputObjectType(type2)) {
        isValidValueNode(context, node2);
        return false;
      }
      const fieldNodeMap = keyMap(node2.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type2.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(
            new GraphQLError(
              `Field "${type2.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
              {
                nodes: node2
              }
            )
          );
        }
      }
      if (type2.isOneOf) {
        validateOneOfInputObject(
          context,
          node2,
          type2,
          fieldNodeMap,
          variableDefinitions2
        );
      }
    },
    ObjectField(node2) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(
          node2.name.value,
          Object.keys(parentType.getFields())
        );
        context.reportError(
          new GraphQLError(
            `Field "${node2.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
            {
              nodes: node2
            }
          )
        );
      }
    },
    NullValue(node2) {
      const type2 = context.getInputType();
      if (isNonNullType(type2)) {
        context.reportError(
          new GraphQLError(
            `Expected value of type "${inspect(type2)}", found ${print(node2)}.`,
            {
              nodes: node2
            }
          )
        );
      }
    },
    EnumValue: (node2) => isValidValueNode(context, node2),
    IntValue: (node2) => isValidValueNode(context, node2),
    FloatValue: (node2) => isValidValueNode(context, node2),
    StringValue: (node2) => isValidValueNode(context, node2),
    BooleanValue: (node2) => isValidValueNode(context, node2)
  };
}
function isValidValueNode(context, node2) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type2 = getNamedType(locationType);
  if (!isLeafType(type2)) {
    const typeStr = inspect(locationType);
    context.reportError(
      new GraphQLError(
        `Expected value of type "${typeStr}", found ${print(node2)}.`,
        {
          nodes: node2
        }
      )
    );
    return;
  }
  try {
    const parseResult = type2.parseLiteral(
      node2,
      void 0
      /* variables */
    );
    if (parseResult === void 0) {
      const typeStr = inspect(locationType);
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node2)}.`,
          {
            nodes: node2
          }
        )
      );
    }
  } catch (error2) {
    const typeStr = inspect(locationType);
    if (error2 instanceof GraphQLError) {
      context.reportError(error2);
    } else {
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node2)}; ` + error2.message,
          {
            nodes: node2,
            originalError: error2
          }
        )
      );
    }
  }
}
function validateOneOfInputObject(context, node2, type2, fieldNodeMap, variableDefinitions2) {
  var _fieldNodeMap$keys$;
  const keys2 = Object.keys(fieldNodeMap);
  const isNotExactlyOneField = keys2.length !== 1;
  if (isNotExactlyOneField) {
    context.reportError(
      new GraphQLError(
        `OneOf Input Object "${type2.name}" must specify exactly one key.`,
        {
          nodes: [node2]
        }
      )
    );
    return;
  }
  const value2 = (_fieldNodeMap$keys$ = fieldNodeMap[keys2[0]]) === null || _fieldNodeMap$keys$ === void 0 ? void 0 : _fieldNodeMap$keys$.value;
  const isNullLiteral = !value2 || value2.kind === Kind.NULL;
  const isVariable = (value2 === null || value2 === void 0 ? void 0 : value2.kind) === Kind.VARIABLE;
  if (isNullLiteral) {
    context.reportError(
      new GraphQLError(`Field "${type2.name}.${keys2[0]}" must be non-null.`, {
        nodes: [node2]
      })
    );
    return;
  }
  if (isVariable) {
    const variableName = value2.name.value;
    const definition2 = variableDefinitions2[variableName];
    const isNullableVariable = definition2.type.kind !== Kind.NON_NULL_TYPE;
    if (isNullableVariable) {
      context.reportError(
        new GraphQLError(
          `Variable "${variableName}" must be non-nullable to be used for OneOf Input Object "${type2.name}".`,
          {
            nodes: [node2]
          }
        )
      );
    }
  }
}

// node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node2) {
      const type2 = typeFromAST(context.getSchema(), node2.type);
      if (type2 !== void 0 && !isInputType(type2)) {
        const variableName = node2.variable.name.value;
        const typeName = print(node2.type);
        context.reportError(
          new GraphQLError(
            `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
            {
              nodes: node2.type
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
function VariablesInAllowedPositionRule(context) {
  let varDefMap = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node: node2, type: type2, defaultValue, parentType } of usages) {
          const varName = node2.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type2) {
            const schema = context.getSchema();
            const varType = typeFromAST(schema, varDef.type);
            if (varType && !allowedVariableUsage(
              schema,
              varType,
              varDef.defaultValue,
              type2,
              defaultValue
            )) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type2);
              context.reportError(
                new GraphQLError(
                  `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                  {
                    nodes: [varDef, node2]
                  }
                )
              );
            }
            if (isInputObjectType(parentType) && parentType.isOneOf && isNullableType(varType)) {
              context.reportError(
                new GraphQLError(
                  `Variable "$${varName}" is of type "${varType}" but must be non-nullable to be used for OneOf Input Object "${parentType}".`,
                  {
                    nodes: [varDef, node2]
                  }
                )
              );
            }
          }
        }
      }
    },
    VariableDefinition(node2) {
      varDefMap[node2.variable.name.value] = node2;
    }
  };
}
function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema, varType, locationType);
}

// node_modules/graphql/validation/specifiedRules.mjs
var recommendedRules = Object.freeze([MaxIntrospectionDepthRule]);
var specifiedRules = Object.freeze([
  ExecutableDefinitionsRule,
  UniqueOperationNamesRule,
  LoneAnonymousOperationRule,
  SingleFieldSubscriptionsRule,
  KnownTypeNamesRule,
  FragmentsOnCompositeTypesRule,
  VariablesAreInputTypesRule,
  ScalarLeafsRule,
  FieldsOnCorrectTypeRule,
  UniqueFragmentNamesRule,
  KnownFragmentNamesRule,
  NoUnusedFragmentsRule,
  PossibleFragmentSpreadsRule,
  NoFragmentCyclesRule,
  UniqueVariableNamesRule,
  NoUndefinedVariablesRule,
  NoUnusedVariablesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  KnownArgumentNamesRule,
  UniqueArgumentNamesRule,
  ValuesOfCorrectTypeRule,
  ProvidedRequiredArgumentsRule,
  VariablesInAllowedPositionRule,
  OverlappingFieldsCanBeMergedRule,
  UniqueInputFieldNamesRule,
  ...recommendedRules
]);
var specifiedSDLRules = Object.freeze([
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  KnownArgumentNamesOnDirectivesRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule,
  ProvidedRequiredArgumentsOnDirectivesRule
]);

// node_modules/graphql/jsutils/memoize3.mjs
function memoize3(fn) {
  let cache0;
  return function memoized(a1, a2, a3) {
    if (cache0 === void 0) {
      cache0 = /* @__PURE__ */ new WeakMap();
    }
    let cache1 = cache0.get(a1);
    if (cache1 === void 0) {
      cache1 = /* @__PURE__ */ new WeakMap();
      cache0.set(a1, cache1);
    }
    let cache2 = cache1.get(a2);
    if (cache2 === void 0) {
      cache2 = /* @__PURE__ */ new WeakMap();
      cache1.set(a2, cache2);
    }
    let fnResult = cache2.get(a3);
    if (fnResult === void 0) {
      fnResult = fn(a1, a2, a3);
      cache2.set(a3, fnResult);
    }
    return fnResult;
  };
}

// node_modules/graphql/execution/execute.mjs
var collectSubfields2 = memoize3(
  (exeContext, returnType, fieldNodes) => collectSubfields(
    exeContext.schema,
    exeContext.fragments,
    exeContext.variableValues,
    returnType,
    fieldNodes
  )
);

// node_modules/graphql/utilities/extendSchema.mjs
var stdTypeMap = keyMap(
  [...specifiedScalarTypes, ...introspectionTypes],
  (type2) => type2.name
);

// node_modules/graphql/utilities/findBreakingChanges.mjs
var BreakingChangeType;
(function(BreakingChangeType2) {
  BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
  BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
  BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
  BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
  BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
  BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
  BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
  BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
  BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
  BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
  BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
  BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
  BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
  BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
  BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
  BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
})(BreakingChangeType || (BreakingChangeType = {}));
var DangerousChangeType;
(function(DangerousChangeType2) {
  DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
  DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
  DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
  DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
  DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
  DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
})(DangerousChangeType || (DangerousChangeType = {}));

// node_modules/@copilotkit/shared/dist/chunk-XLQ2EIPH.mjs
function parseJson(json, fallback = "unset") {
  try {
    return JSON.parse(json);
  } catch (e3) {
    return fallback === "unset" ? null : fallback;
  }
}
function isMacOS() {
  return /Mac|iMac|Macintosh/i.test(navigator.userAgent);
}
var COPILOTKIT_VERSION = version;
var Severity = ((Severity2) => {
  Severity2["CRITICAL"] = "critical";
  Severity2["WARNING"] = "warning";
  Severity2["INFO"] = "info";
  return Severity2;
})(Severity || {});
var ErrorVisibility = ((ErrorVisibility2) => {
  ErrorVisibility2["BANNER"] = "banner";
  ErrorVisibility2["TOAST"] = "toast";
  ErrorVisibility2["SILENT"] = "silent";
  ErrorVisibility2["DEV_ONLY"] = "dev_only";
  return ErrorVisibility2;
})(ErrorVisibility || {});
var ERROR_NAMES = {
  COPILOT_ERROR: "CopilotError",
  COPILOT_API_DISCOVERY_ERROR: "CopilotApiDiscoveryError",
  COPILOT_REMOTE_ENDPOINT_DISCOVERY_ERROR: "CopilotKitRemoteEndpointDiscoveryError",
  COPILOT_KIT_AGENT_DISCOVERY_ERROR: "CopilotKitAgentDiscoveryError",
  COPILOT_KIT_LOW_LEVEL_ERROR: "CopilotKitLowLevelError",
  COPILOT_KIT_VERSION_MISMATCH_ERROR: "CopilotKitVersionMismatchError",
  RESOLVED_COPILOT_KIT_ERROR: "ResolvedCopilotKitError",
  CONFIGURATION_ERROR: "ConfigurationError",
  MISSING_PUBLIC_API_KEY_ERROR: "MissingPublicApiKeyError",
  UPGRADE_REQUIRED_ERROR: "UpgradeRequiredError"
};
var BANNER_ERROR_NAMES = [
  ERROR_NAMES.CONFIGURATION_ERROR,
  ERROR_NAMES.MISSING_PUBLIC_API_KEY_ERROR,
  ERROR_NAMES.UPGRADE_REQUIRED_ERROR,
  ERROR_NAMES.COPILOT_API_DISCOVERY_ERROR,
  ERROR_NAMES.COPILOT_REMOTE_ENDPOINT_DISCOVERY_ERROR,
  ERROR_NAMES.COPILOT_KIT_AGENT_DISCOVERY_ERROR
];
var CopilotKitErrorCode = ((CopilotKitErrorCode2) => {
  CopilotKitErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  CopilotKitErrorCode2["NOT_FOUND"] = "NOT_FOUND";
  CopilotKitErrorCode2["AGENT_NOT_FOUND"] = "AGENT_NOT_FOUND";
  CopilotKitErrorCode2["API_NOT_FOUND"] = "API_NOT_FOUND";
  CopilotKitErrorCode2["REMOTE_ENDPOINT_NOT_FOUND"] = "REMOTE_ENDPOINT_NOT_FOUND";
  CopilotKitErrorCode2["AUTHENTICATION_ERROR"] = "AUTHENTICATION_ERROR";
  CopilotKitErrorCode2["MISUSE"] = "MISUSE";
  CopilotKitErrorCode2["UNKNOWN"] = "UNKNOWN";
  CopilotKitErrorCode2["VERSION_MISMATCH"] = "VERSION_MISMATCH";
  CopilotKitErrorCode2["CONFIGURATION_ERROR"] = "CONFIGURATION_ERROR";
  CopilotKitErrorCode2["MISSING_PUBLIC_API_KEY_ERROR"] = "MISSING_PUBLIC_API_KEY_ERROR";
  CopilotKitErrorCode2["UPGRADE_REQUIRED_ERROR"] = "UPGRADE_REQUIRED_ERROR";
  return CopilotKitErrorCode2;
})(CopilotKitErrorCode || {});
var BASE_URL = "https://docs.copilotkit.ai";
var getSeeMoreMarkdown = (link2) => `See more: [${link2}](${link2})`;
var ERROR_CONFIG = {
  [
    "NETWORK_ERROR"
    /* NETWORK_ERROR */
  ]: {
    statusCode: 503,
    troubleshootingUrl: `${BASE_URL}/troubleshooting/common-issues#i-am-getting-a-network-errors--api-not-found`,
    visibility: "banner",
    severity: "critical"
    /* CRITICAL */
  },
  [
    "NOT_FOUND"
    /* NOT_FOUND */
  ]: {
    statusCode: 404,
    troubleshootingUrl: `${BASE_URL}/troubleshooting/common-issues#i-am-getting-a-network-errors--api-not-found`,
    visibility: "banner",
    severity: "critical"
    /* CRITICAL */
  },
  [
    "AGENT_NOT_FOUND"
    /* AGENT_NOT_FOUND */
  ]: {
    statusCode: 500,
    troubleshootingUrl: `${BASE_URL}/coagents/troubleshooting/common-issues#i-am-getting-agent-not-found-error`,
    visibility: "banner",
    severity: "critical"
    /* CRITICAL */
  },
  [
    "API_NOT_FOUND"
    /* API_NOT_FOUND */
  ]: {
    statusCode: 404,
    troubleshootingUrl: `${BASE_URL}/troubleshooting/common-issues#i-am-getting-a-network-errors--api-not-found`,
    visibility: "banner",
    severity: "critical"
    /* CRITICAL */
  },
  [
    "REMOTE_ENDPOINT_NOT_FOUND"
    /* REMOTE_ENDPOINT_NOT_FOUND */
  ]: {
    statusCode: 404,
    troubleshootingUrl: `${BASE_URL}/troubleshooting/common-issues#i-am-getting-copilotkits-remote-endpoint-not-found-error`,
    visibility: "banner",
    severity: "critical"
    /* CRITICAL */
  },
  [
    "AUTHENTICATION_ERROR"
    /* AUTHENTICATION_ERROR */
  ]: {
    statusCode: 401,
    troubleshootingUrl: `${BASE_URL}/troubleshooting/common-issues#authentication-errors`,
    visibility: "banner",
    severity: "critical"
    /* CRITICAL */
  },
  [
    "MISUSE"
    /* MISUSE */
  ]: {
    statusCode: 400,
    troubleshootingUrl: null,
    visibility: "dev_only",
    severity: "warning"
    /* WARNING */
  },
  [
    "UNKNOWN"
    /* UNKNOWN */
  ]: {
    statusCode: 500,
    visibility: "toast",
    severity: "critical"
    /* CRITICAL */
  },
  [
    "CONFIGURATION_ERROR"
    /* CONFIGURATION_ERROR */
  ]: {
    statusCode: 400,
    troubleshootingUrl: null,
    severity: "warning",
    visibility: "banner"
    /* BANNER */
  },
  [
    "MISSING_PUBLIC_API_KEY_ERROR"
    /* MISSING_PUBLIC_API_KEY_ERROR */
  ]: {
    statusCode: 400,
    troubleshootingUrl: null,
    severity: "critical",
    visibility: "banner"
    /* BANNER */
  },
  [
    "UPGRADE_REQUIRED_ERROR"
    /* UPGRADE_REQUIRED_ERROR */
  ]: {
    statusCode: 402,
    troubleshootingUrl: null,
    severity: "warning",
    visibility: "banner"
    /* BANNER */
  },
  [
    "VERSION_MISMATCH"
    /* VERSION_MISMATCH */
  ]: {
    statusCode: 400,
    troubleshootingUrl: null,
    visibility: "dev_only",
    severity: "info"
    /* INFO */
  }
};
var CopilotKitError = class extends GraphQLError {
  constructor({
    message: message2 = "Unknown error occurred",
    code: code2,
    severity,
    visibility
  }) {
    const name2 = ERROR_NAMES.COPILOT_ERROR;
    const config = ERROR_CONFIG[code2];
    const { statusCode } = config;
    const resolvedVisibility = visibility ?? config.visibility ?? "toast";
    const resolvedSeverity = severity ?? ("severity" in config ? config.severity : void 0);
    super(message2, {
      extensions: {
        name: name2,
        statusCode,
        code: code2,
        visibility: resolvedVisibility,
        severity: resolvedSeverity,
        troubleshootingUrl: "troubleshootingUrl" in config ? config.troubleshootingUrl : null,
        originalError: {
          message: message2,
          stack: new Error().stack
        }
      }
    });
    this.code = code2;
    this.name = name2;
    this.statusCode = statusCode;
    this.severity = resolvedSeverity;
    this.visibility = resolvedVisibility;
  }
};
var getVersionMismatchErrorMessage = ({
  reactCoreVersion,
  runtimeVersion,
  runtimeClientGqlVersion
}) => `Version mismatch detected: @copilotkit/runtime@${runtimeVersion ?? ""} is not compatible with @copilotkit/react-core@${reactCoreVersion} and @copilotkit/runtime-client-gql@${runtimeClientGqlVersion}. Please ensure all installed copilotkit packages are on the same version.`;
var CopilotKitVersionMismatchError = class extends CopilotKitError {
  constructor({
    reactCoreVersion,
    runtimeVersion,
    runtimeClientGqlVersion
  }) {
    const code2 = "VERSION_MISMATCH";
    super({
      message: getVersionMismatchErrorMessage({
        reactCoreVersion,
        runtimeVersion,
        runtimeClientGqlVersion
      }),
      code: code2
    });
    this.name = ERROR_NAMES.COPILOT_KIT_VERSION_MISMATCH_ERROR;
  }
};
var CopilotKitApiDiscoveryError = class extends CopilotKitError {
  constructor(params = {}) {
    const url = params.url ?? "";
    let operationSuffix = "";
    if (url == null ? void 0 : url.includes("/info"))
      operationSuffix = `when fetching CopilotKit info`;
    else if (url.includes("/actions/execute"))
      operationSuffix = `when attempting to execute actions.`;
    else if (url.includes("/agents/state"))
      operationSuffix = `when attempting to get agent state.`;
    else if (url.includes("/agents/execute"))
      operationSuffix = `when attempting to execute agent(s).`;
    const message2 = params.message ?? (params.url ? `Failed to find CopilotKit API endpoint at url ${params.url} ${operationSuffix}` : `Failed to find CopilotKit API endpoint.`);
    const code2 = params.code ?? "API_NOT_FOUND";
    const errorMessage = `${message2}.

${getSeeMoreMarkdown(ERROR_CONFIG[code2].troubleshootingUrl)}`;
    super({ message: errorMessage, code: code2 });
    this.name = ERROR_NAMES.COPILOT_API_DISCOVERY_ERROR;
  }
};
var CopilotKitRemoteEndpointDiscoveryError = class extends CopilotKitApiDiscoveryError {
  constructor(params) {
    const message2 = (params == null ? void 0 : params.message) ?? ((params == null ? void 0 : params.url) ? `Failed to find or contact remote endpoint at url ${params.url}` : "Failed to find or contact remote endpoint");
    const code2 = "REMOTE_ENDPOINT_NOT_FOUND";
    super({ message: message2, code: code2 });
    this.name = ERROR_NAMES.COPILOT_REMOTE_ENDPOINT_DISCOVERY_ERROR;
  }
};
var CopilotKitAgentDiscoveryError = class extends CopilotKitError {
  constructor(params) {
    const { agentName, availableAgents } = params;
    const code2 = "AGENT_NOT_FOUND";
    const seeMore = getSeeMoreMarkdown(ERROR_CONFIG[code2].troubleshootingUrl);
    let message2;
    if (availableAgents.length) {
      const agentList = availableAgents.map((agent) => agent.name).join(", ");
      if (agentName) {
        message2 = `Agent '${agentName}' was not found. Available agents are: ${agentList}. Please verify the agent name in your configuration and ensure it matches one of the available agents.

${seeMore}`;
      } else {
        message2 = `The requested agent was not found. Available agents are: ${agentList}. Please verify the agent name in your configuration and ensure it matches one of the available agents.

${seeMore}`;
      }
    } else {
      message2 = `${agentName ? `Agent '${agentName}'` : "The requested agent"} was not found. Please set up at least one agent before proceeding. ${seeMore}`;
    }
    super({ message: message2, code: code2 });
    this.name = ERROR_NAMES.COPILOT_KIT_AGENT_DISCOVERY_ERROR;
  }
};
var CopilotKitLowLevelError = class extends CopilotKitError {
  constructor({ error: error2, url, message: message2 }) {
    let code2 = "NETWORK_ERROR";
    const errorCode = error2.code;
    const errorMessage = message2 ?? resolveLowLevelErrorMessage({ errorCode, url });
    super({ message: errorMessage, code: code2 });
    this.name = ERROR_NAMES.COPILOT_KIT_LOW_LEVEL_ERROR;
  }
};
var ResolvedCopilotKitError = class extends CopilotKitError {
  constructor({
    status,
    message: message2,
    code: code2,
    isRemoteEndpoint,
    url
  }) {
    let resolvedCode = code2;
    if (!resolvedCode) {
      switch (status) {
        case 400:
          throw new CopilotKitApiDiscoveryError({ message: message2, url });
        case 404:
          throw isRemoteEndpoint ? new CopilotKitRemoteEndpointDiscoveryError({ message: message2, url }) : new CopilotKitApiDiscoveryError({ message: message2, url });
        default:
          resolvedCode = "UNKNOWN";
          break;
      }
    }
    super({ message: message2, code: resolvedCode });
    this.name = ERROR_NAMES.RESOLVED_COPILOT_KIT_ERROR;
  }
};
var ConfigurationError = class extends CopilotKitError {
  constructor(message2) {
    super({
      message: message2,
      code: "CONFIGURATION_ERROR"
      /* CONFIGURATION_ERROR */
    });
    this.name = ERROR_NAMES.CONFIGURATION_ERROR;
    this.severity = "warning";
  }
};
var MissingPublicApiKeyError = class extends ConfigurationError {
  constructor(message2) {
    super(message2);
    this.name = ERROR_NAMES.MISSING_PUBLIC_API_KEY_ERROR;
    this.severity = "critical";
  }
};
async function getPossibleVersionMismatch({
  runtimeVersion,
  runtimeClientGqlVersion
}) {
  if (!runtimeVersion || runtimeVersion === "" || !runtimeClientGqlVersion)
    return;
  if (COPILOTKIT_VERSION !== runtimeVersion || COPILOTKIT_VERSION !== runtimeClientGqlVersion || runtimeVersion !== runtimeClientGqlVersion) {
    return {
      runtimeVersion,
      runtimeClientGqlVersion,
      reactCoreVersion: COPILOTKIT_VERSION,
      message: getVersionMismatchErrorMessage({
        runtimeVersion,
        runtimeClientGqlVersion,
        reactCoreVersion: COPILOTKIT_VERSION
      })
    };
  }
  return;
}
var resolveLowLevelErrorMessage = ({ errorCode, url }) => {
  const troubleshootingLink = ERROR_CONFIG[
    "NETWORK_ERROR"
    /* NETWORK_ERROR */
  ].troubleshootingUrl;
  const genericMessage = (description = `Failed to fetch from url ${url}.`) => `${description}.

Possible reasons:
- -The server may have an error preventing it from returning a response (Check the server logs for more info).
- -The server might be down or unreachable
- -There might be a network issue (e.g., DNS failure, connection timeout) 
- -The URL might be incorrect
- -The server is not running on the specified port

${getSeeMoreMarkdown(troubleshootingLink)}`;
  if (url.includes("/info"))
    return genericMessage(`Failed to fetch CopilotKit agents/action information from url ${url}.`);
  if (url.includes("/actions/execute"))
    return genericMessage(`Fetch call to ${url} to execute actions failed.`);
  if (url.includes("/agents/state"))
    return genericMessage(`Fetch call to ${url} to get agent state failed.`);
  if (url.includes("/agents/execute"))
    return genericMessage(`Fetch call to ${url} to execute agent(s) failed.`);
  switch (errorCode) {
    case "ECONNREFUSED":
      return `Connection to ${url} was refused. Ensure the server is running and accessible.

${getSeeMoreMarkdown(troubleshootingLink)}`;
    case "ENOTFOUND":
      return `The server on ${url} could not be found. Check the URL or your network configuration.

${getSeeMoreMarkdown(ERROR_CONFIG[
        "NOT_FOUND"
        /* NOT_FOUND */
      ].troubleshootingUrl)}`;
    case "ETIMEDOUT":
      return `The connection to ${url} timed out. The server might be overloaded or taking too long to respond.

${getSeeMoreMarkdown(troubleshootingLink)}`;
    default:
      return;
  }
};

// node_modules/@copilotkit/shared/dist/chunk-6W2UEO2M.mjs
var ConsoleColors = {
  /** Primary brand blue - for titles and links */
  primary: "#007acc",
  /** Success green - for positive messaging */
  success: "#22c55e",
  /** Purple - for feature highlights */
  feature: "#a855f7",
  /** Red - for calls-to-action */
  cta: "#ef4444",
  /** Cyan - for closing statements */
  info: "#06b6d4",
  /** Inherit console default - for body text */
  inherit: "inherit",
  /** Warning style */
  warning: "#f59e0b"
};
var ConsoleStyles = {
  /** Large header style */
  header: `color: ${ConsoleColors.warning}; font-weight: bold; font-size: 16px;`,
  /** Section header style */
  section: `color: ${ConsoleColors.success}; font-weight: bold;`,
  /** Feature highlight style */
  highlight: `color: ${ConsoleColors.feature}; font-weight: bold;`,
  /** Call-to-action style */
  cta: `color: ${ConsoleColors.success}; font-weight: bold;`,
  /** Info style */
  info: `color: ${ConsoleColors.info}; font-weight: bold;`,
  /** Link style */
  link: `color: ${ConsoleColors.primary}; text-decoration: underline;`,
  /** Body text - inherits console theme */
  body: `color: ${ConsoleColors.inherit};`,
  /** Warning style */
  warning: `color: ${ConsoleColors.cta}; font-weight: bold;`
};
function logCopilotKitPlatformMessage() {
  console.log(
    `%cCopilotKit Warning%c

useCopilotChatHeadless_c provides full compatibility with CopilotKit's newly released Headless UI feature set. To enable this premium feature, add your public license key, available for free at:

%chttps://cloud.copilotkit.ai%c

Alternatively, useCopilotChat is available for basic programmatic control, and does not require an API key.

To learn more about premium features, read the documentation here:

%chttps://docs.copilotkit.ai/premium%c`,
    ConsoleStyles.header,
    ConsoleStyles.body,
    ConsoleStyles.cta,
    ConsoleStyles.body,
    ConsoleStyles.link,
    ConsoleStyles.body
  );
}
function publicApiKeyRequired(feature) {
  console.log(
    `
%cCopilotKit Warning%c 

In order to use ${feature}, you need to add your CopilotKit API key, available for free at https://cloud.copilotkit.ai.
    `.trim(),
    ConsoleStyles.header,
    ConsoleStyles.body
  );
}
function logStyled(template, styles) {
  console.log(template, ...styles);
}
var styledConsole = {
  /** Log a success message */
  success: (message2) => logStyled(`%c ${message2}`, [ConsoleStyles.section]),
  /** Log an info message */
  info: (message2) => logStyled(`%c ${message2}`, [ConsoleStyles.info]),
  /** Log a feature highlight */
  feature: (message2) => logStyled(`%c ${message2}`, [ConsoleStyles.highlight]),
  /** Log a call-to-action */
  cta: (message2) => logStyled(`%c ${message2}`, [ConsoleStyles.cta]),
  /** Log the CopilotKit platform promotion */
  logCopilotKitPlatformMessage,
  /** Log a `publicApiKeyRequired` warning */
  publicApiKeyRequired
};

// node_modules/@copilotkit/shared/dist/chunk-2KQ6HEWZ.mjs
function actionParametersToJsonSchema(actionParameters) {
  let parameters = {};
  for (let parameter of actionParameters || []) {
    parameters[parameter.name] = convertAttribute(parameter);
  }
  let requiredParameterNames = [];
  for (let arg of actionParameters || []) {
    if (arg.required !== false) {
      requiredParameterNames.push(arg.name);
    }
  }
  return {
    type: "object",
    properties: parameters,
    required: requiredParameterNames
  };
}
function convertAttribute(attribute) {
  var _a2, _b2, _c;
  switch (attribute.type) {
    case "string":
      return {
        type: "string",
        description: attribute.description,
        ...attribute.enum && { enum: attribute.enum }
      };
    case "number":
    case "boolean":
      return {
        type: attribute.type,
        description: attribute.description
      };
    case "object":
    case "object[]":
      const properties = (_a2 = attribute.attributes) == null ? void 0 : _a2.reduce(
        (acc, attr) => {
          acc[attr.name] = convertAttribute(attr);
          return acc;
        },
        {}
      );
      const required = (_b2 = attribute.attributes) == null ? void 0 : _b2.filter((attr) => attr.required !== false).map((attr) => attr.name);
      if (attribute.type === "object[]") {
        return {
          type: "array",
          items: {
            type: "object",
            ...properties && { properties },
            ...required && required.length > 0 && { required }
          },
          description: attribute.description
        };
      }
      return {
        type: "object",
        description: attribute.description,
        ...properties && { properties },
        ...required && required.length > 0 && { required }
      };
    default:
      if ((_c = attribute.type) == null ? void 0 : _c.endsWith("[]")) {
        const itemType = attribute.type.slice(0, -2);
        return {
          type: "array",
          items: { type: itemType },
          description: attribute.description
        };
      }
      return {
        type: "string",
        description: attribute.description
      };
  }
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate2(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate2;

// node_modules/uuid/dist/esm-browser/parse.js
function parse2(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v2;
  var arr = new Uint8Array(16);
  arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v2 >>> 16 & 255;
  arr[2] = v2 >>> 8 & 255;
  arr[3] = v2 & 255;
  arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v2 & 255;
  arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v2 & 255;
  arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v2 & 255;
  arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v2 / 4294967296 & 255;
  arr[12] = v2 >>> 24 & 255;
  arr[13] = v2 >>> 16 & 255;
  arr[14] = v2 >>> 8 & 255;
  arr[15] = v2 & 255;
  return arr;
}
var parse_default = parse2;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i3 = 0; i3 < 256; ++i3) {
  byteToHex.push((i3 + 256).toString(16).slice(1));
}
var i3;
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i3 = 0; i3 < str.length; ++i3) {
    bytes.push(str.charCodeAt(i3));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name2, version5, hashfunc) {
  function generateUUID(value2, namespace, buf, offset) {
    var _namespace;
    if (typeof value2 === "string") {
      value2 = stringToBytes(value2);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value2.length);
    bytes.set(namespace);
    bytes.set(value2, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version5;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i3 = 0; i3 < 16; ++i3) {
        buf[offset + i3] = bytes[i3];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name2;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i3 = 0; i3 < msg.length; ++i3) {
      bytes[i3] = msg.charCodeAt(i3);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i3 = 0; i3 < length32; i3 += 8) {
    var x = input[i3 >> 5] >>> i3 % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a2 = 1732584193;
  var b = -271733879;
  var c2 = -1732584194;
  var d3 = 271733878;
  for (var i3 = 0; i3 < x.length; i3 += 16) {
    var olda = a2;
    var oldb = b;
    var oldc = c2;
    var oldd = d3;
    a2 = md5ff(a2, b, c2, d3, x[i3], 7, -680876936);
    d3 = md5ff(d3, a2, b, c2, x[i3 + 1], 12, -389564586);
    c2 = md5ff(c2, d3, a2, b, x[i3 + 2], 17, 606105819);
    b = md5ff(b, c2, d3, a2, x[i3 + 3], 22, -1044525330);
    a2 = md5ff(a2, b, c2, d3, x[i3 + 4], 7, -176418897);
    d3 = md5ff(d3, a2, b, c2, x[i3 + 5], 12, 1200080426);
    c2 = md5ff(c2, d3, a2, b, x[i3 + 6], 17, -1473231341);
    b = md5ff(b, c2, d3, a2, x[i3 + 7], 22, -45705983);
    a2 = md5ff(a2, b, c2, d3, x[i3 + 8], 7, 1770035416);
    d3 = md5ff(d3, a2, b, c2, x[i3 + 9], 12, -1958414417);
    c2 = md5ff(c2, d3, a2, b, x[i3 + 10], 17, -42063);
    b = md5ff(b, c2, d3, a2, x[i3 + 11], 22, -1990404162);
    a2 = md5ff(a2, b, c2, d3, x[i3 + 12], 7, 1804603682);
    d3 = md5ff(d3, a2, b, c2, x[i3 + 13], 12, -40341101);
    c2 = md5ff(c2, d3, a2, b, x[i3 + 14], 17, -1502002290);
    b = md5ff(b, c2, d3, a2, x[i3 + 15], 22, 1236535329);
    a2 = md5gg(a2, b, c2, d3, x[i3 + 1], 5, -165796510);
    d3 = md5gg(d3, a2, b, c2, x[i3 + 6], 9, -1069501632);
    c2 = md5gg(c2, d3, a2, b, x[i3 + 11], 14, 643717713);
    b = md5gg(b, c2, d3, a2, x[i3], 20, -373897302);
    a2 = md5gg(a2, b, c2, d3, x[i3 + 5], 5, -701558691);
    d3 = md5gg(d3, a2, b, c2, x[i3 + 10], 9, 38016083);
    c2 = md5gg(c2, d3, a2, b, x[i3 + 15], 14, -660478335);
    b = md5gg(b, c2, d3, a2, x[i3 + 4], 20, -405537848);
    a2 = md5gg(a2, b, c2, d3, x[i3 + 9], 5, 568446438);
    d3 = md5gg(d3, a2, b, c2, x[i3 + 14], 9, -1019803690);
    c2 = md5gg(c2, d3, a2, b, x[i3 + 3], 14, -187363961);
    b = md5gg(b, c2, d3, a2, x[i3 + 8], 20, 1163531501);
    a2 = md5gg(a2, b, c2, d3, x[i3 + 13], 5, -1444681467);
    d3 = md5gg(d3, a2, b, c2, x[i3 + 2], 9, -51403784);
    c2 = md5gg(c2, d3, a2, b, x[i3 + 7], 14, 1735328473);
    b = md5gg(b, c2, d3, a2, x[i3 + 12], 20, -1926607734);
    a2 = md5hh(a2, b, c2, d3, x[i3 + 5], 4, -378558);
    d3 = md5hh(d3, a2, b, c2, x[i3 + 8], 11, -2022574463);
    c2 = md5hh(c2, d3, a2, b, x[i3 + 11], 16, 1839030562);
    b = md5hh(b, c2, d3, a2, x[i3 + 14], 23, -35309556);
    a2 = md5hh(a2, b, c2, d3, x[i3 + 1], 4, -1530992060);
    d3 = md5hh(d3, a2, b, c2, x[i3 + 4], 11, 1272893353);
    c2 = md5hh(c2, d3, a2, b, x[i3 + 7], 16, -155497632);
    b = md5hh(b, c2, d3, a2, x[i3 + 10], 23, -1094730640);
    a2 = md5hh(a2, b, c2, d3, x[i3 + 13], 4, 681279174);
    d3 = md5hh(d3, a2, b, c2, x[i3], 11, -358537222);
    c2 = md5hh(c2, d3, a2, b, x[i3 + 3], 16, -722521979);
    b = md5hh(b, c2, d3, a2, x[i3 + 6], 23, 76029189);
    a2 = md5hh(a2, b, c2, d3, x[i3 + 9], 4, -640364487);
    d3 = md5hh(d3, a2, b, c2, x[i3 + 12], 11, -421815835);
    c2 = md5hh(c2, d3, a2, b, x[i3 + 15], 16, 530742520);
    b = md5hh(b, c2, d3, a2, x[i3 + 2], 23, -995338651);
    a2 = md5ii(a2, b, c2, d3, x[i3], 6, -198630844);
    d3 = md5ii(d3, a2, b, c2, x[i3 + 7], 10, 1126891415);
    c2 = md5ii(c2, d3, a2, b, x[i3 + 14], 15, -1416354905);
    b = md5ii(b, c2, d3, a2, x[i3 + 5], 21, -57434055);
    a2 = md5ii(a2, b, c2, d3, x[i3 + 12], 6, 1700485571);
    d3 = md5ii(d3, a2, b, c2, x[i3 + 3], 10, -1894986606);
    c2 = md5ii(c2, d3, a2, b, x[i3 + 10], 15, -1051523);
    b = md5ii(b, c2, d3, a2, x[i3 + 1], 21, -2054922799);
    a2 = md5ii(a2, b, c2, d3, x[i3 + 8], 6, 1873313359);
    d3 = md5ii(d3, a2, b, c2, x[i3 + 15], 10, -30611744);
    c2 = md5ii(c2, d3, a2, b, x[i3 + 6], 15, -1560198380);
    b = md5ii(b, c2, d3, a2, x[i3 + 13], 21, 1309151649);
    a2 = md5ii(a2, b, c2, d3, x[i3 + 4], 6, -145523070);
    d3 = md5ii(d3, a2, b, c2, x[i3 + 11], 10, -1120210379);
    c2 = md5ii(c2, d3, a2, b, x[i3 + 2], 15, 718787259);
    b = md5ii(b, c2, d3, a2, x[i3 + 9], 21, -343485551);
    a2 = safeAdd(a2, olda);
    b = safeAdd(b, oldb);
    c2 = safeAdd(c2, oldc);
    d3 = safeAdd(d3, oldd);
  }
  return [a2, b, c2, d3];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i3 = 0; i3 < length8; i3 += 8) {
    output[i3 >> 5] |= (input[i3 / 8] & 255) << i3 % 32;
  }
  return output;
}
function safeAdd(x, y2) {
  var lsw = (x & 65535) + (y2 & 65535);
  var msw = (x >> 16) + (y2 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a2, b, x, s, t2) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q), safeAdd(x, t2)), s), b);
}
function md5ff(a2, b, c2, d3, x, s, t2) {
  return md5cmn(b & c2 | ~b & d3, a2, b, x, s, t2);
}
function md5gg(a2, b, c2, d3, x, s, t2) {
  return md5cmn(b & d3 | c2 & ~d3, a2, b, x, s, t2);
}
function md5hh(a2, b, c2, d3, x, s, t2) {
  return md5cmn(b ^ c2 ^ d3, a2, b, x, s, t2);
}
function md5ii(a2, b, c2, d3, x, s, t2) {
  return md5cmn(c2 ^ (b | ~d3), a2, b, x, s, t2);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i3 = 0; i3 < 16; ++i3) {
      buf[offset + i3] = rnds[i3];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y2, z) {
  switch (s) {
    case 0:
      return x & y2 ^ ~x & z;
    case 1:
      return x ^ y2 ^ z;
    case 2:
      return x & y2 ^ x & z ^ y2 & z;
    case 3:
      return x ^ y2 ^ z;
  }
}
function ROTL(x, n2) {
  return x << n2 | x >>> 32 - n2;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i3 = 0; i3 < msg.length; ++i3) {
      bytes.push(msg.charCodeAt(i3));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l2 = bytes.length / 4 + 2;
  var N = Math.ceil(l2 / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t2 = 0; t2 < 16; ++t2) {
      W[t2] = M[_i2][t2];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a2 = H[0];
    var b = H[1];
    var c2 = H[2];
    var d3 = H[3];
    var e3 = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a2, 5) + f(s, b, c2, d3) + e3 + K[s] + W[_t2] >>> 0;
      e3 = d3;
      d3 = c2;
      c2 = ROTL(b, 30) >>> 0;
      b = a2;
      a2 = T;
    }
    H[0] = H[0] + a2 >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c2 >>> 0;
    H[3] = H[3] + d3 >>> 0;
    H[4] = H[4] + e3 >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);
var v5_default = v5;

// node_modules/@copilotkit/shared/dist/chunk-VNNKZIFB.mjs
function randomId() {
  return "ck-" + v4_default();
}
function randomUUID2() {
  return v4_default();
}
function dataToUUID(input, namespace) {
  const BASE_NAMESPACE = "e4b01160-ff74-4c6e-9b27-d53cd930fe8e";
  const boundNamespace = namespace ? v5_default(namespace, BASE_NAMESPACE) : BASE_NAMESPACE;
  return v5_default(input, boundNamespace);
}

// node_modules/@copilotkit/shared/dist/chunk-GYZIHHE6.mjs
var COPILOT_CLOUD_API_URL = "https://api.cloud.copilotkit.ai";
var COPILOT_CLOUD_VERSION = "v1";
var COPILOT_CLOUD_CHAT_URL = `${COPILOT_CLOUD_API_URL}/copilotkit/${COPILOT_CLOUD_VERSION}`;
var COPILOT_CLOUD_PUBLIC_API_KEY_HEADER = "X-CopilotCloud-Public-Api-Key";

// node_modules/@copilotkit/shared/dist/chunk-6QGXWNS5.mjs
var import_chalk = __toESM(require_source(), 1);

// node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d3, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
    d4.__proto__ = b2;
  } || function(d4, b2) {
    for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d4[p2] = b2[p2];
  };
  return extendStatics(d3, b);
};
function __extends(d3, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d3, b);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
      s = arguments[i3];
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2)) t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e3) {
  var t2 = {};
  for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e3.indexOf(p2) < 0)
    t2[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s); i3 < p2.length; i3++) {
      if (e3.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i3]))
        t2[p2[i3]] = s[p2[i3]];
    }
  return t2;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f3, y2, t2, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f3) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f3 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
      if (y2 = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t2[1]) {
            _.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _.label < t2[2]) {
            _.label = t2[2];
            _.ops.push(op);
            break;
          }
          if (t2[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e3) {
      op = [6, e3];
      y2 = 0;
    } finally {
      f3 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i3 = 0, l2 = from.length, ar; i3 < l2; i3++) {
    if (ar || !(i3 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i3);
      ar[i3] = from[i3];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/dset/dist/index.mjs
function dset(obj, keys2, val) {
  keys2.split && (keys2 = keys2.split("."));
  var i3 = 0, l2 = keys2.length, t2 = obj, x, k;
  while (i3 < l2) {
    k = "" + keys2[i3++];
    if (k === "__proto__" || k === "constructor" || k === "prototype") break;
    t2 = t2[k] = i3 === l2 ? val : typeof (x = t2[k]) === typeof keys2 ? x : keys2[i3] * 0 !== 0 || !!~("" + keys2[i3]).indexOf(".") ? {} : [];
  }
}

// node_modules/@segment/analytics-core/dist/esm/utils/pick.js
var pickBy = function(obj, fn) {
  return Object.keys(obj).filter(function(k) {
    return fn(k, obj[k]);
  }).reduce(function(acc, key) {
    return acc[key] = obj[key], acc;
  }, {});
};

// node_modules/@segment/analytics-core/dist/esm/validation/errors.js
var ValidationError = (
  /** @class */
  function(_super) {
    __extends(ValidationError2, _super);
    function ValidationError2(field, message2) {
      var _this = _super.call(this, "".concat(field, " ").concat(message2)) || this;
      _this.field = field;
      return _this;
    }
    return ValidationError2;
  }(Error)
);

// node_modules/@segment/analytics-core/dist/esm/validation/helpers.js
function isString(obj) {
  return typeof obj === "string";
}
function exists(val) {
  return val !== void 0 && val !== null;
}
function isPlainObject(obj) {
  return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase() === "object";
}

// node_modules/@segment/analytics-core/dist/esm/validation/assertions.js
var stringError = "is not a string";
var objError = "is not an object";
var nilError = "is nil";
function assertEventExists(event) {
  if (!exists(event)) {
    throw new ValidationError("Event", nilError);
  }
  if (typeof event !== "object") {
    throw new ValidationError("Event", objError);
  }
}
function assertEventType(event) {
  if (!isString(event.type)) {
    throw new ValidationError(".type", stringError);
  }
}
function assertTrackEventName(event) {
  if (!isString(event.event)) {
    throw new ValidationError(".event", stringError);
  }
}
function assertTrackEventProperties(event) {
  if (!isPlainObject(event.properties)) {
    throw new ValidationError(".properties", objError);
  }
}
function assertTraits(event) {
  if (!isPlainObject(event.traits)) {
    throw new ValidationError(".traits", objError);
  }
}
function assertMessageId(event) {
  if (!isString(event.messageId)) {
    throw new ValidationError(".messageId", stringError);
  }
}
function validateEvent(event) {
  assertEventExists(event);
  assertEventType(event);
  assertMessageId(event);
  if (event.type === "track") {
    assertTrackEventName(event);
    assertTrackEventProperties(event);
  }
  if (["group", "identify"].includes(event.type)) {
    assertTraits(event);
  }
}

// node_modules/@segment/analytics-core/dist/esm/events/index.js
var InternalEventFactorySettings = (
  /** @class */
  /* @__PURE__ */ function() {
    function InternalEventFactorySettings2(settings) {
      var _a2, _b2;
      this.settings = settings;
      this.createMessageId = settings.createMessageId;
      this.onEventMethodCall = (_a2 = settings.onEventMethodCall) !== null && _a2 !== void 0 ? _a2 : function() {
      };
      this.onFinishedEvent = (_b2 = settings.onFinishedEvent) !== null && _b2 !== void 0 ? _b2 : function() {
      };
    }
    return InternalEventFactorySettings2;
  }()
);
var CoreEventFactory = (
  /** @class */
  function() {
    function CoreEventFactory2(settings) {
      this.settings = new InternalEventFactorySettings(settings);
    }
    CoreEventFactory2.prototype.track = function(event, properties, options, integrationOptions) {
      this.settings.onEventMethodCall({ type: "track", options });
      return this.normalize(__assign(__assign({}, this.baseEvent()), { event, type: "track", properties: properties !== null && properties !== void 0 ? properties : {}, options: __assign({}, options), integrations: __assign({}, integrationOptions) }));
    };
    CoreEventFactory2.prototype.page = function(category, page, properties, options, integrationOptions) {
      var _a2;
      this.settings.onEventMethodCall({ type: "page", options });
      var event = {
        type: "page",
        properties: __assign({}, properties),
        options: __assign({}, options),
        integrations: __assign({}, integrationOptions)
      };
      if (category !== null) {
        event.category = category;
        event.properties = (_a2 = event.properties) !== null && _a2 !== void 0 ? _a2 : {};
        event.properties.category = category;
      }
      if (page !== null) {
        event.name = page;
      }
      return this.normalize(__assign(__assign({}, this.baseEvent()), event));
    };
    CoreEventFactory2.prototype.screen = function(category, screen, properties, options, integrationOptions) {
      this.settings.onEventMethodCall({ type: "screen", options });
      var event = {
        type: "screen",
        properties: __assign({}, properties),
        options: __assign({}, options),
        integrations: __assign({}, integrationOptions)
      };
      if (category !== null) {
        event.category = category;
      }
      if (screen !== null) {
        event.name = screen;
      }
      return this.normalize(__assign(__assign({}, this.baseEvent()), event));
    };
    CoreEventFactory2.prototype.identify = function(userId, traits, options, integrationsOptions) {
      this.settings.onEventMethodCall({ type: "identify", options });
      return this.normalize(__assign(__assign({}, this.baseEvent()), { type: "identify", userId, traits: traits !== null && traits !== void 0 ? traits : {}, options: __assign({}, options), integrations: integrationsOptions }));
    };
    CoreEventFactory2.prototype.group = function(groupId, traits, options, integrationOptions) {
      this.settings.onEventMethodCall({ type: "group", options });
      return this.normalize(__assign(__assign({}, this.baseEvent()), {
        type: "group",
        traits: traits !== null && traits !== void 0 ? traits : {},
        options: __assign({}, options),
        integrations: __assign({}, integrationOptions),
        //
        groupId
      }));
    };
    CoreEventFactory2.prototype.alias = function(to, from, options, integrationOptions) {
      this.settings.onEventMethodCall({ type: "alias", options });
      var base2 = {
        userId: to,
        type: "alias",
        options: __assign({}, options),
        integrations: __assign({}, integrationOptions)
      };
      if (from !== null) {
        base2.previousId = from;
      }
      if (to === void 0) {
        return this.normalize(__assign(__assign({}, base2), this.baseEvent()));
      }
      return this.normalize(__assign(__assign({}, this.baseEvent()), base2));
    };
    CoreEventFactory2.prototype.baseEvent = function() {
      return {
        integrations: {},
        options: {}
      };
    };
    CoreEventFactory2.prototype.context = function(options) {
      var _a2;
      var eventOverrideKeys = [
        "userId",
        "anonymousId",
        "timestamp",
        "messageId"
      ];
      delete options["integrations"];
      var providedOptionsKeys = Object.keys(options);
      var context = (_a2 = options.context) !== null && _a2 !== void 0 ? _a2 : {};
      var eventOverrides = {};
      providedOptionsKeys.forEach(function(key) {
        if (key === "context") {
          return;
        }
        if (eventOverrideKeys.includes(key)) {
          dset(eventOverrides, key, options[key]);
        } else {
          dset(context, key, options[key]);
        }
      });
      return [context, eventOverrides];
    };
    CoreEventFactory2.prototype.normalize = function(event) {
      var _a2, _b2;
      var integrationBooleans = Object.keys((_a2 = event.integrations) !== null && _a2 !== void 0 ? _a2 : {}).reduce(function(integrationNames, name2) {
        var _a3;
        var _b3;
        return __assign(__assign({}, integrationNames), (_a3 = {}, _a3[name2] = Boolean((_b3 = event.integrations) === null || _b3 === void 0 ? void 0 : _b3[name2]), _a3));
      }, {});
      event.options = pickBy(event.options || {}, function(_, value2) {
        return value2 !== void 0;
      });
      var allIntegrations = __assign(__assign({}, integrationBooleans), (_b2 = event.options) === null || _b2 === void 0 ? void 0 : _b2.integrations);
      var _c = event.options ? this.context(event.options) : [], context = _c[0], overrides = _c[1];
      var options = event.options, rest = __rest(event, ["options"]);
      var evt = __assign(__assign(__assign(__assign({ timestamp: /* @__PURE__ */ new Date() }, rest), { context, integrations: allIntegrations }), overrides), { messageId: options.messageId || this.settings.createMessageId() });
      this.settings.onFinishedEvent(evt);
      validateEvent(evt);
      return evt;
    };
    return CoreEventFactory2;
  }()
);

// node_modules/@segment/analytics-generic-utils/dist/esm/emitter/emitter.js
var Emitter = (
  /** @class */
  function() {
    function Emitter2(options) {
      var _a2;
      this.callbacks = {};
      this.warned = false;
      this.maxListeners = (_a2 = options === null || options === void 0 ? void 0 : options.maxListeners) !== null && _a2 !== void 0 ? _a2 : 10;
    }
    Emitter2.prototype.warnIfPossibleMemoryLeak = function(event) {
      if (this.warned) {
        return;
      }
      if (this.maxListeners && this.callbacks[event].length > this.maxListeners) {
        console.warn("Event Emitter: Possible memory leak detected; ".concat(String(event), " has exceeded ").concat(this.maxListeners, " listeners."));
        this.warned = true;
      }
    };
    Emitter2.prototype.on = function(event, callback) {
      if (!this.callbacks[event]) {
        this.callbacks[event] = [callback];
      } else {
        this.callbacks[event].push(callback);
        this.warnIfPossibleMemoryLeak(event);
      }
      return this;
    };
    Emitter2.prototype.once = function(event, callback) {
      var _this = this;
      var on = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        _this.off(event, on);
        callback.apply(_this, args);
      };
      this.on(event, on);
      return this;
    };
    Emitter2.prototype.off = function(event, callback) {
      var _a2;
      var fns = (_a2 = this.callbacks[event]) !== null && _a2 !== void 0 ? _a2 : [];
      var without = fns.filter(function(fn) {
        return fn !== callback;
      });
      this.callbacks[event] = without;
      return this;
    };
    Emitter2.prototype.emit = function(event) {
      var _this = this;
      var _a2;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var callbacks = (_a2 = this.callbacks[event]) !== null && _a2 !== void 0 ? _a2 : [];
      callbacks.forEach(function(callback) {
        callback.apply(_this, args);
      });
      return this;
    };
    return Emitter2;
  }()
);

// node_modules/@segment/analytics-core/dist/esm/priority-queue/backoff.js
function backoff(params) {
  var random = Math.random() + 1;
  var _a2 = params.minTimeout, minTimeout = _a2 === void 0 ? 500 : _a2, _b2 = params.factor, factor = _b2 === void 0 ? 2 : _b2, attempt2 = params.attempt, _c = params.maxTimeout, maxTimeout = _c === void 0 ? Infinity : _c;
  return Math.min(random * minTimeout * Math.pow(factor, attempt2), maxTimeout);
}

// node_modules/@segment/analytics-core/dist/esm/priority-queue/index.js
var ON_REMOVE_FROM_FUTURE = "onRemoveFromFuture";
var PriorityQueue = (
  /** @class */
  function(_super) {
    __extends(PriorityQueue2, _super);
    function PriorityQueue2(maxAttempts, queue, seen) {
      var _this = _super.call(this) || this;
      _this.future = [];
      _this.maxAttempts = maxAttempts;
      _this.queue = queue;
      _this.seen = seen !== null && seen !== void 0 ? seen : {};
      return _this;
    }
    PriorityQueue2.prototype.push = function() {
      var _this = this;
      var items = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        items[_i] = arguments[_i];
      }
      var accepted = items.map(function(operation) {
        var attempts = _this.updateAttempts(operation);
        if (attempts > _this.maxAttempts || _this.includes(operation)) {
          return false;
        }
        _this.queue.push(operation);
        return true;
      });
      this.queue = this.queue.sort(function(a2, b) {
        return _this.getAttempts(a2) - _this.getAttempts(b);
      });
      return accepted;
    };
    PriorityQueue2.prototype.pushWithBackoff = function(item, minTimeout) {
      var _this = this;
      if (minTimeout === void 0) {
        minTimeout = 0;
      }
      if (minTimeout == 0 && this.getAttempts(item) === 0) {
        return this.push(item)[0];
      }
      var attempt2 = this.updateAttempts(item);
      if (attempt2 > this.maxAttempts || this.includes(item)) {
        return false;
      }
      var timeout = backoff({ attempt: attempt2 - 1 });
      if (minTimeout > 0 && timeout < minTimeout) {
        timeout = minTimeout;
      }
      setTimeout(function() {
        _this.queue.push(item);
        _this.future = _this.future.filter(function(f3) {
          return f3.id !== item.id;
        });
        _this.emit(ON_REMOVE_FROM_FUTURE);
      }, timeout);
      this.future.push(item);
      return true;
    };
    PriorityQueue2.prototype.getAttempts = function(item) {
      var _a2;
      return (_a2 = this.seen[item.id]) !== null && _a2 !== void 0 ? _a2 : 0;
    };
    PriorityQueue2.prototype.updateAttempts = function(item) {
      this.seen[item.id] = this.getAttempts(item) + 1;
      return this.getAttempts(item);
    };
    PriorityQueue2.prototype.includes = function(item) {
      return this.queue.includes(item) || this.future.includes(item) || Boolean(this.queue.find(function(i3) {
        return i3.id === item.id;
      })) || Boolean(this.future.find(function(i3) {
        return i3.id === item.id;
      }));
    };
    PriorityQueue2.prototype.pop = function() {
      return this.queue.shift();
    };
    Object.defineProperty(PriorityQueue2.prototype, "length", {
      get: function() {
        return this.queue.length;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PriorityQueue2.prototype, "todo", {
      get: function() {
        return this.queue.length + this.future.length;
      },
      enumerable: false,
      configurable: true
    });
    return PriorityQueue2;
  }(Emitter)
);

// node_modules/@lukeed/uuid/dist/index.mjs
var IDX = 256;
var HEX = [];
var BUFFER;
while (IDX--) HEX[IDX] = (IDX + 256).toString(16).substring(1);
function v42() {
  var i3 = 0, num, out = "";
  if (!BUFFER || IDX + 16 > 256) {
    BUFFER = Array(i3 = 256);
    while (i3--) BUFFER[i3] = 256 * Math.random() | 0;
    i3 = IDX = 0;
  }
  for (; i3 < 16; i3++) {
    num = BUFFER[IDX + i3];
    if (i3 == 6) out += HEX[num & 15 | 64];
    else if (i3 == 8) out += HEX[num & 63 | 128];
    else out += HEX[num];
    if (i3 & 1 && i3 > 1 && i3 < 11) out += "-";
  }
  IDX++;
  return out;
}

// node_modules/@segment/analytics-core/dist/esm/logger/index.js
var CoreLogger = (
  /** @class */
  function() {
    function CoreLogger2() {
      this._logs = [];
    }
    CoreLogger2.prototype.log = function(level, message2, extras) {
      var time = /* @__PURE__ */ new Date();
      this._logs.push({
        level,
        message: message2,
        time,
        extras
      });
    };
    Object.defineProperty(CoreLogger2.prototype, "logs", {
      get: function() {
        return this._logs;
      },
      enumerable: false,
      configurable: true
    });
    CoreLogger2.prototype.flush = function() {
      if (this.logs.length > 1) {
        var formatted = this._logs.reduce(function(logs, log) {
          var _a2;
          var _b2, _c;
          var line2 = __assign(__assign({}, log), { json: JSON.stringify(log.extras, null, " "), extras: log.extras });
          delete line2["time"];
          var key = (_c = (_b2 = log.time) === null || _b2 === void 0 ? void 0 : _b2.toISOString()) !== null && _c !== void 0 ? _c : "";
          if (logs[key]) {
            key = "".concat(key, "-").concat(Math.random());
          }
          return __assign(__assign({}, logs), (_a2 = {}, _a2[key] = line2, _a2));
        }, {});
        if (console.table) {
          console.table(formatted);
        } else {
          console.log(formatted);
        }
      } else {
        this.logs.forEach(function(logEntry) {
          var level = logEntry.level, message2 = logEntry.message, extras = logEntry.extras;
          if (level === "info" || level === "debug") {
            console.log(message2, extras !== null && extras !== void 0 ? extras : "");
          } else {
            console[level](message2, extras !== null && extras !== void 0 ? extras : "");
          }
        });
      }
      this._logs = [];
    };
    return CoreLogger2;
  }()
);

// node_modules/@segment/analytics-core/dist/esm/stats/index.js
var compactMetricType = function(type2) {
  var enums = {
    gauge: "g",
    counter: "c"
  };
  return enums[type2];
};
var CoreStats = (
  /** @class */
  function() {
    function CoreStats2() {
      this.metrics = [];
    }
    CoreStats2.prototype.increment = function(metric, by, tags) {
      if (by === void 0) {
        by = 1;
      }
      this.metrics.push({
        metric,
        value: by,
        tags: tags !== null && tags !== void 0 ? tags : [],
        type: "counter",
        timestamp: Date.now()
      });
    };
    CoreStats2.prototype.gauge = function(metric, value2, tags) {
      this.metrics.push({
        metric,
        value: value2,
        tags: tags !== null && tags !== void 0 ? tags : [],
        type: "gauge",
        timestamp: Date.now()
      });
    };
    CoreStats2.prototype.flush = function() {
      var formatted = this.metrics.map(function(m) {
        return __assign(__assign({}, m), { tags: m.tags.join(",") });
      });
      if (console.table) {
        console.table(formatted);
      } else {
        console.log(formatted);
      }
      this.metrics = [];
    };
    CoreStats2.prototype.serialize = function() {
      return this.metrics.map(function(m) {
        return {
          m: m.metric,
          v: m.value,
          t: m.tags,
          k: compactMetricType(m.type),
          e: m.timestamp
        };
      });
    };
    return CoreStats2;
  }()
);
var NullStats = (
  /** @class */
  function(_super) {
    __extends(NullStats2, _super);
    function NullStats2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NullStats2.prototype.gauge = function() {
      var _args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        _args[_i] = arguments[_i];
      }
    };
    NullStats2.prototype.increment = function() {
      var _args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        _args[_i] = arguments[_i];
      }
    };
    NullStats2.prototype.flush = function() {
      var _args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        _args[_i] = arguments[_i];
      }
    };
    NullStats2.prototype.serialize = function() {
      var _args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        _args[_i] = arguments[_i];
      }
      return [];
    };
    return NullStats2;
  }(CoreStats)
);

// node_modules/@segment/analytics-core/dist/esm/context/index.js
var ContextCancelation = (
  /** @class */
  /* @__PURE__ */ function() {
    function ContextCancelation2(options) {
      var _a2, _b2, _c;
      this.retry = (_a2 = options.retry) !== null && _a2 !== void 0 ? _a2 : true;
      this.type = (_b2 = options.type) !== null && _b2 !== void 0 ? _b2 : "plugin Error";
      this.reason = (_c = options.reason) !== null && _c !== void 0 ? _c : "";
    }
    return ContextCancelation2;
  }()
);
var CoreContext = (
  /** @class */
  function() {
    function CoreContext2(event, id, stats, logger) {
      if (id === void 0) {
        id = v42();
      }
      if (stats === void 0) {
        stats = new NullStats();
      }
      if (logger === void 0) {
        logger = new CoreLogger();
      }
      this.attempts = 0;
      this.event = event;
      this._id = id;
      this.logger = logger;
      this.stats = stats;
    }
    CoreContext2.system = function() {
    };
    CoreContext2.prototype.isSame = function(other) {
      return other.id === this.id;
    };
    CoreContext2.prototype.cancel = function(error2) {
      if (error2) {
        throw error2;
      }
      throw new ContextCancelation({ reason: "Context Cancel" });
    };
    CoreContext2.prototype.log = function(level, message2, extras) {
      this.logger.log(level, message2, extras);
    };
    Object.defineProperty(CoreContext2.prototype, "id", {
      get: function() {
        return this._id;
      },
      enumerable: false,
      configurable: true
    });
    CoreContext2.prototype.updateEvent = function(path2, val) {
      var _a2;
      if (path2.split(".")[0] === "integrations") {
        var integrationName = path2.split(".")[1];
        if (((_a2 = this.event.integrations) === null || _a2 === void 0 ? void 0 : _a2[integrationName]) === false) {
          return this.event;
        }
      }
      dset(this.event, path2, val);
      return this.event;
    };
    CoreContext2.prototype.failedDelivery = function() {
      return this._failedDelivery;
    };
    CoreContext2.prototype.setFailedDelivery = function(options) {
      this._failedDelivery = options;
    };
    CoreContext2.prototype.logs = function() {
      return this.logger.logs;
    };
    CoreContext2.prototype.flush = function() {
      this.logger.flush();
      this.stats.flush();
    };
    CoreContext2.prototype.toJSON = function() {
      return {
        id: this._id,
        event: this.event,
        logs: this.logger.logs,
        metrics: this.stats.metrics
      };
    };
    return CoreContext2;
  }()
);

// node_modules/@segment/analytics-core/dist/esm/utils/group-by.js
function groupBy2(collection, grouper) {
  var results = {};
  collection.forEach(function(item) {
    var _a2;
    var key = void 0;
    if (typeof grouper === "string") {
      var suggestedKey = item[grouper];
      key = typeof suggestedKey !== "string" ? JSON.stringify(suggestedKey) : suggestedKey;
    } else if (grouper instanceof Function) {
      key = grouper(item);
    }
    if (key === void 0) {
      return;
    }
    results[key] = __spreadArray(__spreadArray([], (_a2 = results[key]) !== null && _a2 !== void 0 ? _a2 : [], true), [item], false);
  });
  return results;
}

// node_modules/@segment/analytics-core/dist/esm/utils/is-thenable.js
var isThenable = function(value2) {
  return typeof value2 === "object" && value2 !== null && "then" in value2 && typeof value2.then === "function";
};

// node_modules/@segment/analytics-core/dist/esm/task/task-group.js
var createTaskGroup = function() {
  var taskCompletionPromise;
  var resolvePromise;
  var count = 0;
  return {
    done: function() {
      return taskCompletionPromise;
    },
    run: function(op) {
      var returnValue = op();
      if (isThenable(returnValue)) {
        if (++count === 1) {
          taskCompletionPromise = new Promise(function(res) {
            return resolvePromise = res;
          });
        }
        returnValue.finally(function() {
          return --count === 0 && resolvePromise();
        });
      }
      return returnValue;
    }
  };
};

// node_modules/@segment/analytics-core/dist/esm/queue/delivery.js
function tryAsync(fn) {
  return __awaiter(this, void 0, void 0, function() {
    var err_1;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          _a2.trys.push([0, 2, , 3]);
          return [4, fn()];
        case 1:
          return [2, _a2.sent()];
        case 2:
          err_1 = _a2.sent();
          return [2, Promise.reject(err_1)];
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function attempt(ctx, plugin) {
  ctx.log("debug", "plugin", { plugin: plugin.name });
  var start2 = (/* @__PURE__ */ new Date()).getTime();
  var hook = plugin[ctx.event.type];
  if (hook === void 0) {
    return Promise.resolve(ctx);
  }
  var newCtx = tryAsync(function() {
    return hook.apply(plugin, [ctx]);
  }).then(function(ctx2) {
    var done = (/* @__PURE__ */ new Date()).getTime() - start2;
    ctx2.stats.gauge("plugin_time", done, ["plugin:".concat(plugin.name)]);
    return ctx2;
  }).catch(function(err) {
    if (err instanceof ContextCancelation && err.type === "middleware_cancellation") {
      throw err;
    }
    if (err instanceof ContextCancelation) {
      ctx.log("warn", err.type, {
        plugin: plugin.name,
        error: err
      });
      return err;
    }
    ctx.log("error", "plugin Error", {
      plugin: plugin.name,
      error: err
    });
    ctx.stats.increment("plugin_error", 1, ["plugin:".concat(plugin.name)]);
    return err;
  });
  return newCtx;
}
function ensure(ctx, plugin) {
  return attempt(ctx, plugin).then(function(newContext) {
    if (newContext instanceof CoreContext) {
      return newContext;
    }
    ctx.log("debug", "Context canceled");
    ctx.stats.increment("context_canceled");
    ctx.cancel(newContext);
  });
}

// node_modules/@segment/analytics-core/dist/esm/queue/event-queue.js
var CoreEventQueue = (
  /** @class */
  function(_super) {
    __extends(CoreEventQueue2, _super);
    function CoreEventQueue2(priorityQueue) {
      var _this = _super.call(this) || this;
      _this.criticalTasks = createTaskGroup();
      _this.plugins = [];
      _this.failedInitializations = [];
      _this.flushing = false;
      _this.queue = priorityQueue;
      _this.queue.on(ON_REMOVE_FROM_FUTURE, function() {
        _this.scheduleFlush(0);
      });
      return _this;
    }
    CoreEventQueue2.prototype.register = function(ctx, plugin, instance) {
      return __awaiter(this, void 0, void 0, function() {
        var handleLoadError, err_1;
        var _this = this;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              this.plugins.push(plugin);
              handleLoadError = function(err) {
                _this.failedInitializations.push(plugin.name);
                _this.emit("initialization_failure", plugin);
                console.warn(plugin.name, err);
                ctx.log("warn", "Failed to load destination", {
                  plugin: plugin.name,
                  error: err
                });
                _this.plugins = _this.plugins.filter(function(p2) {
                  return p2 !== plugin;
                });
              };
              if (!(plugin.type === "destination" && plugin.name !== "Segment.io")) return [3, 1];
              plugin.load(ctx, instance).catch(handleLoadError);
              return [3, 4];
            case 1:
              _a2.trys.push([1, 3, , 4]);
              return [4, plugin.load(ctx, instance)];
            case 2:
              _a2.sent();
              return [3, 4];
            case 3:
              err_1 = _a2.sent();
              handleLoadError(err_1);
              return [3, 4];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CoreEventQueue2.prototype.deregister = function(ctx, plugin, instance) {
      return __awaiter(this, void 0, void 0, function() {
        var e_1;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              _a2.trys.push([0, 3, , 4]);
              if (!plugin.unload) return [3, 2];
              return [4, Promise.resolve(plugin.unload(ctx, instance))];
            case 1:
              _a2.sent();
              _a2.label = 2;
            case 2:
              this.plugins = this.plugins.filter(function(p2) {
                return p2.name !== plugin.name;
              });
              return [3, 4];
            case 3:
              e_1 = _a2.sent();
              ctx.log("warn", "Failed to unload destination", {
                plugin: plugin.name,
                error: e_1
              });
              return [3, 4];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CoreEventQueue2.prototype.dispatch = function(ctx) {
      return __awaiter(this, void 0, void 0, function() {
        var willDeliver;
        return __generator(this, function(_a2) {
          ctx.log("debug", "Dispatching");
          ctx.stats.increment("message_dispatched");
          this.queue.push(ctx);
          willDeliver = this.subscribeToDelivery(ctx);
          this.scheduleFlush(0);
          return [2, willDeliver];
        });
      });
    };
    CoreEventQueue2.prototype.subscribeToDelivery = function(ctx) {
      return __awaiter(this, void 0, void 0, function() {
        var _this = this;
        return __generator(this, function(_a2) {
          return [2, new Promise(function(resolve) {
            var onDeliver = function(flushed, delivered) {
              if (flushed.isSame(ctx)) {
                _this.off("flush", onDeliver);
                if (delivered) {
                  resolve(flushed);
                } else {
                  resolve(flushed);
                }
              }
            };
            _this.on("flush", onDeliver);
          })];
        });
      });
    };
    CoreEventQueue2.prototype.dispatchSingle = function(ctx) {
      return __awaiter(this, void 0, void 0, function() {
        var _this = this;
        return __generator(this, function(_a2) {
          ctx.log("debug", "Dispatching");
          ctx.stats.increment("message_dispatched");
          this.queue.updateAttempts(ctx);
          ctx.attempts = 1;
          return [2, this.deliver(ctx).catch(function(err) {
            var accepted = _this.enqueuRetry(err, ctx);
            if (!accepted) {
              ctx.setFailedDelivery({ reason: err });
              return ctx;
            }
            return _this.subscribeToDelivery(ctx);
          })];
        });
      });
    };
    CoreEventQueue2.prototype.isEmpty = function() {
      return this.queue.length === 0;
    };
    CoreEventQueue2.prototype.scheduleFlush = function(timeout) {
      var _this = this;
      if (timeout === void 0) {
        timeout = 500;
      }
      if (this.flushing) {
        return;
      }
      this.flushing = true;
      setTimeout(function() {
        _this.flush().then(function() {
          setTimeout(function() {
            _this.flushing = false;
            if (_this.queue.length) {
              _this.scheduleFlush(0);
            }
          }, 0);
        });
      }, timeout);
    };
    CoreEventQueue2.prototype.deliver = function(ctx) {
      return __awaiter(this, void 0, void 0, function() {
        var start2, done, err_2, error2;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.criticalTasks.done()];
            case 1:
              _a2.sent();
              start2 = Date.now();
              _a2.label = 2;
            case 2:
              _a2.trys.push([2, 4, , 5]);
              return [4, this.flushOne(ctx)];
            case 3:
              ctx = _a2.sent();
              done = Date.now() - start2;
              this.emit("delivery_success", ctx);
              ctx.stats.gauge("delivered", done);
              ctx.log("debug", "Delivered", ctx.event);
              return [2, ctx];
            case 4:
              err_2 = _a2.sent();
              error2 = err_2;
              ctx.log("error", "Failed to deliver", error2);
              this.emit("delivery_failure", ctx, error2);
              ctx.stats.increment("delivery_failed");
              throw err_2;
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CoreEventQueue2.prototype.enqueuRetry = function(err, ctx) {
      var retriable = !(err instanceof ContextCancelation) || err.retry;
      if (!retriable) {
        return false;
      }
      return this.queue.pushWithBackoff(ctx);
    };
    CoreEventQueue2.prototype.flush = function() {
      return __awaiter(this, void 0, void 0, function() {
        var ctx, err_3, accepted;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (this.queue.length === 0) {
                return [2, []];
              }
              ctx = this.queue.pop();
              if (!ctx) {
                return [2, []];
              }
              ctx.attempts = this.queue.getAttempts(ctx);
              _a2.label = 1;
            case 1:
              _a2.trys.push([1, 3, , 4]);
              return [4, this.deliver(ctx)];
            case 2:
              ctx = _a2.sent();
              this.emit("flush", ctx, true);
              return [3, 4];
            case 3:
              err_3 = _a2.sent();
              accepted = this.enqueuRetry(err_3, ctx);
              if (!accepted) {
                ctx.setFailedDelivery({ reason: err_3 });
                this.emit("flush", ctx, false);
              }
              return [2, []];
            case 4:
              return [2, [ctx]];
          }
        });
      });
    };
    CoreEventQueue2.prototype.isReady = function() {
      return true;
    };
    CoreEventQueue2.prototype.availableExtensions = function(denyList) {
      var available = this.plugins.filter(function(p2) {
        var _a3, _b3, _c2;
        if (p2.type !== "destination" && p2.name !== "Segment.io") {
          return true;
        }
        var alternativeNameMatch = void 0;
        (_a3 = p2.alternativeNames) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(name2) {
          if (denyList[name2] !== void 0) {
            alternativeNameMatch = denyList[name2];
          }
        });
        return (_c2 = (_b3 = denyList[p2.name]) !== null && _b3 !== void 0 ? _b3 : alternativeNameMatch) !== null && _c2 !== void 0 ? _c2 : (p2.name === "Segment.io" ? true : denyList.All) !== false;
      });
      var _a2 = groupBy2(available, "type"), _b2 = _a2.before, before = _b2 === void 0 ? [] : _b2, _c = _a2.enrichment, enrichment = _c === void 0 ? [] : _c, _d = _a2.destination, destination = _d === void 0 ? [] : _d, _e = _a2.after, after = _e === void 0 ? [] : _e;
      return {
        before,
        enrichment,
        destinations: destination,
        after
      };
    };
    CoreEventQueue2.prototype.flushOne = function(ctx) {
      var _a2, _b2;
      return __awaiter(this, void 0, void 0, function() {
        var _c, before, enrichment, _i, before_1, beforeWare, temp, _d, enrichment_1, enrichmentWare, temp, _e, destinations, after, afterCalls;
        return __generator(this, function(_f) {
          switch (_f.label) {
            case 0:
              if (!this.isReady()) {
                throw new Error("Not ready");
              }
              if (ctx.attempts > 1) {
                this.emit("delivery_retry", ctx);
              }
              _c = this.availableExtensions((_a2 = ctx.event.integrations) !== null && _a2 !== void 0 ? _a2 : {}), before = _c.before, enrichment = _c.enrichment;
              _i = 0, before_1 = before;
              _f.label = 1;
            case 1:
              if (!(_i < before_1.length)) return [3, 4];
              beforeWare = before_1[_i];
              return [4, ensure(ctx, beforeWare)];
            case 2:
              temp = _f.sent();
              if (temp instanceof CoreContext) {
                ctx = temp;
              }
              this.emit("message_enriched", ctx, beforeWare);
              _f.label = 3;
            case 3:
              _i++;
              return [3, 1];
            case 4:
              _d = 0, enrichment_1 = enrichment;
              _f.label = 5;
            case 5:
              if (!(_d < enrichment_1.length)) return [3, 8];
              enrichmentWare = enrichment_1[_d];
              return [4, attempt(ctx, enrichmentWare)];
            case 6:
              temp = _f.sent();
              if (temp instanceof CoreContext) {
                ctx = temp;
              }
              this.emit("message_enriched", ctx, enrichmentWare);
              _f.label = 7;
            case 7:
              _d++;
              return [3, 5];
            case 8:
              _e = this.availableExtensions((_b2 = ctx.event.integrations) !== null && _b2 !== void 0 ? _b2 : {}), destinations = _e.destinations, after = _e.after;
              return [4, new Promise(function(resolve, reject) {
                setTimeout(function() {
                  var attempts = destinations.map(function(destination) {
                    return attempt(ctx, destination);
                  });
                  Promise.all(attempts).then(resolve).catch(reject);
                }, 0);
              })];
            case 9:
              _f.sent();
              ctx.stats.increment("message_delivered");
              this.emit("message_delivered", ctx);
              afterCalls = after.map(function(after2) {
                return attempt(ctx, after2);
              });
              return [4, Promise.all(afterCalls)];
            case 10:
              _f.sent();
              return [2, ctx];
          }
        });
      });
    };
    return CoreEventQueue2;
  }(Emitter)
);

// node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default = crypto;
var isCryptoKey = (key) => key instanceof CryptoKey;

// node_modules/jose/dist/browser/lib/buffer_utils.js
var encoder = new TextEncoder();
var decoder = new TextDecoder();
var MAX_INT32 = 2 ** 32;

// node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase64 = (input) => {
  let unencoded = input;
  if (typeof unencoded === "string") {
    unencoded = encoder.encode(unencoded);
  }
  const CHUNK_SIZE = 32768;
  const arr = [];
  for (let i3 = 0; i3 < unencoded.length; i3 += CHUNK_SIZE) {
    arr.push(String.fromCharCode.apply(null, unencoded.subarray(i3, i3 + CHUNK_SIZE)));
  }
  return btoa(arr.join(""));
};
var encode = (input) => {
  return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
};
var decodeBase64 = (encoded) => {
  const binary = atob(encoded);
  const bytes = new Uint8Array(binary.length);
  for (let i3 = 0; i3 < binary.length; i3++) {
    bytes[i3] = binary.charCodeAt(i3);
  }
  return bytes;
};
var decode = (input) => {
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return decodeBase64(encoded);
  } catch {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
};

// node_modules/jose/dist/browser/util/errors.js
var errors_exports = {};
__export(errors_exports, {
  JOSEAlgNotAllowed: () => JOSEAlgNotAllowed,
  JOSEError: () => JOSEError,
  JOSENotSupported: () => JOSENotSupported,
  JWEDecryptionFailed: () => JWEDecryptionFailed,
  JWEInvalid: () => JWEInvalid,
  JWKInvalid: () => JWKInvalid,
  JWKSInvalid: () => JWKSInvalid,
  JWKSMultipleMatchingKeys: () => JWKSMultipleMatchingKeys,
  JWKSNoMatchingKey: () => JWKSNoMatchingKey,
  JWKSTimeout: () => JWKSTimeout,
  JWSInvalid: () => JWSInvalid,
  JWSSignatureVerificationFailed: () => JWSSignatureVerificationFailed,
  JWTClaimValidationFailed: () => JWTClaimValidationFailed,
  JWTExpired: () => JWTExpired,
  JWTInvalid: () => JWTInvalid
});
var JOSEError = class extends Error {
  constructor(message2, options) {
    var _a2;
    super(message2, options);
    this.code = "ERR_JOSE_GENERIC";
    this.name = this.constructor.name;
    (_a2 = Error.captureStackTrace) == null ? void 0 : _a2.call(Error, this, this.constructor);
  }
};
JOSEError.code = "ERR_JOSE_GENERIC";
var JWTClaimValidationFailed = class extends JOSEError {
  constructor(message2, payload, claim = "unspecified", reason = "unspecified") {
    super(message2, { cause: { claim, reason, payload } });
    this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
    this.claim = claim;
    this.reason = reason;
    this.payload = payload;
  }
};
JWTClaimValidationFailed.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
var JWTExpired = class extends JOSEError {
  constructor(message2, payload, claim = "unspecified", reason = "unspecified") {
    super(message2, { cause: { claim, reason, payload } });
    this.code = "ERR_JWT_EXPIRED";
    this.claim = claim;
    this.reason = reason;
    this.payload = payload;
  }
};
JWTExpired.code = "ERR_JWT_EXPIRED";
var JOSEAlgNotAllowed = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
  }
};
JOSEAlgNotAllowed.code = "ERR_JOSE_ALG_NOT_ALLOWED";
var JOSENotSupported = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
};
JOSENotSupported.code = "ERR_JOSE_NOT_SUPPORTED";
var JWEDecryptionFailed = class extends JOSEError {
  constructor(message2 = "decryption operation failed", options) {
    super(message2, options);
    this.code = "ERR_JWE_DECRYPTION_FAILED";
  }
};
JWEDecryptionFailed.code = "ERR_JWE_DECRYPTION_FAILED";
var JWEInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWE_INVALID";
  }
};
JWEInvalid.code = "ERR_JWE_INVALID";
var JWSInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_INVALID";
  }
};
JWSInvalid.code = "ERR_JWS_INVALID";
var JWTInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWT_INVALID";
  }
};
JWTInvalid.code = "ERR_JWT_INVALID";
var JWKInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWK_INVALID";
  }
};
JWKInvalid.code = "ERR_JWK_INVALID";
var JWKSInvalid = class extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWKS_INVALID";
  }
};
JWKSInvalid.code = "ERR_JWKS_INVALID";
var JWKSNoMatchingKey = class extends JOSEError {
  constructor(message2 = "no applicable key found in the JSON Web Key Set", options) {
    super(message2, options);
    this.code = "ERR_JWKS_NO_MATCHING_KEY";
  }
};
JWKSNoMatchingKey.code = "ERR_JWKS_NO_MATCHING_KEY";
var JWKSMultipleMatchingKeys = class extends JOSEError {
  constructor(message2 = "multiple matching keys found in the JSON Web Key Set", options) {
    super(message2, options);
    this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
  }
};
JWKSMultipleMatchingKeys.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
var JWKSTimeout = class extends JOSEError {
  constructor(message2 = "request timed out", options) {
    super(message2, options);
    this.code = "ERR_JWKS_TIMEOUT";
  }
};
JWKSTimeout.code = "ERR_JWKS_TIMEOUT";
var JWSSignatureVerificationFailed = class extends JOSEError {
  constructor(message2 = "signature verification failed", options) {
    super(message2, options);
    this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  }
};
JWSSignatureVerificationFailed.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";

// node_modules/jose/dist/browser/runtime/random.js
var random_default = webcrypto_default.getRandomValues.bind(webcrypto_default);

// node_modules/jose/dist/browser/lib/invalid_key_input.js
function message(msg, actual, ...types3) {
  var _a2;
  types3 = types3.filter(Boolean);
  if (types3.length > 2) {
    const last = types3.pop();
    msg += `one of type ${types3.join(", ")}, or ${last}.`;
  } else if (types3.length === 2) {
    msg += `one of type ${types3[0]} or ${types3[1]}.`;
  } else {
    msg += `of type ${types3[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if ((_a2 = actual.constructor) == null ? void 0 : _a2.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
function withAlg(alg, actual, ...types3) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types3);
}

// node_modules/jose/dist/browser/runtime/is_key_like.js
var is_key_like_default = (key) => {
  if (isCryptoKey(key)) {
    return true;
  }
  return (key == null ? void 0 : key[Symbol.toStringTag]) === "KeyObject";
};
var types = ["CryptoKey"];

// node_modules/jose/dist/browser/lib/is_object.js
function isObjectLike2(value2) {
  return typeof value2 === "object" && value2 !== null;
}
function isObject(input) {
  if (!isObjectLike2(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}

// node_modules/jose/dist/browser/lib/is_jwk.js
function isJWK(key) {
  return isObject(key) && typeof key.kty === "string";
}
function isPrivateJWK(key) {
  return key.kty !== "oct" && typeof key.d === "string";
}
function isPublicJWK(key) {
  return key.kty !== "oct" && typeof key.d === "undefined";
}
function isSecretJWK(key) {
  return isJWK(key) && key.kty === "oct" && typeof key.k === "string";
}

// node_modules/jose/dist/browser/lib/check_key_type.js
var tag = (key) => key == null ? void 0 : key[Symbol.toStringTag];
var jwkMatchesOp = (alg, key, usage) => {
  var _a2, _b2;
  if (key.use !== void 0 && key.use !== "sig") {
    throw new TypeError("Invalid key for this operation, when present its use must be sig");
  }
  if (key.key_ops !== void 0 && ((_b2 = (_a2 = key.key_ops).includes) == null ? void 0 : _b2.call(_a2, usage)) !== true) {
    throw new TypeError(`Invalid key for this operation, when present its key_ops must include ${usage}`);
  }
  if (key.alg !== void 0 && key.alg !== alg) {
    throw new TypeError(`Invalid key for this operation, when present its alg must be ${alg}`);
  }
  return true;
};
var symmetricTypeCheck = (alg, key, usage, allowJwk) => {
  if (key instanceof Uint8Array)
    return;
  if (allowJwk && isJWK(key)) {
    if (isSecretJWK(key) && jwkMatchesOp(alg, key, usage))
      return;
    throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present`);
  }
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types, "Uint8Array", allowJwk ? "JSON Web Key" : null));
  }
  if (key.type !== "secret") {
    throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type "secret"`);
  }
};
var asymmetricTypeCheck = (alg, key, usage, allowJwk) => {
  if (allowJwk && isJWK(key)) {
    switch (usage) {
      case "sign":
        if (isPrivateJWK(key) && jwkMatchesOp(alg, key, usage))
          return;
        throw new TypeError(`JSON Web Key for this operation be a private JWK`);
      case "verify":
        if (isPublicJWK(key) && jwkMatchesOp(alg, key, usage))
          return;
        throw new TypeError(`JSON Web Key for this operation be a public JWK`);
    }
  }
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types, allowJwk ? "JSON Web Key" : null));
  }
  if (key.type === "secret") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (usage === "sign" && key.type === "public") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type "private"`);
  }
  if (usage === "decrypt" && key.type === "public") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type "private"`);
  }
  if (key.algorithm && usage === "verify" && key.type === "private") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type "public"`);
  }
  if (key.algorithm && usage === "encrypt" && key.type === "private") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type "public"`);
  }
};
function checkKeyType(allowJwk, alg, key, usage) {
  const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
  if (symmetric) {
    symmetricTypeCheck(alg, key, usage, allowJwk);
  } else {
    asymmetricTypeCheck(alg, key, usage, allowJwk);
  }
}
var check_key_type_default = checkKeyType.bind(void 0, false);
var checkKeyTypeWithJwk = checkKeyType.bind(void 0, true);

// node_modules/jose/dist/browser/lib/private_symbols.js
var unprotected = Symbol();

// node_modules/jose/dist/browser/lib/secs.js
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;

// node_modules/jose/dist/browser/jwks/remote.js
var USER_AGENT;
var _a, _b;
if (typeof navigator === "undefined" || !((_b = (_a = navigator.userAgent) == null ? void 0 : _a.startsWith) == null ? void 0 : _b.call(_a, "Mozilla/5.0 "))) {
  const NAME = "jose";
  const VERSION = "v5.10.0";
  USER_AGENT = `${NAME}/${VERSION}`;
}
var jwksCache = Symbol();

// node_modules/jose/dist/browser/util/base64url.js
var base64url_exports2 = {};
__export(base64url_exports2, {
  decode: () => decode2,
  encode: () => encode2
});
var encode2 = encode;
var decode2 = decode;

// node_modules/@copilotkit/runtime-client-gql/dist/chunk-VVFJT2PN.mjs
var Message = class {
  constructor(props) {
    props.id ?? (props.id = randomId());
    props.status ?? (props.status = {
      code: "Success"
      /* Success */
    });
    props.createdAt ?? (props.createdAt = /* @__PURE__ */ new Date());
    Object.assign(this, props);
  }
  isTextMessage() {
    return this.type === "TextMessage";
  }
  isActionExecutionMessage() {
    return this.type === "ActionExecutionMessage";
  }
  isResultMessage() {
    return this.type === "ResultMessage";
  }
  isAgentStateMessage() {
    return this.type === "AgentStateMessage";
  }
  isImageMessage() {
    return this.type === "ImageMessage";
  }
};
var Role = MessageRole;
var TextMessage = class extends Message {
  constructor(props) {
    super(props);
    this.type = "TextMessage";
  }
};
var ActionExecutionMessage = class extends Message {
  constructor(props) {
    super(props);
    this.type = "ActionExecutionMessage";
  }
};
var ResultMessage = class extends Message {
  constructor(props) {
    super(props);
    this.type = "ResultMessage";
  }
  static decodeResult(result) {
    return parseJson(result, result);
  }
  static encodeResult(result) {
    if (result === void 0) {
      return "";
    } else if (typeof result === "string") {
      return result;
    } else {
      return JSON.stringify(result);
    }
  }
};
var AgentStateMessage = class extends Message {
  constructor(props) {
    super(props);
    this.type = "AgentStateMessage";
  }
};
var ImageMessage = class extends Message {
  constructor(props) {
    super(props);
    this.type = "ImageMessage";
  }
};
function langGraphInterruptEvent(eventProps) {
  return { ...eventProps, name: "LangGraphInterruptEvent", type: "MetaEvent" };
}

// node_modules/@copilotkit/runtime-client-gql/dist/chunk-TNC2H2EO.mjs
function extractAgentName(message2) {
  if (message2.role !== "assistant") {
    throw new Error(`Cannot extract agent name from message with role ${message2.role}`);
  }
  return message2.agentName || "unknown";
}
function isAgentStateMessage(message2) {
  return message2.role === "assistant" && "agentName" in message2 && "state" in message2;
}
function hasImageProperty(message2) {
  const canContainImage = message2.role === "assistant" || message2.role === "user";
  if (!canContainImage || message2.image === void 0) {
    return false;
  }
  const isMalformed = message2.image.format === void 0 || message2.image.bytes === void 0;
  if (isMalformed) {
    return false;
  }
  return true;
}
function aguiToGQL(messages, actions, coAgentStateRenders) {
  const gqlMessages = [];
  messages = Array.isArray(messages) ? messages : [messages];
  const toolCallNames = {};
  for (const message2 of messages) {
    if (isAgentStateMessage(message2)) {
      const agentName = extractAgentName(message2);
      const state = "state" in message2 && message2.state ? message2.state : {};
      gqlMessages.push(
        new AgentStateMessage({
          id: message2.id,
          agentName,
          state,
          role: Role.Assistant
        })
      );
      if ("generativeUI" in message2 && message2.generativeUI && coAgentStateRenders) {
        coAgentStateRenders[agentName] = {
          name: agentName,
          render: message2.generativeUI
        };
      }
      continue;
    }
    if (hasImageProperty(message2)) {
      gqlMessages.push(aguiMessageWithImageToGQLMessage(message2));
      continue;
    }
    if (message2.role === "assistant" && message2.toolCalls) {
      gqlMessages.push(aguiTextMessageToGQLMessage(message2));
      for (const toolCall of message2.toolCalls) {
        toolCallNames[toolCall.id] = toolCall.function.name;
        const actionExecMsg = aguiToolCallToGQLActionExecution(toolCall, message2.id);
        if ("generativeUI" in message2 && message2.generativeUI && actions) {
          const actionName = toolCall.function.name;
          const specificAction = Object.values(actions).find(
            (action) => action.name === actionName
          );
          const wildcardAction = Object.values(actions).find((action) => action.name === "*");
          if (specificAction) {
            specificAction.render = message2.generativeUI;
          } else if (wildcardAction) {
            wildcardAction.render = message2.generativeUI;
          }
        }
        gqlMessages.push(actionExecMsg);
      }
      continue;
    }
    if (message2.role === "developer" || message2.role === "system" || message2.role === "assistant" || message2.role === "user") {
      gqlMessages.push(aguiTextMessageToGQLMessage(message2));
      continue;
    }
    if (message2.role === "tool") {
      gqlMessages.push(aguiToolMessageToGQLResultMessage(message2, toolCallNames));
      continue;
    }
    throw new Error(
      `Unknown message role: "${message2.role}" in message with id: ${message2.id}`
    );
  }
  return gqlMessages;
}
function aguiTextMessageToGQLMessage(message2) {
  if (message2.role !== "developer" && message2.role !== "system" && message2.role !== "assistant" && message2.role !== "user") {
    throw new Error(`Cannot convert message with role ${message2.role} to TextMessage`);
  }
  let roleValue;
  if (message2.role === "developer") {
    roleValue = Role.Developer;
  } else if (message2.role === "system") {
    roleValue = Role.System;
  } else if (message2.role === "assistant") {
    roleValue = Role.Assistant;
  } else {
    roleValue = Role.User;
  }
  return new TextMessage({
    id: message2.id,
    content: message2.content || "",
    role: roleValue
  });
}
function aguiToolCallToGQLActionExecution(toolCall, parentMessageId) {
  if (toolCall.type !== "function") {
    throw new Error(`Unsupported tool call type: ${toolCall.type}`);
  }
  let argumentsObj;
  if (typeof toolCall.function.arguments === "string") {
    try {
      argumentsObj = JSON.parse(toolCall.function.arguments);
    } catch (error2) {
      console.warn(`Failed to parse tool call arguments for ${toolCall.function.name}:`, error2);
      argumentsObj = {};
    }
  } else if (typeof toolCall.function.arguments === "object" && toolCall.function.arguments !== null) {
    argumentsObj = toolCall.function.arguments;
  } else {
    console.warn(
      `Invalid tool call arguments type for ${toolCall.function.name}:`,
      typeof toolCall.function.arguments
    );
    argumentsObj = {};
  }
  return new ActionExecutionMessage({
    id: toolCall.id,
    name: toolCall.function.name,
    arguments: argumentsObj,
    parentMessageId
  });
}
function aguiToolMessageToGQLResultMessage(message2, toolCallNames) {
  if (message2.role !== "tool") {
    throw new Error(`Cannot convert message with role ${message2.role} to ResultMessage`);
  }
  if (!message2.toolCallId) {
    throw new Error("Tool message must have a toolCallId");
  }
  const actionName = toolCallNames[message2.toolCallId] || "unknown";
  let resultContent;
  const messageContent = message2.content || "";
  if (typeof messageContent === "string") {
    resultContent = messageContent;
  } else if (typeof messageContent === "object" && messageContent !== null) {
    try {
      resultContent = JSON.stringify(messageContent);
    } catch (error2) {
      console.warn(`Failed to stringify tool result for ${actionName}:`, error2);
      resultContent = String(messageContent);
    }
  } else {
    resultContent = String(messageContent);
  }
  return new ResultMessage({
    id: message2.id,
    result: resultContent,
    actionExecutionId: message2.toolCallId,
    actionName: message2.toolName || actionName
  });
}
function aguiMessageWithImageToGQLMessage(message2) {
  if (!hasImageProperty(message2)) {
    throw new Error(`Cannot convert message to ImageMessage: missing format or bytes`);
  }
  let roleValue;
  if (message2.role === "assistant") {
    roleValue = Role.Assistant;
  } else {
    roleValue = Role.User;
  }
  if (message2.role !== "assistant" && message2.role !== "user") {
    throw new Error(`Cannot convert message with role ${message2.role} to ImageMessage`);
  }
  return new ImageMessage({
    id: message2.id,
    format: message2.image.format,
    bytes: message2.image.bytes,
    role: roleValue
  });
}

// node_modules/@copilotkit/runtime-client-gql/dist/chunk-O7JH6IWQ.mjs
var VALID_IMAGE_FORMATS = ["jpeg", "png", "webp", "gif"];
function validateImageFormat(format) {
  return VALID_IMAGE_FORMATS.includes(format);
}
function gqlToAGUI(messages, actions, coAgentStateRenders) {
  let aguiMessages = [];
  messages = Array.isArray(messages) ? messages : [messages];
  const actionResults = /* @__PURE__ */ new Map();
  for (const message2 of messages) {
    if (message2.isResultMessage()) {
      actionResults.set(message2.actionExecutionId, message2.result);
    }
  }
  for (const message2 of messages) {
    if (message2.isTextMessage()) {
      aguiMessages.push(gqlTextMessageToAGUIMessage(message2));
    } else if (message2.isResultMessage()) {
      aguiMessages.push(gqlResultMessageToAGUIMessage(message2));
    } else if (message2.isActionExecutionMessage()) {
      aguiMessages.push(gqlActionExecutionMessageToAGUIMessage(message2, actions, actionResults));
    } else if (message2.isAgentStateMessage()) {
      aguiMessages.push(gqlAgentStateMessageToAGUIMessage(message2, coAgentStateRenders));
    } else if (message2.isImageMessage()) {
      aguiMessages.push(gqlImageMessageToAGUIMessage(message2));
    } else {
      throw new Error("Unknown message type");
    }
  }
  return aguiMessages;
}
function gqlActionExecutionMessageToAGUIMessage(message2, actions, actionResults) {
  const hasSpecificAction = actions && Object.values(actions).some((action2) => action2.name === message2.name);
  const hasWildcardAction = actions && Object.values(actions).some((action2) => action2.name === "*");
  if (!actions || !hasSpecificAction && !hasWildcardAction) {
    return {
      id: message2.id,
      role: "assistant",
      toolCalls: [actionExecutionMessageToAGUIMessage(message2)],
      name: message2.name
    };
  }
  const action = Object.values(actions).find((action2) => action2.name === message2.name) || Object.values(actions).find((action2) => action2.name === "*");
  const createRenderWrapper = (originalRender) => {
    if (!originalRender)
      return void 0;
    return (props) => {
      var _a2;
      let actionResult = actionResults == null ? void 0 : actionResults.get(message2.id);
      let status = "inProgress";
      if (actionResult !== void 0) {
        status = "complete";
      } else if (((_a2 = message2.status) == null ? void 0 : _a2.code) !== "Pending") {
        status = "executing";
      }
      if (typeof (props == null ? void 0 : props.result) === "string") {
        try {
          props.result = JSON.parse(props.result);
        } catch (e3) {
        }
      }
      if (typeof actionResult === "string") {
        try {
          actionResult = JSON.parse(actionResult);
        } catch (e3) {
        }
      }
      const baseProps = {
        status: (props == null ? void 0 : props.status) || status,
        args: message2.arguments || {},
        result: (props == null ? void 0 : props.result) || actionResult || void 0,
        messageId: message2.id
      };
      if (action.name === "*") {
        return originalRender({
          ...baseProps,
          ...props,
          name: message2.name
        });
      } else {
        const respond = (props == null ? void 0 : props.respond) ?? (() => {
        });
        return originalRender({
          ...baseProps,
          ...props,
          respond
        });
      }
    };
  };
  return {
    id: message2.id,
    role: "assistant",
    content: "",
    toolCalls: [actionExecutionMessageToAGUIMessage(message2)],
    generativeUI: createRenderWrapper(action.render),
    name: message2.name
  };
}
function gqlAgentStateMessageToAGUIMessage(message2, coAgentStateRenders) {
  if (coAgentStateRenders && Object.values(coAgentStateRenders).some((render) => render.name === message2.agentName)) {
    const render = Object.values(coAgentStateRenders).find(
      (render2) => render2.name === message2.agentName
    );
    const createRenderWrapper = (originalRender) => {
      if (!originalRender)
        return void 0;
      return (props) => {
        const state = message2.state;
        const renderProps = {
          state
        };
        return originalRender(renderProps);
      };
    };
    return {
      id: message2.id,
      role: "assistant",
      generativeUI: createRenderWrapper(render.render),
      agentName: message2.agentName,
      state: message2.state
    };
  }
  return {
    id: message2.id,
    role: "assistant",
    agentName: message2.agentName,
    state: message2.state
  };
}
function actionExecutionMessageToAGUIMessage(actionExecutionMessage) {
  return {
    id: actionExecutionMessage.id,
    function: {
      name: actionExecutionMessage.name,
      arguments: JSON.stringify(actionExecutionMessage.arguments)
    },
    type: "function"
  };
}
function gqlTextMessageToAGUIMessage(message2) {
  switch (message2.role) {
    case Role.Developer:
      return {
        id: message2.id,
        role: "developer",
        content: message2.content
      };
    case Role.System:
      return {
        id: message2.id,
        role: "system",
        content: message2.content
      };
    case Role.Assistant:
      return {
        id: message2.id,
        role: "assistant",
        content: message2.content
      };
    case Role.User:
      return {
        id: message2.id,
        role: "user",
        content: message2.content
      };
    default:
      throw new Error("Unknown message role");
  }
}
function gqlResultMessageToAGUIMessage(message2) {
  return {
    id: message2.id,
    role: "tool",
    content: message2.result,
    toolCallId: message2.actionExecutionId,
    toolName: message2.actionName
  };
}
function gqlImageMessageToAGUIMessage(message2) {
  if (!validateImageFormat(message2.format)) {
    throw new Error(
      `Invalid image format: ${message2.format}. Supported formats are: ${VALID_IMAGE_FORMATS.join(", ")}`
    );
  }
  if (!message2.bytes || typeof message2.bytes !== "string" || message2.bytes.trim() === "") {
    throw new Error("Image bytes must be a non-empty string");
  }
  const role = message2.role === Role.Assistant ? "assistant" : "user";
  const imageMessage = {
    id: message2.id,
    role,
    content: "",
    image: {
      format: message2.format,
      bytes: message2.bytes
    }
  };
  return imageMessage;
}

// node_modules/@copilotkit/runtime-client-gql/dist/chunk-AQ2Y6PF5.mjs
var documents = {
  "\n  mutation generateCopilotResponse($data: GenerateCopilotResponseInput!, $properties: JSONObject) {\n    generateCopilotResponse(data: $data, properties: $properties) {\n      threadId\n      runId\n      extensions {\n        openaiAssistantAPI {\n          runId\n          threadId\n        }\n      }\n      ... on CopilotResponse @defer {\n        status {\n          ... on BaseResponseStatus {\n            code\n          }\n          ... on FailedResponseStatus {\n            reason\n            details\n          }\n        }\n      }\n      messages @stream {\n        __typename\n        ... on BaseMessageOutput {\n          id\n          createdAt\n        }\n        ... on BaseMessageOutput @defer {\n          status {\n            ... on SuccessMessageStatus {\n              code\n            }\n            ... on FailedMessageStatus {\n              code\n              reason\n            }\n            ... on PendingMessageStatus {\n              code\n            }\n          }\n        }\n        ... on TextMessageOutput {\n          content @stream\n          role\n          parentMessageId\n        }\n        ... on ImageMessageOutput {\n          format\n          bytes\n          role\n          parentMessageId\n        }\n        ... on ActionExecutionMessageOutput {\n          name\n          arguments @stream\n          parentMessageId\n        }\n        ... on ResultMessageOutput {\n          result\n          actionExecutionId\n          actionName\n        }\n        ... on AgentStateMessageOutput {\n          threadId\n          state\n          running\n          agentName\n          nodeName\n          runId\n          active\n          role\n        }\n      }\n      metaEvents @stream {\n        ... on LangGraphInterruptEvent {\n          type\n          name\n          value\n        }\n\n        ... on CopilotKitLangGraphInterruptEvent {\n          type\n          name\n          data {\n            messages {\n              __typename\n              ... on BaseMessageOutput {\n                id\n                createdAt\n              }\n              ... on BaseMessageOutput @defer {\n                status {\n                  ... on SuccessMessageStatus {\n                    code\n                  }\n                  ... on FailedMessageStatus {\n                    code\n                    reason\n                  }\n                  ... on PendingMessageStatus {\n                    code\n                  }\n                }\n              }\n              ... on TextMessageOutput {\n                content\n                role\n                parentMessageId\n              }\n              ... on ActionExecutionMessageOutput {\n                name\n                arguments\n                parentMessageId\n              }\n              ... on ResultMessageOutput {\n                result\n                actionExecutionId\n                actionName\n              }\n            }\n            value\n          }\n        }\n      }\n    }\n  }\n": GenerateCopilotResponseDocument,
  "\n  query availableAgents {\n    availableAgents {\n      agents {\n        name\n        id\n        description\n      }\n    }\n  }\n": AvailableAgentsDocument,
  "\n  query loadAgentState($data: LoadAgentStateInput!) {\n    loadAgentState(data: $data) {\n      threadId\n      threadExists\n      state\n      messages\n    }\n  }\n": LoadAgentStateDocument
};
function graphql2(source) {
  return documents[source] ?? {};
}

// node_modules/@copilotkit/runtime-client-gql/dist/chunk-WUF3XSW5.mjs
var getAvailableAgentsQuery = graphql2(
  /** GraphQL **/
  `
  query availableAgents {
    availableAgents {
      agents {
        name
        id
        description
      }
    }
  }
`
);
var loadAgentStateQuery = graphql2(
  /** GraphQL **/
  `
  query loadAgentState($data: LoadAgentStateInput!) {
    loadAgentState(data: $data) {
      threadId
      threadExists
      state
      messages
    }
  }
`
);

// node_modules/@copilotkit/runtime-client-gql/dist/chunk-EWRHYLZE.mjs
var generateCopilotResponseMutation = graphql2(
  /** GraphQL **/
  `
  mutation generateCopilotResponse($data: GenerateCopilotResponseInput!, $properties: JSONObject) {
    generateCopilotResponse(data: $data, properties: $properties) {
      threadId
      runId
      extensions {
        openaiAssistantAPI {
          runId
          threadId
        }
      }
      ... on CopilotResponse @defer {
        status {
          ... on BaseResponseStatus {
            code
          }
          ... on FailedResponseStatus {
            reason
            details
          }
        }
      }
      messages @stream {
        __typename
        ... on BaseMessageOutput {
          id
          createdAt
        }
        ... on BaseMessageOutput @defer {
          status {
            ... on SuccessMessageStatus {
              code
            }
            ... on FailedMessageStatus {
              code
              reason
            }
            ... on PendingMessageStatus {
              code
            }
          }
        }
        ... on TextMessageOutput {
          content @stream
          role
          parentMessageId
        }
        ... on ImageMessageOutput {
          format
          bytes
          role
          parentMessageId
        }
        ... on ActionExecutionMessageOutput {
          name
          arguments @stream
          parentMessageId
        }
        ... on ResultMessageOutput {
          result
          actionExecutionId
          actionName
        }
        ... on AgentStateMessageOutput {
          threadId
          state
          running
          agentName
          nodeName
          runId
          active
          role
        }
      }
      metaEvents @stream {
        ... on LangGraphInterruptEvent {
          type
          name
          value
        }

        ... on CopilotKitLangGraphInterruptEvent {
          type
          name
          data {
            messages {
              __typename
              ... on BaseMessageOutput {
                id
                createdAt
              }
              ... on BaseMessageOutput @defer {
                status {
                  ... on SuccessMessageStatus {
                    code
                  }
                  ... on FailedMessageStatus {
                    code
                    reason
                  }
                  ... on PendingMessageStatus {
                    code
                  }
                }
              }
              ... on TextMessageOutput {
                content
                role
                parentMessageId
              }
              ... on ActionExecutionMessageOutput {
                name
                arguments
                parentMessageId
              }
              ... on ResultMessageOutput {
                result
                actionExecutionId
                actionName
              }
            }
            value
          }
        }
      }
    }
  }
`
);

// node_modules/@0no-co/graphql.web/dist/graphql.web.mjs
var e = {
  NAME: "Name",
  DOCUMENT: "Document",
  OPERATION_DEFINITION: "OperationDefinition",
  VARIABLE_DEFINITION: "VariableDefinition",
  SELECTION_SET: "SelectionSet",
  FIELD: "Field",
  ARGUMENT: "Argument",
  FRAGMENT_SPREAD: "FragmentSpread",
  INLINE_FRAGMENT: "InlineFragment",
  FRAGMENT_DEFINITION: "FragmentDefinition",
  VARIABLE: "Variable",
  INT: "IntValue",
  FLOAT: "FloatValue",
  STRING: "StringValue",
  BOOLEAN: "BooleanValue",
  NULL: "NullValue",
  ENUM: "EnumValue",
  LIST: "ListValue",
  OBJECT: "ObjectValue",
  OBJECT_FIELD: "ObjectField",
  DIRECTIVE: "Directive",
  NAMED_TYPE: "NamedType",
  LIST_TYPE: "ListType",
  NON_NULL_TYPE: "NonNullType"
};
var GraphQLError2 = class extends Error {
  constructor(e3, r2, i3, n2, t2, a2, o2) {
    if (super(e3), this.name = "GraphQLError", this.message = e3, t2) {
      this.path = t2;
    }
    if (r2) {
      this.nodes = Array.isArray(r2) ? r2 : [r2];
    }
    if (i3) {
      this.source = i3;
    }
    if (n2) {
      this.positions = n2;
    }
    if (a2) {
      this.originalError = a2;
    }
    var l2 = o2;
    if (!l2 && a2) {
      var d3 = a2.extensions;
      if (d3 && "object" == typeof d3) {
        l2 = d3;
      }
    }
    this.extensions = l2 || {};
  }
  toJSON() {
    return {
      ...this,
      message: this.message
    };
  }
  toString() {
    return this.message;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
};
var i;
var n;
function error(e3) {
  return new GraphQLError2(`Syntax Error: Unexpected token at ${n} in ${e3}`);
}
function advance(e3) {
  if (e3.lastIndex = n, e3.test(i)) {
    return i.slice(n, n = e3.lastIndex);
  }
}
var t = / +(?=[^\s])/y;
function blockString(e3) {
  var r2 = e3.split("\n");
  var i3 = "";
  var n2 = 0;
  var a2 = 0;
  var o2 = r2.length - 1;
  for (var l2 = 0; l2 < r2.length; l2++) {
    if (t.lastIndex = 0, t.test(r2[l2])) {
      if (l2 && (!n2 || t.lastIndex < n2)) {
        n2 = t.lastIndex;
      }
      a2 = a2 || l2, o2 = l2;
    }
  }
  for (var d3 = a2; d3 <= o2; d3++) {
    if (d3 !== a2) {
      i3 += "\n";
    }
    i3 += r2[d3].slice(n2).replace(/\\"""/g, '"""');
  }
  return i3;
}
function ignored() {
  for (var e3 = 0 | i.charCodeAt(n++); 9 === e3 || 10 === e3 || 13 === e3 || 32 === e3 || 35 === e3 || 44 === e3 || 65279 === e3; e3 = 0 | i.charCodeAt(n++)) {
    if (35 === e3) {
      for (; (e3 = 0 | i.charCodeAt(n++)) && 10 !== e3 && 13 !== e3; ) {
      }
    }
  }
  n--;
}
function name() {
  var e3 = n;
  for (var r2 = 0 | i.charCodeAt(n++); r2 >= 48 && r2 <= 57 || r2 >= 65 && r2 <= 90 || 95 === r2 || r2 >= 97 && r2 <= 122; r2 = 0 | i.charCodeAt(n++)) {
  }
  if (e3 === n - 1) {
    throw error("Name");
  }
  var t2 = i.slice(e3, --n);
  return ignored(), t2;
}
function nameNode() {
  return {
    kind: "Name",
    value: name()
  };
}
var a = /(?:"""|(?:[\s\S]*?[^\\])""")/y;
var o = /(?:(?:\.\d+)?[eE][+-]?\d+|\.\d+)/y;
function value(e3) {
  var r2;
  switch (i.charCodeAt(n)) {
    case 91:
      n++, ignored();
      var t2 = [];
      for (; 93 !== i.charCodeAt(n); ) {
        t2.push(value(e3));
      }
      return n++, ignored(), {
        kind: "ListValue",
        values: t2
      };
    case 123:
      n++, ignored();
      var l2 = [];
      for (; 125 !== i.charCodeAt(n); ) {
        var d3 = nameNode();
        if (58 !== i.charCodeAt(n++)) {
          throw error("ObjectField");
        }
        ignored(), l2.push({
          kind: "ObjectField",
          name: d3,
          value: value(e3)
        });
      }
      return n++, ignored(), {
        kind: "ObjectValue",
        fields: l2
      };
    case 36:
      if (e3) {
        throw error("Variable");
      }
      return n++, {
        kind: "Variable",
        name: nameNode()
      };
    case 34:
      if (34 === i.charCodeAt(n + 1) && 34 === i.charCodeAt(n + 2)) {
        if (n += 3, null == (r2 = advance(a))) {
          throw error("StringValue");
        }
        return ignored(), {
          kind: "StringValue",
          value: blockString(r2.slice(0, -3)),
          block: true
        };
      } else {
        var u3 = n;
        var s;
        n++;
        var c2 = false;
        for (s = 0 | i.charCodeAt(n++); 92 === s && (n++, c2 = true) || 10 !== s && 13 !== s && 34 !== s && s; s = 0 | i.charCodeAt(n++)) {
        }
        if (34 !== s) {
          throw error("StringValue");
        }
        return r2 = i.slice(u3, n), ignored(), {
          kind: "StringValue",
          value: c2 ? JSON.parse(r2) : r2.slice(1, -1),
          block: false
        };
      }
    case 45:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      var v2 = n++;
      var f3;
      for (; (f3 = 0 | i.charCodeAt(n++)) >= 48 && f3 <= 57; ) {
      }
      var m = i.slice(v2, --n);
      if (46 === (f3 = i.charCodeAt(n)) || 69 === f3 || 101 === f3) {
        if (null == (r2 = advance(o))) {
          throw error("FloatValue");
        }
        return ignored(), {
          kind: "FloatValue",
          value: m + r2
        };
      } else {
        return ignored(), {
          kind: "IntValue",
          value: m
        };
      }
    case 110:
      if (117 === i.charCodeAt(n + 1) && 108 === i.charCodeAt(n + 2) && 108 === i.charCodeAt(n + 3)) {
        return n += 4, ignored(), {
          kind: "NullValue"
        };
      } else {
        break;
      }
    case 116:
      if (114 === i.charCodeAt(n + 1) && 117 === i.charCodeAt(n + 2) && 101 === i.charCodeAt(n + 3)) {
        return n += 4, ignored(), {
          kind: "BooleanValue",
          value: true
        };
      } else {
        break;
      }
    case 102:
      if (97 === i.charCodeAt(n + 1) && 108 === i.charCodeAt(n + 2) && 115 === i.charCodeAt(n + 3) && 101 === i.charCodeAt(n + 4)) {
        return n += 5, ignored(), {
          kind: "BooleanValue",
          value: false
        };
      } else {
        break;
      }
  }
  return {
    kind: "EnumValue",
    value: name()
  };
}
function arguments_(e3) {
  if (40 === i.charCodeAt(n)) {
    var r2 = [];
    n++, ignored();
    do {
      var t2 = nameNode();
      if (58 !== i.charCodeAt(n++)) {
        throw error("Argument");
      }
      ignored(), r2.push({
        kind: "Argument",
        name: t2,
        value: value(e3)
      });
    } while (41 !== i.charCodeAt(n));
    return n++, ignored(), r2;
  }
}
function directives(e3) {
  if (64 === i.charCodeAt(n)) {
    var r2 = [];
    do {
      n++, r2.push({
        kind: "Directive",
        name: nameNode(),
        arguments: arguments_(e3)
      });
    } while (64 === i.charCodeAt(n));
    return r2;
  }
}
function type() {
  var e3 = 0;
  for (; 91 === i.charCodeAt(n); ) {
    e3++, n++, ignored();
  }
  var r2 = {
    kind: "NamedType",
    name: nameNode()
  };
  do {
    if (33 === i.charCodeAt(n)) {
      n++, ignored(), r2 = {
        kind: "NonNullType",
        type: r2
      };
    }
    if (e3) {
      if (93 !== i.charCodeAt(n++)) {
        throw error("NamedType");
      }
      ignored(), r2 = {
        kind: "ListType",
        type: r2
      };
    }
  } while (e3--);
  return r2;
}
function selectionSetStart() {
  if (123 !== i.charCodeAt(n++)) {
    throw error("SelectionSet");
  }
  return ignored(), selectionSet();
}
function selectionSet() {
  var e3 = [];
  do {
    if (46 === i.charCodeAt(n)) {
      if (46 !== i.charCodeAt(++n) || 46 !== i.charCodeAt(++n)) {
        throw error("SelectionSet");
      }
      switch (n++, ignored(), i.charCodeAt(n)) {
        case 64:
          e3.push({
            kind: "InlineFragment",
            typeCondition: void 0,
            directives: directives(false),
            selectionSet: selectionSetStart()
          });
          break;
        case 111:
          if (110 === i.charCodeAt(n + 1)) {
            n += 2, ignored(), e3.push({
              kind: "InlineFragment",
              typeCondition: {
                kind: "NamedType",
                name: nameNode()
              },
              directives: directives(false),
              selectionSet: selectionSetStart()
            });
          } else {
            e3.push({
              kind: "FragmentSpread",
              name: nameNode(),
              directives: directives(false)
            });
          }
          break;
        case 123:
          n++, ignored(), e3.push({
            kind: "InlineFragment",
            typeCondition: void 0,
            directives: void 0,
            selectionSet: selectionSet()
          });
          break;
        default:
          e3.push({
            kind: "FragmentSpread",
            name: nameNode(),
            directives: directives(false)
          });
      }
    } else {
      var r2 = nameNode();
      var t2 = void 0;
      if (58 === i.charCodeAt(n)) {
        n++, ignored(), t2 = r2, r2 = nameNode();
      }
      var a2 = arguments_(false);
      var o2 = directives(false);
      var l2 = void 0;
      if (123 === i.charCodeAt(n)) {
        n++, ignored(), l2 = selectionSet();
      }
      e3.push({
        kind: "Field",
        alias: t2,
        name: r2,
        arguments: a2,
        directives: o2,
        selectionSet: l2
      });
    }
  } while (125 !== i.charCodeAt(n));
  return n++, ignored(), {
    kind: "SelectionSet",
    selections: e3
  };
}
function variableDefinitions() {
  if (ignored(), 40 === i.charCodeAt(n)) {
    var e3 = [];
    n++, ignored();
    do {
      var r2 = void 0;
      if (34 === i.charCodeAt(n)) {
        r2 = value(true);
      }
      if (36 !== i.charCodeAt(n++)) {
        throw error("Variable");
      }
      var t2 = nameNode();
      if (58 !== i.charCodeAt(n++)) {
        throw error("VariableDefinition");
      }
      ignored();
      var a2 = type();
      var o2 = void 0;
      if (61 === i.charCodeAt(n)) {
        n++, ignored(), o2 = value(true);
      }
      ignored();
      var l2 = {
        kind: "VariableDefinition",
        variable: {
          kind: "Variable",
          name: t2
        },
        type: a2,
        defaultValue: o2,
        directives: directives(true)
      };
      if (r2) {
        l2.description = r2;
      }
      e3.push(l2);
    } while (41 !== i.charCodeAt(n));
    return n++, ignored(), e3;
  }
}
function fragmentDefinition(e3) {
  var r2 = nameNode();
  if (111 !== i.charCodeAt(n++) || 110 !== i.charCodeAt(n++)) {
    throw error("FragmentDefinition");
  }
  ignored();
  var t2 = {
    kind: "FragmentDefinition",
    name: r2,
    typeCondition: {
      kind: "NamedType",
      name: nameNode()
    },
    directives: directives(false),
    selectionSet: selectionSetStart()
  };
  if (e3) {
    t2.description = e3;
  }
  return t2;
}
function definitions() {
  var e3 = [];
  do {
    var r2 = void 0;
    if (34 === i.charCodeAt(n)) {
      r2 = value(true);
    }
    if (123 === i.charCodeAt(n)) {
      if (r2) {
        throw error("Document");
      }
      n++, ignored(), e3.push({
        kind: "OperationDefinition",
        operation: "query",
        name: void 0,
        variableDefinitions: void 0,
        directives: void 0,
        selectionSet: selectionSet()
      });
    } else {
      var t2 = name();
      switch (t2) {
        case "fragment":
          e3.push(fragmentDefinition(r2));
          break;
        case "query":
        case "mutation":
        case "subscription":
          var a2;
          var o2 = void 0;
          if (40 !== (a2 = i.charCodeAt(n)) && 64 !== a2 && 123 !== a2) {
            o2 = nameNode();
          }
          var l2 = {
            kind: "OperationDefinition",
            operation: t2,
            name: o2,
            variableDefinitions: variableDefinitions(),
            directives: directives(false),
            selectionSet: selectionSetStart()
          };
          if (r2) {
            l2.description = r2;
          }
          e3.push(l2);
          break;
        default:
          throw error("Document");
      }
    }
  } while (n < i.length);
  return e3;
}
function parse3(e3, r2) {
  if (i = e3.body ? e3.body : e3, n = 0, ignored(), r2 && r2.noLocation) {
    return {
      kind: "Document",
      definitions: definitions()
    };
  } else {
    return {
      kind: "Document",
      definitions: definitions(),
      loc: {
        start: 0,
        end: i.length,
        startToken: void 0,
        endToken: void 0,
        source: {
          body: i,
          name: "graphql.web",
          locationOffset: {
            line: 1,
            column: 1
          }
        }
      }
    };
  }
}
function mapJoin(e3, r2, i3) {
  var n2 = "";
  for (var t2 = 0; t2 < e3.length; t2++) {
    if (t2) {
      n2 += r2;
    }
    n2 += i3(e3[t2]);
  }
  return n2;
}
function printString2(e3) {
  return JSON.stringify(e3);
}
function printBlockString2(e3) {
  return '"""\n' + e3.replace(/"""/g, '\\"""') + '\n"""';
}
var d = "\n";
var u = {
  OperationDefinition(e3) {
    var r2 = "";
    if (e3.description) {
      r2 += u.StringValue(e3.description) + "\n";
    }
    if (r2 += e3.operation, e3.name) {
      r2 += " " + e3.name.value;
    }
    if (e3.variableDefinitions && e3.variableDefinitions.length) {
      if (!e3.name) {
        r2 += " ";
      }
      r2 += "(" + mapJoin(e3.variableDefinitions, ", ", u.VariableDefinition) + ")";
    }
    if (e3.directives && e3.directives.length) {
      r2 += " " + mapJoin(e3.directives, " ", u.Directive);
    }
    var i3 = u.SelectionSet(e3.selectionSet);
    return "query" !== r2 ? r2 + " " + i3 : i3;
  },
  VariableDefinition(e3) {
    var r2 = "";
    if (e3.description) {
      r2 += u.StringValue(e3.description) + " ";
    }
    if (r2 += u.Variable(e3.variable) + ": " + _print(e3.type), e3.defaultValue) {
      r2 += " = " + _print(e3.defaultValue);
    }
    if (e3.directives && e3.directives.length) {
      r2 += " " + mapJoin(e3.directives, " ", u.Directive);
    }
    return r2;
  },
  Field(e3) {
    var r2 = e3.alias ? e3.alias.value + ": " + e3.name.value : e3.name.value;
    if (e3.arguments && e3.arguments.length) {
      var i3 = mapJoin(e3.arguments, ", ", u.Argument);
      if (r2.length + i3.length + 2 > 80) {
        r2 += "(" + (d += "  ") + mapJoin(e3.arguments, d, u.Argument) + (d = d.slice(0, -2)) + ")";
      } else {
        r2 += "(" + i3 + ")";
      }
    }
    if (e3.directives && e3.directives.length) {
      r2 += " " + mapJoin(e3.directives, " ", u.Directive);
    }
    if (e3.selectionSet && e3.selectionSet.selections.length) {
      r2 += " " + u.SelectionSet(e3.selectionSet);
    }
    return r2;
  },
  StringValue(e3) {
    if (e3.block) {
      return printBlockString2(e3.value).replace(/\n/g, d);
    } else {
      return printString2(e3.value);
    }
  },
  BooleanValue: (e3) => "" + e3.value,
  NullValue: (e3) => "null",
  IntValue: (e3) => e3.value,
  FloatValue: (e3) => e3.value,
  EnumValue: (e3) => e3.value,
  Name: (e3) => e3.value,
  Variable: (e3) => "$" + e3.name.value,
  ListValue: (e3) => "[" + mapJoin(e3.values, ", ", _print) + "]",
  ObjectValue: (e3) => "{" + mapJoin(e3.fields, ", ", u.ObjectField) + "}",
  ObjectField: (e3) => e3.name.value + ": " + _print(e3.value),
  Document(e3) {
    if (!e3.definitions || !e3.definitions.length) {
      return "";
    } else {
      return mapJoin(e3.definitions, "\n\n", _print);
    }
  },
  SelectionSet: (e3) => "{" + (d += "  ") + mapJoin(e3.selections, d, _print) + (d = d.slice(0, -2)) + "}",
  Argument: (e3) => e3.name.value + ": " + _print(e3.value),
  FragmentSpread(e3) {
    var r2 = "..." + e3.name.value;
    if (e3.directives && e3.directives.length) {
      r2 += " " + mapJoin(e3.directives, " ", u.Directive);
    }
    return r2;
  },
  InlineFragment(e3) {
    var r2 = "...";
    if (e3.typeCondition) {
      r2 += " on " + e3.typeCondition.name.value;
    }
    if (e3.directives && e3.directives.length) {
      r2 += " " + mapJoin(e3.directives, " ", u.Directive);
    }
    return r2 += " " + u.SelectionSet(e3.selectionSet);
  },
  FragmentDefinition(e3) {
    var r2 = "";
    if (e3.description) {
      r2 += u.StringValue(e3.description) + "\n";
    }
    if (r2 += "fragment " + e3.name.value, r2 += " on " + e3.typeCondition.name.value, e3.directives && e3.directives.length) {
      r2 += " " + mapJoin(e3.directives, " ", u.Directive);
    }
    return r2 + " " + u.SelectionSet(e3.selectionSet);
  },
  Directive(e3) {
    var r2 = "@" + e3.name.value;
    if (e3.arguments && e3.arguments.length) {
      r2 += "(" + mapJoin(e3.arguments, ", ", u.Argument) + ")";
    }
    return r2;
  },
  NamedType: (e3) => e3.name.value,
  ListType: (e3) => "[" + _print(e3.type) + "]",
  NonNullType: (e3) => _print(e3.type) + "!"
};
var _print = (e3) => u[e3.kind](e3);
function print2(e3) {
  return d = "\n", u[e3.kind] ? u[e3.kind](e3) : "";
}

// node_modules/wonka/dist/wonka.mjs
var teardownPlaceholder = () => {
};
var e2 = teardownPlaceholder;
function start(e3) {
  return {
    tag: 0,
    0: e3
  };
}
function push(e3) {
  return {
    tag: 1,
    0: e3
  };
}
var asyncIteratorSymbol = () => "function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator";
var identity = (e3) => e3;
function filter(r2) {
  return (t2) => (i3) => {
    var a2 = e2;
    t2((e3) => {
      if (0 === e3) {
        i3(0);
      } else if (0 === e3.tag) {
        a2 = e3[0];
        i3(e3);
      } else if (!r2(e3[0])) {
        a2(0);
      } else {
        i3(e3);
      }
    });
  };
}
function map(e3) {
  return (r2) => (t2) => r2((r3) => {
    if (0 === r3 || 0 === r3.tag) {
      t2(r3);
    } else {
      t2(push(e3(r3[0])));
    }
  });
}
function mergeMap(r2) {
  return (t2) => (i3) => {
    var a2 = [];
    var f3 = e2;
    var n2 = false;
    var s = false;
    t2((t3) => {
      if (s) {
      } else if (0 === t3) {
        s = true;
        if (!a2.length) {
          i3(0);
        }
      } else if (0 === t3.tag) {
        f3 = t3[0];
      } else {
        n2 = false;
        !function applyInnerSource(r3) {
          var t4 = e2;
          r3((e3) => {
            if (0 === e3) {
              if (a2.length) {
                var r4 = a2.indexOf(t4);
                if (r4 > -1) {
                  (a2 = a2.slice()).splice(r4, 1);
                }
                if (!a2.length) {
                  if (s) {
                    i3(0);
                  } else if (!n2) {
                    n2 = true;
                    f3(0);
                  }
                }
              }
            } else if (0 === e3.tag) {
              a2.push(t4 = e3[0]);
              t4(0);
            } else if (a2.length) {
              i3(e3);
              t4(0);
            }
          });
        }(r2(t3[0]));
        if (!n2) {
          n2 = true;
          f3(0);
        }
      }
    });
    i3(start((e3) => {
      if (1 === e3) {
        if (!s) {
          s = true;
          f3(1);
        }
        for (var r3 = 0, t3 = a2, i4 = a2.length; r3 < i4; r3++) {
          t3[r3](1);
        }
        a2.length = 0;
      } else {
        if (!s && !n2) {
          n2 = true;
          f3(0);
        } else {
          n2 = false;
        }
        for (var l2 = 0, u3 = a2, o2 = a2.length; l2 < o2; l2++) {
          u3[l2](0);
        }
      }
    }));
  };
}
function mergeAll(e3) {
  return mergeMap(identity)(e3);
}
function merge(e3) {
  return mergeAll(r(e3));
}
function onEnd(e3) {
  return (r2) => (t2) => {
    var i3 = false;
    r2((r3) => {
      if (i3) {
      } else if (0 === r3) {
        i3 = true;
        t2(0);
        e3();
      } else if (0 === r3.tag) {
        var a2 = r3[0];
        t2(start((r4) => {
          if (1 === r4) {
            i3 = true;
            a2(1);
            e3();
          } else {
            a2(r4);
          }
        }));
      } else {
        t2(r3);
      }
    });
  };
}
function onPush(e3) {
  return (r2) => (t2) => {
    var i3 = false;
    r2((r3) => {
      if (i3) {
      } else if (0 === r3) {
        i3 = true;
        t2(0);
      } else if (0 === r3.tag) {
        var a2 = r3[0];
        t2(start((e4) => {
          if (1 === e4) {
            i3 = true;
          }
          a2(e4);
        }));
      } else {
        e3(r3[0]);
        t2(r3);
      }
    });
  };
}
function onStart(e3) {
  return (r2) => (t2) => r2((r3) => {
    if (0 === r3) {
      t2(0);
    } else if (0 === r3.tag) {
      t2(r3);
      e3();
    } else {
      t2(r3);
    }
  });
}
function share(r2) {
  var t2 = [];
  var i3 = e2;
  var a2 = false;
  return (e3) => {
    t2.push(e3);
    if (1 === t2.length) {
      r2((e4) => {
        if (0 === e4) {
          for (var r3 = 0, f3 = t2, n2 = t2.length; r3 < n2; r3++) {
            f3[r3](0);
          }
          t2.length = 0;
        } else if (0 === e4.tag) {
          i3 = e4[0];
        } else {
          a2 = false;
          for (var s = 0, l2 = t2, u3 = t2.length; s < u3; s++) {
            l2[s](e4);
          }
        }
      });
    }
    e3(start((r3) => {
      if (1 === r3) {
        var f3 = t2.indexOf(e3);
        if (f3 > -1) {
          (t2 = t2.slice()).splice(f3, 1);
        }
        if (!t2.length) {
          i3(1);
        }
      } else if (!a2) {
        a2 = true;
        i3(0);
      }
    }));
  };
}
function switchMap(r2) {
  return (t2) => (i3) => {
    var a2 = e2;
    var f3 = e2;
    var n2 = false;
    var s = false;
    var l2 = false;
    var u3 = false;
    t2((t3) => {
      if (u3) {
      } else if (0 === t3) {
        u3 = true;
        if (!l2) {
          i3(0);
        }
      } else if (0 === t3.tag) {
        a2 = t3[0];
      } else {
        if (l2) {
          f3(1);
          f3 = e2;
        }
        if (!n2) {
          n2 = true;
          a2(0);
        } else {
          n2 = false;
        }
        !function applyInnerSource(e3) {
          l2 = true;
          e3((e4) => {
            if (!l2) {
            } else if (0 === e4) {
              l2 = false;
              if (u3) {
                i3(0);
              } else if (!n2) {
                n2 = true;
                a2(0);
              }
            } else if (0 === e4.tag) {
              s = false;
              (f3 = e4[0])(0);
            } else {
              i3(e4);
              if (!s) {
                f3(0);
              } else {
                s = false;
              }
            }
          });
        }(r2(t3[0]));
      }
    });
    i3(start((e3) => {
      if (1 === e3) {
        if (!u3) {
          u3 = true;
          a2(1);
        }
        if (l2) {
          l2 = false;
          f3(1);
        }
      } else {
        if (!u3 && !n2) {
          n2 = true;
          a2(0);
        }
        if (l2 && !s) {
          s = true;
          f3(0);
        }
      }
    }));
  };
}
function take(r2) {
  return (t2) => (i3) => {
    var a2 = e2;
    var f3 = false;
    var n2 = 0;
    t2((e3) => {
      if (f3) {
      } else if (0 === e3) {
        f3 = true;
        i3(0);
      } else if (0 === e3.tag) {
        if (r2 <= 0) {
          f3 = true;
          i3(0);
          e3[0](1);
        } else {
          a2 = e3[0];
        }
      } else if (n2++ < r2) {
        i3(e3);
        if (!f3 && n2 >= r2) {
          f3 = true;
          i3(0);
          a2(1);
        }
      } else {
        i3(e3);
      }
    });
    i3(start((e3) => {
      if (1 === e3 && !f3) {
        f3 = true;
        a2(1);
      } else if (0 === e3 && !f3 && n2 < r2) {
        a2(0);
      }
    }));
  };
}
function takeUntil(r2) {
  return (t2) => (i3) => {
    var a2 = e2;
    var f3 = e2;
    var n2 = false;
    t2((e3) => {
      if (n2) {
      } else if (0 === e3) {
        n2 = true;
        f3(1);
        i3(0);
      } else if (0 === e3.tag) {
        a2 = e3[0];
        r2((e4) => {
          if (0 === e4) {
          } else if (0 === e4.tag) {
            (f3 = e4[0])(0);
          } else {
            n2 = true;
            f3(1);
            a2(1);
            i3(0);
          }
        });
      } else {
        i3(e3);
      }
    });
    i3(start((e3) => {
      if (1 === e3 && !n2) {
        n2 = true;
        a2(1);
        f3(1);
      } else if (!n2) {
        a2(0);
      }
    }));
  };
}
function takeWhile(r2, t2) {
  return (i3) => (a2) => {
    var f3 = e2;
    var n2 = false;
    i3((e3) => {
      if (n2) {
      } else if (0 === e3) {
        n2 = true;
        a2(0);
      } else if (0 === e3.tag) {
        f3 = e3[0];
        a2(e3);
      } else if (!r2(e3[0])) {
        n2 = true;
        if (t2) {
          a2(e3);
        }
        a2(0);
        f3(1);
      } else {
        a2(e3);
      }
    });
  };
}
function lazy(e3) {
  return (r2) => e3()(r2);
}
function fromAsyncIterable(e3) {
  return (r2) => {
    var t2 = e3[asyncIteratorSymbol()] && e3[asyncIteratorSymbol()]() || e3;
    var i3 = false;
    var a2 = false;
    var f3 = false;
    var n2;
    r2(start(async (e4) => {
      if (1 === e4) {
        i3 = true;
        if (t2.return) {
          t2.return();
        }
      } else if (a2) {
        f3 = true;
      } else {
        for (f3 = a2 = true; f3 && !i3; ) {
          if ((n2 = await t2.next()).done) {
            i3 = true;
            if (t2.return) {
              await t2.return();
            }
            r2(0);
          } else {
            try {
              f3 = false;
              r2(push(n2.value));
            } catch (e5) {
              if (t2.throw) {
                if (i3 = !!(await t2.throw(e5)).done) {
                  r2(0);
                }
              } else {
                throw e5;
              }
            }
          }
        }
        a2 = false;
      }
    }));
  };
}
function fromIterable(e3) {
  if (e3[Symbol.asyncIterator]) {
    return fromAsyncIterable(e3);
  }
  return (r2) => {
    var t2 = e3[Symbol.iterator]();
    var i3 = false;
    var a2 = false;
    var f3 = false;
    var n2;
    r2(start((e4) => {
      if (1 === e4) {
        i3 = true;
        if (t2.return) {
          t2.return();
        }
      } else if (a2) {
        f3 = true;
      } else {
        for (f3 = a2 = true; f3 && !i3; ) {
          if ((n2 = t2.next()).done) {
            i3 = true;
            if (t2.return) {
              t2.return();
            }
            r2(0);
          } else {
            try {
              f3 = false;
              r2(push(n2.value));
            } catch (e5) {
              if (t2.throw) {
                if (i3 = !!t2.throw(e5).done) {
                  r2(0);
                }
              } else {
                throw e5;
              }
            }
          }
        }
        a2 = false;
      }
    }));
  };
}
var r = fromIterable;
function fromValue(e3) {
  return (r2) => {
    var t2 = false;
    r2(start((i3) => {
      if (1 === i3) {
        t2 = true;
      } else if (!t2) {
        t2 = true;
        r2(push(e3));
        r2(0);
      }
    }));
  };
}
function make(e3) {
  return (r2) => {
    var t2 = false;
    var i3 = e3({
      next(e4) {
        if (!t2) {
          r2(push(e4));
        }
      },
      complete() {
        if (!t2) {
          t2 = true;
          r2(0);
        }
      }
    });
    r2(start((e4) => {
      if (1 === e4 && !t2) {
        t2 = true;
        i3();
      }
    }));
  };
}
function makeSubject() {
  var e3;
  var r2;
  return {
    source: share(make((t2) => {
      e3 = t2.next;
      r2 = t2.complete;
      return teardownPlaceholder;
    })),
    next(r3) {
      if (e3) {
        e3(r3);
      }
    },
    complete() {
      if (r2) {
        r2();
      }
    }
  };
}
function subscribe2(r2) {
  return (t2) => {
    var i3 = e2;
    var a2 = false;
    t2((e3) => {
      if (0 === e3) {
        a2 = true;
      } else if (0 === e3.tag) {
        (i3 = e3[0])(0);
      } else if (!a2) {
        r2(e3[0]);
        i3(0);
      }
    });
    return {
      unsubscribe() {
        if (!a2) {
          a2 = true;
          i3(1);
        }
      }
    };
  };
}
function publish(e3) {
  subscribe2((e4) => {
  })(e3);
}
function toPromise(r2) {
  return new Promise((t2) => {
    var i3 = e2;
    var a2;
    r2((e3) => {
      if (0 === e3) {
        Promise.resolve(a2).then(t2);
      } else if (0 === e3.tag) {
        (i3 = e3[0])(0);
      } else {
        a2 = e3[0];
        i3(0);
      }
    });
  });
}

// node_modules/@urql/core/dist/urql-core-chunk.mjs
var rehydrateGraphQlError = (r2) => {
  if (r2 && "string" == typeof r2.message && (r2.extensions || "GraphQLError" === r2.name)) {
    return r2;
  } else if ("object" == typeof r2 && "string" == typeof r2.message) {
    return new GraphQLError2(r2.message, r2.nodes, r2.source, r2.positions, r2.path, r2, r2.extensions || {});
  } else {
    return new GraphQLError2(r2);
  }
};
var CombinedError = class extends Error {
  constructor(e3) {
    var r2 = (e3.graphQLErrors || []).map(rehydrateGraphQlError);
    var t2 = ((e4, r3) => {
      var t3 = "";
      if (e4) {
        return `[Network] ${e4.message}`;
      }
      if (r3) {
        for (var a2 = 0, n2 = r3.length; a2 < n2; a2++) {
          if (t3) {
            t3 += "\n";
          }
          t3 += `[GraphQL] ${r3[a2].message}`;
        }
      }
      return t3;
    })(e3.networkError, r2);
    super(t2);
    this.name = "CombinedError";
    this.message = t2;
    this.graphQLErrors = r2;
    this.networkError = e3.networkError;
    this.response = e3.response;
  }
  toString() {
    return this.message;
  }
};
var phash = (e3, r2) => {
  var t2 = 0 | (r2 || 5381);
  for (var a2 = 0, n2 = 0 | e3.length; a2 < n2; a2++) {
    t2 = (t2 << 5) + t2 + e3.charCodeAt(a2);
  }
  return t2;
};
var i2 = /* @__PURE__ */ new Set();
var f2 = /* @__PURE__ */ new WeakMap();
var stringify = (e3, r2) => {
  if (null === e3 || i2.has(e3)) {
    return "null";
  } else if ("object" != typeof e3) {
    return JSON.stringify(e3) || "";
  } else if (e3.toJSON) {
    return stringify(e3.toJSON(), r2);
  } else if (Array.isArray(e3)) {
    var t2 = "[";
    for (var a2 = 0, n2 = e3.length; a2 < n2; a2++) {
      if (t2.length > 1) {
        t2 += ",";
      }
      t2 += stringify(e3[a2], r2) || "null";
    }
    return t2 += "]";
  } else if (!r2 && (d2 !== NoopConstructor && e3 instanceof d2 || l !== NoopConstructor && e3 instanceof l)) {
    return "null";
  }
  var o2 = Object.keys(e3).sort();
  if (!o2.length && e3.constructor && Object.getPrototypeOf(e3).constructor !== Object.prototype.constructor) {
    var s = f2.get(e3) || Math.random().toString(36).slice(2);
    f2.set(e3, s);
    return stringify({
      __key: s
    }, r2);
  }
  i2.add(e3);
  var c2 = "{";
  for (var v2 = 0, u3 = o2.length; v2 < u3; v2++) {
    var p2 = stringify(e3[o2[v2]], r2);
    if (p2) {
      if (c2.length > 1) {
        c2 += ",";
      }
      c2 += stringify(o2[v2], r2) + ":" + p2;
    }
  }
  i2.delete(e3);
  return c2 += "}";
};
var extract = (e3, r2, t2) => {
  if (null == t2 || "object" != typeof t2 || t2.toJSON || i2.has(t2)) {
  } else if (Array.isArray(t2)) {
    for (var a2 = 0, n2 = t2.length; a2 < n2; a2++) {
      extract(e3, `${r2}.${a2}`, t2[a2]);
    }
  } else if (t2 instanceof d2 || t2 instanceof l) {
    e3.set(r2, t2);
  } else {
    i2.add(t2);
    for (var o2 in t2) {
      extract(e3, `${r2}.${o2}`, t2[o2]);
    }
  }
};
var stringifyVariables = (e3, r2) => {
  i2.clear();
  return stringify(e3, r2 || false);
};
var NoopConstructor = class {
};
var d2 = "undefined" != typeof File ? File : NoopConstructor;
var l = "undefined" != typeof Blob ? Blob : NoopConstructor;
var c = /("{3}[\s\S]*"{3}|"(?:\\.|[^"])*")/g;
var v = /(?:#[^\n\r]+)?(?:[\r\n]+|$)/g;
var replaceOutsideStrings = (e3, r2) => r2 % 2 == 0 ? e3.replace(v, "\n") : e3;
var sanitizeDocument = (e3) => e3.split(c).map(replaceOutsideStrings).join("").trim();
var u2 = /* @__PURE__ */ new Map();
var p = /* @__PURE__ */ new Map();
var stringifyDocument = (e3) => {
  var t2;
  if ("string" == typeof e3) {
    t2 = sanitizeDocument(e3);
  } else if (e3.loc && p.get(e3.__key) === e3) {
    t2 = e3.loc.source.body;
  } else {
    t2 = u2.get(e3) || sanitizeDocument(print2(e3));
    u2.set(e3, t2);
  }
  if ("string" != typeof e3 && !e3.loc) {
    e3.loc = {
      start: 0,
      end: t2.length,
      source: {
        body: t2,
        name: "gql",
        locationOffset: {
          line: 1,
          column: 1
        }
      }
    };
  }
  return t2;
};
var hashDocument = (e3) => {
  var r2;
  if (e3.documentId) {
    r2 = phash(e3.documentId);
  } else {
    r2 = phash(stringifyDocument(e3));
    if (e3.definitions) {
      var t2 = getOperationName(e3);
      if (t2) {
        r2 = phash(`
# ${t2}`, r2);
      }
    }
  }
  return r2;
};
var keyDocument = (e3) => {
  var r2;
  var t2;
  if ("string" == typeof e3) {
    r2 = hashDocument(e3);
    t2 = p.get(r2) || parse3(e3, {
      noLocation: true
    });
  } else {
    r2 = e3.__key || hashDocument(e3);
    t2 = p.get(r2) || e3;
  }
  if (!t2.loc) {
    stringifyDocument(t2);
  }
  t2.__key = r2;
  p.set(r2, t2);
  return t2;
};
var createRequest = (e3, r2, t2) => {
  var a2 = r2 || {};
  var n2 = keyDocument(e3);
  var o2 = stringifyVariables(a2, true);
  var s = n2.__key;
  if ("{}" !== o2) {
    s = phash(o2, s);
  }
  return {
    key: s,
    query: n2,
    variables: a2,
    extensions: t2
  };
};
var getOperationName = (e3) => {
  for (var r2 = 0, a2 = e3.definitions.length; r2 < a2; r2++) {
    var n2 = e3.definitions[r2];
    if (n2.kind === e.OPERATION_DEFINITION) {
      return n2.name ? n2.name.value : void 0;
    }
  }
};
var getOperationType = (e3) => {
  for (var r2 = 0, a2 = e3.definitions.length; r2 < a2; r2++) {
    var n2 = e3.definitions[r2];
    if (n2.kind === e.OPERATION_DEFINITION) {
      return n2.operation;
    }
  }
};
var makeResult = (e3, r2, t2) => {
  if (!("data" in r2 || "errors" in r2 && Array.isArray(r2.errors))) {
    throw new Error("No Content");
  }
  var a2 = "subscription" === e3.kind;
  return {
    operation: e3,
    data: r2.data,
    error: Array.isArray(r2.errors) ? new CombinedError({
      graphQLErrors: r2.errors,
      response: t2
    }) : void 0,
    extensions: r2.extensions ? {
      ...r2.extensions
    } : void 0,
    hasNext: null == r2.hasNext ? a2 : r2.hasNext,
    stale: false
  };
};
var deepMerge = (e3, r2) => {
  if ("object" == typeof e3 && null != e3) {
    if (Array.isArray(e3)) {
      e3 = [...e3];
      for (var t2 = 0, a2 = r2.length; t2 < a2; t2++) {
        e3[t2] = deepMerge(e3[t2], r2[t2]);
      }
      return e3;
    }
    if (!e3.constructor || e3.constructor === Object) {
      e3 = {
        ...e3
      };
      for (var n2 in r2) {
        e3[n2] = deepMerge(e3[n2], r2[n2]);
      }
      return e3;
    }
  }
  return r2;
};
var mergeResultPatch = (e3, r2, t2, a2) => {
  var n2 = e3.error ? e3.error.graphQLErrors : [];
  var o2 = !!e3.extensions || !!(r2.payload || r2).extensions;
  var s = {
    ...e3.extensions,
    ...(r2.payload || r2).extensions
  };
  var i3 = r2.incremental;
  if ("path" in r2) {
    i3 = [r2];
  }
  var f3 = {
    data: e3.data
  };
  if (i3) {
    var _loop = function() {
      var e4 = i3[d3];
      if (Array.isArray(e4.errors)) {
        n2.push(...e4.errors);
      }
      if (e4.extensions) {
        Object.assign(s, e4.extensions);
        o2 = true;
      }
      var r3 = "data";
      var t3 = f3;
      var l3 = [];
      if (e4.path) {
        l3 = e4.path;
      } else if (a2) {
        var c2 = a2.find((r4) => r4.id === e4.id);
        if (e4.subPath) {
          l3 = [...c2.path, ...e4.subPath];
        } else {
          l3 = c2.path;
        }
      }
      for (var v2 = 0, u3 = l3.length; v2 < u3; r3 = l3[v2++]) {
        t3 = t3[r3] = Array.isArray(t3[r3]) ? [...t3[r3]] : {
          ...t3[r3]
        };
      }
      if (e4.items) {
        var p2 = +r3 >= 0 ? r3 : 0;
        for (var h2 = 0, y2 = e4.items.length; h2 < y2; h2++) {
          t3[p2 + h2] = deepMerge(t3[p2 + h2], e4.items[h2]);
        }
      } else if (void 0 !== e4.data) {
        t3[r3] = deepMerge(t3[r3], e4.data);
      }
    };
    for (var d3 = 0, l2 = i3.length; d3 < l2; d3++) {
      _loop();
    }
  } else {
    f3.data = (r2.payload || r2).data || e3.data;
    n2 = r2.errors || r2.payload && r2.payload.errors || n2;
  }
  return {
    operation: e3.operation,
    data: f3.data,
    error: n2.length ? new CombinedError({
      graphQLErrors: n2,
      response: t2
    }) : void 0,
    extensions: o2 ? s : void 0,
    hasNext: null != r2.hasNext ? r2.hasNext : e3.hasNext,
    stale: false
  };
};
var makeErrorResult = (e3, r2, t2) => ({
  operation: e3,
  data: void 0,
  error: new CombinedError({
    networkError: r2,
    response: t2
  }),
  extensions: void 0,
  hasNext: false,
  stale: false
});
function makeFetchBody(e3) {
  var r2 = {
    query: void 0,
    documentId: void 0,
    operationName: getOperationName(e3.query),
    variables: e3.variables || void 0,
    extensions: e3.extensions
  };
  if ("documentId" in e3.query && e3.query.documentId && (!e3.query.definitions || !e3.query.definitions.length)) {
    r2.documentId = e3.query.documentId;
  } else if (!e3.extensions || !e3.extensions.persistedQuery || e3.extensions.persistedQuery.miss) {
    r2.query = stringifyDocument(e3.query);
  }
  return r2;
}
var makeFetchURL = (e3, r2) => {
  var t2 = "query" === e3.kind && e3.context.preferGetMethod;
  if (!t2 || !r2) {
    return e3.context.url;
  }
  var a2 = splitOutSearchParams(e3.context.url);
  for (var n2 in r2) {
    var o2 = r2[n2];
    if (o2) {
      a2[1].set(n2, "object" == typeof o2 ? stringifyVariables(o2) : o2);
    }
  }
  var s = a2.join("?");
  if (s.length > 2047 && "force" !== t2) {
    e3.context.preferGetMethod = false;
    return e3.context.url;
  }
  return s;
};
var splitOutSearchParams = (e3) => {
  var r2 = e3.indexOf("?");
  return r2 > -1 ? [e3.slice(0, r2), new URLSearchParams(e3.slice(r2 + 1))] : [e3, new URLSearchParams()];
};
var serializeBody = (e3, r2) => {
  if (r2 && !("query" === e3.kind && !!e3.context.preferGetMethod)) {
    var t2 = stringifyVariables(r2);
    var a2 = ((e4) => {
      var r3 = /* @__PURE__ */ new Map();
      if (d2 !== NoopConstructor || l !== NoopConstructor) {
        i2.clear();
        extract(r3, "variables", e4);
      }
      return r3;
    })(r2.variables);
    if (a2.size) {
      var n2 = new FormData();
      n2.append("operations", t2);
      n2.append("map", stringifyVariables({
        ...[...a2.keys()].map((e4) => [e4])
      }));
      var o2 = 0;
      for (var s of a2.values()) {
        n2.append("" + o2++, s);
      }
      return n2;
    }
    return t2;
  }
};
var makeFetchOptions = (e3, r2) => {
  var t2 = {
    accept: "subscription" === e3.kind ? "text/event-stream, multipart/mixed" : "application/graphql-response+json, application/graphql+json, application/json, text/event-stream, multipart/mixed"
  };
  var a2 = ("function" == typeof e3.context.fetchOptions ? e3.context.fetchOptions() : e3.context.fetchOptions) || {};
  if (a2.headers) {
    if (((e4) => "has" in e4 && !Object.keys(e4).length)(a2.headers)) {
      a2.headers.forEach((e4, r3) => {
        t2[r3] = e4;
      });
    } else if (Array.isArray(a2.headers)) {
      a2.headers.forEach((e4, r3) => {
        if (Array.isArray(e4)) {
          if (t2[e4[0]]) {
            t2[e4[0]] = `${t2[e4[0]]},${e4[1]}`;
          } else {
            t2[e4[0]] = e4[1];
          }
        } else {
          t2[r3] = e4;
        }
      });
    } else {
      for (var n2 in a2.headers) {
        t2[n2.toLowerCase()] = a2.headers[n2];
      }
    }
  }
  var o2 = serializeBody(e3, r2);
  if ("string" == typeof o2 && !t2["content-type"]) {
    t2["content-type"] = "application/json";
  }
  return {
    ...a2,
    method: o2 ? "POST" : "GET",
    body: o2,
    headers: t2
  };
};
var h = /boundary="?([^=";]+)"?/i;
var y = /data: ?([^\n]+)/;
async function* streamBody(e3) {
  if (e3.body[Symbol.asyncIterator]) {
    for await (var r2 of e3.body) {
      yield r2;
    }
  } else {
    var t2 = e3.body.getReader();
    var a2;
    try {
      while (!(a2 = await t2.read()).done) {
        yield a2.value;
      }
    } finally {
      t2.cancel();
    }
  }
}
async function* streamToBoundedChunks(e3, r2) {
  var t2 = "undefined" != typeof TextDecoder ? new TextDecoder() : null;
  var a2 = "";
  var n2;
  for await (var o2 of e3) {
    a2 += "Buffer" === o2.constructor.name ? o2.toString() : t2.decode(o2, {
      stream: true
    });
    while ((n2 = a2.indexOf(r2)) > -1) {
      yield a2.slice(0, n2);
      a2 = a2.slice(n2 + r2.length);
    }
  }
}
async function* fetchOperation(e3, r2, t2) {
  var a2 = true;
  var n2 = null;
  var o2;
  try {
    yield await Promise.resolve();
    var s = (o2 = await (e3.context.fetch || fetch)(r2, t2)).headers.get("Content-Type") || "";
    var i3;
    if (/multipart\/mixed/i.test(s)) {
      i3 = async function* parseMultipartMixed(e4, r3) {
        var t3 = e4.match(h);
        var a3 = "--" + (t3 ? t3[1] : "-");
        var n3 = true;
        var o3;
        for await (var s2 of streamToBoundedChunks(streamBody(r3), "\r\n" + a3)) {
          if (n3) {
            n3 = false;
            var i4 = s2.indexOf(a3);
            if (i4 > -1) {
              s2 = s2.slice(i4 + a3.length);
            } else {
              continue;
            }
          }
          try {
            yield o3 = JSON.parse(s2.slice(s2.indexOf("\r\n\r\n") + 4));
          } catch (e5) {
            if (!o3) {
              throw e5;
            }
          }
          if (o3 && false === o3.hasNext) {
            break;
          }
        }
        if (o3 && false !== o3.hasNext) {
          yield {
            hasNext: false
          };
        }
      }(s, o2);
    } else if (/text\/event-stream/i.test(s)) {
      i3 = async function* parseEventStream(e4) {
        var r3;
        for await (var t3 of streamToBoundedChunks(streamBody(e4), "\n\n")) {
          var a3 = t3.match(y);
          if (a3) {
            var n3 = a3[1];
            try {
              yield r3 = JSON.parse(n3);
            } catch (e5) {
              if (!r3) {
                throw e5;
              }
            }
            if (r3 && false === r3.hasNext) {
              break;
            }
          }
        }
        if (r3 && false !== r3.hasNext) {
          yield {
            hasNext: false
          };
        }
      }(o2);
    } else if (!/text\//i.test(s)) {
      i3 = async function* parseJSON(e4) {
        yield JSON.parse(await e4.text());
      }(o2);
    } else {
      i3 = async function* parseMaybeJSON(e4) {
        var r3 = await e4.text();
        try {
          var t3 = JSON.parse(r3);
          if (true) {
            console.warn('Found response with content-type "text/plain" but it had a valid "application/json" response.');
          }
          yield t3;
        } catch (e5) {
          throw new Error(r3);
        }
      }(o2);
    }
    var f3;
    for await (var d3 of i3) {
      if (d3.pending && !n2) {
        f3 = d3.pending;
      } else if (d3.pending) {
        f3 = [...f3, ...d3.pending];
      }
      n2 = n2 ? mergeResultPatch(n2, d3, o2, f3) : makeResult(e3, d3, o2);
      a2 = false;
      yield n2;
      a2 = true;
    }
    if (!n2) {
      yield n2 = makeResult(e3, {}, o2);
    }
  } catch (r3) {
    if (!a2) {
      throw r3;
    }
    yield makeErrorResult(e3, o2 && (o2.status < 200 || o2.status >= 300) && o2.statusText ? new Error(o2.statusText) : r3, o2);
  }
}
function makeFetchSource(e3, r2, t2) {
  var a2;
  if ("undefined" != typeof AbortController) {
    t2.signal = (a2 = new AbortController()).signal;
  }
  return onEnd(() => {
    if (a2) {
      a2.abort();
    }
  })(filter((e4) => !!e4)(fromAsyncIterable(fetchOperation(e3, r2, t2))));
}

// node_modules/@urql/core/dist/urql-core.mjs
var collectTypes = (e3, r2) => {
  if (Array.isArray(e3)) {
    for (var t2 = 0, n2 = e3.length; t2 < n2; t2++) {
      collectTypes(e3[t2], r2);
    }
  } else if ("object" == typeof e3 && null !== e3) {
    for (var a2 in e3) {
      if ("__typename" === a2 && "string" == typeof e3[a2]) {
        r2.add(e3[a2]);
      } else {
        collectTypes(e3[a2], r2);
      }
    }
  }
  return r2;
};
var formatNode = (r2) => {
  if ("definitions" in r2) {
    var t2 = [];
    for (var n2 = 0, a2 = r2.definitions.length; n2 < a2; n2++) {
      var i3 = formatNode(r2.definitions[n2]);
      t2.push(i3);
    }
    return {
      ...r2,
      definitions: t2
    };
  }
  if ("directives" in r2 && r2.directives && r2.directives.length) {
    var o2 = [];
    var s = {};
    for (var c2 = 0, u3 = r2.directives.length; c2 < u3; c2++) {
      var p2 = r2.directives[c2];
      var d3 = p2.name.value;
      if ("_" !== d3[0]) {
        o2.push(p2);
      } else {
        d3 = d3.slice(1);
      }
      s[d3] = p2;
    }
    r2 = {
      ...r2,
      directives: o2,
      _directives: s
    };
  }
  if ("selectionSet" in r2) {
    var v2 = [];
    var l2 = r2.kind === e.OPERATION_DEFINITION;
    if (r2.selectionSet) {
      for (var f3 = 0, h2 = r2.selectionSet.selections.length; f3 < h2; f3++) {
        var k = r2.selectionSet.selections[f3];
        l2 = l2 || k.kind === e.FIELD && "__typename" === k.name.value && !k.alias;
        var y2 = formatNode(k);
        v2.push(y2);
      }
      if (!l2) {
        v2.push({
          kind: e.FIELD,
          name: {
            kind: e.NAME,
            value: "__typename"
          },
          _generated: true
        });
      }
      return {
        ...r2,
        selectionSet: {
          ...r2.selectionSet,
          selections: v2
        }
      };
    }
  }
  return r2;
};
var I = /* @__PURE__ */ new Map();
var formatDocument = (e3) => {
  var t2 = keyDocument(e3);
  var n2 = I.get(t2.__key);
  if (!n2) {
    I.set(t2.__key, n2 = formatNode(t2));
    Object.defineProperty(n2, "__key", {
      value: t2.__key,
      enumerable: false
    });
  }
  return n2;
};
function withPromise(e3) {
  var source$ = (r2) => e3(r2);
  source$.toPromise = () => toPromise(take(1)(filter((e4) => !e4.stale && !e4.hasNext)(source$)));
  source$.then = (e4, r2) => source$.toPromise().then(e4, r2);
  source$.subscribe = (e4) => subscribe2(e4)(source$);
  return source$;
}
function makeOperation(e3, r2, t2) {
  return {
    ...r2,
    kind: e3,
    context: r2.context ? {
      ...r2.context,
      ...t2
    } : t2 || r2.context
  };
}
var addMetadata = (e3, r2) => makeOperation(e3.kind, e3, {
  meta: {
    ...e3.context.meta,
    ...r2
  }
});
var noop = () => {
};
var shouldSkip = ({ kind: e3 }) => "mutation" !== e3 && "query" !== e3;
var mapTypeNames = (e3) => {
  var r2 = formatDocument(e3.query);
  if (r2 !== e3.query) {
    var t2 = makeOperation(e3.kind, e3);
    t2.query = r2;
    return t2;
  } else {
    return e3;
  }
};
var cacheExchange = ({ forward: e3, client: r2, dispatchDebug: t2 }) => {
  var a2 = /* @__PURE__ */ new Map();
  var i3 = /* @__PURE__ */ new Map();
  var isOperationCached = (e4) => "query" === e4.kind && "network-only" !== e4.context.requestPolicy && ("cache-only" === e4.context.requestPolicy || a2.has(e4.key));
  return (o2) => {
    var s = map((e4) => {
      var i4 = a2.get(e4.key);
      t2({
        operation: e4,
        ...i4 ? {
          type: "cacheHit",
          message: "The result was successfully retrieved from the cache"
        } : {
          type: "cacheMiss",
          message: "The result could not be retrieved from the cache"
        },
        source: "cacheExchange"
      });
      var o3 = i4 || makeResult(e4, {
        data: null
      });
      o3 = {
        ...o3,
        operation: addMetadata(e4, {
          cacheOutcome: i4 ? "hit" : "miss"
        })
      };
      if ("cache-and-network" === e4.context.requestPolicy) {
        o3.stale = true;
        reexecuteOperation(r2, e4);
      }
      return o3;
    })(filter((e4) => !shouldSkip(e4) && isOperationCached(e4))(o2));
    var c2 = onPush((e4) => {
      var { operation: n2 } = e4;
      if (!n2) {
        return;
      }
      var o3 = n2.context.additionalTypenames || [];
      if ("subscription" !== e4.operation.kind) {
        o3 = ((e5) => [...collectTypes(e5, /* @__PURE__ */ new Set())])(e4.data).concat(o3);
      }
      if ("mutation" === e4.operation.kind || "subscription" === e4.operation.kind) {
        var s2 = /* @__PURE__ */ new Set();
        t2({
          type: "cacheInvalidation",
          message: `The following typenames have been invalidated: ${o3}`,
          operation: n2,
          data: {
            typenames: o3,
            response: e4
          },
          source: "cacheExchange"
        });
        for (var c3 = 0; c3 < o3.length; c3++) {
          var u3 = o3[c3];
          var p2 = i3.get(u3);
          if (!p2) {
            i3.set(u3, p2 = /* @__PURE__ */ new Set());
          }
          for (var d3 of p2.values()) {
            s2.add(d3);
          }
          p2.clear();
        }
        for (var v2 of s2.values()) {
          if (a2.has(v2)) {
            n2 = a2.get(v2).operation;
            a2.delete(v2);
            reexecuteOperation(r2, n2);
          }
        }
      } else if ("query" === n2.kind && e4.data) {
        a2.set(n2.key, e4);
        for (var l2 = 0; l2 < o3.length; l2++) {
          var f3 = o3[l2];
          var h2 = i3.get(f3);
          if (!h2) {
            i3.set(f3, h2 = /* @__PURE__ */ new Set());
          }
          h2.add(n2.key);
        }
      }
    })(e3(filter((e4) => "query" !== e4.kind || "cache-only" !== e4.context.requestPolicy)(map((e4) => addMetadata(e4, {
      cacheOutcome: "miss"
    }))(merge([map(mapTypeNames)(filter((e4) => !shouldSkip(e4) && !isOperationCached(e4))(o2)), filter((e4) => shouldSkip(e4))(o2)])))));
    return merge([s, c2]);
  };
};
var reexecuteOperation = (e3, r2) => e3.reexecuteOperation(makeOperation(r2.kind, r2, {
  requestPolicy: "network-only"
}));
var fetchExchange = ({ forward: e3, dispatchDebug: r2 }) => (t2) => {
  var n2 = mergeMap((e4) => {
    var n3 = makeFetchBody(e4);
    var a3 = makeFetchURL(e4, n3);
    var i3 = makeFetchOptions(e4, n3);
    r2({
      type: "fetchRequest",
      message: "A fetch request is being executed.",
      operation: e4,
      data: {
        url: a3,
        fetchOptions: i3
      },
      source: "fetchExchange"
    });
    var s = takeUntil(filter((r3) => "teardown" === r3.kind && r3.key === e4.key)(t2))(makeFetchSource(e4, a3, i3));
    if (true) {
      return onPush((t3) => {
        var n4 = !t3.data ? t3.error : void 0;
        r2({
          type: n4 ? "fetchError" : "fetchSuccess",
          message: `A ${n4 ? "failed" : "successful"} fetch response has been returned.`,
          operation: e4,
          data: {
            url: a3,
            fetchOptions: i3,
            value: n4 || t3
          },
          source: "fetchExchange"
        });
      })(s);
    }
    return s;
  })(filter((e4) => "teardown" !== e4.kind && ("subscription" !== e4.kind || !!e4.context.fetchSubscriptions))(t2));
  var a2 = e3(filter((e4) => "teardown" === e4.kind || "subscription" === e4.kind && !e4.context.fetchSubscriptions)(t2));
  return merge([n2, a2]);
};
var composeExchanges = (e3) => ({ client: r2, forward: t2, dispatchDebug: n2 }) => e3.reduceRight((e4, t3) => {
  var a2 = false;
  return t3({
    client: r2,
    forward(r3) {
      if (true) {
        if (a2) {
          throw new Error("forward() must only be called once in each Exchange.");
        }
        a2 = true;
      }
      return share(e4(share(r3)));
    },
    dispatchDebug(e5) {
      n2({
        timestamp: Date.now(),
        source: t3.name,
        ...e5
      });
    }
  });
}, t2);
var fallbackExchange = ({ dispatchDebug: e3 }) => (r2) => {
  if (true) {
    r2 = onPush((r3) => {
      if ("teardown" !== r3.kind && true) {
        var t2 = `No exchange has handled operations of kind "${r3.kind}". Check whether you've added an exchange responsible for these operations.`;
        e3({
          type: "fallbackCatch",
          message: t2,
          operation: r3,
          source: "fallbackExchange"
        });
        console.warn(t2);
      }
    })(r2);
  }
  return filter((e4) => false)(r2);
};
var C = function Client(e3) {
  if (!e3.url) {
    throw new Error("You are creating an urql-client without a url.");
  }
  var r2 = 0;
  var t2 = /* @__PURE__ */ new Map();
  var n2 = /* @__PURE__ */ new Map();
  var a2 = /* @__PURE__ */ new Set();
  var i3 = [];
  var o2 = {
    url: e3.url,
    fetchSubscriptions: e3.fetchSubscriptions,
    fetchOptions: e3.fetchOptions,
    fetch: e3.fetch,
    preferGetMethod: e3.preferGetMethod,
    requestPolicy: e3.requestPolicy || "cache-first"
  };
  var s = makeSubject();
  function nextOperation(e4) {
    if ("mutation" === e4.kind || "teardown" === e4.kind || !a2.has(e4.key)) {
      if ("teardown" === e4.kind) {
        a2.delete(e4.key);
      } else if ("mutation" !== e4.kind) {
        a2.add(e4.key);
      }
      s.next(e4);
    }
  }
  var c2 = false;
  function dispatchOperation(e4) {
    if (e4) {
      nextOperation(e4);
    }
    if (!c2) {
      c2 = true;
      while (c2 && (e4 = i3.shift())) {
        nextOperation(e4);
      }
      c2 = false;
    }
  }
  var makeResultSource = (e4) => {
    var r3 = takeUntil(filter((r4) => "teardown" === r4.kind && r4.key === e4.key)(s.source))(filter((r4) => r4.operation.kind === e4.kind && r4.operation.key === e4.key && (!r4.operation.context._instance || r4.operation.context._instance === e4.context._instance))(E));
    if ("query" !== e4.kind) {
      r3 = takeWhile((e5) => !!e5.hasNext, true)(r3);
    } else {
      r3 = switchMap((r4) => {
        var t3 = fromValue(r4);
        return r4.stale || r4.hasNext ? t3 : merge([t3, map(() => {
          r4.stale = true;
          return r4;
        })(take(1)(filter((r5) => r5.key === e4.key)(s.source)))]);
      })(r3);
    }
    if ("mutation" !== e4.kind) {
      r3 = onEnd(() => {
        a2.delete(e4.key);
        t2.delete(e4.key);
        n2.delete(e4.key);
        c2 = false;
        for (var r4 = i3.length - 1; r4 >= 0; r4--) {
          if (i3[r4].key === e4.key) {
            i3.splice(r4, 1);
          }
        }
        nextOperation(makeOperation("teardown", e4, e4.context));
      })(onPush((r4) => {
        if (r4.stale) {
          if (!r4.hasNext) {
            a2.delete(e4.key);
          } else {
            for (var n3 = 0; n3 < i3.length; n3++) {
              var o3 = i3[n3];
              if (o3.key === r4.operation.key) {
                a2.delete(o3.key);
                break;
              }
            }
          }
        } else if (!r4.hasNext) {
          a2.delete(e4.key);
        }
        t2.set(e4.key, r4);
      })(r3));
    } else {
      r3 = onStart(() => {
        nextOperation(e4);
      })(r3);
    }
    return share(r3);
  };
  var u3 = this instanceof Client ? this : Object.create(Client.prototype);
  var p2 = Object.assign(u3, {
    suspense: !!e3.suspense,
    operations$: s.source,
    reexecuteOperation(e4) {
      if ("teardown" === e4.kind) {
        dispatchOperation(e4);
      } else if ("mutation" === e4.kind) {
        i3.push(e4);
        Promise.resolve().then(dispatchOperation);
      } else if (n2.has(e4.key)) {
        var r3 = false;
        for (var t3 = 0; t3 < i3.length; t3++) {
          if (i3[t3].key === e4.key) {
            i3[t3] = e4;
            r3 = true;
          }
        }
        if (!(r3 || a2.has(e4.key) && "network-only" !== e4.context.requestPolicy)) {
          i3.push(e4);
          Promise.resolve().then(dispatchOperation);
        } else {
          a2.delete(e4.key);
          Promise.resolve().then(dispatchOperation);
        }
      }
    },
    createRequestOperation(e4, t3, n3) {
      if (!n3) {
        n3 = {};
      }
      var a3;
      if ("teardown" !== e4 && (a3 = getOperationType(t3.query)) !== e4) {
        throw new Error(`Expected operation of type "${e4}" but found "${a3}"`);
      }
      return makeOperation(e4, t3, {
        _instance: "mutation" === e4 ? r2 = r2 + 1 | 0 : void 0,
        ...o2,
        ...n3,
        requestPolicy: n3.requestPolicy || o2.requestPolicy,
        suspense: n3.suspense || false !== n3.suspense && p2.suspense
      });
    },
    executeRequestOperation(e4) {
      if ("mutation" === e4.kind) {
        return withPromise(makeResultSource(e4));
      }
      return withPromise(lazy(() => {
        var r3 = n2.get(e4.key);
        if (!r3) {
          n2.set(e4.key, r3 = makeResultSource(e4));
        }
        r3 = onStart(() => {
          dispatchOperation(e4);
        })(r3);
        var a3 = t2.get(e4.key);
        if ("query" === e4.kind && a3 && (a3.stale || a3.hasNext)) {
          return switchMap(fromValue)(merge([r3, filter((r4) => r4 === t2.get(e4.key))(fromValue(a3))]));
        } else {
          return r3;
        }
      }));
    },
    executeQuery(e4, r3) {
      var t3 = p2.createRequestOperation("query", e4, r3);
      return p2.executeRequestOperation(t3);
    },
    executeSubscription(e4, r3) {
      var t3 = p2.createRequestOperation("subscription", e4, r3);
      return p2.executeRequestOperation(t3);
    },
    executeMutation(e4, r3) {
      var t3 = p2.createRequestOperation("mutation", e4, r3);
      return p2.executeRequestOperation(t3);
    },
    readQuery(e4, r3, t3) {
      var n3 = null;
      subscribe2((e5) => {
        n3 = e5;
      })(p2.query(e4, r3, t3)).unsubscribe();
      return n3;
    },
    query: (e4, r3, t3) => p2.executeQuery(createRequest(e4, r3), t3),
    subscription: (e4, r3, t3) => p2.executeSubscription(createRequest(e4, r3), t3),
    mutation: (e4, r3, t3) => p2.executeMutation(createRequest(e4, r3), t3)
  });
  var d3 = noop;
  if (true) {
    var { next: f3, source: x } = makeSubject();
    p2.subscribeToDebugTarget = (e4) => subscribe2(e4)(x);
    d3 = f3;
  }
  var w = composeExchanges(e3.exchanges);
  var E = share(w({
    client: p2,
    dispatchDebug: d3,
    forward: fallbackExchange({
      dispatchDebug: d3
    })
  })(s.source));
  publish(E);
  return p2;
};

// node_modules/@copilotkit/runtime-client-gql/dist/chunk-SYV4LIDU.mjs
var version4 = "1.10.6";
var createFetchFn = (signal, handleGQLWarning) => async (...args) => {
  var _a2, _b2;
  const publicApiKey = (_b2 = (_a2 = args[1]) == null ? void 0 : _a2.headers) == null ? void 0 : _b2["x-copilotcloud-public-api-key"];
  try {
    const result = await fetch(args[0], { ...args[1] ?? {}, signal });
    const mismatch = publicApiKey ? null : await getPossibleVersionMismatch({
      runtimeVersion: result.headers.get("X-CopilotKit-Runtime-Version"),
      runtimeClientGqlVersion: version4
    });
    if (result.status !== 200) {
      if (result.status >= 400 && result.status <= 500) {
        if (mismatch) {
          throw new CopilotKitVersionMismatchError(mismatch);
        }
        throw new ResolvedCopilotKitError({ status: result.status });
      }
    }
    if (mismatch && handleGQLWarning) {
      handleGQLWarning(mismatch.message);
    }
    return result;
  } catch (error2) {
    if (error2.message.includes("BodyStreamBuffer was aborted") || error2.message.includes("signal is aborted without reason")) {
      throw error2;
    }
    if (error2 instanceof CopilotKitError) {
      throw error2;
    }
    throw new CopilotKitLowLevelError({ error: error2, url: args[0] });
  }
};
var CopilotRuntimeClient = class {
  constructor(options) {
    const headers = {};
    this.handleGQLErrors = options.handleGQLErrors;
    this.handleGQLWarning = options.handleGQLWarning;
    if (options.headers) {
      Object.assign(headers, options.headers);
    }
    if (options.publicApiKey) {
      headers["x-copilotcloud-public-api-key"] = options.publicApiKey;
    }
    this.client = new C({
      url: options.url,
      exchanges: [cacheExchange, fetchExchange],
      fetchOptions: {
        headers: {
          ...headers,
          "X-CopilotKit-Runtime-Client-GQL-Version": version4
        },
        ...options.credentials ? { credentials: options.credentials } : {}
      }
    });
  }
  generateCopilotResponse({
    data,
    properties,
    signal
  }) {
    const fetchFn = createFetchFn(signal, this.handleGQLWarning);
    const result = this.client.mutation(generateCopilotResponseMutation, { data, properties }, { fetch: fetchFn });
    return result;
  }
  asStream(source) {
    const handleGQLErrors = this.handleGQLErrors;
    return new ReadableStream({
      start(controller) {
        source.subscribe(({ data, hasNext, error: error2 }) => {
          var _a2;
          if (error2) {
            if (error2.message.includes("BodyStreamBuffer was aborted") || error2.message.includes("signal is aborted without reason")) {
              if (!hasNext)
                controller.close();
              console.warn("Abort error suppressed");
              return;
            }
            if ((_a2 = error2.extensions) == null ? void 0 : _a2.visibility) {
              const syntheticError = {
                ...error2,
                graphQLErrors: [
                  {
                    message: error2.message,
                    extensions: error2.extensions
                  }
                ]
              };
              if (handleGQLErrors) {
                handleGQLErrors(syntheticError);
              }
              return;
            }
            controller.error(error2);
            if (handleGQLErrors) {
              handleGQLErrors(error2);
            }
          } else {
            controller.enqueue(data);
            if (!hasNext) {
              controller.close();
            }
          }
        });
      }
    });
  }
  availableAgents() {
    const fetchFn = createFetchFn();
    return this.client.query(getAvailableAgentsQuery, {}, { fetch: fetchFn });
  }
  loadAgentState(data) {
    const fetchFn = createFetchFn();
    const result = this.client.query(
      loadAgentStateQuery,
      { data },
      { fetch: fetchFn }
    );
    result.toPromise().then(({ error: error2 }) => {
      if (error2 && this.handleGQLErrors) {
        this.handleGQLErrors(error2);
      }
    }).catch(() => {
    });
    return result;
  }
  static removeGraphQLTypename(data) {
    if (Array.isArray(data)) {
      data.forEach((item) => CopilotRuntimeClient.removeGraphQLTypename(item));
    } else if (typeof data === "object" && data !== null) {
      delete data.__typename;
      Object.keys(data).forEach((key) => {
        if (typeof data[key] === "object" && data[key] !== null) {
          CopilotRuntimeClient.removeGraphQLTypename(data[key]);
        }
      });
    }
    return data;
  }
};

// node_modules/untruncate-json/dist/esm/index.js
function isWhitespace(char) {
  return " \r\n	".indexOf(char) >= 0;
}
function untruncateJson(json) {
  var contextStack = [
    "topLevel"
    /* TOP_LEVEL */
  ];
  var position4 = 0;
  var respawnPosition;
  var respawnStackLength;
  var respawnReason;
  var push3 = function(context) {
    return contextStack.push(context);
  };
  var replace = function(context) {
    return contextStack[contextStack.length - 1] = context;
  };
  var setRespawn = function(reason) {
    if (respawnPosition == null) {
      respawnPosition = position4;
      respawnStackLength = contextStack.length;
      respawnReason = reason;
    }
  };
  var clearRespawn = function(reason) {
    if (reason === respawnReason) {
      respawnPosition = void 0;
      respawnStackLength = void 0;
      respawnReason = void 0;
    }
  };
  var pop = function() {
    return contextStack.pop();
  };
  var dontConsumeCharacter = function() {
    return position4--;
  };
  var startAny = function(char2) {
    if ("0" <= char2 && char2 <= "9") {
      push3(
        "number"
        /* NUMBER */
      );
      return;
    }
    switch (char2) {
      case '"':
        push3(
          "string"
          /* STRING */
        );
        return;
      case "-":
        push3(
          "numberNeedsDigit"
          /* NUMBER_NEEDS_DIGIT */
        );
        return;
      case "t":
        push3(
          "true"
          /* TRUE */
        );
        return;
      case "f":
        push3(
          "false"
          /* FALSE */
        );
        return;
      case "n":
        push3(
          "null"
          /* NULL */
        );
        return;
      case "[":
        push3(
          "arrayNeedsValue"
          /* ARRAY_NEEDS_VALUE */
        );
        return;
      case "{":
        push3(
          "objectNeedsKey"
          /* OBJECT_NEEDS_KEY */
        );
        return;
    }
  };
  for (var length = json.length; position4 < length; position4++) {
    var char = json[position4];
    switch (contextStack[contextStack.length - 1]) {
      case "topLevel":
        startAny(char);
        break;
      case "string":
        switch (char) {
          case '"':
            pop();
            break;
          case "\\":
            setRespawn(
              "stringEscape"
              /* STRING_ESCAPE */
            );
            push3(
              "stringEscaped"
              /* STRING_ESCAPED */
            );
            break;
        }
        break;
      case "stringEscaped":
        if (char === "u") {
          push3(
            "stringUnicode"
            /* STRING_UNICODE */
          );
        } else {
          clearRespawn(
            "stringEscape"
            /* STRING_ESCAPE */
          );
          pop();
        }
        break;
      case "stringUnicode":
        if (position4 - json.lastIndexOf("u", position4) === 4) {
          clearRespawn(
            "stringEscape"
            /* STRING_ESCAPE */
          );
          pop();
        }
        break;
      case "number":
        if (char === ".") {
          replace(
            "numberNeedsDigit"
            /* NUMBER_NEEDS_DIGIT */
          );
        } else if (char === "e" || char === "E") {
          replace(
            "numberNeedsExponent"
            /* NUMBER_NEEDS_EXPONENT */
          );
        } else if (char < "0" || char > "9") {
          dontConsumeCharacter();
          pop();
        }
        break;
      case "numberNeedsDigit":
        replace(
          "number"
          /* NUMBER */
        );
        break;
      case "numberNeedsExponent":
        if (char === "+" || char === "-") {
          replace(
            "numberNeedsDigit"
            /* NUMBER_NEEDS_DIGIT */
          );
        } else {
          replace(
            "number"
            /* NUMBER */
          );
        }
        break;
      case "true":
      case "false":
      case "null":
        if (char < "a" || char > "z") {
          dontConsumeCharacter();
          pop();
        }
        break;
      case "arrayNeedsValue":
        if (char === "]") {
          pop();
        } else if (!isWhitespace(char)) {
          clearRespawn(
            "collectionItem"
            /* COLLECTION_ITEM */
          );
          replace(
            "arrayNeedsComma"
            /* ARRAY_NEEDS_COMMA */
          );
          startAny(char);
        }
        break;
      case "arrayNeedsComma":
        if (char === "]") {
          pop();
        } else if (char === ",") {
          setRespawn(
            "collectionItem"
            /* COLLECTION_ITEM */
          );
          replace(
            "arrayNeedsValue"
            /* ARRAY_NEEDS_VALUE */
          );
        }
        break;
      case "objectNeedsKey":
        if (char === "}") {
          pop();
        } else if (char === '"') {
          setRespawn(
            "collectionItem"
            /* COLLECTION_ITEM */
          );
          replace(
            "objectNeedsColon"
            /* OBJECT_NEEDS_COLON */
          );
          push3(
            "string"
            /* STRING */
          );
        }
        break;
      case "objectNeedsColon":
        if (char === ":") {
          replace(
            "objectNeedsValue"
            /* OBJECT_NEEDS_VALUE */
          );
        }
        break;
      case "objectNeedsValue":
        if (!isWhitespace(char)) {
          clearRespawn(
            "collectionItem"
            /* COLLECTION_ITEM */
          );
          replace(
            "objectNeedsComma"
            /* OBJECT_NEEDS_COMMA */
          );
          startAny(char);
        }
        break;
      case "objectNeedsComma":
        if (char === "}") {
          pop();
        } else if (char === ",") {
          setRespawn(
            "collectionItem"
            /* COLLECTION_ITEM */
          );
          replace(
            "objectNeedsKey"
            /* OBJECT_NEEDS_KEY */
          );
        }
        break;
    }
  }
  if (respawnStackLength != null) {
    contextStack.length = respawnStackLength;
  }
  var result = [
    respawnPosition != null ? json.slice(0, respawnPosition) : json
  ];
  var finishWord = function(word) {
    return result.push(word.slice(json.length - json.lastIndexOf(word[0])));
  };
  for (var i3 = contextStack.length - 1; i3 >= 0; i3--) {
    switch (contextStack[i3]) {
      case "string":
        result.push('"');
        break;
      case "numberNeedsDigit":
      case "numberNeedsExponent":
        result.push("0");
        break;
      case "true":
        finishWord("true");
        break;
      case "false":
        finishWord("false");
        break;
      case "null":
        finishWord("null");
        break;
      case "arrayNeedsValue":
      case "arrayNeedsComma":
        result.push("]");
        break;
      case "objectNeedsKey":
      case "objectNeedsColon":
      case "objectNeedsValue":
      case "objectNeedsComma":
        result.push("}");
        break;
    }
  }
  return result.join("");
}

// node_modules/@copilotkit/runtime-client-gql/dist/chunk-TDZBGVZB.mjs
function filterAgentStateMessages(messages) {
  return messages.filter((message2) => !message2.isAgentStateMessage());
}
function convertMessagesToGqlInput(messages) {
  return messages.map((message2) => {
    if (message2.isTextMessage()) {
      return {
        id: message2.id,
        createdAt: message2.createdAt,
        textMessage: {
          content: message2.content,
          role: message2.role,
          parentMessageId: message2.parentMessageId
        }
      };
    } else if (message2.isActionExecutionMessage()) {
      return {
        id: message2.id,
        createdAt: message2.createdAt,
        actionExecutionMessage: {
          name: message2.name,
          arguments: JSON.stringify(message2.arguments),
          parentMessageId: message2.parentMessageId
        }
      };
    } else if (message2.isResultMessage()) {
      return {
        id: message2.id,
        createdAt: message2.createdAt,
        resultMessage: {
          result: message2.result,
          actionExecutionId: message2.actionExecutionId,
          actionName: message2.actionName
        }
      };
    } else if (message2.isAgentStateMessage()) {
      return {
        id: message2.id,
        createdAt: message2.createdAt,
        agentStateMessage: {
          threadId: message2.threadId,
          role: message2.role,
          agentName: message2.agentName,
          nodeName: message2.nodeName,
          runId: message2.runId,
          active: message2.active,
          running: message2.running,
          state: JSON.stringify(message2.state)
        }
      };
    } else if (message2.isImageMessage()) {
      return {
        id: message2.id,
        createdAt: message2.createdAt,
        imageMessage: {
          format: message2.format,
          bytes: message2.bytes,
          role: message2.role,
          parentMessageId: message2.parentMessageId
        }
      };
    } else {
      throw new Error("Unknown message type");
    }
  });
}
function filterAdjacentAgentStateMessages(messages) {
  const filteredMessages = [];
  messages.forEach((message2, i3) => {
    if (message2.__typename !== "AgentStateMessageOutput") {
      filteredMessages.push(message2);
    } else {
      const prevAgentStateMessageIndex = filteredMessages.findIndex(
        // TODO: also check runId
        (m) => m.__typename === "AgentStateMessageOutput" && m.agentName === message2.agentName
      );
      if (prevAgentStateMessageIndex === -1) {
        filteredMessages.push(message2);
      } else {
        filteredMessages[prevAgentStateMessageIndex] = message2;
      }
    }
  });
  return filteredMessages;
}
function convertGqlOutputToMessages(messages) {
  return messages.map((message2) => {
    if (message2.__typename === "TextMessageOutput") {
      return new TextMessage({
        id: message2.id,
        role: message2.role,
        content: message2.content.join(""),
        parentMessageId: message2.parentMessageId,
        createdAt: /* @__PURE__ */ new Date(),
        status: message2.status || {
          code: "Pending"
          /* Pending */
        }
      });
    } else if (message2.__typename === "ActionExecutionMessageOutput") {
      return new ActionExecutionMessage({
        id: message2.id,
        name: message2.name,
        arguments: getPartialArguments(message2.arguments),
        parentMessageId: message2.parentMessageId,
        createdAt: /* @__PURE__ */ new Date(),
        status: message2.status || {
          code: "Pending"
          /* Pending */
        }
      });
    } else if (message2.__typename === "ResultMessageOutput") {
      return new ResultMessage({
        id: message2.id,
        result: message2.result,
        actionExecutionId: message2.actionExecutionId,
        actionName: message2.actionName,
        createdAt: /* @__PURE__ */ new Date(),
        status: message2.status || {
          code: "Pending"
          /* Pending */
        }
      });
    } else if (message2.__typename === "AgentStateMessageOutput") {
      return new AgentStateMessage({
        id: message2.id,
        threadId: message2.threadId,
        role: message2.role,
        agentName: message2.agentName,
        nodeName: message2.nodeName,
        runId: message2.runId,
        active: message2.active,
        running: message2.running,
        state: parseJson(message2.state, {}),
        createdAt: /* @__PURE__ */ new Date()
      });
    } else if (message2.__typename === "ImageMessageOutput") {
      return new ImageMessage({
        id: message2.id,
        format: message2.format,
        bytes: message2.bytes,
        role: message2.role,
        parentMessageId: message2.parentMessageId,
        createdAt: /* @__PURE__ */ new Date(),
        status: message2.status || {
          code: "Pending"
          /* Pending */
        }
      });
    }
    throw new Error("Unknown message type");
  });
}
function loadMessagesFromJsonRepresentation(json) {
  const result = [];
  for (const item of json) {
    if ("content" in item) {
      result.push(
        new TextMessage({
          id: item.id,
          role: item.role,
          content: item.content,
          parentMessageId: item.parentMessageId,
          createdAt: item.createdAt || /* @__PURE__ */ new Date(),
          status: item.status || {
            code: "Success"
            /* Success */
          }
        })
      );
    } else if ("arguments" in item) {
      result.push(
        new ActionExecutionMessage({
          id: item.id,
          name: item.name,
          arguments: item.arguments,
          parentMessageId: item.parentMessageId,
          createdAt: item.createdAt || /* @__PURE__ */ new Date(),
          status: item.status || {
            code: "Success"
            /* Success */
          }
        })
      );
    } else if ("result" in item) {
      result.push(
        new ResultMessage({
          id: item.id,
          result: item.result,
          actionExecutionId: item.actionExecutionId,
          actionName: item.actionName,
          createdAt: item.createdAt || /* @__PURE__ */ new Date(),
          status: item.status || {
            code: "Success"
            /* Success */
          }
        })
      );
    } else if ("state" in item) {
      result.push(
        new AgentStateMessage({
          id: item.id,
          threadId: item.threadId,
          role: item.role,
          agentName: item.agentName,
          nodeName: item.nodeName,
          runId: item.runId,
          active: item.active,
          running: item.running,
          state: item.state,
          createdAt: item.createdAt || /* @__PURE__ */ new Date()
        })
      );
    } else if ("format" in item && "bytes" in item) {
      result.push(
        new ImageMessage({
          id: item.id,
          format: item.format,
          bytes: item.bytes,
          role: item.role,
          parentMessageId: item.parentMessageId,
          createdAt: item.createdAt || /* @__PURE__ */ new Date(),
          status: item.status || {
            code: "Success"
            /* Success */
          }
        })
      );
    }
  }
  return result;
}
function getPartialArguments(args) {
  try {
    if (!args.length)
      return {};
    return JSON.parse(untruncateJson(args.join("")));
  } catch (e3) {
    return {};
  }
}

// node_modules/@copilotkit/react-core/dist/chunk-4CEQJ2X6.mjs
function processActionsForRuntimeRequest(actions) {
  const filteredActions = actions.filter(
    (action) => action.available !== ActionInputAvailability.Disabled && action.disabled !== true && action.name !== "*" && action.available != "frontend" && !action.pairedAction
  ).map((action) => {
    let available = ActionInputAvailability.Enabled;
    if (action.disabled) {
      available = ActionInputAvailability.Disabled;
    } else if (action.available === "disabled") {
      available = ActionInputAvailability.Disabled;
    } else if (action.available === "remote") {
      available = ActionInputAvailability.Remote;
    }
    return {
      name: action.name,
      description: action.description || "",
      jsonSchema: JSON.stringify(actionParametersToJsonSchema(action.parameters || [])),
      available
    };
  });
  return filteredActions;
}

// node_modules/@copilotkit/react-core/dist/chunk-ICIK2BSB.mjs
function isLocalhost() {
  if (typeof window === "undefined")
    return false;
  return window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1" || window.location.hostname === "0.0.0.0";
}
function shouldShowDevConsole(showDevConsole) {
  if (showDevConsole !== void 0) {
    return showDevConsole;
  }
  return isLocalhost();
}

// node_modules/@copilotkit/react-core/dist/chunk-SKC7AJIV.mjs
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a2, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b) => __defProps(a2, __getOwnPropDescs(b));
var __restKey = (key) => typeof key === "symbol" ? key : key + "";
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value2) => {
      try {
        step(generator.next(value2));
      } catch (e3) {
        reject(e3);
      }
    };
    var rejected = (value2) => {
      try {
        step(generator.throw(value2));
      } catch (e3) {
        reject(e3);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/@copilotkit/react-core/dist/chunk-EFL5OBKN.mjs
var import_react = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var ToastContext = (0, import_react.createContext)(void 0);
function getErrorSeverity(error2) {
  if (error2.severity) {
    switch (error2.severity) {
      case Severity.CRITICAL:
        return "critical";
      case Severity.WARNING:
        return "warning";
      case Severity.INFO:
        return "info";
      default:
        return "info";
    }
  }
  const message2 = error2.message.toLowerCase();
  if (message2.includes("api key") || message2.includes("401") || message2.includes("unauthorized") || message2.includes("authentication") || message2.includes("incorrect api key")) {
    return "critical";
  }
  return "info";
}
function getErrorColors(severity) {
  switch (severity) {
    case "critical":
      return {
        background: "#fee2e2",
        border: "#dc2626",
        text: "#7f1d1d",
        icon: "#dc2626"
      };
    case "warning":
      return {
        background: "#fef3c7",
        border: "#d97706",
        text: "#78350f",
        icon: "#d97706"
      };
    case "info":
      return {
        background: "#dbeafe",
        border: "#2563eb",
        text: "#1e3a8a",
        icon: "#2563eb"
      };
  }
}
function useToast() {
  const context = (0, import_react.useContext)(ToastContext);
  if (!context) {
    throw new Error("useToast must be used within a ToastProvider");
  }
  return context;
}
function ToastProvider({
  enabled,
  children
}) {
  const [toasts, setToasts] = (0, import_react.useState)([]);
  const [bannerError, setBannerErrorState] = (0, import_react.useState)(null);
  const removeToast = (0, import_react.useCallback)((id) => {
    setToasts((prev) => prev.filter((toast) => toast.id !== id));
  }, []);
  const addToast = (0, import_react.useCallback)(
    (toast) => {
      var _a2;
      if (!enabled) {
        return;
      }
      const id = (_a2 = toast.id) != null ? _a2 : Math.random().toString(36).substring(2, 9);
      setToasts((currentToasts) => {
        if (currentToasts.find((toast2) => toast2.id === id))
          return currentToasts;
        return [...currentToasts, __spreadProps(__spreadValues({}, toast), { id })];
      });
      if (toast.duration) {
        setTimeout(() => {
          removeToast(id);
        }, toast.duration);
      }
    },
    [enabled, removeToast]
  );
  const setBannerError = (0, import_react.useCallback)(
    (error2) => {
      if (!enabled && error2 !== null) {
        return;
      }
      setBannerErrorState(error2);
    },
    [enabled]
  );
  const addGraphQLErrorsToast = (0, import_react.useCallback)((errors) => {
    console.warn("addGraphQLErrorsToast is deprecated. All errors now show as banners.");
  }, []);
  const value2 = {
    toasts,
    addToast,
    addGraphQLErrorsToast,
    removeToast,
    enabled,
    bannerError,
    setBannerError
  };
  return (0, import_jsx_runtime.jsxs)(ToastContext.Provider, { value: value2, children: [
    bannerError && (() => {
      const severity = getErrorSeverity(bannerError);
      const colors2 = getErrorColors(severity);
      return (0, import_jsx_runtime.jsx)(
        "div",
        {
          style: {
            position: "fixed",
            bottom: "20px",
            left: "50%",
            transform: "translateX(-50%)",
            zIndex: 9999,
            backgroundColor: colors2.background,
            border: `1px solid ${colors2.border}`,
            borderLeft: `4px solid ${colors2.border}`,
            borderRadius: "8px",
            padding: "12px 16px",
            fontSize: "13px",
            boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
            backdropFilter: "blur(8px)",
            maxWidth: "min(90vw, 700px)",
            width: "100%",
            boxSizing: "border-box",
            overflow: "hidden"
          },
          children: (0, import_jsx_runtime.jsxs)(
            "div",
            {
              style: {
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                gap: "10px"
              },
              children: [
                (0, import_jsx_runtime.jsxs)(
                  "div",
                  {
                    style: {
                      display: "flex",
                      alignItems: "center",
                      gap: "8px",
                      flex: 1,
                      minWidth: 0
                    },
                    children: [
                      (0, import_jsx_runtime.jsx)(
                        "div",
                        {
                          style: {
                            width: "12px",
                            height: "12px",
                            borderRadius: "50%",
                            backgroundColor: colors2.border,
                            flexShrink: 0
                          }
                        }
                      ),
                      (0, import_jsx_runtime.jsxs)(
                        "div",
                        {
                          style: {
                            display: "flex",
                            alignItems: "center",
                            gap: "10px",
                            flex: 1,
                            minWidth: 0
                          },
                          children: [
                            (0, import_jsx_runtime.jsx)(
                              "div",
                              {
                                style: {
                                  color: colors2.text,
                                  lineHeight: "1.4",
                                  fontWeight: "400",
                                  fontSize: "13px",
                                  flex: 1,
                                  wordBreak: "break-all",
                                  overflowWrap: "break-word",
                                  maxWidth: "550px",
                                  overflow: "hidden",
                                  display: "-webkit-box",
                                  WebkitLineClamp: 10,
                                  WebkitBoxOrient: "vertical"
                                },
                                children: (() => {
                                  let message2 = bannerError.message;
                                  const jsonMatch = message2.match(/'message':\s*'([^']+)'/);
                                  if (jsonMatch) {
                                    return jsonMatch[1];
                                  }
                                  message2 = message2.split(" - ")[0];
                                  message2 = message2.split(": Error code")[0];
                                  message2 = message2.replace(/:\s*\d{3}$/, "");
                                  message2 = message2.replace(/See more:.*$/g, "");
                                  message2 = message2.trim();
                                  return message2 || "Configuration error occurred.";
                                })()
                              }
                            ),
                            (() => {
                              const message2 = bannerError.message;
                              const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
                              const plainUrlRegex = /(https?:\/\/[^\s)]+)/g;
                              let url = null;
                              let buttonText = "See More";
                              const markdownMatch = markdownLinkRegex.exec(message2);
                              if (markdownMatch) {
                                url = markdownMatch[2];
                                buttonText = "See More";
                              } else {
                                const urlMatch = plainUrlRegex.exec(message2);
                                if (urlMatch) {
                                  url = urlMatch[0].replace(/[.,;:'"]*$/, "");
                                  buttonText = "See More";
                                }
                              }
                              if (!url)
                                return null;
                              return (0, import_jsx_runtime.jsx)(
                                "button",
                                {
                                  onClick: () => window.open(url, "_blank", "noopener,noreferrer"),
                                  style: {
                                    background: colors2.border,
                                    color: "white",
                                    border: "none",
                                    borderRadius: "5px",
                                    padding: "4px 10px",
                                    fontSize: "11px",
                                    fontWeight: "500",
                                    cursor: "pointer",
                                    transition: "all 0.2s ease",
                                    flexShrink: 0
                                  },
                                  onMouseEnter: (e3) => {
                                    e3.currentTarget.style.opacity = "0.9";
                                    e3.currentTarget.style.transform = "translateY(-1px)";
                                  },
                                  onMouseLeave: (e3) => {
                                    e3.currentTarget.style.opacity = "1";
                                    e3.currentTarget.style.transform = "translateY(0)";
                                  },
                                  children: buttonText
                                }
                              );
                            })()
                          ]
                        }
                      )
                    ]
                  }
                ),
                (0, import_jsx_runtime.jsx)(
                  "button",
                  {
                    onClick: () => setBannerError(null),
                    style: {
                      background: "transparent",
                      border: "none",
                      color: colors2.text,
                      cursor: "pointer",
                      padding: "2px",
                      borderRadius: "3px",
                      fontSize: "14px",
                      lineHeight: "1",
                      opacity: 0.6,
                      transition: "all 0.2s ease",
                      flexShrink: 0
                    },
                    title: "Dismiss",
                    onMouseEnter: (e3) => {
                      e3.currentTarget.style.opacity = "1";
                      e3.currentTarget.style.background = "rgba(0, 0, 0, 0.05)";
                    },
                    onMouseLeave: (e3) => {
                      e3.currentTarget.style.opacity = "0.6";
                      e3.currentTarget.style.background = "transparent";
                    },
                    children: ""
                  }
                )
              ]
            }
          )
        }
      );
    })(),
    children
  ] });
}

// node_modules/@copilotkit/react-core/dist/chunk-EUX2P2E7.mjs
var import_react2 = __toESM(require_react(), 1);
var emptyCopilotContext = {
  actions: {},
  setAction: () => {
  },
  removeAction: () => {
  },
  coAgentStateRenders: {},
  setCoAgentStateRender: () => {
  },
  removeCoAgentStateRender: () => {
  },
  chatComponentsCache: { current: { actions: {}, coAgentStateRenders: {} } },
  getContextString: (documents2, categories) => returnAndThrowInDebug(""),
  addContext: () => "",
  removeContext: () => {
  },
  getAllContext: () => [],
  getFunctionCallHandler: () => returnAndThrowInDebug(() => __async(void 0, null, function* () {
  })),
  isLoading: false,
  setIsLoading: () => returnAndThrowInDebug(false),
  chatInstructions: "",
  setChatInstructions: () => returnAndThrowInDebug(""),
  additionalInstructions: [],
  setAdditionalInstructions: () => returnAndThrowInDebug([]),
  getDocumentsContext: (categories) => returnAndThrowInDebug([]),
  addDocumentContext: () => returnAndThrowInDebug(""),
  removeDocumentContext: () => {
  },
  runtimeClient: {},
  copilotApiConfig: new class {
    get chatApiEndpoint() {
      throw new Error("Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!");
    }
    get headers() {
      return {};
    }
    get body() {
      return {};
    }
  }(),
  chatSuggestionConfiguration: {},
  addChatSuggestionConfiguration: () => {
  },
  removeChatSuggestionConfiguration: () => {
  },
  showDevConsole: false,
  coagentStates: {},
  setCoagentStates: () => {
  },
  coagentStatesRef: { current: {} },
  setCoagentStatesWithRef: () => {
  },
  agentSession: null,
  setAgentSession: () => {
  },
  forwardedParameters: {},
  agentLock: null,
  threadId: "",
  setThreadId: () => {
  },
  runId: null,
  setRunId: () => {
  },
  chatAbortControllerRef: { current: null },
  availableAgents: [],
  extensions: {},
  setExtensions: () => {
  },
  langGraphInterruptAction: null,
  setLangGraphInterruptAction: () => {
  },
  removeLangGraphInterruptAction: () => {
  },
  onError: () => {
  },
  bannerError: null,
  setBannerError: () => {
  },
  internalErrorHandlers: {},
  setInternalErrorHandler: () => {
  },
  removeInternalErrorHandler: () => {
  }
};
var CopilotContext = import_react2.default.createContext(emptyCopilotContext);
function useCopilotContext() {
  const context = import_react2.default.useContext(CopilotContext);
  if (context === emptyCopilotContext) {
    throw new Error("Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!");
  }
  return context;
}
function returnAndThrowInDebug(_value) {
  throw new Error("Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!");
}

// node_modules/@copilotkit/react-core/dist/chunk-ZLQVRPDS.mjs
var import_react3 = __toESM(require_react(), 1);
var emptyCopilotContext2 = {
  messages: [],
  setMessages: () => [],
  // suggestions state
  suggestions: [],
  setSuggestions: () => []
};
var CopilotMessagesContext = import_react3.default.createContext(emptyCopilotContext2);
function useCopilotMessagesContext() {
  const context = import_react3.default.useContext(CopilotMessagesContext);
  if (context === emptyCopilotContext2) {
    throw new Error(
      "A messages consuming component was not wrapped with `<CopilotMessages> {...} </CopilotMessages>`"
    );
  }
  return context;
}

// node_modules/@copilotkit/react-core/dist/chunk-C6IANC2R.mjs
var import_react4 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var MessagesTapContext = (0, import_react4.createContext)(null);
function useMessagesTap() {
  const tap = (0, import_react4.useContext)(MessagesTapContext);
  if (!tap)
    throw new Error("useMessagesTap must be used inside <MessagesTapProvider>");
  return tap;
}
function MessagesTapProvider({ children }) {
  const messagesRef = (0, import_react4.useRef)([]);
  const tapRef = (0, import_react4.useRef)({
    getMessagesFromTap: () => messagesRef.current,
    updateTapMessages: (messages) => {
      messagesRef.current = messages;
    }
  });
  return (0, import_jsx_runtime2.jsx)(MessagesTapContext.Provider, { value: tapRef.current, children });
}
function CopilotMessages({ children }) {
  const [messages, setMessages] = (0, import_react4.useState)([]);
  const lastLoadedThreadId = (0, import_react4.useRef)();
  const lastLoadedAgentName = (0, import_react4.useRef)();
  const lastLoadedMessages = (0, import_react4.useRef)();
  const { updateTapMessages } = useMessagesTap();
  const { threadId, agentSession, runtimeClient, showDevConsole, onError, copilotApiConfig } = useCopilotContext();
  const { setBannerError } = useToast();
  const traceUIError = (0, import_react4.useCallback)(
    (error2, originalError) => __async(this, null, function* () {
      if (!onError || !copilotApiConfig.publicApiKey)
        return;
      try {
        const traceEvent = {
          type: "error",
          timestamp: Date.now(),
          context: {
            source: "ui",
            request: {
              operation: "loadAgentState",
              url: copilotApiConfig.chatApiEndpoint,
              startTime: Date.now()
            },
            technical: {
              environment: "browser",
              userAgent: typeof navigator !== "undefined" ? navigator.userAgent : void 0,
              stackTrace: originalError instanceof Error ? originalError.stack : void 0
            }
          },
          error: error2
        };
        yield onError(traceEvent);
      } catch (traceError) {
        console.error("Error in CopilotMessages onError handler:", traceError);
      }
    }),
    [onError, copilotApiConfig.publicApiKey, copilotApiConfig.chatApiEndpoint]
  );
  const createStructuredError2 = (gqlError) => {
    const extensions = gqlError.extensions;
    const originalError = extensions == null ? void 0 : extensions.originalError;
    if (originalError == null ? void 0 : originalError.stack) {
      if (originalError.stack.includes("CopilotApiDiscoveryError")) {
        return new CopilotKitApiDiscoveryError({ message: originalError.message });
      }
      if (originalError.stack.includes("CopilotKitRemoteEndpointDiscoveryError")) {
        return new CopilotKitRemoteEndpointDiscoveryError({ message: originalError.message });
      }
      if (originalError.stack.includes("CopilotKitAgentDiscoveryError")) {
        return new CopilotKitAgentDiscoveryError({
          agentName: "",
          availableAgents: []
        });
      }
    }
    const message2 = (originalError == null ? void 0 : originalError.message) || gqlError.message;
    const code2 = extensions == null ? void 0 : extensions.code;
    if (code2) {
      return new CopilotKitError({ message: message2, code: code2 });
    }
    return null;
  };
  const handleGraphQLErrors = (0, import_react4.useCallback)(
    (error2) => {
      var _a2;
      if ((_a2 = error2.graphQLErrors) == null ? void 0 : _a2.length) {
        const graphQLErrors = error2.graphQLErrors;
        const routeError = (gqlError) => {
          const extensions = gqlError.extensions;
          const visibility = extensions == null ? void 0 : extensions.visibility;
          const isDev = shouldShowDevConsole(showDevConsole);
          if (!isDev) {
            console.error("CopilotKit Error (hidden in production):", gqlError.message);
            return;
          }
          if (visibility === ErrorVisibility.SILENT) {
            console.error("CopilotKit Silent Error:", gqlError.message);
            return;
          }
          const ckError = createStructuredError2(gqlError);
          if (ckError) {
            setBannerError(ckError);
            traceUIError(ckError, gqlError);
          } else {
            const fallbackError = new CopilotKitError({
              message: gqlError.message,
              code: CopilotKitErrorCode.UNKNOWN
            });
            setBannerError(fallbackError);
            traceUIError(fallbackError, gqlError);
          }
        };
        graphQLErrors.forEach(routeError);
      } else {
        const isDev = shouldShowDevConsole(showDevConsole);
        if (!isDev) {
          console.error("CopilotKit Error (hidden in production):", error2);
        } else {
          const fallbackError = new CopilotKitError({
            message: (error2 == null ? void 0 : error2.message) || String(error2),
            code: CopilotKitErrorCode.UNKNOWN
          });
          setBannerError(fallbackError);
          traceUIError(fallbackError, error2);
        }
      }
    },
    [setBannerError, showDevConsole, traceUIError]
  );
  (0, import_react4.useEffect)(() => {
    if (!threadId || threadId === lastLoadedThreadId.current)
      return;
    if (threadId === lastLoadedThreadId.current && (agentSession == null ? void 0 : agentSession.agentName) === lastLoadedAgentName.current) {
      return;
    }
    const fetchMessages = () => __async(this, null, function* () {
      var _a2, _b2, _c;
      if (!(agentSession == null ? void 0 : agentSession.agentName))
        return;
      const result = yield runtimeClient.loadAgentState({
        threadId,
        agentName: agentSession == null ? void 0 : agentSession.agentName
      });
      if (result.error) {
        lastLoadedThreadId.current = threadId;
        lastLoadedAgentName.current = agentSession == null ? void 0 : agentSession.agentName;
        handleGraphQLErrors(result.error);
        return;
      }
      const newMessages = (_b2 = (_a2 = result.data) == null ? void 0 : _a2.loadAgentState) == null ? void 0 : _b2.messages;
      if (newMessages === lastLoadedMessages.current)
        return;
      if ((_c = result.data) == null ? void 0 : _c.loadAgentState) {
        lastLoadedMessages.current = newMessages;
        lastLoadedThreadId.current = threadId;
        lastLoadedAgentName.current = agentSession == null ? void 0 : agentSession.agentName;
        const messages2 = loadMessagesFromJsonRepresentation(JSON.parse(newMessages || "[]"));
        setMessages(messages2);
      }
    });
    void fetchMessages();
  }, [threadId, agentSession == null ? void 0 : agentSession.agentName]);
  (0, import_react4.useEffect)(() => {
    updateTapMessages(messages);
  }, [messages, updateTapMessages]);
  const memoizedChildren = (0, import_react4.useMemo)(() => children, [children]);
  const [suggestions, setSuggestions] = (0, import_react4.useState)([]);
  return (0, import_jsx_runtime2.jsx)(
    CopilotMessagesContext.Provider,
    {
      value: {
        messages,
        setMessages,
        suggestions,
        setSuggestions
      },
      children: memoizedChildren
    }
  );
}

// node_modules/@copilotkit/react-core/dist/chunk-PMAFHQ7P.mjs
var STATUS_CHECK_INTERVAL = 1e3 * 60 * 5;
var StatusChecker = class {
  constructor() {
    this.activeKey = null;
    this.intervalId = null;
    this.instanceCount = 0;
    this.lastResponse = null;
  }
  start(publicApiKey, onUpdate) {
    return __async(this, null, function* () {
      this.instanceCount++;
      if (this.activeKey === publicApiKey)
        return;
      if (this.intervalId)
        clearInterval(this.intervalId);
      const checkStatus = () => __async(this, null, function* () {
        try {
          const response = yield fetch(`${COPILOT_CLOUD_API_URL}/ciu`, {
            method: "GET",
            headers: {
              [COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: publicApiKey
            }
          }).then((response2) => response2.json());
          this.lastResponse = response;
          onUpdate == null ? void 0 : onUpdate(response);
          return response;
        } catch (error2) {
          return null;
        }
      });
      const initialResponse = yield checkStatus();
      this.intervalId = setInterval(checkStatus, STATUS_CHECK_INTERVAL);
      this.activeKey = publicApiKey;
      return initialResponse;
    });
  }
  getLastResponse() {
    return this.lastResponse;
  }
  stop() {
    this.instanceCount--;
    if (this.instanceCount === 0) {
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
        this.activeKey = null;
        this.lastResponse = null;
      }
    }
  }
};

// node_modules/@copilotkit/react-core/dist/chunk-O7ARI5CV.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var ExclamationMarkIcon = ({
  className,
  style
}) => (0, import_jsx_runtime3.jsxs)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    className: `lucide lucide-circle-alert ${className ? className : ""}`,
    style,
    children: [
      (0, import_jsx_runtime3.jsx)("circle", { cx: "12", cy: "12", r: "10" }),
      (0, import_jsx_runtime3.jsx)("line", { x1: "12", x2: "12", y1: "8", y2: "12" }),
      (0, import_jsx_runtime3.jsx)("line", { x1: "12", x2: "12.01", y1: "16", y2: "16" })
    ]
  }
);

// node_modules/@copilotkit/react-core/dist/chunk-N4WEHORG.mjs
var import_react7 = __toESM(require_react(), 1);

// node_modules/react-markdown/lib/uri-transformer.js
var protocols = ["http", "https", "mailto", "tel"];
function uriTransformer(uri) {
  const url = (uri || "").trim();
  const first = url.charAt(0);
  if (first === "#" || first === "/") {
    return url;
  }
  const colon = url.indexOf(":");
  if (colon === -1) {
    return url;
  }
  let index3 = -1;
  while (++index3 < protocols.length) {
    const protocol = protocols[index3];
    if (colon === protocol.length && url.slice(0, protocol.length).toLowerCase() === protocol) {
      return url;
    }
  }
  index3 = url.indexOf("?");
  if (index3 !== -1 && colon > index3) {
    return url;
  }
  index3 = url.indexOf("#");
  if (index3 !== -1 && colon > index3) {
    return url;
  }
  return "javascript:void(0)";
}

// node_modules/react-markdown/lib/react-markdown.js
var import_react6 = __toESM(require_react(), 1);

// node_modules/vfile/lib/index.js
var import_is_buffer = __toESM(require_is_buffer(), 1);

// node_modules/vfile-message/node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition(value2) {
  if (!value2 || typeof value2 !== "object") {
    return "";
  }
  if ("position" in value2 || "type" in value2) {
    return position(value2.position);
  }
  if ("start" in value2 || "end" in value2) {
    return position(value2);
  }
  if ("line" in value2 || "column" in value2) {
    return point(value2);
  }
  return "";
}
function point(point5) {
  return index(point5 && point5.line) + ":" + index(point5 && point5.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index(value2) {
  return value2 && typeof value2 === "number" ? value2 : 1;
}

// node_modules/vfile-message/lib/index.js
var VFileMessage = class extends Error {
  /**
   * Create a message for `reason` at `place` from `origin`.
   *
   * When an error is passed in as `reason`, the `stack` is copied.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   *
   *   >  **Note**: you should use markdown.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // To do: next major: expose `undefined` everywhere instead of `null`.
  constructor(reason, place, origin) {
    const parts = [null, null];
    let position4 = {
      // @ts-expect-error: we always follows the structure of `position`.
      start: { line: null, column: null },
      // @ts-expect-error: "
      end: { line: null, column: null }
    };
    super();
    if (typeof place === "string") {
      origin = place;
      place = void 0;
    }
    if (typeof origin === "string") {
      const index3 = origin.indexOf(":");
      if (index3 === -1) {
        parts[1] = origin;
      } else {
        parts[0] = origin.slice(0, index3);
        parts[1] = origin.slice(index3 + 1);
      }
    }
    if (place) {
      if ("type" in place || "position" in place) {
        if (place.position) {
          position4 = place.position;
        }
      } else if ("start" in place || "end" in place) {
        position4 = place;
      } else if ("line" in place || "column" in place) {
        position4.start = place;
      }
    }
    this.name = stringifyPosition(place) || "1:1";
    this.message = typeof reason === "object" ? reason.message : reason;
    this.stack = "";
    if (typeof reason === "object" && reason.stack) {
      this.stack = reason.stack;
    }
    this.reason = this.message;
    this.fatal;
    this.line = position4.start.line;
    this.column = position4.start.column;
    this.position = position4;
    this.source = parts[0];
    this.ruleId = parts[1];
    this.file;
    this.actual;
    this.expected;
    this.url;
    this.note;
  }
};
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.fatal = null;
VFileMessage.prototype.column = null;
VFileMessage.prototype.line = null;
VFileMessage.prototype.source = null;
VFileMessage.prototype.ruleId = null;
VFileMessage.prototype.position = null;

// node_modules/vfile/lib/minpath.browser.js
var path = { basename, dirname, extname, join: join2, sep: "/" };
function basename(path2, ext) {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path2);
  let start2 = 0;
  let end = -1;
  let index3 = path2.length;
  let seenNonSlash;
  if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
    while (index3--) {
      if (path2.charCodeAt(index3) === 47) {
        if (seenNonSlash) {
          start2 = index3 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index3 + 1;
      }
    }
    return end < 0 ? "" : path2.slice(start2, end);
  }
  if (ext === path2) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extIndex = ext.length - 1;
  while (index3--) {
    if (path2.charCodeAt(index3) === 47) {
      if (seenNonSlash) {
        start2 = index3 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index3 + 1;
      }
      if (extIndex > -1) {
        if (path2.charCodeAt(index3) === ext.charCodeAt(extIndex--)) {
          if (extIndex < 0) {
            end = index3;
          }
        } else {
          extIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start2 === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path2.length;
  }
  return path2.slice(start2, end);
}
function dirname(path2) {
  assertPath(path2);
  if (path2.length === 0) {
    return ".";
  }
  let end = -1;
  let index3 = path2.length;
  let unmatchedSlash;
  while (--index3) {
    if (path2.charCodeAt(index3) === 47) {
      if (unmatchedSlash) {
        end = index3;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path2.charCodeAt(0) === 47 ? "/" : "." : end === 1 && path2.charCodeAt(0) === 47 ? "//" : path2.slice(0, end);
}
function extname(path2) {
  assertPath(path2);
  let index3 = path2.length;
  let end = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index3--) {
    const code2 = path2.charCodeAt(index3);
    if (code2 === 47) {
      if (unmatchedSlash) {
        startPart = index3 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index3 + 1;
    }
    if (code2 === 46) {
      if (startDot < 0) {
        startDot = index3;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end);
}
function join2(...segments) {
  let index3 = -1;
  let joined;
  while (++index3 < segments.length) {
    assertPath(segments[index3]);
    if (segments[index3]) {
      joined = joined === void 0 ? segments[index3] : joined + "/" + segments[index3];
    }
  }
  return joined === void 0 ? "." : normalize(joined);
}
function normalize(path2) {
  assertPath(path2);
  const absolute = path2.charCodeAt(0) === 47;
  let value2 = normalizeString(path2, !absolute);
  if (value2.length === 0 && !absolute) {
    value2 = ".";
  }
  if (value2.length > 0 && path2.charCodeAt(path2.length - 1) === 47) {
    value2 += "/";
  }
  return absolute ? "/" + value2 : value2;
}
function normalizeString(path2, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index3 = -1;
  let code2;
  let lastSlashIndex;
  while (++index3 <= path2.length) {
    if (index3 < path2.length) {
      code2 = path2.charCodeAt(index3);
    } else if (code2 === 47) {
      break;
    } else {
      code2 = 47;
    }
    if (code2 === 47) {
      if (lastSlash === index3 - 1 || dots === 1) {
      } else if (lastSlash !== index3 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 || result.charCodeAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index3;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index3;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path2.slice(lastSlash + 1, index3);
        } else {
          result = path2.slice(lastSlash + 1, index3);
        }
        lastSegmentLength = index3 - lastSlash - 1;
      }
      lastSlash = index3;
      dots = 0;
    } else if (code2 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path2)
    );
  }
}

// node_modules/vfile/lib/minproc.browser.js
var proc = { cwd };
function cwd() {
  return "/";
}

// node_modules/vfile/lib/minurl.shared.js
function isUrl(fileUrlOrPath) {
  return fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && // @ts-expect-error: indexable.
  fileUrlOrPath.href && // @ts-expect-error: indexable.
  fileUrlOrPath.origin;
}

// node_modules/vfile/lib/minurl.browser.js
function urlToPath(path2) {
  if (typeof path2 === "string") {
    path2 = new URL(path2);
  } else if (!isUrl(path2)) {
    const error2 = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
    );
    error2.code = "ERR_INVALID_ARG_TYPE";
    throw error2;
  }
  if (path2.protocol !== "file:") {
    const error2 = new TypeError("The URL must be of scheme file");
    error2.code = "ERR_INVALID_URL_SCHEME";
    throw error2;
  }
  return getPathFromURLPosix(path2);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error2 = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error2.code = "ERR_INVALID_FILE_URL_HOST";
    throw error2;
  }
  const pathname = url.pathname;
  let index3 = -1;
  while (++index3 < pathname.length) {
    if (pathname.charCodeAt(index3) === 37 && pathname.charCodeAt(index3 + 1) === 50) {
      const third = pathname.charCodeAt(index3 + 2);
      if (third === 70 || third === 102) {
        const error2 = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error2.code = "ERR_INVALID_FILE_URL_PATH";
        throw error2;
      }
    }
  }
  return decodeURIComponent(pathname);
}

// node_modules/vfile/lib/index.js
var order = ["history", "path", "basename", "stem", "extname", "dirname"];
var VFile = class {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Buffer`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value2) {
    let options;
    if (!value2) {
      options = {};
    } else if (typeof value2 === "string" || buffer(value2)) {
      options = { value: value2 };
    } else if (isUrl(value2)) {
      options = { path: value2 };
    } else {
      options = value2;
    }
    this.data = {};
    this.messages = [];
    this.history = [];
    this.cwd = proc.cwd();
    this.value;
    this.stored;
    this.result;
    this.map;
    let index3 = -1;
    while (++index3 < order.length) {
      const prop2 = order[index3];
      if (prop2 in options && options[prop2] !== void 0 && options[prop2] !== null) {
        this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
      }
    }
    let prop;
    for (prop in options) {
      if (!order.includes(prop)) {
        this[prop] = options[prop];
      }
    }
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {string | URL} path
   */
  set path(path2) {
    if (isUrl(path2)) {
      path2 = urlToPath(path2);
    }
    assertNonEmpty(path2, "path");
    if (this.path !== path2) {
      this.history.push(path2);
    }
  }
  /**
   * Get the parent path (example: `'~'`).
   */
  get dirname() {
    return typeof this.path === "string" ? path.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   */
  set dirname(dirname2) {
    assertPath2(this.basename, "dirname");
    this.path = path.join(dirname2 || "", this.basename);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   */
  get basename() {
    return typeof this.path === "string" ? path.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = path.join(this.dirname || "", basename2);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   */
  get extname() {
    return typeof this.path === "string" ? path.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   */
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath2(this.dirname, "extname");
    if (extname2) {
      if (extname2.charCodeAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = path.join(this.dirname, this.stem + (extname2 || ""));
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   */
  get stem() {
    return typeof this.path === "string" ? path.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = path.join(this.dirname || "", stem + (this.extname || ""));
  }
  /**
   * Serialize the file.
   *
   * @param {BufferEncoding | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Buffer`
   *   (default: `'utf8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    return (this.value || "").toString(encoding || void 0);
  }
  /**
   * Create a warning message associated with the file.
   *
   * Its `fatal` is set to `false` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(reason, place, origin) {
    const message2 = new VFileMessage(reason, place, origin);
    if (this.path) {
      message2.name = this.path + ":" + message2.name;
      message2.file = this.path;
    }
    message2.fatal = false;
    this.messages.push(message2);
    return message2;
  }
  /**
   * Create an info message associated with the file.
   *
   * Its `fatal` is set to `null` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(reason, place, origin) {
    const message2 = this.message(reason, place, origin);
    message2.fatal = null;
    return message2;
  }
  /**
   * Create a fatal error associated with the file.
   *
   * Its `fatal` is set to `true` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * >  **Note**: a fatal error means that a file is no longer processable.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Message.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(reason, place, origin) {
    const message2 = this.message(reason, place, origin);
    message2.fatal = true;
    throw message2;
  }
};
function assertPart(part, name2) {
  if (part && part.includes(path.sep)) {
    throw new Error(
      "`" + name2 + "` cannot be a path: did not expect `" + path.sep + "`"
    );
  }
}
function assertNonEmpty(part, name2) {
  if (!part) {
    throw new Error("`" + name2 + "` cannot be empty");
  }
}
function assertPath2(path2, name2) {
  if (!path2) {
    throw new Error("Setting `" + name2 + "` requires `path` to be set too");
  }
}
function buffer(value2) {
  return (0, import_is_buffer.default)(value2);
}

// node_modules/bail/index.js
function bail(error2) {
  if (error2) {
    throw error2;
  }
}

// node_modules/unified/lib/index.js
var import_is_buffer2 = __toESM(require_is_buffer(), 1);
var import_extend = __toESM(require_extend(), 1);

// node_modules/is-plain-obj/index.js
function isPlainObject2(value2) {
  if (typeof value2 !== "object" || value2 === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value2);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value2) && !(Symbol.iterator in value2);
}

// node_modules/trough/lib/index.js
function trough() {
  const fns = [];
  const pipeline = { run: run2, use };
  return pipeline;
  function run2(...values3) {
    let middlewareIndex = -1;
    const callback = values3.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next(null, ...values3);
    function next(error2, ...output) {
      const fn = fns[++middlewareIndex];
      let index3 = -1;
      if (error2) {
        callback(error2);
        return;
      }
      while (++index3 < values3.length) {
        if (output[index3] === null || output[index3] === void 0) {
          output[index3] = values3[index3];
        }
      }
      values3 = output;
      if (fn) {
        wrap4(fn, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap4(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware.apply(this, parameters);
    } catch (error2) {
      const exception = (
        /** @type {Error} */
        error2
      );
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result && result.then && typeof result.then === "function") {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error2, ...output) {
    if (!called) {
      called = true;
      callback(error2, ...output);
    }
  }
  function then(value2) {
    done(null, value2);
  }
}

// node_modules/unified/lib/index.js
var unified = base().freeze();
var own = {}.hasOwnProperty;
function base() {
  const transformers = trough();
  const attachers = [];
  let namespace = {};
  let frozen;
  let freezeIndex = -1;
  processor.data = data;
  processor.Parser = void 0;
  processor.Compiler = void 0;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse7;
  processor.stringify = stringify5;
  processor.run = run2;
  processor.runSync = runSync;
  processor.process = process2;
  processor.processSync = processSync;
  return processor;
  function processor() {
    const destination = base();
    let index3 = -1;
    while (++index3 < attachers.length) {
      destination.use(...attachers[index3]);
    }
    destination.data((0, import_extend.default)(true, {}, namespace));
    return destination;
  }
  function data(key, value2) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", frozen);
        namespace[key] = value2;
        return processor;
      }
      return own.call(namespace, key) && namespace[key] || null;
    }
    if (key) {
      assertUnfrozen("data", frozen);
      namespace = key;
      return processor;
    }
    return namespace;
  }
  function freeze() {
    if (frozen) {
      return processor;
    }
    while (++freezeIndex < attachers.length) {
      const [attacher, ...options] = attachers[freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(processor, ...options);
      if (typeof transformer === "function") {
        transformers.use(transformer);
      }
    }
    frozen = true;
    freezeIndex = Number.POSITIVE_INFINITY;
    return processor;
  }
  function use(value2, ...options) {
    let settings;
    assertUnfrozen("use", frozen);
    if (value2 === null || value2 === void 0) {
    } else if (typeof value2 === "function") {
      addPlugin(value2, ...options);
    } else if (typeof value2 === "object") {
      if (Array.isArray(value2)) {
        addList(value2);
      } else {
        addPreset(value2);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value2 + "`");
    }
    if (settings) {
      namespace.settings = Object.assign(namespace.settings || {}, settings);
    }
    return processor;
    function add(value3) {
      if (typeof value3 === "function") {
        addPlugin(value3);
      } else if (typeof value3 === "object") {
        if (Array.isArray(value3)) {
          const [plugin, ...options2] = value3;
          addPlugin(plugin, ...options2);
        } else {
          addPreset(value3);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value3 + "`");
      }
    }
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings) {
        settings = Object.assign(settings || {}, result.settings);
      }
    }
    function addList(plugins) {
      let index3 = -1;
      if (plugins === null || plugins === void 0) {
      } else if (Array.isArray(plugins)) {
        while (++index3 < plugins.length) {
          const thing = plugins[index3];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, value3) {
      let index3 = -1;
      let entry;
      while (++index3 < attachers.length) {
        if (attachers[index3][0] === plugin) {
          entry = attachers[index3];
          break;
        }
      }
      if (entry) {
        if (isPlainObject2(entry[1]) && isPlainObject2(value3)) {
          value3 = (0, import_extend.default)(true, entry[1], value3);
        }
        entry[1] = value3;
      } else {
        attachers.push([...arguments]);
      }
    }
  }
  function parse7(doc) {
    processor.freeze();
    const file = vfile(doc);
    const Parser = processor.Parser;
    assertParser("parse", Parser);
    if (newable(Parser, "parse")) {
      return new Parser(String(file), file).parse();
    }
    return Parser(String(file), file);
  }
  function stringify5(node2, doc) {
    processor.freeze();
    const file = vfile(doc);
    const Compiler = processor.Compiler;
    assertCompiler("stringify", Compiler);
    assertNode(node2);
    if (newable(Compiler, "compile")) {
      return new Compiler(node2, file).compile();
    }
    return Compiler(node2, file);
  }
  function run2(node2, doc, callback) {
    assertNode(node2);
    processor.freeze();
    if (!callback && typeof doc === "function") {
      callback = doc;
      doc = void 0;
    }
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve, reject) {
      transformers.run(node2, vfile(doc), done);
      function done(error2, tree, file) {
        tree = tree || node2;
        if (error2) {
          reject(error2);
        } else if (resolve) {
          resolve(tree);
        } else {
          callback(null, tree, file);
        }
      }
    }
  }
  function runSync(node2, file) {
    let result;
    let complete;
    processor.run(node2, file, done);
    assertDone("runSync", "run", complete);
    return result;
    function done(error2, tree) {
      bail(error2);
      result = tree;
      complete = true;
    }
  }
  function process2(doc, callback) {
    processor.freeze();
    assertParser("process", processor.Parser);
    assertCompiler("process", processor.Compiler);
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve, reject) {
      const file = vfile(doc);
      processor.run(processor.parse(file), file, (error2, tree, file2) => {
        if (error2 || !tree || !file2) {
          done(error2);
        } else {
          const result = processor.stringify(tree, file2);
          if (result === void 0 || result === null) {
          } else if (looksLikeAVFileValue(result)) {
            file2.value = result;
          } else {
            file2.result = result;
          }
          done(error2, file2);
        }
      });
      function done(error2, file2) {
        if (error2 || !file2) {
          reject(error2);
        } else if (resolve) {
          resolve(file2);
        } else {
          callback(null, file2);
        }
      }
    }
  }
  function processSync(doc) {
    let complete;
    processor.freeze();
    assertParser("processSync", processor.Parser);
    assertCompiler("processSync", processor.Compiler);
    const file = vfile(doc);
    processor.process(file, done);
    assertDone("processSync", "process", complete);
    return file;
    function done(error2) {
      complete = true;
      bail(error2);
    }
  }
}
function newable(value2, name2) {
  return typeof value2 === "function" && // Prototypes do exist.
  // type-coverage:ignore-next-line
  value2.prototype && // A function with keys in its prototype is probably a constructor.
  // Classes prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  // type-coverage:ignore-next-line
  (keys(value2.prototype) || name2 in value2.prototype);
}
function keys(value2) {
  let key;
  for (key in value2) {
    if (own.call(value2, key)) {
      return true;
    }
  }
  return false;
}
function assertParser(name2, value2) {
  if (typeof value2 !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `Parser`");
  }
}
function assertCompiler(name2, value2) {
  if (typeof value2 !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `Compiler`");
  }
}
function assertUnfrozen(name2, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node2) {
  if (!isPlainObject2(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name2, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value2) {
  return looksLikeAVFile(value2) ? value2 : new VFile(value2);
}
function looksLikeAVFile(value2) {
  return Boolean(
    value2 && typeof value2 === "object" && "message" in value2 && "messages" in value2
  );
}
function looksLikeAVFileValue(value2) {
  return typeof value2 === "string" || (0, import_is_buffer2.default)(value2);
}

// node_modules/dequal/dist/index.mjs
var has = Object.prototype.hasOwnProperty;
function find(iter, tar, key) {
  for (key of iter.keys()) {
    if (dequal(key, tar)) return key;
  }
}
function dequal(foo, bar) {
  var ctor, len, tmp;
  if (foo === bar) return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date) return foo.getTime() === bar.getTime();
    if (ctor === RegExp) return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len])) ;
      }
      return len === -1;
    }
    if (ctor === Set) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len;
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp) return false;
        }
        if (!bar.has(tmp)) return false;
      }
      return true;
    }
    if (ctor === Map) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len[0];
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp) return false;
        }
        if (!dequal(len[1], bar.get(tmp))) {
          return false;
        }
      }
      return true;
    }
    if (ctor === ArrayBuffer) {
      foo = new Uint8Array(foo);
      bar = new Uint8Array(bar);
    } else if (ctor === DataView) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo.getInt8(len) === bar.getInt8(len)) ;
      }
      return len === -1;
    }
    if (ArrayBuffer.isView(foo)) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo[len] === bar[len]) ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// node_modules/kleur/index.mjs
var FORCE_COLOR;
var NODE_DISABLE_COLORS;
var NO_COLOR;
var TERM;
var isTTY = true;
if (typeof process !== "undefined") {
  ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
  isTTY = process.stdout && process.stdout.isTTY;
}
var $ = {
  enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== "dumb" && (FORCE_COLOR != null && FORCE_COLOR !== "0" || isTTY),
  // modifiers
  reset: init(0, 0),
  bold: init(1, 22),
  dim: init(2, 22),
  italic: init(3, 23),
  underline: init(4, 24),
  inverse: init(7, 27),
  hidden: init(8, 28),
  strikethrough: init(9, 29),
  // colors
  black: init(30, 39),
  red: init(31, 39),
  green: init(32, 39),
  yellow: init(33, 39),
  blue: init(34, 39),
  magenta: init(35, 39),
  cyan: init(36, 39),
  white: init(37, 39),
  gray: init(90, 39),
  grey: init(90, 39),
  // background colors
  bgBlack: init(40, 49),
  bgRed: init(41, 49),
  bgGreen: init(42, 49),
  bgYellow: init(43, 49),
  bgBlue: init(44, 49),
  bgMagenta: init(45, 49),
  bgCyan: init(46, 49),
  bgWhite: init(47, 49)
};
function run(arr, str) {
  let i3 = 0, tmp, beg = "", end = "";
  for (; i3 < arr.length; i3++) {
    tmp = arr[i3];
    beg += tmp.open;
    end += tmp.close;
    if (!!~str.indexOf(tmp.close)) {
      str = str.replace(tmp.rgx, tmp.close + tmp.open);
    }
  }
  return beg + str + end;
}
function chain(has2, keys2) {
  let ctx = { has: has2, keys: keys2 };
  ctx.reset = $.reset.bind(ctx);
  ctx.bold = $.bold.bind(ctx);
  ctx.dim = $.dim.bind(ctx);
  ctx.italic = $.italic.bind(ctx);
  ctx.underline = $.underline.bind(ctx);
  ctx.inverse = $.inverse.bind(ctx);
  ctx.hidden = $.hidden.bind(ctx);
  ctx.strikethrough = $.strikethrough.bind(ctx);
  ctx.black = $.black.bind(ctx);
  ctx.red = $.red.bind(ctx);
  ctx.green = $.green.bind(ctx);
  ctx.yellow = $.yellow.bind(ctx);
  ctx.blue = $.blue.bind(ctx);
  ctx.magenta = $.magenta.bind(ctx);
  ctx.cyan = $.cyan.bind(ctx);
  ctx.white = $.white.bind(ctx);
  ctx.gray = $.gray.bind(ctx);
  ctx.grey = $.grey.bind(ctx);
  ctx.bgBlack = $.bgBlack.bind(ctx);
  ctx.bgRed = $.bgRed.bind(ctx);
  ctx.bgGreen = $.bgGreen.bind(ctx);
  ctx.bgYellow = $.bgYellow.bind(ctx);
  ctx.bgBlue = $.bgBlue.bind(ctx);
  ctx.bgMagenta = $.bgMagenta.bind(ctx);
  ctx.bgCyan = $.bgCyan.bind(ctx);
  ctx.bgWhite = $.bgWhite.bind(ctx);
  return ctx;
}
function init(open, close) {
  let blk = {
    open: `\x1B[${open}m`,
    close: `\x1B[${close}m`,
    rgx: new RegExp(`\\x1b\\[${close}m`, "g")
  };
  return function(txt) {
    if (this !== void 0 && this.has !== void 0) {
      !!~this.has.indexOf(open) || (this.has.push(open), this.keys.push(blk));
      return txt === void 0 ? this : $.enabled ? run(this.keys, txt + "") : txt + "";
    }
    return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt + "") : txt + "";
  };
}
var kleur_default = $;

// node_modules/diff/lib/index.mjs
function Diff() {
}
Diff.prototype = {
  diff: function diff(oldString, newString) {
    var _options$timeout;
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var callback = options.callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    this.options = options;
    var self = this;
    function done(value2) {
      if (callback) {
        setTimeout(function() {
          callback(void 0, value2);
        }, 0);
        return true;
      } else {
        return value2;
      }
    }
    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length, oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    if (options.maxEditLength) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }
    var maxExecutionTime = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;
    var abortAfterTimestamp = Date.now() + maxExecutionTime;
    var bestPath = [{
      oldPos: -1,
      lastComponent: void 0
    }];
    var newPos = this.extractCommon(bestPath[0], newString, oldString, 0);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      return done([{
        value: this.join(newString),
        count: newString.length
      }]);
    }
    var minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
    function execEditLength() {
      for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        var basePath = void 0;
        var removePath = bestPath[diagonalPath - 1], addPath2 = bestPath[diagonalPath + 1];
        if (removePath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        var canAdd = false;
        if (addPath2) {
          var addPathNewPos = addPath2.oldPos - diagonalPath;
          canAdd = addPath2 && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        var canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos + 1 < addPath2.oldPos) {
          basePath = self.addToPath(addPath2, true, void 0, 0);
        } else {
          basePath = self.addToPath(removePath, void 0, true, 1);
        }
        newPos = self.extractCommon(basePath, newString, oldString, diagonalPath);
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));
        } else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }
          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }
      editLength++;
    }
    if (callback) {
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback();
          }
          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        var ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  },
  addToPath: function addToPath(path2, added, removed, oldPosInc) {
    var last = path2.lastComponent;
    if (last && last.added === added && last.removed === removed) {
      return {
        oldPos: path2.oldPos + oldPosInc,
        lastComponent: {
          count: last.count + 1,
          added,
          removed,
          previousComponent: last.previousComponent
        }
      };
    } else {
      return {
        oldPos: path2.oldPos + oldPosInc,
        lastComponent: {
          count: 1,
          added,
          removed,
          previousComponent: last
        }
      };
    }
  },
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length, oldLen = oldString.length, oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }
    if (commonCount) {
      basePath.lastComponent = {
        count: commonCount,
        previousComponent: basePath.lastComponent
      };
    }
    basePath.oldPos = oldPos;
    return newPos;
  },
  equals: function equals(left, right) {
    if (this.options.comparator) {
      return this.options.comparator(left, right);
    } else {
      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },
  removeEmpty: function removeEmpty(array) {
    var ret = [];
    for (var i3 = 0; i3 < array.length; i3++) {
      if (array[i3]) {
        ret.push(array[i3]);
      }
    }
    return ret;
  },
  castInput: function castInput(value2) {
    return value2;
  },
  tokenize: function tokenize(value2) {
    return value2.split("");
  },
  join: function join3(chars2) {
    return chars2.join("");
  }
};
function buildValues(diff2, lastComponent, newString, oldString, useLongestToken) {
  var components = [];
  var nextComponent;
  while (lastComponent) {
    components.push(lastComponent);
    nextComponent = lastComponent.previousComponent;
    delete lastComponent.previousComponent;
    lastComponent = nextComponent;
  }
  components.reverse();
  var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];
    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value2 = newString.slice(newPos, newPos + component.count);
        value2 = value2.map(function(value3, i3) {
          var oldValue = oldString[oldPos + i3];
          return oldValue.length > value3.length ? oldValue : value3;
        });
        component.value = diff2.join(value2);
      } else {
        component.value = diff2.join(newString.slice(newPos, newPos + component.count));
      }
      newPos += component.count;
      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff2.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count;
      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  }
  var finalComponent = components[componentLen - 1];
  if (componentLen > 1 && typeof finalComponent.value === "string" && (finalComponent.added || finalComponent.removed) && diff2.equals("", finalComponent.value)) {
    components[componentLen - 2].value += finalComponent.value;
    components.pop();
  }
  return components;
}
var characterDiff = new Diff();
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}
var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
var reWhitespace = /\S/;
var wordDiff = new Diff();
wordDiff.equals = function(left, right) {
  if (this.options.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }
  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
};
wordDiff.tokenize = function(value2) {
  var tokens = value2.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
  for (var i3 = 0; i3 < tokens.length - 1; i3++) {
    if (!tokens[i3 + 1] && tokens[i3 + 2] && extendedWordChars.test(tokens[i3]) && extendedWordChars.test(tokens[i3 + 2])) {
      tokens[i3] += tokens[i3 + 2];
      tokens.splice(i3 + 1, 2);
      i3--;
    }
  }
  return tokens;
};
var lineDiff = new Diff();
lineDiff.tokenize = function(value2) {
  if (this.options.stripTrailingCr) {
    value2 = value2.replace(/\r\n/g, "\n");
  }
  var retLines = [], linesAndNewlines = value2.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (var i3 = 0; i3 < linesAndNewlines.length; i3++) {
    var line2 = linesAndNewlines[i3];
    if (i3 % 2 && !this.options.newlineIsToken) {
      retLines[retLines.length - 1] += line2;
    } else {
      if (this.options.ignoreWhitespace) {
        line2 = line2.trim();
      }
      retLines.push(line2);
    }
  }
  return retLines;
};
function diffLines(oldStr, newStr, callback) {
  return lineDiff.diff(oldStr, newStr, callback);
}
var sentenceDiff = new Diff();
sentenceDiff.tokenize = function(value2) {
  return value2.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var cssDiff = new Diff();
cssDiff.tokenize = function(value2) {
  return value2.split(/([{}:;,]|\s+)/);
};
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
var objectPrototypeToString = Object.prototype.toString;
var jsonDiff = new Diff();
jsonDiff.useLongestToken = true;
jsonDiff.tokenize = lineDiff.tokenize;
jsonDiff.castInput = function(value2) {
  var _this$options = this.options, undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k, v2) {
    return typeof v2 === "undefined" ? undefinedReplacement : v2;
  } : _this$options$stringi;
  return typeof value2 === "string" ? value2 : JSON.stringify(canonicalize(value2, null, null, stringifyReplacer), stringifyReplacer, "  ");
};
jsonDiff.equals = function(left, right) {
  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"));
};
function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];
  if (replacer) {
    obj = replacer(key, obj);
  }
  var i3;
  for (i3 = 0; i3 < stack.length; i3 += 1) {
    if (stack[i3] === obj) {
      return replacementStack[i3];
    }
  }
  var canonicalizedObj;
  if ("[object Array]" === objectPrototypeToString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i3 = 0; i3 < obj.length; i3 += 1) {
      canonicalizedObj[i3] = canonicalize(obj[i3], stack, replacementStack, replacer, key);
    }
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }
  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }
  if (_typeof(obj) === "object" && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    var sortedKeys = [], _key;
    for (_key in obj) {
      if (obj.hasOwnProperty(_key)) {
        sortedKeys.push(_key);
      }
    }
    sortedKeys.sort();
    for (i3 = 0; i3 < sortedKeys.length; i3 += 1) {
      _key = sortedKeys[i3];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }
    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }
  return canonicalizedObj;
}
var arrayDiff = new Diff();
arrayDiff.tokenize = function(value2) {
  return value2.slice();
};
arrayDiff.join = arrayDiff.removeEmpty = function(value2) {
  return value2;
};
function diffArrays(oldArr, newArr, callback) {
  return arrayDiff.diff(oldArr, newArr, callback);
}

// node_modules/uvu/diff/index.mjs
var colors = {
  "--": kleur_default.red,
  "": kleur_default.grey,
  "++": kleur_default.green
};
var TITLE = kleur_default.dim().italic;
var TAB = kleur_default.dim("");
var SPACE = kleur_default.dim("");
var NL = kleur_default.dim("");
var LOG = (sym, str) => colors[sym](sym + PRETTY(str)) + "\n";
var LINE = (num, x) => kleur_default.dim("L" + String(num).padStart(x, "0") + " ");
var PRETTY = (str) => str.replace(/[ ]/g, SPACE).replace(/\t/g, TAB).replace(/(\r?\n)/g, NL);
function line(obj, prev, pad) {
  let char = obj.removed ? "--" : obj.added ? "++" : "";
  let arr = obj.value.replace(/\r?\n$/, "").split("\n");
  let i3 = 0, tmp, out = "";
  if (obj.added) out += colors[char]().underline(TITLE("Expected:")) + "\n";
  else if (obj.removed) out += colors[char]().underline(TITLE("Actual:")) + "\n";
  for (; i3 < arr.length; i3++) {
    tmp = arr[i3];
    if (tmp != null) {
      if (prev) out += LINE(prev + i3, pad);
      out += LOG(char, tmp || "\n");
    }
  }
  return out;
}
function arrays(input, expect) {
  let arr = diffArrays(input, expect);
  let i3 = 0, j = 0, k = 0, tmp, val, char, isObj, str;
  let out = LOG("", "[");
  for (; i3 < arr.length; i3++) {
    char = (tmp = arr[i3]).removed ? "--" : tmp.added ? "++" : "";
    if (tmp.added) {
      out += colors[char]().underline(TITLE("Expected:")) + "\n";
    } else if (tmp.removed) {
      out += colors[char]().underline(TITLE("Actual:")) + "\n";
    }
    for (j = 0; j < tmp.value.length; j++) {
      isObj = tmp.value[j] && typeof tmp.value[j] === "object";
      val = stringify2(tmp.value[j]).split(/\r?\n/g);
      for (k = 0; k < val.length; ) {
        str = "  " + val[k++] + (isObj ? "" : ",");
        if (isObj && k === val.length && j + 1 < tmp.value.length) str += ",";
        out += LOG(char, str);
      }
    }
  }
  return out + LOG("", "]");
}
function lines(input, expect, linenum = 0) {
  let i3 = 0, tmp, output = "";
  let arr = diffLines(input, expect);
  let pad = String(expect.split(/\r?\n/g).length - linenum).length;
  for (; i3 < arr.length; i3++) {
    output += line(tmp = arr[i3], linenum, pad);
    if (linenum && !tmp.removed) linenum += tmp.count;
  }
  return output;
}
function chars(input, expect) {
  let arr = diffChars(input, expect);
  let i3 = 0, output = "", tmp;
  let l1 = input.length;
  let l2 = expect.length;
  let p1 = PRETTY(input);
  let p2 = PRETTY(expect);
  tmp = arr[i3];
  if (l1 === l2) {
  } else if (tmp.removed && arr[i3 + 1]) {
    let del = tmp.count - arr[i3 + 1].count;
    if (del == 0) {
    } else if (del > 0) {
      expect = " ".repeat(del) + expect;
      p2 = " ".repeat(del) + p2;
      l2 += del;
    } else if (del < 0) {
      input = " ".repeat(-del) + input;
      p1 = " ".repeat(-del) + p1;
      l1 += -del;
    }
  }
  output += direct(p1, p2, l1, l2);
  if (l1 === l2) {
    for (tmp = "  "; i3 < l1; i3++) {
      tmp += input[i3] === expect[i3] ? " " : "^";
    }
  } else {
    for (tmp = "  "; i3 < arr.length; i3++) {
      tmp += (arr[i3].added || arr[i3].removed ? "^" : " ").repeat(Math.max(arr[i3].count, 0));
      if (i3 + 1 < arr.length && (arr[i3].added && arr[i3 + 1].removed || arr[i3].removed && arr[i3 + 1].added)) {
        arr[i3 + 1].count -= arr[i3].count;
      }
    }
  }
  return output + kleur_default.red(tmp);
}
function direct(input, expect, lenA = String(input).length, lenB = String(expect).length) {
  let gutter = 4;
  let lenC = Math.max(lenA, lenB);
  let typeA = typeof input, typeB = typeof expect;
  if (typeA !== typeB) {
    gutter = 2;
    let delA = gutter + lenC - lenA;
    let delB = gutter + lenC - lenB;
    input += " ".repeat(delA) + kleur_default.dim(`[${typeA}]`);
    expect += " ".repeat(delB) + kleur_default.dim(`[${typeB}]`);
    lenA += delA + typeA.length + 2;
    lenB += delB + typeB.length + 2;
    lenC = Math.max(lenA, lenB);
  }
  let output = colors["++"]("++" + expect + " ".repeat(gutter + lenC - lenB) + TITLE("(Expected)")) + "\n";
  return output + colors["--"]("--" + input + " ".repeat(gutter + lenC - lenA) + TITLE("(Actual)")) + "\n";
}
function sort(input, expect) {
  var k, i3 = 0, tmp, isArr = Array.isArray(input);
  var keys2 = [], out = isArr ? Array(input.length) : {};
  if (isArr) {
    for (i3 = 0; i3 < out.length; i3++) {
      tmp = input[i3];
      if (!tmp || typeof tmp !== "object") out[i3] = tmp;
      else out[i3] = sort(tmp, expect[i3]);
    }
  } else {
    for (k in expect)
      keys2.push(k);
    for (; i3 < keys2.length; i3++) {
      if (Object.prototype.hasOwnProperty.call(input, k = keys2[i3])) {
        if (!(tmp = input[k]) || typeof tmp !== "object") out[k] = tmp;
        else out[k] = sort(tmp, expect[k]);
      }
    }
    for (k in input) {
      if (!out.hasOwnProperty(k)) {
        out[k] = input[k];
      }
    }
  }
  return out;
}
function circular() {
  var cache = /* @__PURE__ */ new Set();
  return function print3(key, val) {
    if (val === void 0) return "[__VOID__]";
    if (typeof val === "number" && val !== val) return "[__NAN__]";
    if (typeof val === "bigint") return val.toString();
    if (!val || typeof val !== "object") return val;
    if (cache.has(val)) return "[Circular]";
    cache.add(val);
    return val;
  };
}
function stringify2(input) {
  return JSON.stringify(input, circular(), 2).replace(/"\[__NAN__\]"/g, "NaN").replace(/"\[__VOID__\]"/g, "undefined");
}
function compare(input, expect) {
  if (Array.isArray(expect) && Array.isArray(input)) return arrays(input, expect);
  if (expect instanceof RegExp) return chars("" + input, "" + expect);
  let isA = input && typeof input == "object";
  let isB = expect && typeof expect == "object";
  if (isA && isB) input = sort(input, expect);
  if (isB) expect = stringify2(expect);
  if (isA) input = stringify2(input);
  if (expect && typeof expect == "object") {
    input = stringify2(sort(input, expect));
    expect = stringify2(expect);
  }
  isA = typeof input == "string";
  isB = typeof expect == "string";
  if (isA && /\r?\n/.test(input)) return lines(input, "" + expect);
  if (isB && /\r?\n/.test(expect)) return lines("" + input, expect);
  if (isA && isB) return chars(input, expect);
  return direct(input, expect);
}

// node_modules/uvu/assert/index.mjs
function dedent(str) {
  str = str.replace(/\r?\n/g, "\n");
  let arr = str.match(/^[ \t]*(?=\S)/gm);
  let i3 = 0, min = 1 / 0, len = (arr || []).length;
  for (; i3 < len; i3++) min = Math.min(min, arr[i3].length);
  return len && min ? str.replace(new RegExp(`^[ \\t]{${min}}`, "gm"), "") : str;
}
var Assertion = class extends Error {
  constructor(opts = {}) {
    super(opts.message);
    this.name = "Assertion";
    this.code = "ERR_ASSERTION";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.details = opts.details || false;
    this.generated = !!opts.generated;
    this.operator = opts.operator;
    this.expects = opts.expects;
    this.actual = opts.actual;
  }
};
function assert(bool, actual, expects, operator, detailer, backup, msg) {
  if (bool) return;
  let message2 = msg || backup;
  if (msg instanceof Error) throw msg;
  let details = detailer && detailer(actual, expects);
  throw new Assertion({ actual, expects, operator, message: message2, details, generated: !msg });
}
function ok(val, msg) {
  assert(!!val, false, true, "ok", false, "Expected value to be truthy", msg);
}
function is(val, exp, msg) {
  assert(val === exp, val, exp, "is", compare, "Expected values to be strictly equal:", msg);
}
function not(val, msg) {
  assert(!val, true, false, "not", false, "Expected value to be falsey", msg);
}
not.ok = not;
is.not = function(val, exp, msg) {
  assert(val !== exp, val, exp, "is.not", false, "Expected values not to be strictly equal", msg);
};
not.equal = function(val, exp, msg) {
  assert(!dequal(val, exp), val, exp, "not.equal", false, "Expected values not to be deeply equal", msg);
};
not.type = function(val, exp, msg) {
  let tmp = typeof val;
  assert(tmp !== exp, tmp, exp, "not.type", false, `Expected "${tmp}" not to be "${exp}"`, msg);
};
not.instance = function(val, exp, msg) {
  let name2 = "`" + (exp.name || exp.constructor.name) + "`";
  assert(!(val instanceof exp), val, exp, "not.instance", false, `Expected value not to be an instance of ${name2}`, msg);
};
not.snapshot = function(val, exp, msg) {
  val = dedent(val);
  exp = dedent(exp);
  assert(val !== exp, val, exp, "not.snapshot", false, "Expected value not to match snapshot", msg);
};
not.fixture = function(val, exp, msg) {
  val = dedent(val);
  exp = dedent(exp);
  assert(val !== exp, val, exp, "not.fixture", false, "Expected value not to match fixture", msg);
};
not.match = function(val, exp, msg) {
  if (typeof exp === "string") {
    assert(!val.includes(exp), val, exp, "not.match", false, `Expected value not to include "${exp}" substring`, msg);
  } else {
    assert(!exp.test(val), val, exp, "not.match", false, `Expected value not to match \`${String(exp)}\` pattern`, msg);
  }
};
not.throws = function(blk, exp, msg) {
  if (!msg && typeof exp === "string") {
    msg = exp;
    exp = null;
  }
  try {
    blk();
  } catch (err) {
    if (typeof exp === "function") {
      assert(!exp(err), true, false, "not.throws", false, "Expected function not to throw matching exception", msg);
    } else if (exp instanceof RegExp) {
      assert(!exp.test(err.message), true, false, "not.throws", false, `Expected function not to throw exception matching \`${String(exp)}\` pattern`, msg);
    } else if (!exp) {
      assert(false, true, false, "not.throws", false, "Expected function not to throw", msg);
    }
  }
};

// node_modules/remark-parse/node_modules/mdast-util-to-string/lib/index.js
var emptyOptions = {};
function toString(value2, options) {
  const settings = options || emptyOptions;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one(value2, includeImageAlt, includeHtml);
}
function one(value2, includeImageAlt, includeHtml) {
  if (node(value2)) {
    if ("value" in value2) {
      return value2.type === "html" && !includeHtml ? "" : value2.value;
    }
    if (includeImageAlt && "alt" in value2 && value2.alt) {
      return value2.alt;
    }
    if ("children" in value2) {
      return all(value2.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value2)) {
    return all(value2, includeImageAlt, includeHtml);
  }
  return "";
}
function all(values3, includeImageAlt, includeHtml) {
  const result = [];
  let index3 = -1;
  while (++index3 < values3.length) {
    result[index3] = one(values3[index3], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value2) {
  return Boolean(value2 && typeof value2 === "object");
}

// node_modules/remark-parse/node_modules/micromark-util-symbol/constants.js
var constants = (
  /** @type {const} */
  {
    attentionSideBefore: 1,
    // Symbol to mark an attention sequence as before content: `*a`
    attentionSideAfter: 2,
    // Symbol to mark an attention sequence as after content: `a*`
    atxHeadingOpeningFenceSizeMax: 6,
    // 6 number signs is fine, 7 isnt.
    autolinkDomainSizeMax: 63,
    // 63 characters is fine, 64 is too many.
    autolinkSchemeSizeMax: 32,
    // 32 characters is fine, 33 is too many.
    cdataOpeningString: "CDATA[",
    // And preceded by `<![`.
    characterGroupWhitespace: 1,
    // Symbol used to indicate a character is whitespace
    characterGroupPunctuation: 2,
    // Symbol used to indicate a character is punctuation
    characterReferenceDecimalSizeMax: 7,
    // `&#9999999;`.
    characterReferenceHexadecimalSizeMax: 6,
    // `&#xff9999;`.
    characterReferenceNamedSizeMax: 31,
    // `&CounterClockwiseContourIntegral;`.
    codeFencedSequenceSizeMin: 3,
    // At least 3 ticks or tildes are needed.
    contentTypeDocument: "document",
    contentTypeFlow: "flow",
    contentTypeContent: "content",
    contentTypeString: "string",
    contentTypeText: "text",
    hardBreakPrefixSizeMin: 2,
    // At least 2 trailing spaces are needed.
    htmlRaw: 1,
    // Symbol for `<script>`
    htmlComment: 2,
    // Symbol for `<!---->`
    htmlInstruction: 3,
    // Symbol for `<?php?>`
    htmlDeclaration: 4,
    // Symbol for `<!doctype>`
    htmlCdata: 5,
    // Symbol for `<![CDATA[]]>`
    htmlBasic: 6,
    // Symbol for `<div`
    htmlComplete: 7,
    // Symbol for `<x>`
    htmlRawSizeMax: 8,
    // Length of `textarea`.
    linkResourceDestinationBalanceMax: 32,
    // See: <https://spec.commonmark.org/0.30/#link-destination>, <https://github.com/remarkjs/react-markdown/issues/658#issuecomment-984345577>
    linkReferenceSizeMax: 999,
    // See: <https://spec.commonmark.org/0.30/#link-label>
    listItemValueSizeMax: 10,
    // See: <https://spec.commonmark.org/0.30/#ordered-list-marker>
    numericBaseDecimal: 10,
    numericBaseHexadecimal: 16,
    tabSize: 4,
    // Tabs have a hard-coded size of 4, per CommonMark.
    thematicBreakMarkerCountMin: 3,
    // At least 3 asterisks, dashes, or underscores are needed.
    v8MaxSafeChunkSize: 1e4
    // V8 (and potentially others) have problems injecting giant arrays into other arrays, hence we operate in chunks.
  }
);

// node_modules/remark-parse/node_modules/micromark-util-chunked/dev/index.js
function splice(list3, start2, remove, items) {
  const end = list3.length;
  let chunkStart = 0;
  let parameters;
  if (start2 < 0) {
    start2 = -start2 > end ? 0 : end + start2;
  } else {
    start2 = start2 > end ? end : start2;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < constants.v8MaxSafeChunkSize) {
    parameters = Array.from(items);
    parameters.unshift(start2, remove);
    list3.splice(...parameters);
  } else {
    if (remove) list3.splice(start2, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(
        chunkStart,
        chunkStart + constants.v8MaxSafeChunkSize
      );
      parameters.unshift(start2, 0);
      list3.splice(...parameters);
      chunkStart += constants.v8MaxSafeChunkSize;
      start2 += constants.v8MaxSafeChunkSize;
    }
  }
}
function push2(list3, items) {
  if (list3.length > 0) {
    splice(list3, list3.length, 0, items);
    return list3;
  }
  return items;
}

// node_modules/remark-parse/node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty2 = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all3 = {};
  let index3 = -1;
  while (++index3 < extensions.length) {
    syntaxExtension(all3, extensions[index3]);
  }
  return all3;
}
function syntaxExtension(all3, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty2.call(all3, hook) ? all3[hook] : void 0;
    const left = maybe || (all3[hook] = {});
    const right = extension2[hook];
    let code2;
    if (right) {
      for (code2 in right) {
        if (!hasOwnProperty2.call(left, code2)) left[code2] = [];
        const value2 = right[code2];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code2],
          Array.isArray(value2) ? value2 : value2 ? [value2] : []
        );
      }
    }
  }
}
function constructs(existing, list3) {
  let index3 = -1;
  const before = [];
  while (++index3 < list3.length) {
    ;
    (list3[index3].add === "after" ? existing : before).push(list3[index3]);
  }
  splice(existing, 0, 0, before);
}

// node_modules/remark-parse/node_modules/micromark-util-symbol/codes.js
var codes = (
  /** @type {const} */
  {
    carriageReturn: -5,
    lineFeed: -4,
    carriageReturnLineFeed: -3,
    horizontalTab: -2,
    virtualSpace: -1,
    eof: null,
    nul: 0,
    soh: 1,
    stx: 2,
    etx: 3,
    eot: 4,
    enq: 5,
    ack: 6,
    bel: 7,
    bs: 8,
    ht: 9,
    // `\t`
    lf: 10,
    // `\n`
    vt: 11,
    // `\v`
    ff: 12,
    // `\f`
    cr: 13,
    // `\r`
    so: 14,
    si: 15,
    dle: 16,
    dc1: 17,
    dc2: 18,
    dc3: 19,
    dc4: 20,
    nak: 21,
    syn: 22,
    etb: 23,
    can: 24,
    em: 25,
    sub: 26,
    esc: 27,
    fs: 28,
    gs: 29,
    rs: 30,
    us: 31,
    space: 32,
    exclamationMark: 33,
    // `!`
    quotationMark: 34,
    // `"`
    numberSign: 35,
    // `#`
    dollarSign: 36,
    // `$`
    percentSign: 37,
    // `%`
    ampersand: 38,
    // `&`
    apostrophe: 39,
    // `'`
    leftParenthesis: 40,
    // `(`
    rightParenthesis: 41,
    // `)`
    asterisk: 42,
    // `*`
    plusSign: 43,
    // `+`
    comma: 44,
    // `,`
    dash: 45,
    // `-`
    dot: 46,
    // `.`
    slash: 47,
    // `/`
    digit0: 48,
    // `0`
    digit1: 49,
    // `1`
    digit2: 50,
    // `2`
    digit3: 51,
    // `3`
    digit4: 52,
    // `4`
    digit5: 53,
    // `5`
    digit6: 54,
    // `6`
    digit7: 55,
    // `7`
    digit8: 56,
    // `8`
    digit9: 57,
    // `9`
    colon: 58,
    // `:`
    semicolon: 59,
    // `;`
    lessThan: 60,
    // `<`
    equalsTo: 61,
    // `=`
    greaterThan: 62,
    // `>`
    questionMark: 63,
    // `?`
    atSign: 64,
    // `@`
    uppercaseA: 65,
    // `A`
    uppercaseB: 66,
    // `B`
    uppercaseC: 67,
    // `C`
    uppercaseD: 68,
    // `D`
    uppercaseE: 69,
    // `E`
    uppercaseF: 70,
    // `F`
    uppercaseG: 71,
    // `G`
    uppercaseH: 72,
    // `H`
    uppercaseI: 73,
    // `I`
    uppercaseJ: 74,
    // `J`
    uppercaseK: 75,
    // `K`
    uppercaseL: 76,
    // `L`
    uppercaseM: 77,
    // `M`
    uppercaseN: 78,
    // `N`
    uppercaseO: 79,
    // `O`
    uppercaseP: 80,
    // `P`
    uppercaseQ: 81,
    // `Q`
    uppercaseR: 82,
    // `R`
    uppercaseS: 83,
    // `S`
    uppercaseT: 84,
    // `T`
    uppercaseU: 85,
    // `U`
    uppercaseV: 86,
    // `V`
    uppercaseW: 87,
    // `W`
    uppercaseX: 88,
    // `X`
    uppercaseY: 89,
    // `Y`
    uppercaseZ: 90,
    // `Z`
    leftSquareBracket: 91,
    // `[`
    backslash: 92,
    // `\`
    rightSquareBracket: 93,
    // `]`
    caret: 94,
    // `^`
    underscore: 95,
    // `_`
    graveAccent: 96,
    // `` ` ``
    lowercaseA: 97,
    // `a`
    lowercaseB: 98,
    // `b`
    lowercaseC: 99,
    // `c`
    lowercaseD: 100,
    // `d`
    lowercaseE: 101,
    // `e`
    lowercaseF: 102,
    // `f`
    lowercaseG: 103,
    // `g`
    lowercaseH: 104,
    // `h`
    lowercaseI: 105,
    // `i`
    lowercaseJ: 106,
    // `j`
    lowercaseK: 107,
    // `k`
    lowercaseL: 108,
    // `l`
    lowercaseM: 109,
    // `m`
    lowercaseN: 110,
    // `n`
    lowercaseO: 111,
    // `o`
    lowercaseP: 112,
    // `p`
    lowercaseQ: 113,
    // `q`
    lowercaseR: 114,
    // `r`
    lowercaseS: 115,
    // `s`
    lowercaseT: 116,
    // `t`
    lowercaseU: 117,
    // `u`
    lowercaseV: 118,
    // `v`
    lowercaseW: 119,
    // `w`
    lowercaseX: 120,
    // `x`
    lowercaseY: 121,
    // `y`
    lowercaseZ: 122,
    // `z`
    leftCurlyBrace: 123,
    // `{`
    verticalBar: 124,
    // `|`
    rightCurlyBrace: 125,
    // `}`
    tilde: 126,
    // `~`
    del: 127,
    // Unicode Specials block.
    byteOrderMarker: 65279,
    // Unicode Specials block.
    replacementCharacter: 65533
    // ``
  }
);

// node_modules/remark-parse/node_modules/micromark-util-character/dev/lib/unicode-punctuation-regex.js
var unicodePunctuationRegex = /[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;

// node_modules/remark-parse/node_modules/micromark-util-character/dev/index.js
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code2) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code2 !== null && (code2 < codes.space || code2 === codes.del)
  );
}
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code2) {
  return code2 !== null && code2 < codes.horizontalTab;
}
function markdownLineEndingOrSpace(code2) {
  return code2 !== null && (code2 < codes.nul || code2 === codes.space);
}
function markdownSpace(code2) {
  return code2 === codes.horizontalTab || code2 === codes.virtualSpace || code2 === codes.space;
}
var unicodePunctuation = regexCheck(unicodePunctuationRegex);
var unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex) {
  return check;
  function check(code2) {
    return code2 !== null && regex.test(String.fromCharCode(code2));
  }
}

// node_modules/remark-parse/node_modules/micromark-factory-space/dev/index.js
function factorySpace(effects, ok3, type2, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start2;
  function start2(code2) {
    if (markdownSpace(code2)) {
      effects.enter(type2);
      return prefix(code2);
    }
    return ok3(code2);
  }
  function prefix(code2) {
    if (markdownSpace(code2) && size++ < limit) {
      effects.consume(code2);
      return prefix;
    }
    effects.exit(type2);
    return ok3(code2);
  }
}

// node_modules/remark-parse/node_modules/micromark-util-symbol/types.js
var types2 = (
  /** @type {const} */
  {
    // Generic type for data, such as in a title, a destination, etc.
    data: "data",
    // Generic type for syntactic whitespace (tabs, virtual spaces, spaces).
    // Such as, between a fenced code fence and an info string.
    whitespace: "whitespace",
    // Generic type for line endings (line feed, carriage return, carriage return +
    // line feed).
    lineEnding: "lineEnding",
    // A line ending, but ending a blank line.
    lineEndingBlank: "lineEndingBlank",
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a
    // line.
    linePrefix: "linePrefix",
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the end of a
    // line.
    lineSuffix: "lineSuffix",
    // Whole ATX heading:
    //
    // ```markdown
    // #
    // ## Alpha
    // ### Bravo ###
    // ```
    //
    // Includes `atxHeadingSequence`, `whitespace`, `atxHeadingText`.
    atxHeading: "atxHeading",
    // Sequence of number signs in an ATX heading (`###`).
    atxHeadingSequence: "atxHeadingSequence",
    // Content in an ATX heading (`alpha`).
    // Includes text.
    atxHeadingText: "atxHeadingText",
    // Whole autolink (`<https://example.com>` or `<admin@example.com>`)
    // Includes `autolinkMarker` and `autolinkProtocol` or `autolinkEmail`.
    autolink: "autolink",
    // Email autolink w/o markers (`admin@example.com`)
    autolinkEmail: "autolinkEmail",
    // Marker around an `autolinkProtocol` or `autolinkEmail` (`<` or `>`).
    autolinkMarker: "autolinkMarker",
    // Protocol autolink w/o markers (`https://example.com`)
    autolinkProtocol: "autolinkProtocol",
    // A whole character escape (`\-`).
    // Includes `escapeMarker` and `characterEscapeValue`.
    characterEscape: "characterEscape",
    // The escaped character (`-`).
    characterEscapeValue: "characterEscapeValue",
    // A whole character reference (`&amp;`, `&#8800;`, or `&#x1D306;`).
    // Includes `characterReferenceMarker`, an optional
    // `characterReferenceMarkerNumeric`, in which case an optional
    // `characterReferenceMarkerHexadecimal`, and a `characterReferenceValue`.
    characterReference: "characterReference",
    // The start or end marker (`&` or `;`).
    characterReferenceMarker: "characterReferenceMarker",
    // Mark reference as numeric (`#`).
    characterReferenceMarkerNumeric: "characterReferenceMarkerNumeric",
    // Mark reference as numeric (`x` or `X`).
    characterReferenceMarkerHexadecimal: "characterReferenceMarkerHexadecimal",
    // Value of character reference w/o markers (`amp`, `8800`, or `1D306`).
    characterReferenceValue: "characterReferenceValue",
    // Whole fenced code:
    //
    // ````markdown
    // ```js
    // alert(1)
    // ```
    // ````
    codeFenced: "codeFenced",
    // A fenced code fence, including whitespace, sequence, info, and meta
    // (` ```js `).
    codeFencedFence: "codeFencedFence",
    // Sequence of grave accent or tilde characters (` ``` `) in a fence.
    codeFencedFenceSequence: "codeFencedFenceSequence",
    // Info word (`js`) in a fence.
    // Includes string.
    codeFencedFenceInfo: "codeFencedFenceInfo",
    // Meta words (`highlight="1"`) in a fence.
    // Includes string.
    codeFencedFenceMeta: "codeFencedFenceMeta",
    // A line of code.
    codeFlowValue: "codeFlowValue",
    // Whole indented code:
    //
    // ```markdown
    //     alert(1)
    // ```
    //
    // Includes `lineEnding`, `linePrefix`, and `codeFlowValue`.
    codeIndented: "codeIndented",
    // A text code (``` `alpha` ```).
    // Includes `codeTextSequence`, `codeTextData`, `lineEnding`, and can include
    // `codeTextPadding`.
    codeText: "codeText",
    codeTextData: "codeTextData",
    // A space or line ending right after or before a tick.
    codeTextPadding: "codeTextPadding",
    // A text code fence (` `` `).
    codeTextSequence: "codeTextSequence",
    // Whole content:
    //
    // ```markdown
    // [a]: b
    // c
    // =
    // d
    // ```
    //
    // Includes `paragraph` and `definition`.
    content: "content",
    // Whole definition:
    //
    // ```markdown
    // [micromark]: https://github.com/micromark/micromark
    // ```
    //
    // Includes `definitionLabel`, `definitionMarker`, `whitespace`,
    // `definitionDestination`, and optionally `lineEnding` and `definitionTitle`.
    definition: "definition",
    // Destination of a definition (`https://github.com/micromark/micromark` or
    // `<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteral` or `definitionDestinationRaw`.
    definitionDestination: "definitionDestination",
    // Enclosed destination of a definition
    // (`<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteralMarker` and optionally
    // `definitionDestinationString`.
    definitionDestinationLiteral: "definitionDestinationLiteral",
    // Markers of an enclosed definition destination (`<` or `>`).
    definitionDestinationLiteralMarker: "definitionDestinationLiteralMarker",
    // Unenclosed destination of a definition
    // (`https://github.com/micromark/micromark`).
    // Includes `definitionDestinationString`.
    definitionDestinationRaw: "definitionDestinationRaw",
    // Text in an destination (`https://github.com/micromark/micromark`).
    // Includes string.
    definitionDestinationString: "definitionDestinationString",
    // Label of a definition (`[micromark]`).
    // Includes `definitionLabelMarker` and `definitionLabelString`.
    definitionLabel: "definitionLabel",
    // Markers of a definition label (`[` or `]`).
    definitionLabelMarker: "definitionLabelMarker",
    // Value of a definition label (`micromark`).
    // Includes string.
    definitionLabelString: "definitionLabelString",
    // Marker between a label and a destination (`:`).
    definitionMarker: "definitionMarker",
    // Title of a definition (`"x"`, `'y'`, or `(z)`).
    // Includes `definitionTitleMarker` and optionally `definitionTitleString`.
    definitionTitle: "definitionTitle",
    // Marker around a title of a definition (`"`, `'`, `(`, or `)`).
    definitionTitleMarker: "definitionTitleMarker",
    // Data without markers in a title (`z`).
    // Includes string.
    definitionTitleString: "definitionTitleString",
    // Emphasis (`*alpha*`).
    // Includes `emphasisSequence` and `emphasisText`.
    emphasis: "emphasis",
    // Sequence of emphasis markers (`*` or `_`).
    emphasisSequence: "emphasisSequence",
    // Emphasis text (`alpha`).
    // Includes text.
    emphasisText: "emphasisText",
    // The character escape marker (`\`).
    escapeMarker: "escapeMarker",
    // A hard break created with a backslash (`\\n`).
    // Note: does not include the line ending.
    hardBreakEscape: "hardBreakEscape",
    // A hard break created with trailing spaces (`  \n`).
    // Does not include the line ending.
    hardBreakTrailing: "hardBreakTrailing",
    // Flow HTML:
    //
    // ```markdown
    // <div
    // ```
    //
    // Inlcudes `lineEnding`, `htmlFlowData`.
    htmlFlow: "htmlFlow",
    htmlFlowData: "htmlFlowData",
    // HTML in text (the tag in `a <i> b`).
    // Includes `lineEnding`, `htmlTextData`.
    htmlText: "htmlText",
    htmlTextData: "htmlTextData",
    // Whole image (`![alpha](bravo)`, `![alpha][bravo]`, `![alpha][]`, or
    // `![alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    image: "image",
    // Whole link label (`[*alpha*]`).
    // Includes `labelLink` or `labelImage`, `labelText`, and `labelEnd`.
    label: "label",
    // Text in an label (`*alpha*`).
    // Includes text.
    labelText: "labelText",
    // Start a link label (`[`).
    // Includes a `labelMarker`.
    labelLink: "labelLink",
    // Start an image label (`![`).
    // Includes `labelImageMarker` and `labelMarker`.
    labelImage: "labelImage",
    // Marker of a label (`[` or `]`).
    labelMarker: "labelMarker",
    // Marker to start an image (`!`).
    labelImageMarker: "labelImageMarker",
    // End a label (`]`).
    // Includes `labelMarker`.
    labelEnd: "labelEnd",
    // Whole link (`[alpha](bravo)`, `[alpha][bravo]`, `[alpha][]`, or `[alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    link: "link",
    // Whole paragraph:
    //
    // ```markdown
    // alpha
    // bravo.
    // ```
    //
    // Includes text.
    paragraph: "paragraph",
    // A reference (`[alpha]` or `[]`).
    // Includes `referenceMarker` and an optional `referenceString`.
    reference: "reference",
    // A reference marker (`[` or `]`).
    referenceMarker: "referenceMarker",
    // Reference text (`alpha`).
    // Includes string.
    referenceString: "referenceString",
    // A resource (`(https://example.com "alpha")`).
    // Includes `resourceMarker`, an optional `resourceDestination` with an optional
    // `whitespace` and `resourceTitle`.
    resource: "resource",
    // A resource destination (`https://example.com`).
    // Includes `resourceDestinationLiteral` or `resourceDestinationRaw`.
    resourceDestination: "resourceDestination",
    // A literal resource destination (`<https://example.com>`).
    // Includes `resourceDestinationLiteralMarker` and optionally
    // `resourceDestinationString`.
    resourceDestinationLiteral: "resourceDestinationLiteral",
    // A resource destination marker (`<` or `>`).
    resourceDestinationLiteralMarker: "resourceDestinationLiteralMarker",
    // A raw resource destination (`https://example.com`).
    // Includes `resourceDestinationString`.
    resourceDestinationRaw: "resourceDestinationRaw",
    // Resource destination text (`https://example.com`).
    // Includes string.
    resourceDestinationString: "resourceDestinationString",
    // A resource marker (`(` or `)`).
    resourceMarker: "resourceMarker",
    // A resource title (`"alpha"`, `'alpha'`, or `(alpha)`).
    // Includes `resourceTitleMarker` and optionally `resourceTitleString`.
    resourceTitle: "resourceTitle",
    // A resource title marker (`"`, `'`, `(`, or `)`).
    resourceTitleMarker: "resourceTitleMarker",
    // Resource destination title (`alpha`).
    // Includes string.
    resourceTitleString: "resourceTitleString",
    // Whole setext heading:
    //
    // ```markdown
    // alpha
    // bravo
    // =====
    // ```
    //
    // Includes `setextHeadingText`, `lineEnding`, `linePrefix`, and
    // `setextHeadingLine`.
    setextHeading: "setextHeading",
    // Content in a setext heading (`alpha\nbravo`).
    // Includes text.
    setextHeadingText: "setextHeadingText",
    // Underline in a setext heading, including whitespace suffix (`==`).
    // Includes `setextHeadingLineSequence`.
    setextHeadingLine: "setextHeadingLine",
    // Sequence of equals or dash characters in underline in a setext heading (`-`).
    setextHeadingLineSequence: "setextHeadingLineSequence",
    // Strong (`**alpha**`).
    // Includes `strongSequence` and `strongText`.
    strong: "strong",
    // Sequence of strong markers (`**` or `__`).
    strongSequence: "strongSequence",
    // Strong text (`alpha`).
    // Includes text.
    strongText: "strongText",
    // Whole thematic break:
    //
    // ```markdown
    // * * *
    // ```
    //
    // Includes `thematicBreakSequence` and `whitespace`.
    thematicBreak: "thematicBreak",
    // A sequence of one or more thematic break markers (`***`).
    thematicBreakSequence: "thematicBreakSequence",
    // Whole block quote:
    //
    // ```markdown
    // > a
    // >
    // > b
    // ```
    //
    // Includes `blockQuotePrefix` and flow.
    blockQuote: "blockQuote",
    // The `>` or `> ` of a block quote.
    blockQuotePrefix: "blockQuotePrefix",
    // The `>` of a block quote prefix.
    blockQuoteMarker: "blockQuoteMarker",
    // The optional ` ` of a block quote prefix.
    blockQuotePrefixWhitespace: "blockQuotePrefixWhitespace",
    // Whole unordered list:
    //
    // ```markdown
    // - a
    //   b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listOrdered: "listOrdered",
    // Whole ordered list:
    //
    // ```markdown
    // 1. a
    //    b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listUnordered: "listUnordered",
    // The indent of further list item lines.
    listItemIndent: "listItemIndent",
    // A marker, as in, `*`, `+`, `-`, `.`, or `)`.
    listItemMarker: "listItemMarker",
    // The thing that starts a list item, such as `1. `.
    // Includes `listItemValue` if ordered, `listItemMarker`, and
    // `listItemPrefixWhitespace` (unless followed by a line ending).
    listItemPrefix: "listItemPrefix",
    // The whitespace after a marker.
    listItemPrefixWhitespace: "listItemPrefixWhitespace",
    // The numerical value of an ordered item.
    listItemValue: "listItemValue",
    // Internal types used for subtokenizers, compiled away
    chunkDocument: "chunkDocument",
    chunkContent: "chunkContent",
    chunkFlow: "chunkFlow",
    chunkText: "chunkText",
    chunkString: "chunkString"
  }
);

// node_modules/remark-parse/node_modules/micromark/dev/lib/initialize/content.js
var content = { tokenize: initializeContent };
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  let previous2;
  return contentStart;
  function afterContentStartConstruct(code2) {
    ok(
      code2 === codes.eof || markdownLineEnding(code2),
      "expected eol or eof"
    );
    if (code2 === codes.eof) {
      effects.consume(code2);
      return;
    }
    effects.enter(types2.lineEnding);
    effects.consume(code2);
    effects.exit(types2.lineEnding);
    return factorySpace(effects, contentStart, types2.linePrefix);
  }
  function paragraphInitial(code2) {
    ok(
      code2 !== codes.eof && !markdownLineEnding(code2),
      "expected anything other than a line ending or EOF"
    );
    effects.enter(types2.paragraph);
    return lineStart(code2);
  }
  function lineStart(code2) {
    const token = effects.enter(types2.chunkText, {
      contentType: constants.contentTypeText,
      previous: previous2
    });
    if (previous2) {
      previous2.next = token;
    }
    previous2 = token;
    return data(code2);
  }
  function data(code2) {
    if (code2 === codes.eof) {
      effects.exit(types2.chunkText);
      effects.exit(types2.paragraph);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      effects.exit(types2.chunkText);
      return lineStart;
    }
    effects.consume(code2);
    return data;
  }
}

// node_modules/remark-parse/node_modules/micromark/dev/lib/initialize/document.js
var document2 = { tokenize: initializeDocument };
var containerConstruct = { tokenize: tokenizeContainer };
function initializeDocument(effects) {
  const self = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start2;
  function start2(code2) {
    if (continued < stack.length) {
      const item = stack[continued];
      self.containerState = item[1];
      ok(
        item[0].continuation,
        "expected `continuation` to be defined on container construct"
      );
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code2);
    }
    return checkNewContainers(code2);
  }
  function documentContinue(code2) {
    ok(
      self.containerState,
      "expected `containerState` to be defined after continuation"
    );
    continued++;
    if (self.containerState._closeFlow) {
      self.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point5;
      while (indexBeforeFlow--) {
        if (self.events[indexBeforeFlow][0] === "exit" && self.events[indexBeforeFlow][1].type === types2.chunkFlow) {
          point5 = self.events[indexBeforeFlow][1].end;
          break;
        }
      }
      ok(point5, "could not find previous flow chunk");
      exitContainers(continued);
      let index3 = indexBeforeExits;
      while (index3 < self.events.length) {
        self.events[index3][1].end = Object.assign({}, point5);
        index3++;
      }
      splice(
        self.events,
        indexBeforeFlow + 1,
        0,
        self.events.slice(indexBeforeExits)
      );
      self.events.length = index3;
      return checkNewContainers(code2);
    }
    return start2(code2);
  }
  function checkNewContainers(code2) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code2);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code2);
      }
      self.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }
    self.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code2);
  }
  function thereIsANewContainer(code2) {
    if (childFlow) closeFlow();
    exitContainers(continued);
    return documentContinued(code2);
  }
  function thereIsNoNewContainer(code2) {
    self.parser.lazy[self.now().line] = continued !== stack.length;
    lineStartOffset = self.now().offset;
    return flowStart(code2);
  }
  function documentContinued(code2) {
    self.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code2);
  }
  function containerContinue(code2) {
    ok(
      self.currentConstruct,
      "expected `currentConstruct` to be defined on tokenizer"
    );
    ok(
      self.containerState,
      "expected `containerState` to be defined on tokenizer"
    );
    continued++;
    stack.push([self.currentConstruct, self.containerState]);
    return documentContinued(code2);
  }
  function flowStart(code2) {
    if (code2 === codes.eof) {
      if (childFlow) closeFlow();
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    childFlow = childFlow || self.parser.flow(self.now());
    effects.enter(types2.chunkFlow, {
      contentType: constants.contentTypeFlow,
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code2);
  }
  function flowContinue(code2) {
    if (code2 === codes.eof) {
      writeToChild(effects.exit(types2.chunkFlow), true);
      exitContainers(0);
      effects.consume(code2);
      return;
    }
    if (markdownLineEnding(code2)) {
      effects.consume(code2);
      writeToChild(effects.exit(types2.chunkFlow));
      continued = 0;
      self.interrupt = void 0;
      return start2;
    }
    effects.consume(code2);
    return flowContinue;
  }
  function writeToChild(token, eof) {
    ok(childFlow, "expected `childFlow` to be defined when continuing");
    const stream = self.sliceStream(token);
    if (eof) stream.push(null);
    token.previous = childToken;
    if (childToken) childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self.parser.lazy[token.start.line]) {
      let index3 = childFlow.events.length;
      while (index3--) {
        if (
          // The token starts before the line ending
          childFlow.events[index3][1].start.offset < lineStartOffset && // and either is not ended yet
          (!childFlow.events[index3][1].end || // or ends after it.
          childFlow.events[index3][1].end.offset > lineStartOffset)
        ) {
          return;
        }
      }
      const indexBeforeExits = self.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point5;
      while (indexBeforeFlow--) {
        if (self.events[indexBeforeFlow][0] === "exit" && self.events[indexBeforeFlow][1].type === types2.chunkFlow) {
          if (seen) {
            point5 = self.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      ok(point5, "could not find previous flow chunk");
      exitContainers(continued);
      index3 = indexBeforeExits;
      while (index3 < self.events.length) {
        self.events[index3][1].end = Object.assign({}, point5);
        index3++;
      }
      splice(
        self.events,
        indexBeforeFlow + 1,
        0,
        self.events.slice(indexBeforeExits)
      );
      self.events.length = index3;
    }
  }
  function exitContainers(size) {
    let index3 = stack.length;
    while (index3-- > size) {
      const entry = stack[index3];
      self.containerState = entry[1];
      ok(
        entry[0].exit,
        "expected `exit` to be defined on container construct"
      );
      entry[0].exit.call(self, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    ok(
      self.containerState,
      "expected `containerState` to be defined when closing flow"
    );
    ok(childFlow, "expected `childFlow` to be defined when closing it");
    childFlow.write([codes.eof]);
    childToken = void 0;
    childFlow = void 0;
    self.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok3, nok) {
  ok(
    this.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok3, nok),
    types2.linePrefix,
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
  );
}

// node_modules/remark-parse/node_modules/micromark-util-classify-character/dev/index.js
function classifyCharacter(code2) {
  if (code2 === codes.eof || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
    return constants.characterGroupWhitespace;
  }
  if (unicodePunctuation(code2)) {
    return constants.characterGroupPunctuation;
  }
}

// node_modules/remark-parse/node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
  const called = [];
  let index3 = -1;
  while (++index3 < constructs2.length) {
    const resolve = constructs2[index3].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/attention.js
var attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events, context) {
  let index3 = -1;
  let open;
  let group;
  let text4;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset;
  while (++index3 < events.length) {
    if (events[index3][0] === "enter" && events[index3][1].type === "attentionSequence" && events[index3][1]._close) {
      open = index3;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index3][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index3][1]._open) && (events[index3][1].end.offset - events[index3][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index3][1].end.offset - events[index3][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index3][1].end.offset - events[index3][1].start.offset > 1 ? 2 : 1;
          const start2 = Object.assign({}, events[open][1].end);
          const end = Object.assign({}, events[index3][1].start);
          movePoint(start2, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? types2.strongSequence : types2.emphasisSequence,
            start: start2,
            end: Object.assign({}, events[open][1].end)
          };
          closingSequence = {
            type: use > 1 ? types2.strongSequence : types2.emphasisSequence,
            start: Object.assign({}, events[index3][1].start),
            end
          };
          text4 = {
            type: use > 1 ? types2.strongText : types2.emphasisText,
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index3][1].start)
          };
          group = {
            type: use > 1 ? types2.strong : types2.emphasis,
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open][1].end = Object.assign({}, openingSequence.start);
          events[index3][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push2(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push2(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text4, context]
          ]);
          ok(
            context.parser.constructs.insideSpan.null,
            "expected `insideSpan` to be populated"
          );
          nextEvents = push2(
            nextEvents,
            resolveAll(
              context.parser.constructs.insideSpan.null,
              events.slice(open + 1, index3),
              context
            )
          );
          nextEvents = push2(nextEvents, [
            ["exit", text4, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index3][1].end.offset - events[index3][1].start.offset) {
            offset = 2;
            nextEvents = push2(nextEvents, [
              ["enter", events[index3][1], context],
              ["exit", events[index3][1], context]
            ]);
          } else {
            offset = 0;
          }
          splice(events, open - 1, index3 - open + 3, nextEvents);
          index3 = open + nextEvents.length - offset - 2;
          break;
        }
      }
    }
  }
  index3 = -1;
  while (++index3 < events.length) {
    if (events[index3][1].type === "attentionSequence") {
      events[index3][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok3) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous2 = this.previous;
  const before = classifyCharacter(previous2);
  let marker;
  return start2;
  function start2(code2) {
    ok(
      code2 === codes.asterisk || code2 === codes.underscore,
      "expected asterisk or underscore"
    );
    marker = code2;
    effects.enter("attentionSequence");
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code2);
    ok(attentionMarkers2, "expected `attentionMarkers` to be populated");
    const open = !after || after === constants.characterGroupPunctuation && before || attentionMarkers2.includes(code2);
    const close = !before || before === constants.characterGroupPunctuation && after || attentionMarkers2.includes(previous2);
    token._open = Boolean(
      marker === codes.asterisk ? open : open && (before || !close)
    );
    token._close = Boolean(
      marker === codes.asterisk ? close : close && (after || !open)
    );
    return ok3(code2);
  }
}
function movePoint(point5, offset) {
  point5.column += offset;
  point5.offset += offset;
  point5._bufferIndex += offset;
}

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/autolink.js
var autolink = { name: "autolink", tokenize: tokenizeAutolink };
function tokenizeAutolink(effects, ok3, nok) {
  let size = 0;
  return start2;
  function start2(code2) {
    ok(code2 === codes.lessThan, "expected `<`");
    effects.enter(types2.autolink);
    effects.enter(types2.autolinkMarker);
    effects.consume(code2);
    effects.exit(types2.autolinkMarker);
    effects.enter(types2.autolinkProtocol);
    return open;
  }
  function open(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return schemeOrEmailAtext;
    }
    return emailAtext(code2);
  }
  function schemeOrEmailAtext(code2) {
    if (code2 === codes.plusSign || code2 === codes.dash || code2 === codes.dot || asciiAlphanumeric(code2)) {
      size = 1;
      return schemeInsideOrEmailAtext(code2);
    }
    return emailAtext(code2);
  }
  function schemeInsideOrEmailAtext(code2) {
    if (code2 === codes.colon) {
      effects.consume(code2);
      size = 0;
      return urlInside;
    }
    if ((code2 === codes.plusSign || code2 === codes.dash || code2 === codes.dot || asciiAlphanumeric(code2)) && size++ < constants.autolinkSchemeSizeMax) {
      effects.consume(code2);
      return schemeInsideOrEmailAtext;
    }
    size = 0;
    return emailAtext(code2);
  }
  function urlInside(code2) {
    if (code2 === codes.greaterThan) {
      effects.exit(types2.autolinkProtocol);
      effects.enter(types2.autolinkMarker);
      effects.consume(code2);
      effects.exit(types2.autolinkMarker);
      effects.exit(types2.autolink);
      return ok3;
    }
    if (code2 === codes.eof || code2 === codes.space || code2 === codes.lessThan || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return urlInside;
  }
  function emailAtext(code2) {
    if (code2 === codes.atSign) {
      effects.consume(code2);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code2)) {
      effects.consume(code2);
      return emailAtext;
    }
    return nok(code2);
  }
  function emailAtSignOrDot(code2) {
    return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
  }
  function emailLabel(code2) {
    if (code2 === codes.dot) {
      effects.consume(code2);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code2 === codes.greaterThan) {
      effects.exit(types2.autolinkProtocol).type = types2.autolinkEmail;
      effects.enter(types2.autolinkMarker);
      effects.consume(code2);
      effects.exit(types2.autolinkMarker);
      effects.exit(types2.autolink);
      return ok3;
    }
    return emailValue(code2);
  }
  function emailValue(code2) {
    if ((code2 === codes.dash || asciiAlphanumeric(code2)) && size++ < constants.autolinkDomainSizeMax) {
      const next = code2 === codes.dash ? emailValue : emailLabel;
      effects.consume(code2);
      return next;
    }
    return nok(code2);
  }
}

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/blank-line.js
var blankLine = { tokenize: tokenizeBlankLine, partial: true };
function tokenizeBlankLine(effects, ok3, nok) {
  return start2;
  function start2(code2) {
    return markdownSpace(code2) ? factorySpace(effects, after, types2.linePrefix)(code2) : after(code2);
  }
  function after(code2) {
    return code2 === codes.eof || markdownLineEnding(code2) ? ok3(code2) : nok(code2);
  }
}

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/block-quote.js
var blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: { tokenize: tokenizeBlockQuoteContinuation },
  exit
};
function tokenizeBlockQuoteStart(effects, ok3, nok) {
  const self = this;
  return start2;
  function start2(code2) {
    if (code2 === codes.greaterThan) {
      const state = self.containerState;
      ok(state, "expected `containerState` to be defined in container");
      if (!state.open) {
        effects.enter(types2.blockQuote, { _container: true });
        state.open = true;
      }
      effects.enter(types2.blockQuotePrefix);
      effects.enter(types2.blockQuoteMarker);
      effects.consume(code2);
      effects.exit(types2.blockQuoteMarker);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    if (markdownSpace(code2)) {
      effects.enter(types2.blockQuotePrefixWhitespace);
      effects.consume(code2);
      effects.exit(types2.blockQuotePrefixWhitespace);
      effects.exit(types2.blockQuotePrefix);
      return ok3;
    }
    effects.exit(types2.blockQuotePrefix);
    return ok3(code2);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok3, nok) {
  const self = this;
  return contStart;
  function contStart(code2) {
    if (markdownSpace(code2)) {
      ok(
        self.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      return factorySpace(
        effects,
        contBefore,
        types2.linePrefix,
        self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code2);
    }
    return contBefore(code2);
  }
  function contBefore(code2) {
    return effects.attempt(blockQuote, ok3, nok)(code2);
  }
}
function exit(effects) {
  effects.exit(types2.blockQuote);
}

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/character-escape.js
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok3, nok) {
  return start2;
  function start2(code2) {
    ok(code2 === codes.backslash, "expected `\\`");
    effects.enter(types2.characterEscape);
    effects.enter(types2.escapeMarker);
    effects.consume(code2);
    effects.exit(types2.escapeMarker);
    return inside;
  }
  function inside(code2) {
    if (asciiPunctuation(code2)) {
      effects.enter(types2.characterEscapeValue);
      effects.consume(code2);
      effects.exit(types2.characterEscapeValue);
      effects.exit(types2.characterEscape);
      return ok3;
    }
    return nok(code2);
  }
}

// node_modules/decode-named-character-reference/index.dom.js
var element = document.createElement("i");
function decodeNamedCharacterReference(value2) {
  const characterReference2 = "&" + value2 + ";";
  element.innerHTML = characterReference2;
  const character = element.textContent;
  if (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    character.charCodeAt(character.length - 1) === 59 && value2 !== "semi"
  ) {
    return false;
  }
  return character === characterReference2 ? false : character;
}

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/character-reference.js
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok3, nok) {
  const self = this;
  let size = 0;
  let max;
  let test;
  return start2;
  function start2(code2) {
    ok(code2 === codes.ampersand, "expected `&`");
    effects.enter(types2.characterReference);
    effects.enter(types2.characterReferenceMarker);
    effects.consume(code2);
    effects.exit(types2.characterReferenceMarker);
    return open;
  }
  function open(code2) {
    if (code2 === codes.numberSign) {
      effects.enter(types2.characterReferenceMarkerNumeric);
      effects.consume(code2);
      effects.exit(types2.characterReferenceMarkerNumeric);
      return numeric;
    }
    effects.enter(types2.characterReferenceValue);
    max = constants.characterReferenceNamedSizeMax;
    test = asciiAlphanumeric;
    return value2(code2);
  }
  function numeric(code2) {
    if (code2 === codes.uppercaseX || code2 === codes.lowercaseX) {
      effects.enter(types2.characterReferenceMarkerHexadecimal);
      effects.consume(code2);
      effects.exit(types2.characterReferenceMarkerHexadecimal);
      effects.enter(types2.characterReferenceValue);
      max = constants.characterReferenceHexadecimalSizeMax;
      test = asciiHexDigit;
      return value2;
    }
    effects.enter(types2.characterReferenceValue);
    max = constants.characterReferenceDecimalSizeMax;
    test = asciiDigit;
    return value2(code2);
  }
  function value2(code2) {
    if (code2 === codes.semicolon && size) {
      const token = effects.exit(types2.characterReferenceValue);
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self.sliceSerialize(token))) {
        return nok(code2);
      }
      effects.enter(types2.characterReferenceMarker);
      effects.consume(code2);
      effects.exit(types2.characterReferenceMarker);
      effects.exit(types2.characterReference);
      return ok3;
    }
    if (test(code2) && size++ < max) {
      effects.consume(code2);
      return value2;
    }
    return nok(code2);
  }
}

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/code-fenced.js
var nonLazyContinuation = {
  tokenize: tokenizeNonLazyContinuation,
  partial: true
};
var codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok3, nok) {
  const self = this;
  const closeStart = { tokenize: tokenizeCloseStart, partial: true };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start2;
  function start2(code2) {
    return beforeSequenceOpen(code2);
  }
  function beforeSequenceOpen(code2) {
    ok(
      code2 === codes.graveAccent || code2 === codes.tilde,
      "expected `` ` `` or `~`"
    );
    const tail = self.events[self.events.length - 1];
    initialPrefix = tail && tail[1].type === types2.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code2;
    effects.enter(types2.codeFenced);
    effects.enter(types2.codeFencedFence);
    effects.enter(types2.codeFencedFenceSequence);
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === marker) {
      sizeOpen++;
      effects.consume(code2);
      return sequenceOpen;
    }
    if (sizeOpen < constants.codeFencedSequenceSizeMin) {
      return nok(code2);
    }
    effects.exit(types2.codeFencedFenceSequence);
    return markdownSpace(code2) ? factorySpace(effects, infoBefore, types2.whitespace)(code2) : infoBefore(code2);
  }
  function infoBefore(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types2.codeFencedFence);
      return self.interrupt ? ok3(code2) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter(types2.codeFencedFenceInfo);
    effects.enter(types2.chunkString, { contentType: constants.contentTypeString });
    return info(code2);
  }
  function info(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types2.chunkString);
      effects.exit(types2.codeFencedFenceInfo);
      return infoBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.exit(types2.chunkString);
      effects.exit(types2.codeFencedFenceInfo);
      return factorySpace(effects, metaBefore, types2.whitespace)(code2);
    }
    if (code2 === codes.graveAccent && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return info;
  }
  function metaBefore(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return infoBefore(code2);
    }
    effects.enter(types2.codeFencedFenceMeta);
    effects.enter(types2.chunkString, { contentType: constants.contentTypeString });
    return meta(code2);
  }
  function meta(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types2.chunkString);
      effects.exit(types2.codeFencedFenceMeta);
      return infoBefore(code2);
    }
    if (code2 === codes.graveAccent && code2 === marker) {
      return nok(code2);
    }
    effects.consume(code2);
    return meta;
  }
  function atNonLazyBreak(code2) {
    ok(markdownLineEnding(code2), "expected eol");
    return effects.attempt(closeStart, after, contentBefore)(code2);
  }
  function contentBefore(code2) {
    ok(markdownLineEnding(code2), "expected eol");
    effects.enter(types2.lineEnding);
    effects.consume(code2);
    effects.exit(types2.lineEnding);
    return contentStart;
  }
  function contentStart(code2) {
    return initialPrefix > 0 && markdownSpace(code2) ? factorySpace(
      effects,
      beforeContentChunk,
      types2.linePrefix,
      initialPrefix + 1
    )(code2) : beforeContentChunk(code2);
  }
  function beforeContentChunk(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
    }
    effects.enter(types2.codeFlowValue);
    return contentChunk(code2);
  }
  function contentChunk(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types2.codeFlowValue);
      return beforeContentChunk(code2);
    }
    effects.consume(code2);
    return contentChunk;
  }
  function after(code2) {
    effects.exit(types2.codeFenced);
    return ok3(code2);
  }
  function tokenizeCloseStart(effects2, ok4, nok2) {
    let size = 0;
    return startBefore;
    function startBefore(code2) {
      ok(markdownLineEnding(code2), "expected eol");
      effects2.enter(types2.lineEnding);
      effects2.consume(code2);
      effects2.exit(types2.lineEnding);
      return start3;
    }
    function start3(code2) {
      ok(
        self.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      effects2.enter(types2.codeFencedFence);
      return markdownSpace(code2) ? factorySpace(
        effects2,
        beforeSequenceClose,
        types2.linePrefix,
        self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code2) : beforeSequenceClose(code2);
    }
    function beforeSequenceClose(code2) {
      if (code2 === marker) {
        effects2.enter(types2.codeFencedFenceSequence);
        return sequenceClose(code2);
      }
      return nok2(code2);
    }
    function sequenceClose(code2) {
      if (code2 === marker) {
        size++;
        effects2.consume(code2);
        return sequenceClose;
      }
      if (size >= sizeOpen) {
        effects2.exit(types2.codeFencedFenceSequence);
        return markdownSpace(code2) ? factorySpace(effects2, sequenceCloseAfter, types2.whitespace)(code2) : sequenceCloseAfter(code2);
      }
      return nok2(code2);
    }
    function sequenceCloseAfter(code2) {
      if (code2 === codes.eof || markdownLineEnding(code2)) {
        effects2.exit(types2.codeFencedFence);
        return ok4(code2);
      }
      return nok2(code2);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok3, nok) {
  const self = this;
  return start2;
  function start2(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    ok(markdownLineEnding(code2), "expected eol");
    effects.enter(types2.lineEnding);
    effects.consume(code2);
    effects.exit(types2.lineEnding);
    return lineStart;
  }
  function lineStart(code2) {
    return self.parser.lazy[self.now().line] ? nok(code2) : ok3(code2);
  }
}

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/code-indented.js
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var furtherStart = { tokenize: tokenizeFurtherStart, partial: true };
function tokenizeCodeIndented(effects, ok3, nok) {
  const self = this;
  return start2;
  function start2(code2) {
    ok(markdownSpace(code2));
    effects.enter(types2.codeIndented);
    return factorySpace(
      effects,
      afterPrefix,
      types2.linePrefix,
      constants.tabSize + 1
    )(code2);
  }
  function afterPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === types2.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? atBreak(code2) : nok(code2);
  }
  function atBreak(code2) {
    if (code2 === codes.eof) {
      return after(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.attempt(furtherStart, atBreak, after)(code2);
    }
    effects.enter(types2.codeFlowValue);
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types2.codeFlowValue);
      return atBreak(code2);
    }
    effects.consume(code2);
    return inside;
  }
  function after(code2) {
    effects.exit(types2.codeIndented);
    return ok3(code2);
  }
}
function tokenizeFurtherStart(effects, ok3, nok) {
  const self = this;
  return furtherStart2;
  function furtherStart2(code2) {
    if (self.parser.lazy[self.now().line]) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter(types2.lineEnding);
      effects.consume(code2);
      effects.exit(types2.lineEnding);
      return furtherStart2;
    }
    return factorySpace(
      effects,
      afterPrefix,
      types2.linePrefix,
      constants.tabSize + 1
    )(code2);
  }
  function afterPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === types2.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? ok3(code2) : markdownLineEnding(code2) ? furtherStart2(code2) : nok(code2);
  }
}

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/code-text.js
var codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index3;
  let enter;
  if ((events[headEnterIndex][1].type === types2.lineEnding || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === types2.lineEnding || events[tailExitIndex][1].type === "space")) {
    index3 = headEnterIndex;
    while (++index3 < tailExitIndex) {
      if (events[index3][1].type === types2.codeTextData) {
        events[headEnterIndex][1].type = types2.codeTextPadding;
        events[tailExitIndex][1].type = types2.codeTextPadding;
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index3 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index3 <= tailExitIndex) {
    if (enter === void 0) {
      if (index3 !== tailExitIndex && events[index3][1].type !== types2.lineEnding) {
        enter = index3;
      }
    } else if (index3 === tailExitIndex || events[index3][1].type === types2.lineEnding) {
      events[enter][1].type = types2.codeTextData;
      if (index3 !== enter + 2) {
        events[enter][1].end = events[index3 - 1][1].end;
        events.splice(enter + 2, index3 - enter - 2);
        tailExitIndex -= index3 - enter - 2;
        index3 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code2) {
  return code2 !== codes.graveAccent || this.events[this.events.length - 1][1].type === types2.characterEscape;
}
function tokenizeCodeText(effects, ok3, nok) {
  const self = this;
  let sizeOpen = 0;
  let size;
  let token;
  return start2;
  function start2(code2) {
    ok(code2 === codes.graveAccent, "expected `` ` ``");
    ok(previous.call(self, self.previous), "expected correct previous");
    effects.enter(types2.codeText);
    effects.enter(types2.codeTextSequence);
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === codes.graveAccent) {
      effects.consume(code2);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit(types2.codeTextSequence);
    return between(code2);
  }
  function between(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (code2 === codes.space) {
      effects.enter("space");
      effects.consume(code2);
      effects.exit("space");
      return between;
    }
    if (code2 === codes.graveAccent) {
      token = effects.enter(types2.codeTextSequence);
      size = 0;
      return sequenceClose(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter(types2.lineEnding);
      effects.consume(code2);
      effects.exit(types2.lineEnding);
      return between;
    }
    effects.enter(types2.codeTextData);
    return data(code2);
  }
  function data(code2) {
    if (code2 === codes.eof || code2 === codes.space || code2 === codes.graveAccent || markdownLineEnding(code2)) {
      effects.exit(types2.codeTextData);
      return between(code2);
    }
    effects.consume(code2);
    return data;
  }
  function sequenceClose(code2) {
    if (code2 === codes.graveAccent) {
      effects.consume(code2);
      size++;
      return sequenceClose;
    }
    if (size === sizeOpen) {
      effects.exit(types2.codeTextSequence);
      effects.exit(types2.codeText);
      return ok3(code2);
    }
    token.type = types2.codeTextData;
    return data(code2);
  }
}

// node_modules/remark-parse/node_modules/micromark-util-subtokenize/dev/index.js
function subtokenize(events) {
  const jumps = {};
  let index3 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  while (++index3 < events.length) {
    while (index3 in jumps) {
      index3 = jumps[index3];
    }
    event = events[index3];
    if (index3 && event[1].type === types2.chunkFlow && events[index3 - 1][1].type === types2.listItemPrefix) {
      ok(event[1]._tokenizer, "expected `_tokenizer` on subtokens");
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types2.lineEndingBlank) {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types2.content) {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === types2.content) {
            break;
          }
          if (subevents[otherIndex][1].type === types2.chunkText) {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index3));
        index3 = jumps[index3];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index3;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events[otherIndex];
        if (otherEvent[1].type === types2.lineEnding || otherEvent[1].type === types2.lineEndingBlank) {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events[lineIndex][1].type = types2.lineEndingBlank;
            }
            otherEvent[1].type = types2.lineEnding;
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = Object.assign({}, events[lineIndex][1].start);
        parameters = events.slice(lineIndex, index3);
        parameters.unshift(event);
        splice(events, lineIndex, index3 - lineIndex + 1, parameters);
      }
    }
  }
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events[eventIndex][1];
  const context = events[eventIndex][2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  ok(token.contentType, "expected `contentType` on subtokens");
  const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous2;
  let index3 = -1;
  let current = token;
  let adjust = 0;
  let start2 = 0;
  const breaks = [start2];
  while (current) {
    while (events[++startPosition][1] !== current) {
    }
    ok(
      !previous2 || current.previous === previous2,
      "expected previous to match"
    );
    ok(!previous2 || previous2.next === current, "expected next to match");
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(codes.eof);
      }
      if (previous2) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous2 = current;
    current = current.next;
  }
  current = token;
  while (++index3 < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index3][0] === "exit" && childEvents[index3 - 1][0] === "enter" && childEvents[index3][1].type === childEvents[index3 - 1][1].type && childEvents[index3][1].start.line !== childEvents[index3][1].end.line
    ) {
      ok(current, "expected a current token");
      start2 = index3 + 1;
      breaks.push(start2);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
    ok(!current.next, "expected no next token");
  } else {
    breaks.pop();
  }
  index3 = breaks.length;
  while (index3--) {
    const slice = childEvents.slice(breaks[index3], breaks[index3 + 1]);
    const start3 = startPositions.pop();
    ok(start3 !== void 0, "expected a start position when splicing");
    jumps.unshift([start3, start3 + slice.length - 1]);
    splice(events, start3, 2, slice);
  }
  index3 = -1;
  while (++index3 < jumps.length) {
    gaps[adjust + jumps[index3][0]] = adjust + jumps[index3][1];
    adjust += jumps[index3][1] - jumps[index3][0] - 1;
  }
  return gaps;
}

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/content.js
var content2 = { tokenize: tokenizeContent, resolve: resolveContent };
var continuationConstruct = { tokenize: tokenizeContinuation, partial: true };
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok3) {
  let previous2;
  return chunkStart;
  function chunkStart(code2) {
    ok(
      code2 !== codes.eof && !markdownLineEnding(code2),
      "expected no eof or eol"
    );
    effects.enter(types2.content);
    previous2 = effects.enter(types2.chunkContent, {
      contentType: constants.contentTypeContent
    });
    return chunkInside(code2);
  }
  function chunkInside(code2) {
    if (code2 === codes.eof) {
      return contentEnd(code2);
    }
    if (markdownLineEnding(code2)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code2);
    }
    effects.consume(code2);
    return chunkInside;
  }
  function contentEnd(code2) {
    effects.exit(types2.chunkContent);
    effects.exit(types2.content);
    return ok3(code2);
  }
  function contentContinue(code2) {
    ok(markdownLineEnding(code2), "expected eol");
    effects.consume(code2);
    effects.exit(types2.chunkContent);
    ok(previous2, "expected previous token");
    previous2.next = effects.enter(types2.chunkContent, {
      contentType: constants.contentTypeContent,
      previous: previous2
    });
    previous2 = previous2.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok3, nok) {
  const self = this;
  return startLookahead;
  function startLookahead(code2) {
    ok(markdownLineEnding(code2), "expected a line ending");
    effects.exit(types2.chunkContent);
    effects.enter(types2.lineEnding);
    effects.consume(code2);
    effects.exit(types2.lineEnding);
    return factorySpace(effects, prefixed, types2.linePrefix);
  }
  function prefixed(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return nok(code2);
    }
    ok(
      self.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    const tail = self.events[self.events.length - 1];
    if (!self.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === types2.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize) {
      return ok3(code2);
    }
    return effects.interrupt(self.parser.constructs.flow, nok, ok3)(code2);
  }
}

// node_modules/remark-parse/node_modules/micromark-factory-destination/dev/index.js
function factoryDestination(effects, ok3, nok, type2, literalType, literalMarkerType, rawType, stringType, max) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start2;
  function start2(code2) {
    if (code2 === codes.lessThan) {
      effects.enter(type2);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code2 === codes.eof || code2 === codes.space || code2 === codes.rightParenthesis || asciiControl(code2)) {
      return nok(code2);
    }
    effects.enter(type2);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter(types2.chunkString, { contentType: constants.contentTypeString });
    return raw(code2);
  }
  function enclosedBefore(code2) {
    if (code2 === codes.greaterThan) {
      effects.enter(literalMarkerType);
      effects.consume(code2);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type2);
      return ok3;
    }
    effects.enter(stringType);
    effects.enter(types2.chunkString, { contentType: constants.contentTypeString });
    return enclosed(code2);
  }
  function enclosed(code2) {
    if (code2 === codes.greaterThan) {
      effects.exit(types2.chunkString);
      effects.exit(stringType);
      return enclosedBefore(code2);
    }
    if (code2 === codes.eof || code2 === codes.lessThan || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === codes.backslash ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code2) {
    if (code2 === codes.lessThan || code2 === codes.greaterThan || code2 === codes.backslash) {
      effects.consume(code2);
      return enclosed;
    }
    return enclosed(code2);
  }
  function raw(code2) {
    if (!balance && (code2 === codes.eof || code2 === codes.rightParenthesis || markdownLineEndingOrSpace(code2))) {
      effects.exit(types2.chunkString);
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type2);
      return ok3(code2);
    }
    if (balance < limit && code2 === codes.leftParenthesis) {
      effects.consume(code2);
      balance++;
      return raw;
    }
    if (code2 === codes.rightParenthesis) {
      effects.consume(code2);
      balance--;
      return raw;
    }
    if (code2 === codes.eof || code2 === codes.space || code2 === codes.leftParenthesis || asciiControl(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return code2 === codes.backslash ? rawEscape : raw;
  }
  function rawEscape(code2) {
    if (code2 === codes.leftParenthesis || code2 === codes.rightParenthesis || code2 === codes.backslash) {
      effects.consume(code2);
      return raw;
    }
    return raw(code2);
  }
}

// node_modules/remark-parse/node_modules/micromark-factory-label/dev/index.js
function factoryLabel(effects, ok3, nok, type2, markerType, stringType) {
  const self = this;
  let size = 0;
  let seen;
  return start2;
  function start2(code2) {
    ok(code2 === codes.leftSquareBracket, "expected `[`");
    effects.enter(type2);
    effects.enter(markerType);
    effects.consume(code2);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code2) {
    if (size > constants.linkReferenceSizeMax || code2 === codes.eof || code2 === codes.leftSquareBracket || code2 === codes.rightSquareBracket && !seen || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code2 === codes.caret && !size && "_hiddenFootnoteSupport" in self.parser.constructs) {
      return nok(code2);
    }
    if (code2 === codes.rightSquareBracket) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type2);
      return ok3;
    }
    if (markdownLineEnding(code2)) {
      effects.enter(types2.lineEnding);
      effects.consume(code2);
      effects.exit(types2.lineEnding);
      return atBreak;
    }
    effects.enter(types2.chunkString, { contentType: constants.contentTypeString });
    return labelInside(code2);
  }
  function labelInside(code2) {
    if (code2 === codes.eof || code2 === codes.leftSquareBracket || code2 === codes.rightSquareBracket || markdownLineEnding(code2) || size++ > constants.linkReferenceSizeMax) {
      effects.exit(types2.chunkString);
      return atBreak(code2);
    }
    effects.consume(code2);
    if (!seen) seen = !markdownSpace(code2);
    return code2 === codes.backslash ? labelEscape : labelInside;
  }
  function labelEscape(code2) {
    if (code2 === codes.leftSquareBracket || code2 === codes.backslash || code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      size++;
      return labelInside;
    }
    return labelInside(code2);
  }
}

// node_modules/remark-parse/node_modules/micromark-factory-title/dev/index.js
function factoryTitle(effects, ok3, nok, type2, markerType, stringType) {
  let marker;
  return start2;
  function start2(code2) {
    if (code2 === codes.quotationMark || code2 === codes.apostrophe || code2 === codes.leftParenthesis) {
      effects.enter(type2);
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      marker = code2 === codes.leftParenthesis ? codes.rightParenthesis : code2;
      return begin;
    }
    return nok(code2);
  }
  function begin(code2) {
    if (code2 === marker) {
      effects.enter(markerType);
      effects.consume(code2);
      effects.exit(markerType);
      effects.exit(type2);
      return ok3;
    }
    effects.enter(stringType);
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      effects.enter(types2.lineEnding);
      effects.consume(code2);
      effects.exit(types2.lineEnding);
      return factorySpace(effects, atBreak, types2.linePrefix);
    }
    effects.enter(types2.chunkString, { contentType: constants.contentTypeString });
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker || code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types2.chunkString);
      return atBreak(code2);
    }
    effects.consume(code2);
    return code2 === codes.backslash ? escape : inside;
  }
  function escape(code2) {
    if (code2 === marker || code2 === codes.backslash) {
      effects.consume(code2);
      return inside;
    }
    return inside(code2);
  }
}

// node_modules/remark-parse/node_modules/micromark-factory-whitespace/dev/index.js
function factoryWhitespace(effects, ok3) {
  let seen;
  return start2;
  function start2(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter(types2.lineEnding);
      effects.consume(code2);
      effects.exit(types2.lineEnding);
      seen = true;
      return start2;
    }
    if (markdownSpace(code2)) {
      return factorySpace(
        effects,
        start2,
        seen ? types2.linePrefix : types2.lineSuffix
      )(code2);
    }
    return ok3(code2);
  }
}

// node_modules/remark-parse/node_modules/micromark-util-symbol/values.js
var values = (
  /** @type {const} */
  {
    ht: "	",
    lf: "\n",
    cr: "\r",
    space: " ",
    exclamationMark: "!",
    quotationMark: '"',
    numberSign: "#",
    dollarSign: "$",
    percentSign: "%",
    ampersand: "&",
    apostrophe: "'",
    leftParenthesis: "(",
    rightParenthesis: ")",
    asterisk: "*",
    plusSign: "+",
    comma: ",",
    dash: "-",
    dot: ".",
    slash: "/",
    digit0: "0",
    digit1: "1",
    digit2: "2",
    digit3: "3",
    digit4: "4",
    digit5: "5",
    digit6: "6",
    digit7: "7",
    digit8: "8",
    digit9: "9",
    colon: ":",
    semicolon: ";",
    lessThan: "<",
    equalsTo: "=",
    greaterThan: ">",
    questionMark: "?",
    atSign: "@",
    uppercaseA: "A",
    uppercaseB: "B",
    uppercaseC: "C",
    uppercaseD: "D",
    uppercaseE: "E",
    uppercaseF: "F",
    uppercaseG: "G",
    uppercaseH: "H",
    uppercaseI: "I",
    uppercaseJ: "J",
    uppercaseK: "K",
    uppercaseL: "L",
    uppercaseM: "M",
    uppercaseN: "N",
    uppercaseO: "O",
    uppercaseP: "P",
    uppercaseQ: "Q",
    uppercaseR: "R",
    uppercaseS: "S",
    uppercaseT: "T",
    uppercaseU: "U",
    uppercaseV: "V",
    uppercaseW: "W",
    uppercaseX: "X",
    uppercaseY: "Y",
    uppercaseZ: "Z",
    leftSquareBracket: "[",
    backslash: "\\",
    rightSquareBracket: "]",
    caret: "^",
    underscore: "_",
    graveAccent: "`",
    lowercaseA: "a",
    lowercaseB: "b",
    lowercaseC: "c",
    lowercaseD: "d",
    lowercaseE: "e",
    lowercaseF: "f",
    lowercaseG: "g",
    lowercaseH: "h",
    lowercaseI: "i",
    lowercaseJ: "j",
    lowercaseK: "k",
    lowercaseL: "l",
    lowercaseM: "m",
    lowercaseN: "n",
    lowercaseO: "o",
    lowercaseP: "p",
    lowercaseQ: "q",
    lowercaseR: "r",
    lowercaseS: "s",
    lowercaseT: "t",
    lowercaseU: "u",
    lowercaseV: "v",
    lowercaseW: "w",
    lowercaseX: "x",
    lowercaseY: "y",
    lowercaseZ: "z",
    leftCurlyBrace: "{",
    verticalBar: "|",
    rightCurlyBrace: "}",
    tilde: "~",
    replacementCharacter: ""
  }
);

// node_modules/remark-parse/node_modules/micromark-util-normalize-identifier/dev/index.js
function normalizeIdentifier(value2) {
  return value2.replace(/[\t\n\r ]+/g, values.space).replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/definition.js
var definition = { name: "definition", tokenize: tokenizeDefinition };
var titleBefore = { tokenize: tokenizeTitleBefore, partial: true };
function tokenizeDefinition(effects, ok3, nok) {
  const self = this;
  let identifier;
  return start2;
  function start2(code2) {
    effects.enter(types2.definition);
    return before(code2);
  }
  function before(code2) {
    ok(code2 === codes.leftSquareBracket, "expected `[`");
    return factoryLabel.call(
      self,
      effects,
      labelAfter,
      // Note: we dont need to reset the way `markdown-rs` does.
      nok,
      types2.definitionLabel,
      types2.definitionLabelMarker,
      types2.definitionLabelString
    )(code2);
  }
  function labelAfter(code2) {
    identifier = normalizeIdentifier(
      self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)
    );
    if (code2 === codes.colon) {
      effects.enter(types2.definitionMarker);
      effects.consume(code2);
      effects.exit(types2.definitionMarker);
      return markerAfter;
    }
    return nok(code2);
  }
  function markerAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, destinationBefore)(code2) : destinationBefore(code2);
  }
  function destinationBefore(code2) {
    return factoryDestination(
      effects,
      destinationAfter,
      // Note: we dont need to reset the way `markdown-rs` does.
      nok,
      types2.definitionDestination,
      types2.definitionDestinationLiteral,
      types2.definitionDestinationLiteralMarker,
      types2.definitionDestinationRaw,
      types2.definitionDestinationString
    )(code2);
  }
  function destinationAfter(code2) {
    return effects.attempt(titleBefore, after, after)(code2);
  }
  function after(code2) {
    return markdownSpace(code2) ? factorySpace(effects, afterWhitespace, types2.whitespace)(code2) : afterWhitespace(code2);
  }
  function afterWhitespace(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types2.definition);
      self.parser.defined.push(identifier);
      return ok3(code2);
    }
    return nok(code2);
  }
}
function tokenizeTitleBefore(effects, ok3, nok) {
  return titleBefore2;
  function titleBefore2(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, beforeMarker)(code2) : nok(code2);
  }
  function beforeMarker(code2) {
    return factoryTitle(
      effects,
      titleAfter,
      nok,
      types2.definitionTitle,
      types2.definitionTitleMarker,
      types2.definitionTitleString
    )(code2);
  }
  function titleAfter(code2) {
    return markdownSpace(code2) ? factorySpace(
      effects,
      titleAfterOptionalWhitespace,
      types2.whitespace
    )(code2) : titleAfterOptionalWhitespace(code2);
  }
  function titleAfterOptionalWhitespace(code2) {
    return code2 === codes.eof || markdownLineEnding(code2) ? ok3(code2) : nok(code2);
  }
}

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/hard-break-escape.js
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok3, nok) {
  return start2;
  function start2(code2) {
    ok(code2 === codes.backslash, "expected `\\`");
    effects.enter(types2.hardBreakEscape);
    effects.consume(code2);
    return after;
  }
  function after(code2) {
    if (markdownLineEnding(code2)) {
      effects.exit(types2.hardBreakEscape);
      return ok3(code2);
    }
    return nok(code2);
  }
}

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/heading-atx.js
var headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content3;
  let text4;
  if (events[contentStart][1].type === types2.whitespace) {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === types2.whitespace) {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === types2.atxHeadingSequence && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === types2.whitespace)) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: types2.atxHeadingText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text4 = {
      type: types2.chunkText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: constants.contentTypeText
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content3, context],
      ["enter", text4, context],
      ["exit", text4, context],
      ["exit", content3, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok3, nok) {
  let size = 0;
  return start2;
  function start2(code2) {
    effects.enter(types2.atxHeading);
    return before(code2);
  }
  function before(code2) {
    ok(code2 === codes.numberSign, "expected `#`");
    effects.enter(types2.atxHeadingSequence);
    return sequenceOpen(code2);
  }
  function sequenceOpen(code2) {
    if (code2 === codes.numberSign && size++ < constants.atxHeadingOpeningFenceSizeMax) {
      effects.consume(code2);
      return sequenceOpen;
    }
    if (code2 === codes.eof || markdownLineEndingOrSpace(code2)) {
      effects.exit(types2.atxHeadingSequence);
      return atBreak(code2);
    }
    return nok(code2);
  }
  function atBreak(code2) {
    if (code2 === codes.numberSign) {
      effects.enter(types2.atxHeadingSequence);
      return sequenceFurther(code2);
    }
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types2.atxHeading);
      return ok3(code2);
    }
    if (markdownSpace(code2)) {
      return factorySpace(effects, atBreak, types2.whitespace)(code2);
    }
    effects.enter(types2.atxHeadingText);
    return data(code2);
  }
  function sequenceFurther(code2) {
    if (code2 === codes.numberSign) {
      effects.consume(code2);
      return sequenceFurther;
    }
    effects.exit(types2.atxHeadingSequence);
    return atBreak(code2);
  }
  function data(code2) {
    if (code2 === codes.eof || code2 === codes.numberSign || markdownLineEndingOrSpace(code2)) {
      effects.exit(types2.atxHeadingText);
      return atBreak(code2);
    }
    effects.consume(code2);
    return data;
  }
}

// node_modules/remark-parse/node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/html-flow.js
var htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
var blankLineBefore = { tokenize: tokenizeBlankLineBefore, partial: true };
var nonLazyContinuationStart = {
  tokenize: tokenizeNonLazyContinuationStart,
  partial: true
};
function resolveToHtmlFlow(events) {
  let index3 = events.length;
  while (index3--) {
    if (events[index3][0] === "enter" && events[index3][1].type === types2.htmlFlow) {
      break;
    }
  }
  if (index3 > 1 && events[index3 - 2][1].type === types2.linePrefix) {
    events[index3][1].start = events[index3 - 2][1].start;
    events[index3 + 1][1].start = events[index3 - 2][1].start;
    events.splice(index3 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok3, nok) {
  const self = this;
  let marker;
  let closingTag;
  let buffer2;
  let index3;
  let markerB;
  return start2;
  function start2(code2) {
    return before(code2);
  }
  function before(code2) {
    ok(code2 === codes.lessThan, "expected `<`");
    effects.enter(types2.htmlFlow);
    effects.enter(types2.htmlFlowData);
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === codes.exclamationMark) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === codes.slash) {
      effects.consume(code2);
      closingTag = true;
      return tagCloseStart;
    }
    if (code2 === codes.questionMark) {
      effects.consume(code2);
      marker = constants.htmlInstruction;
      return self.interrupt ? ok3 : continuationDeclarationInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer2 = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      marker = constants.htmlComment;
      return commentOpenInside;
    }
    if (code2 === codes.leftSquareBracket) {
      effects.consume(code2);
      marker = constants.htmlCdata;
      index3 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      marker = constants.htmlDeclaration;
      return self.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return self.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code2);
  }
  function cdataOpenInside(code2) {
    const value2 = constants.cdataOpeningString;
    if (code2 === value2.charCodeAt(index3++)) {
      effects.consume(code2);
      if (index3 === value2.length) {
        return self.interrupt ? ok3 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      buffer2 = String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function tagName(code2) {
    if (code2 === codes.eof || code2 === codes.slash || code2 === codes.greaterThan || markdownLineEndingOrSpace(code2)) {
      const slash = code2 === codes.slash;
      const name2 = buffer2.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name2)) {
        marker = constants.htmlRaw;
        return self.interrupt ? ok3(code2) : continuation(code2);
      }
      if (htmlBlockNames.includes(buffer2.toLowerCase())) {
        marker = constants.htmlBasic;
        if (slash) {
          effects.consume(code2);
          return basicSelfClosing;
        }
        return self.interrupt ? ok3(code2) : continuation(code2);
      }
      marker = constants.htmlComplete;
      return self.interrupt && !self.parser.lazy[self.now().line] ? nok(code2) : closingTag ? completeClosingTagAfter(code2) : completeAttributeNameBefore(code2);
    }
    if (code2 === codes.dash || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      buffer2 += String.fromCharCode(code2);
      return tagName;
    }
    return nok(code2);
  }
  function basicSelfClosing(code2) {
    if (code2 === codes.greaterThan) {
      effects.consume(code2);
      return self.interrupt ? ok3 : continuation;
    }
    return nok(code2);
  }
  function completeClosingTagAfter(code2) {
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeClosingTagAfter;
    }
    return completeEnd(code2);
  }
  function completeAttributeNameBefore(code2) {
    if (code2 === codes.slash) {
      effects.consume(code2);
      return completeEnd;
    }
    if (code2 === codes.colon || code2 === codes.underscore || asciiAlpha(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameBefore;
    }
    return completeEnd(code2);
  }
  function completeAttributeName(code2) {
    if (code2 === codes.dash || code2 === codes.dot || code2 === codes.colon || code2 === codes.underscore || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code2);
  }
  function completeAttributeNameAfter(code2) {
    if (code2 === codes.equalsTo) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code2);
  }
  function completeAttributeValueBefore(code2) {
    if (code2 === codes.eof || code2 === codes.lessThan || code2 === codes.equalsTo || code2 === codes.greaterThan || code2 === codes.graveAccent) {
      return nok(code2);
    }
    if (code2 === codes.quotationMark || code2 === codes.apostrophe) {
      effects.consume(code2);
      markerB = code2;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code2);
  }
  function completeAttributeValueQuoted(code2) {
    if (code2 === markerB) {
      effects.consume(code2);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return nok(code2);
    }
    effects.consume(code2);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code2) {
    if (code2 === codes.eof || code2 === codes.quotationMark || code2 === codes.apostrophe || code2 === codes.slash || code2 === codes.lessThan || code2 === codes.equalsTo || code2 === codes.greaterThan || code2 === codes.graveAccent || markdownLineEndingOrSpace(code2)) {
      return completeAttributeNameAfter(code2);
    }
    effects.consume(code2);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code2) {
    if (code2 === codes.slash || code2 === codes.greaterThan || markdownSpace(code2)) {
      return completeAttributeNameBefore(code2);
    }
    return nok(code2);
  }
  function completeEnd(code2) {
    if (code2 === codes.greaterThan) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function completeAfter(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return continuation(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return completeAfter;
    }
    return nok(code2);
  }
  function continuation(code2) {
    if (code2 === codes.dash && marker === constants.htmlComment) {
      effects.consume(code2);
      return continuationCommentInside;
    }
    if (code2 === codes.lessThan && marker === constants.htmlRaw) {
      effects.consume(code2);
      return continuationRawTagOpen;
    }
    if (code2 === codes.greaterThan && marker === constants.htmlDeclaration) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === codes.questionMark && marker === constants.htmlInstruction) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    if (code2 === codes.rightSquareBracket && marker === constants.htmlCdata) {
      effects.consume(code2);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code2) && (marker === constants.htmlBasic || marker === constants.htmlComplete)) {
      effects.exit(types2.htmlFlowData);
      return effects.check(
        blankLineBefore,
        continuationAfter,
        continuationStart
      )(code2);
    }
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types2.htmlFlowData);
      return continuationStart(code2);
    }
    effects.consume(code2);
    return continuation;
  }
  function continuationStart(code2) {
    return effects.check(
      nonLazyContinuationStart,
      continuationStartNonLazy,
      continuationAfter
    )(code2);
  }
  function continuationStartNonLazy(code2) {
    ok(markdownLineEnding(code2));
    effects.enter(types2.lineEnding);
    effects.consume(code2);
    effects.exit(types2.lineEnding);
    return continuationBefore;
  }
  function continuationBefore(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      return continuationStart(code2);
    }
    effects.enter(types2.htmlFlowData);
    return continuation(code2);
  }
  function continuationCommentInside(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationRawTagOpen(code2) {
    if (code2 === codes.slash) {
      effects.consume(code2);
      buffer2 = "";
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationRawEndTag(code2) {
    if (code2 === codes.greaterThan) {
      const name2 = buffer2.toLowerCase();
      if (htmlRawNames.includes(name2)) {
        effects.consume(code2);
        return continuationClose;
      }
      return continuation(code2);
    }
    if (asciiAlpha(code2) && buffer2.length < constants.htmlRawSizeMax) {
      effects.consume(code2);
      buffer2 += String.fromCharCode(code2);
      return continuationRawEndTag;
    }
    return continuation(code2);
  }
  function continuationCdataInside(code2) {
    if (code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationDeclarationInside(code2) {
    if (code2 === codes.greaterThan) {
      effects.consume(code2);
      return continuationClose;
    }
    if (code2 === codes.dash && marker === constants.htmlComment) {
      effects.consume(code2);
      return continuationDeclarationInside;
    }
    return continuation(code2);
  }
  function continuationClose(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types2.htmlFlowData);
      return continuationAfter(code2);
    }
    effects.consume(code2);
    return continuationClose;
  }
  function continuationAfter(code2) {
    effects.exit(types2.htmlFlow);
    return ok3(code2);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok3, nok) {
  const self = this;
  return start2;
  function start2(code2) {
    if (markdownLineEnding(code2)) {
      effects.enter(types2.lineEnding);
      effects.consume(code2);
      effects.exit(types2.lineEnding);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return self.parser.lazy[self.now().line] ? nok(code2) : ok3(code2);
  }
}
function tokenizeBlankLineBefore(effects, ok3, nok) {
  return start2;
  function start2(code2) {
    ok(markdownLineEnding(code2), "expected a line ending");
    effects.enter(types2.lineEnding);
    effects.consume(code2);
    effects.exit(types2.lineEnding);
    return effects.attempt(blankLine, ok3, nok);
  }
}

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/html-text.js
var htmlText = { name: "htmlText", tokenize: tokenizeHtmlText };
function tokenizeHtmlText(effects, ok3, nok) {
  const self = this;
  let marker;
  let index3;
  let returnState;
  return start2;
  function start2(code2) {
    ok(code2 === codes.lessThan, "expected `<`");
    effects.enter(types2.htmlText);
    effects.enter(types2.htmlTextData);
    effects.consume(code2);
    return open;
  }
  function open(code2) {
    if (code2 === codes.exclamationMark) {
      effects.consume(code2);
      return declarationOpen;
    }
    if (code2 === codes.slash) {
      effects.consume(code2);
      return tagCloseStart;
    }
    if (code2 === codes.questionMark) {
      effects.consume(code2);
      return instruction;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    return nok(code2);
  }
  function declarationOpen(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return commentOpenInside;
    }
    if (code2 === codes.leftSquareBracket) {
      effects.consume(code2);
      index3 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return declaration;
    }
    return nok(code2);
  }
  function commentOpenInside(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return commentEnd;
    }
    return nok(code2);
  }
  function comment(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (code2 === codes.dash) {
      effects.consume(code2);
      return commentClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = comment;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return comment;
  }
  function commentClose(code2) {
    if (code2 === codes.dash) {
      effects.consume(code2);
      return commentEnd;
    }
    return comment(code2);
  }
  function commentEnd(code2) {
    return code2 === codes.greaterThan ? end(code2) : code2 === codes.dash ? commentClose(code2) : comment(code2);
  }
  function cdataOpenInside(code2) {
    const value2 = constants.cdataOpeningString;
    if (code2 === value2.charCodeAt(index3++)) {
      effects.consume(code2);
      return index3 === value2.length ? cdata : cdataOpenInside;
    }
    return nok(code2);
  }
  function cdata(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      return cdataClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = cdata;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return cdata;
  }
  function cdataClose(code2) {
    if (code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function cdataEnd(code2) {
    if (code2 === codes.greaterThan) {
      return end(code2);
    }
    if (code2 === codes.rightSquareBracket) {
      effects.consume(code2);
      return cdataEnd;
    }
    return cdata(code2);
  }
  function declaration(code2) {
    if (code2 === codes.eof || code2 === codes.greaterThan) {
      return end(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = declaration;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return declaration;
  }
  function instruction(code2) {
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (code2 === codes.questionMark) {
      effects.consume(code2);
      return instructionClose;
    }
    if (markdownLineEnding(code2)) {
      returnState = instruction;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return instruction;
  }
  function instructionClose(code2) {
    return code2 === codes.greaterThan ? end(code2) : instruction(code2);
  }
  function tagCloseStart(code2) {
    if (asciiAlpha(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return nok(code2);
  }
  function tagClose(code2) {
    if (code2 === codes.dash || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagClose;
    }
    return tagCloseBetween(code2);
  }
  function tagCloseBetween(code2) {
    if (markdownLineEnding(code2)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagCloseBetween;
    }
    return end(code2);
  }
  function tagOpen(code2) {
    if (code2 === codes.dash || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpen;
    }
    if (code2 === codes.slash || code2 === codes.greaterThan || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function tagOpenBetween(code2) {
    if (code2 === codes.slash) {
      effects.consume(code2);
      return end;
    }
    if (code2 === codes.colon || code2 === codes.underscore || asciiAlpha(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenBetween;
    }
    return end(code2);
  }
  function tagOpenAttributeName(code2) {
    if (code2 === codes.dash || code2 === codes.dot || code2 === codes.colon || code2 === codes.underscore || asciiAlphanumeric(code2)) {
      effects.consume(code2);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code2);
  }
  function tagOpenAttributeNameAfter(code2) {
    if (code2 === codes.equalsTo) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code2);
  }
  function tagOpenAttributeValueBefore(code2) {
    if (code2 === codes.eof || code2 === codes.lessThan || code2 === codes.equalsTo || code2 === codes.greaterThan || code2 === codes.graveAccent) {
      return nok(code2);
    }
    if (code2 === codes.quotationMark || code2 === codes.apostrophe) {
      effects.consume(code2);
      marker = code2;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code2);
    }
    if (markdownSpace(code2)) {
      effects.consume(code2);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code2 === codes.eof) {
      return nok(code2);
    }
    if (markdownLineEnding(code2)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code2) {
    if (code2 === codes.eof || code2 === codes.quotationMark || code2 === codes.apostrophe || code2 === codes.lessThan || code2 === codes.equalsTo || code2 === codes.graveAccent) {
      return nok(code2);
    }
    if (code2 === codes.slash || code2 === codes.greaterThan || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    effects.consume(code2);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code2) {
    if (code2 === codes.slash || code2 === codes.greaterThan || markdownLineEndingOrSpace(code2)) {
      return tagOpenBetween(code2);
    }
    return nok(code2);
  }
  function end(code2) {
    if (code2 === codes.greaterThan) {
      effects.consume(code2);
      effects.exit(types2.htmlTextData);
      effects.exit(types2.htmlText);
      return ok3;
    }
    return nok(code2);
  }
  function lineEndingBefore(code2) {
    ok(returnState, "expected return state");
    ok(markdownLineEnding(code2), "expected eol");
    effects.exit(types2.htmlTextData);
    effects.enter(types2.lineEnding);
    effects.consume(code2);
    effects.exit(types2.lineEnding);
    return lineEndingAfter;
  }
  function lineEndingAfter(code2) {
    ok(
      self.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return markdownSpace(code2) ? factorySpace(
      effects,
      lineEndingAfterPrefix,
      types2.linePrefix,
      self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code2) : lineEndingAfterPrefix(code2);
  }
  function lineEndingAfterPrefix(code2) {
    effects.enter(types2.htmlTextData);
    return returnState(code2);
  }
}

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/label-end.js
var labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
var resourceConstruct = { tokenize: tokenizeResource };
var referenceFullConstruct = { tokenize: tokenizeReferenceFull };
var referenceCollapsedConstruct = { tokenize: tokenizeReferenceCollapsed };
function resolveAllLabelEnd(events) {
  let index3 = -1;
  while (++index3 < events.length) {
    const token = events[index3][1];
    if (token.type === types2.labelImage || token.type === types2.labelLink || token.type === types2.labelEnd) {
      events.splice(index3 + 1, token.type === types2.labelImage ? 4 : 2);
      token.type = types2.data;
      index3++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index3 = events.length;
  let offset = 0;
  let token;
  let open;
  let close;
  let media;
  while (index3--) {
    token = events[index3][1];
    if (open) {
      if (token.type === types2.link || token.type === types2.labelLink && token._inactive) {
        break;
      }
      if (events[index3][0] === "enter" && token.type === types2.labelLink) {
        token._inactive = true;
      }
    } else if (close) {
      if (events[index3][0] === "enter" && (token.type === types2.labelImage || token.type === types2.labelLink) && !token._balanced) {
        open = index3;
        if (token.type !== types2.labelLink) {
          offset = 2;
          break;
        }
      }
    } else if (token.type === types2.labelEnd) {
      close = index3;
    }
  }
  ok(open !== void 0, "`open` is supposed to be found");
  ok(close !== void 0, "`close` is supposed to be found");
  const group = {
    type: events[open][1].type === types2.labelLink ? types2.link : types2.image,
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label = {
    type: types2.label,
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close][1].end)
  };
  const text4 = {
    type: types2.labelText,
    start: Object.assign({}, events[open + offset + 2][1].end),
    end: Object.assign({}, events[close - 2][1].start)
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push2(media, events.slice(open + 1, open + offset + 3));
  media = push2(media, [["enter", text4, context]]);
  ok(
    context.parser.constructs.insideSpan.null,
    "expected `insideSpan.null` to be populated"
  );
  media = push2(
    media,
    resolveAll(
      context.parser.constructs.insideSpan.null,
      events.slice(open + offset + 4, close - 3),
      context
    )
  );
  media = push2(media, [
    ["exit", text4, context],
    events[close - 2],
    events[close - 1],
    ["exit", label, context]
  ]);
  media = push2(media, events.slice(close + 1));
  media = push2(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok3, nok) {
  const self = this;
  let index3 = self.events.length;
  let labelStart;
  let defined;
  while (index3--) {
    if ((self.events[index3][1].type === types2.labelImage || self.events[index3][1].type === types2.labelLink) && !self.events[index3][1]._balanced) {
      labelStart = self.events[index3][1];
      break;
    }
  }
  return start2;
  function start2(code2) {
    ok(code2 === codes.rightSquareBracket, "expected `]`");
    if (!labelStart) {
      return nok(code2);
    }
    if (labelStart._inactive) {
      return labelEndNok(code2);
    }
    defined = self.parser.defined.includes(
      normalizeIdentifier(
        self.sliceSerialize({ start: labelStart.end, end: self.now() })
      )
    );
    effects.enter(types2.labelEnd);
    effects.enter(types2.labelMarker);
    effects.consume(code2);
    effects.exit(types2.labelMarker);
    effects.exit(types2.labelEnd);
    return after;
  }
  function after(code2) {
    if (code2 === codes.leftParenthesis) {
      return effects.attempt(
        resourceConstruct,
        labelEndOk,
        defined ? labelEndOk : labelEndNok
      )(code2);
    }
    if (code2 === codes.leftSquareBracket) {
      return effects.attempt(
        referenceFullConstruct,
        labelEndOk,
        defined ? referenceNotFull : labelEndNok
      )(code2);
    }
    return defined ? labelEndOk(code2) : labelEndNok(code2);
  }
  function referenceNotFull(code2) {
    return effects.attempt(
      referenceCollapsedConstruct,
      labelEndOk,
      labelEndNok
    )(code2);
  }
  function labelEndOk(code2) {
    return ok3(code2);
  }
  function labelEndNok(code2) {
    labelStart._balanced = true;
    return nok(code2);
  }
}
function tokenizeResource(effects, ok3, nok) {
  return resourceStart;
  function resourceStart(code2) {
    ok(code2 === codes.leftParenthesis, "expected left paren");
    effects.enter(types2.resource);
    effects.enter(types2.resourceMarker);
    effects.consume(code2);
    effects.exit(types2.resourceMarker);
    return resourceBefore;
  }
  function resourceBefore(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceOpen)(code2) : resourceOpen(code2);
  }
  function resourceOpen(code2) {
    if (code2 === codes.rightParenthesis) {
      return resourceEnd(code2);
    }
    return factoryDestination(
      effects,
      resourceDestinationAfter,
      resourceDestinationMissing,
      types2.resourceDestination,
      types2.resourceDestinationLiteral,
      types2.resourceDestinationLiteralMarker,
      types2.resourceDestinationRaw,
      types2.resourceDestinationString,
      constants.linkResourceDestinationBalanceMax
    )(code2);
  }
  function resourceDestinationAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceBetween)(code2) : resourceEnd(code2);
  }
  function resourceDestinationMissing(code2) {
    return nok(code2);
  }
  function resourceBetween(code2) {
    if (code2 === codes.quotationMark || code2 === codes.apostrophe || code2 === codes.leftParenthesis) {
      return factoryTitle(
        effects,
        resourceTitleAfter,
        nok,
        types2.resourceTitle,
        types2.resourceTitleMarker,
        types2.resourceTitleString
      )(code2);
    }
    return resourceEnd(code2);
  }
  function resourceTitleAfter(code2) {
    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceEnd)(code2) : resourceEnd(code2);
  }
  function resourceEnd(code2) {
    if (code2 === codes.rightParenthesis) {
      effects.enter(types2.resourceMarker);
      effects.consume(code2);
      effects.exit(types2.resourceMarker);
      effects.exit(types2.resource);
      return ok3;
    }
    return nok(code2);
  }
}
function tokenizeReferenceFull(effects, ok3, nok) {
  const self = this;
  return referenceFull;
  function referenceFull(code2) {
    ok(code2 === codes.leftSquareBracket, "expected left bracket");
    return factoryLabel.call(
      self,
      effects,
      referenceFullAfter,
      referenceFullMissing,
      types2.reference,
      types2.referenceMarker,
      types2.referenceString
    )(code2);
  }
  function referenceFullAfter(code2) {
    return self.parser.defined.includes(
      normalizeIdentifier(
        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)
      )
    ) ? ok3(code2) : nok(code2);
  }
  function referenceFullMissing(code2) {
    return nok(code2);
  }
}
function tokenizeReferenceCollapsed(effects, ok3, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code2) {
    ok(code2 === codes.leftSquareBracket, "expected left bracket");
    effects.enter(types2.reference);
    effects.enter(types2.referenceMarker);
    effects.consume(code2);
    effects.exit(types2.referenceMarker);
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code2) {
    if (code2 === codes.rightSquareBracket) {
      effects.enter(types2.referenceMarker);
      effects.consume(code2);
      effects.exit(types2.referenceMarker);
      effects.exit(types2.reference);
      return ok3;
    }
    return nok(code2);
  }
}

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/label-start-image.js
var labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage(effects, ok3, nok) {
  const self = this;
  return start2;
  function start2(code2) {
    ok(code2 === codes.exclamationMark, "expected `!`");
    effects.enter(types2.labelImage);
    effects.enter(types2.labelImageMarker);
    effects.consume(code2);
    effects.exit(types2.labelImageMarker);
    return open;
  }
  function open(code2) {
    if (code2 === codes.leftSquareBracket) {
      effects.enter(types2.labelMarker);
      effects.consume(code2);
      effects.exit(types2.labelMarker);
      effects.exit(types2.labelImage);
      return after;
    }
    return nok(code2);
  }
  function after(code2) {
    return code2 === codes.caret && "_hiddenFootnoteSupport" in self.parser.constructs ? nok(code2) : ok3(code2);
  }
}

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/label-start-link.js
var labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink(effects, ok3, nok) {
  const self = this;
  return start2;
  function start2(code2) {
    ok(code2 === codes.leftSquareBracket, "expected `[`");
    effects.enter(types2.labelLink);
    effects.enter(types2.labelMarker);
    effects.consume(code2);
    effects.exit(types2.labelMarker);
    effects.exit(types2.labelLink);
    return after;
  }
  function after(code2) {
    return code2 === codes.caret && "_hiddenFootnoteSupport" in self.parser.constructs ? nok(code2) : ok3(code2);
  }
}

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/line-ending.js
var lineEnding = { name: "lineEnding", tokenize: tokenizeLineEnding };
function tokenizeLineEnding(effects, ok3) {
  return start2;
  function start2(code2) {
    ok(markdownLineEnding(code2), "expected eol");
    effects.enter(types2.lineEnding);
    effects.consume(code2);
    effects.exit(types2.lineEnding);
    return factorySpace(effects, ok3, types2.linePrefix);
  }
}

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/thematic-break.js
var thematicBreak = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok3, nok) {
  let size = 0;
  let marker;
  return start2;
  function start2(code2) {
    effects.enter(types2.thematicBreak);
    return before(code2);
  }
  function before(code2) {
    ok(
      code2 === codes.asterisk || code2 === codes.dash || code2 === codes.underscore,
      "expected `*`, `-`, or `_`"
    );
    marker = code2;
    return atBreak(code2);
  }
  function atBreak(code2) {
    if (code2 === marker) {
      effects.enter(types2.thematicBreakSequence);
      return sequence(code2);
    }
    if (size >= constants.thematicBreakMarkerCountMin && (code2 === codes.eof || markdownLineEnding(code2))) {
      effects.exit(types2.thematicBreak);
      return ok3(code2);
    }
    return nok(code2);
  }
  function sequence(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      size++;
      return sequence;
    }
    effects.exit(types2.thematicBreakSequence);
    return markdownSpace(code2) ? factorySpace(effects, atBreak, types2.whitespace)(code2) : atBreak(code2);
  }
}

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/list.js
var list = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: { tokenize: tokenizeListContinuation },
  exit: tokenizeListEnd
};
var listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
var indentConstruct = { tokenize: tokenizeIndent, partial: true };
function tokenizeListStart(effects, ok3, nok) {
  const self = this;
  const tail = self.events[self.events.length - 1];
  let initialSize = tail && tail[1].type === types2.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start2;
  function start2(code2) {
    ok(self.containerState, "expected state");
    const kind = self.containerState.type || (code2 === codes.asterisk || code2 === codes.plusSign || code2 === codes.dash ? types2.listUnordered : types2.listOrdered);
    if (kind === types2.listUnordered ? !self.containerState.marker || code2 === self.containerState.marker : asciiDigit(code2)) {
      if (!self.containerState.type) {
        self.containerState.type = kind;
        effects.enter(kind, { _container: true });
      }
      if (kind === types2.listUnordered) {
        effects.enter(types2.listItemPrefix);
        return code2 === codes.asterisk || code2 === codes.dash ? effects.check(thematicBreak, nok, atMarker)(code2) : atMarker(code2);
      }
      if (!self.interrupt || code2 === codes.digit1) {
        effects.enter(types2.listItemPrefix);
        effects.enter(types2.listItemValue);
        return inside(code2);
      }
    }
    return nok(code2);
  }
  function inside(code2) {
    ok(self.containerState, "expected state");
    if (asciiDigit(code2) && ++size < constants.listItemValueSizeMax) {
      effects.consume(code2);
      return inside;
    }
    if ((!self.interrupt || size < 2) && (self.containerState.marker ? code2 === self.containerState.marker : code2 === codes.rightParenthesis || code2 === codes.dot)) {
      effects.exit(types2.listItemValue);
      return atMarker(code2);
    }
    return nok(code2);
  }
  function atMarker(code2) {
    ok(self.containerState, "expected state");
    ok(code2 !== codes.eof, "eof (`null`) is not a marker");
    effects.enter(types2.listItemMarker);
    effects.consume(code2);
    effects.exit(types2.listItemMarker);
    self.containerState.marker = self.containerState.marker || code2;
    return effects.check(
      blankLine,
      // Cant be empty when interrupting.
      self.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    );
  }
  function onBlank(code2) {
    ok(self.containerState, "expected state");
    self.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code2);
  }
  function otherPrefix(code2) {
    if (markdownSpace(code2)) {
      effects.enter(types2.listItemPrefixWhitespace);
      effects.consume(code2);
      effects.exit(types2.listItemPrefixWhitespace);
      return endOfPrefix;
    }
    return nok(code2);
  }
  function endOfPrefix(code2) {
    ok(self.containerState, "expected state");
    self.containerState.size = initialSize + self.sliceSerialize(effects.exit(types2.listItemPrefix), true).length;
    return ok3(code2);
  }
}
function tokenizeListContinuation(effects, ok3, nok) {
  const self = this;
  ok(self.containerState, "expected state");
  self.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code2) {
    ok(self.containerState, "expected state");
    ok(typeof self.containerState.size === "number", "expected size");
    self.containerState.furtherBlankLines = self.containerState.furtherBlankLines || self.containerState.initialBlankLine;
    return factorySpace(
      effects,
      ok3,
      types2.listItemIndent,
      self.containerState.size + 1
    )(code2);
  }
  function notBlank(code2) {
    ok(self.containerState, "expected state");
    if (self.containerState.furtherBlankLines || !markdownSpace(code2)) {
      self.containerState.furtherBlankLines = void 0;
      self.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code2);
    }
    self.containerState.furtherBlankLines = void 0;
    self.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok3, notInCurrentItem)(code2);
  }
  function notInCurrentItem(code2) {
    ok(self.containerState, "expected state");
    self.containerState._closeFlow = true;
    self.interrupt = void 0;
    ok(
      self.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return factorySpace(
      effects,
      effects.attempt(list, ok3, nok),
      types2.linePrefix,
      self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code2);
  }
}
function tokenizeIndent(effects, ok3, nok) {
  const self = this;
  ok(self.containerState, "expected state");
  ok(typeof self.containerState.size === "number", "expected size");
  return factorySpace(
    effects,
    afterPrefix,
    types2.listItemIndent,
    self.containerState.size + 1
  );
  function afterPrefix(code2) {
    ok(self.containerState, "expected state");
    const tail = self.events[self.events.length - 1];
    return tail && tail[1].type === types2.listItemIndent && tail[2].sliceSerialize(tail[1], true).length === self.containerState.size ? ok3(code2) : nok(code2);
  }
}
function tokenizeListEnd(effects) {
  ok(this.containerState, "expected state");
  ok(typeof this.containerState.type === "string", "expected type");
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok3, nok) {
  const self = this;
  ok(
    self.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    afterPrefix,
    types2.listItemPrefixWhitespace,
    self.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize + 1
  );
  function afterPrefix(code2) {
    const tail = self.events[self.events.length - 1];
    return !markdownSpace(code2) && tail && tail[1].type === types2.listItemPrefixWhitespace ? ok3(code2) : nok(code2);
  }
}

// node_modules/remark-parse/node_modules/micromark-core-commonmark/dev/lib/setext-underline.js
var setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index3 = events.length;
  let content3;
  let text4;
  let definition2;
  while (index3--) {
    if (events[index3][0] === "enter") {
      if (events[index3][1].type === types2.content) {
        content3 = index3;
        break;
      }
      if (events[index3][1].type === types2.paragraph) {
        text4 = index3;
      }
    } else {
      if (events[index3][1].type === types2.content) {
        events.splice(index3, 1);
      }
      if (!definition2 && events[index3][1].type === types2.definition) {
        definition2 = index3;
      }
    }
  }
  ok(text4 !== void 0, "expected a `text` index to be found");
  ok(content3 !== void 0, "expected a `text` index to be found");
  const heading2 = {
    type: types2.setextHeading,
    start: Object.assign({}, events[text4][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  events[text4][1].type = types2.setextHeadingText;
  if (definition2) {
    events.splice(text4, 0, ["enter", heading2, context]);
    events.splice(definition2 + 1, 0, ["exit", events[content3][1], context]);
    events[content3][1].end = Object.assign({}, events[definition2][1].end);
  } else {
    events[content3][1] = heading2;
  }
  events.push(["exit", heading2, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok3, nok) {
  const self = this;
  let marker;
  return start2;
  function start2(code2) {
    let index3 = self.events.length;
    let paragraph2;
    ok(
      code2 === codes.dash || code2 === codes.equalsTo,
      "expected `=` or `-`"
    );
    while (index3--) {
      if (self.events[index3][1].type !== types2.lineEnding && self.events[index3][1].type !== types2.linePrefix && self.events[index3][1].type !== types2.content) {
        paragraph2 = self.events[index3][1].type === types2.paragraph;
        break;
      }
    }
    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph2)) {
      effects.enter(types2.setextHeadingLine);
      marker = code2;
      return before(code2);
    }
    return nok(code2);
  }
  function before(code2) {
    effects.enter(types2.setextHeadingLineSequence);
    return inside(code2);
  }
  function inside(code2) {
    if (code2 === marker) {
      effects.consume(code2);
      return inside;
    }
    effects.exit(types2.setextHeadingLineSequence);
    return markdownSpace(code2) ? factorySpace(effects, after, types2.lineSuffix)(code2) : after(code2);
  }
  function after(code2) {
    if (code2 === codes.eof || markdownLineEnding(code2)) {
      effects.exit(types2.setextHeadingLine);
      return ok3(code2);
    }
    return nok(code2);
  }
}

// node_modules/remark-parse/node_modules/micromark/dev/lib/initialize/flow.js
var flow = { tokenize: initializeFlow };
function initializeFlow(effects) {
  const self = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content2, afterConstruct)
        ),
        types2.linePrefix
      )
    )
  );
  return initial;
  function atBlankEnding(code2) {
    ok(
      code2 === codes.eof || markdownLineEnding(code2),
      "expected eol or eof"
    );
    if (code2 === codes.eof) {
      effects.consume(code2);
      return;
    }
    effects.enter(types2.lineEndingBlank);
    effects.consume(code2);
    effects.exit(types2.lineEndingBlank);
    self.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code2) {
    ok(
      code2 === codes.eof || markdownLineEnding(code2),
      "expected eol or eof"
    );
    if (code2 === codes.eof) {
      effects.consume(code2);
      return;
    }
    effects.enter(types2.lineEnding);
    effects.consume(code2);
    effects.exit(types2.lineEnding);
    self.currentConstruct = void 0;
    return initial;
  }
}

// node_modules/remark-parse/node_modules/micromark/dev/lib/initialize/text.js
var resolver = { resolveAll: createResolver() };
var string = initializeFactory("string");
var text = initializeFactory("text");
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(
      field === "text" ? resolveAllLineSuffixes : void 0
    )
  };
  function initializeText(effects) {
    const self = this;
    const constructs2 = this.parser.constructs[field];
    const text4 = effects.attempt(constructs2, start2, notText);
    return start2;
    function start2(code2) {
      return atBreak(code2) ? text4(code2) : notText(code2);
    }
    function notText(code2) {
      if (code2 === codes.eof) {
        effects.consume(code2);
        return;
      }
      effects.enter(types2.data);
      effects.consume(code2);
      return data;
    }
    function data(code2) {
      if (atBreak(code2)) {
        effects.exit(types2.data);
        return text4(code2);
      }
      effects.consume(code2);
      return data;
    }
    function atBreak(code2) {
      if (code2 === codes.eof) {
        return true;
      }
      const list3 = constructs2[code2];
      let index3 = -1;
      if (list3) {
        ok(Array.isArray(list3), "expected `disable.null` to be populated");
        while (++index3 < list3.length) {
          const item = list3[index3];
          if (!item.previous || item.previous.call(self, self.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index3 = -1;
    let enter;
    while (++index3 <= events.length) {
      if (enter === void 0) {
        if (events[index3] && events[index3][1].type === types2.data) {
          enter = index3;
          index3++;
        }
      } else if (!events[index3] || events[index3][1].type !== types2.data) {
        if (index3 !== enter + 2) {
          events[enter][1].end = events[index3 - 1][1].end;
          events.splice(enter + 2, index3 - enter - 2);
          index3 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === types2.lineEnding) && events[eventIndex - 1][1].type === types2.data) {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index3 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index3--) {
        const chunk = chunks[index3];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === codes.space) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex) break;
          bufferIndex = -1;
        } else if (chunk === codes.horizontalTab) {
          tabs = true;
          size++;
        } else if (chunk === codes.virtualSpace) {
        } else {
          index3++;
          break;
        }
      }
      if (size) {
        const token = {
          type: eventIndex === events.length || tabs || size < constants.hardBreakPrefixSizeMin ? types2.lineSuffix : types2.hardBreakTrailing,
          start: {
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size,
            _index: data.start._index + index3,
            _bufferIndex: index3 ? bufferIndex : data.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data.end)
        };
        data.end = Object.assign({}, token.start);
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(
            eventIndex,
            0,
            ["enter", token, context],
            ["exit", token, context]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}

// node_modules/remark-parse/node_modules/micromark/dev/lib/create-tokenizer.js
var import_debug = __toESM(require_browser2(), 1);
var debug = (0, import_debug.default)("micromark");
function createTokenizer(parser, initialize, from) {
  let point5 = Object.assign(
    from ? Object.assign({}, from) : { line: 1, column: 1, offset: 0 },
    { _index: 0, _bufferIndex: -1 }
  );
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    consume,
    enter,
    exit: exit2,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, { interrupt: true })
  };
  const context = {
    previous: codes.eof,
    code: codes.eof,
    containerState: {},
    events: [],
    parser,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice) {
    chunks = push2(chunks, slice);
    main();
    if (chunks[chunks.length - 1] !== codes.eof) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    const { line: line2, column, offset, _index, _bufferIndex } = point5;
    return { line: line2, column, offset, _index, _bufferIndex };
  }
  function defineSkip(value2) {
    columnStart[value2.line] = value2.column;
    accountForPotentialSkip();
    debug("position: define skip: `%j`", point5);
  }
  function main() {
    let chunkIndex;
    while (point5._index < chunks.length) {
      const chunk = chunks[point5._index];
      if (typeof chunk === "string") {
        chunkIndex = point5._index;
        if (point5._bufferIndex < 0) {
          point5._bufferIndex = 0;
        }
        while (point5._index === chunkIndex && point5._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point5._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code2) {
    ok(consumed === true, "expected character to be consumed");
    consumed = void 0;
    debug("main: passing `%s` to %s", code2, state && state.name);
    expectedCode = code2;
    ok(typeof state === "function", "expected state");
    state = state(code2);
  }
  function consume(code2) {
    ok(code2 === expectedCode, "expected given code to equal expected code");
    debug("consume: `%s`", code2);
    ok(
      consumed === void 0,
      "expected code to not have been consumed: this might be because `return x(code)` instead of `return x` was used"
    );
    ok(
      code2 === null ? context.events.length === 0 || context.events[context.events.length - 1][0] === "exit" : context.events[context.events.length - 1][0] === "enter",
      "expected last token to be open"
    );
    if (markdownLineEnding(code2)) {
      point5.line++;
      point5.column = 1;
      point5.offset += code2 === codes.carriageReturnLineFeed ? 2 : 1;
      accountForPotentialSkip();
      debug("position: after eol: `%j`", point5);
    } else if (code2 !== codes.virtualSpace) {
      point5.column++;
      point5.offset++;
    }
    if (point5._bufferIndex < 0) {
      point5._index++;
    } else {
      point5._bufferIndex++;
      if (point5._bufferIndex === chunks[point5._index].length) {
        point5._bufferIndex = -1;
        point5._index++;
      }
    }
    context.previous = code2;
    consumed = true;
  }
  function enter(type2, fields) {
    const token = fields || {};
    token.type = type2;
    token.start = now();
    ok(typeof type2 === "string", "expected string type");
    ok(type2.length > 0, "expected non-empty string");
    debug("enter: `%s`", type2);
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit2(type2) {
    ok(typeof type2 === "string", "expected string type");
    ok(type2.length > 0, "expected non-empty string");
    const token = stack.pop();
    ok(token, "cannot close w/o open tokens");
    token.end = now();
    ok(type2 === token.type, "expected exit token to match current token");
    ok(
      !(token.start._index === token.end._index && token.start._bufferIndex === token.end._bufferIndex),
      "expected non-empty token (`" + type2 + "`)"
    );
    debug("exit: `%s`", token.type);
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? (
        /* c8 ignore next 1 */
        handleListOfConstructs(constructs2)
      ) : "tokenize" in constructs2 ? (
        // @ts-expect-error Looks like a construct.
        handleListOfConstructs([constructs2])
      ) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map2) {
        return start2;
        function start2(code2) {
          const def = code2 !== null && map2[code2];
          const all3 = code2 !== null && map2.null;
          const list3 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(def) ? def : def ? [def] : [],
            ...Array.isArray(all3) ? all3 : all3 ? [all3] : []
          ];
          return handleListOfConstructs(list3)(code2);
        }
      }
      function handleListOfConstructs(list3) {
        listOfConstructs = list3;
        constructIndex = 0;
        if (list3.length === 0) {
          ok(bogusState, "expected `bogusState` to be given");
          return bogusState;
        }
        return handleConstruct(list3[constructIndex]);
      }
      function handleConstruct(construct) {
        return start2;
        function start2(code2) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          ok(
            context.parser.constructs.disable.null,
            "expected `disable.null` to be populated"
          );
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code2);
          }
          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok3,
            nok
          )(code2);
        }
      }
      function ok3(code2) {
        ok(code2 === expectedCode, "expected code");
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code2) {
        ok(code2 === expectedCode, "expected code");
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(
        context.events,
        from2,
        context.events.length - from2,
        construct.resolve(context.events.slice(from2), context)
      );
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
    ok(
      construct.partial || context.events.length === 0 || context.events[context.events.length - 1][0] === "exit",
      "expected last token to end"
    );
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return { restore, from: startEventsIndex };
    function restore() {
      point5 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
      debug("position: restore: `%j`", point5);
    }
  }
  function accountForPotentialSkip() {
    if (point5.line in columnStart && point5.column < 2) {
      point5.column = columnStart[point5.line];
      point5.offset += columnStart[point5.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    ok(endBufferIndex > -1, "expected non-negative end buffer index");
    ok(startBufferIndex > -1, "expected non-negative start buffer index");
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head = view[0];
      if (typeof head === "string") {
        view[0] = head.slice(startBufferIndex);
      } else {
        ok(startBufferIndex === 0, "expected `startBufferIndex` to be `0`");
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index3 = -1;
  const result = [];
  let atTab;
  while (++index3 < chunks.length) {
    const chunk = chunks[index3];
    let value2;
    if (typeof chunk === "string") {
      value2 = chunk;
    } else
      switch (chunk) {
        case codes.carriageReturn: {
          value2 = values.cr;
          break;
        }
        case codes.lineFeed: {
          value2 = values.lf;
          break;
        }
        case codes.carriageReturnLineFeed: {
          value2 = values.cr + values.lf;
          break;
        }
        case codes.horizontalTab: {
          value2 = expandTabs ? values.space : values.ht;
          break;
        }
        case codes.virtualSpace: {
          if (!expandTabs && atTab) continue;
          value2 = values.space;
          break;
        }
        default: {
          ok(typeof chunk === "number", "expected number");
          value2 = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === codes.horizontalTab;
    result.push(value2);
  }
  return result.join("");
}

// node_modules/remark-parse/node_modules/micromark/dev/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document3,
  flow: () => flow2,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string2,
  text: () => text2
});
var document3 = {
  [codes.asterisk]: list,
  [codes.plusSign]: list,
  [codes.dash]: list,
  [codes.digit0]: list,
  [codes.digit1]: list,
  [codes.digit2]: list,
  [codes.digit3]: list,
  [codes.digit4]: list,
  [codes.digit5]: list,
  [codes.digit6]: list,
  [codes.digit7]: list,
  [codes.digit8]: list,
  [codes.digit9]: list,
  [codes.greaterThan]: blockQuote
};
var contentInitial = {
  [codes.leftSquareBracket]: definition
};
var flowInitial = {
  [codes.horizontalTab]: codeIndented,
  [codes.virtualSpace]: codeIndented,
  [codes.space]: codeIndented
};
var flow2 = {
  [codes.numberSign]: headingAtx,
  [codes.asterisk]: thematicBreak,
  [codes.dash]: [setextUnderline, thematicBreak],
  [codes.lessThan]: htmlFlow,
  [codes.equalsTo]: setextUnderline,
  [codes.underscore]: thematicBreak,
  [codes.graveAccent]: codeFenced,
  [codes.tilde]: codeFenced
};
var string2 = {
  [codes.ampersand]: characterReference,
  [codes.backslash]: characterEscape
};
var text2 = {
  [codes.carriageReturn]: lineEnding,
  [codes.lineFeed]: lineEnding,
  [codes.carriageReturnLineFeed]: lineEnding,
  [codes.exclamationMark]: labelStartImage,
  [codes.ampersand]: characterReference,
  [codes.asterisk]: attention,
  [codes.lessThan]: [autolink, htmlText],
  [codes.leftSquareBracket]: labelStartLink,
  [codes.backslash]: [hardBreakEscape, characterEscape],
  [codes.rightSquareBracket]: labelEnd,
  [codes.underscore]: attention,
  [codes.graveAccent]: codeText
};
var insideSpan = { null: [attention, resolver] };
var attentionMarkers = { null: [codes.asterisk, codes.underscore] };
var disable = { null: [] };

// node_modules/remark-parse/node_modules/micromark/dev/lib/parse.js
function parse4(options) {
  const settings = options || {};
  const constructs2 = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([constructs_exports, ...settings.extensions || []])
  );
  const parser = {
    defined: [],
    lazy: {},
    constructs: constructs2,
    content: create2(content),
    document: create2(document2),
    flow: create2(flow),
    string: create2(string),
    text: create2(text)
  };
  return parser;
  function create2(initial) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial, from);
    }
  }
}

// node_modules/remark-parse/node_modules/micromark/dev/lib/preprocess.js
var search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer2 = "";
  let start2 = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value2, encoding, end) {
    const chunks = [];
    let match;
    let next;
    let startPosition;
    let endPosition;
    let code2;
    value2 = buffer2 + value2.toString(encoding);
    startPosition = 0;
    buffer2 = "";
    if (start2) {
      if (value2.charCodeAt(0) === codes.byteOrderMarker) {
        startPosition++;
      }
      start2 = void 0;
    }
    while (startPosition < value2.length) {
      search.lastIndex = startPosition;
      match = search.exec(value2);
      endPosition = match && match.index !== void 0 ? match.index : value2.length;
      code2 = value2.charCodeAt(endPosition);
      if (!match) {
        buffer2 = value2.slice(startPosition);
        break;
      }
      if (code2 === codes.lf && startPosition === endPosition && atCarriageReturn) {
        chunks.push(codes.carriageReturnLineFeed);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(codes.carriageReturn);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value2.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code2) {
          case codes.nul: {
            chunks.push(codes.replacementCharacter);
            column++;
            break;
          }
          case codes.ht: {
            next = Math.ceil(column / constants.tabSize) * constants.tabSize;
            chunks.push(codes.horizontalTab);
            while (column++ < next) chunks.push(codes.virtualSpace);
            break;
          }
          case codes.lf: {
            chunks.push(codes.lineFeed);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn) chunks.push(codes.carriageReturn);
      if (buffer2) chunks.push(buffer2);
      chunks.push(codes.eof);
    }
    return chunks;
  }
}

// node_modules/remark-parse/node_modules/micromark/dev/lib/postprocess.js
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}

// node_modules/remark-parse/node_modules/micromark-util-decode-numeric-character-reference/dev/index.js
function decodeNumericCharacterReference(value2, base2) {
  const code2 = Number.parseInt(value2, base2);
  if (
    // C0 except for HT, LF, FF, CR, space.
    code2 < codes.ht || code2 === codes.vt || code2 > codes.cr && code2 < codes.space || // Control character (DEL) of C0, and C1 controls.
    code2 > codes.tilde && code2 < 160 || // Lone high surrogates and low surrogates.
    code2 > 55295 && code2 < 57344 || // Noncharacters.
    code2 > 64975 && code2 < 65008 || /* eslint-disable no-bitwise */
    (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    code2 > 1114111
  ) {
    return values.replacementCharacter;
  }
  return String.fromCharCode(code2);
}

// node_modules/remark-parse/node_modules/micromark-util-decode-string/dev/index.js
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value2) {
  return value2.replace(characterEscapeOrReference, decode3);
}
function decode3($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === codes.numberSign) {
    const head2 = $2.charCodeAt(1);
    const hex = head2 === codes.lowercaseX || head2 === codes.uppercaseX;
    return decodeNumericCharacterReference(
      $2.slice(hex ? 2 : 1),
      hex ? constants.numericBaseHexadecimal : constants.numericBaseDecimal
    );
  }
  return decodeNamedCharacterReference($2) || $0;
}

// node_modules/remark-parse/node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition2(value2) {
  if (!value2 || typeof value2 !== "object") {
    return "";
  }
  if ("position" in value2 || "type" in value2) {
    return position2(value2.position);
  }
  if ("start" in value2 || "end" in value2) {
    return position2(value2);
  }
  if ("line" in value2 || "column" in value2) {
    return point2(value2);
  }
  return "";
}
function point2(point5) {
  return index2(point5 && point5.line) + ":" + index2(point5 && point5.column);
}
function position2(pos) {
  return point2(pos && pos.start) + "-" + point2(pos && pos.end);
}
function index2(value2) {
  return value2 && typeof value2 === "number" ? value2 : 1;
}

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/dev/lib/index.js
var own2 = {}.hasOwnProperty;
var fromMarkdown = (
  /**
   * @type {(
   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &
   *   ((value: Value, options?: Options | null | undefined) => Root)
   * )}
   */
  /**
   * @param {Value} value
   * @param {Encoding | Options | null | undefined} [encoding]
   * @param {Options | null | undefined} [options]
   * @returns {Root}
   */
  function(value2, encoding, options) {
    if (typeof encoding !== "string") {
      options = encoding;
      encoding = void 0;
    }
    return compiler(options)(
      postprocess(
        parse4(options).document().write(preprocess()(value2, encoding, true))
      )
    );
  }
);
function compiler(options) {
  const config = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link2),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading2),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer2,
      codeFencedFenceMeta: buffer2,
      codeIndented: opener(codeFlow, buffer2),
      codeText: opener(codeText2, buffer2),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition2),
      definitionDestinationString: buffer2,
      definitionLabelString: buffer2,
      definitionTitleString: buffer2,
      emphasis: opener(emphasis2),
      hardBreakEscape: opener(hardBreak2),
      hardBreakTrailing: opener(hardBreak2),
      htmlFlow: opener(html4, buffer2),
      htmlFlowData: onenterdata,
      htmlText: opener(html4, buffer2),
      htmlTextData: onenterdata,
      image: opener(image2),
      label: buffer2,
      link: opener(link2),
      listItem: opener(listItem2),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list3, onenterlistordered),
      listUnordered: opener(list3),
      paragraph: opener(paragraph2),
      reference: onenterreference,
      referenceString: buffer2,
      resourceDestinationString: buffer2,
      resourceTitleString: buffer2,
      setextHeading: opener(heading2),
      strong: opener(strong2),
      thematicBreak: opener(thematicBreak3)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config, (options || {}).mdastExtensions || []);
  const data = {};
  return compile;
  function compile(events) {
    let tree = { type: "root", children: [] };
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter,
      exit: exit2,
      buffer: buffer2,
      resume,
      setData,
      getData
    };
    const listStack = [];
    let index3 = -1;
    while (++index3 < events.length) {
      if (events[index3][1].type === types2.listOrdered || events[index3][1].type === types2.listUnordered) {
        if (events[index3][0] === "enter") {
          listStack.push(index3);
        } else {
          const tail = listStack.pop();
          ok(typeof tail === "number", "expected list ot be open");
          index3 = prepareList(events, tail, index3);
        }
      }
    }
    index3 = -1;
    while (++index3 < events.length) {
      const handler = config[events[index3][0]];
      if (own2.call(handler, events[index3][1].type)) {
        handler[events[index3][1].type].call(
          Object.assign(
            { sliceSerialize: events[index3][2].sliceSerialize },
            context
          ),
          events[index3][1]
        );
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point3(
        events.length > 0 ? events[0][1].start : { line: 1, column: 1, offset: 0 }
      ),
      end: point3(
        events.length > 0 ? events[events.length - 2][1].end : { line: 1, column: 1, offset: 0 }
      )
    };
    index3 = -1;
    while (++index3 < config.transforms.length) {
      tree = config.transforms[index3](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start2, length) {
    let index3 = start2 - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem3;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index3 <= length) {
      const event = events[index3];
      if (event[1].type === types2.listUnordered || event[1].type === types2.listOrdered || event[1].type === types2.blockQuote) {
        if (event[0] === "enter") {
          containerBalance++;
        } else {
          containerBalance--;
        }
        atMarker = void 0;
      } else if (event[1].type === types2.lineEndingBlank) {
        if (event[0] === "enter") {
          if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
            firstBlankLineIndex = index3;
          }
          atMarker = void 0;
        }
      } else if (event[1].type === types2.linePrefix || event[1].type === types2.listItemValue || event[1].type === types2.listItemMarker || event[1].type === types2.listItemPrefix || event[1].type === types2.listItemPrefixWhitespace) {
      } else {
        atMarker = void 0;
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === types2.listItemPrefix || containerBalance === -1 && event[0] === "exit" && (event[1].type === types2.listUnordered || event[1].type === types2.listOrdered)) {
        if (listItem3) {
          let tailIndex = index3;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === types2.lineEnding || tailEvent[1].type === types2.lineEndingBlank) {
              if (tailEvent[0] === "exit") continue;
              if (lineIndex) {
                events[lineIndex][1].type = types2.lineEndingBlank;
                listSpread = true;
              }
              tailEvent[1].type = types2.lineEnding;
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === types2.linePrefix || tailEvent[1].type === types2.blockQuotePrefix || tailEvent[1].type === types2.blockQuotePrefixWhitespace || tailEvent[1].type === types2.blockQuoteMarker || tailEvent[1].type === types2.listItemIndent) {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem3._spread = true;
          }
          listItem3.end = Object.assign(
            {},
            lineIndex ? events[lineIndex][1].start : event[1].end
          );
          events.splice(lineIndex || index3, 0, ["exit", listItem3, event[2]]);
          index3++;
          length++;
        }
        if (event[1].type === types2.listItemPrefix) {
          listItem3 = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          events.splice(index3, 0, ["enter", listItem3, event[2]]);
          index3++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start2][1]._spread = listSpread;
    return length;
  }
  function setData(key, value2) {
    data[key] = value2;
  }
  function getData(key) {
    return data[key];
  }
  function opener(create2, and) {
    return open;
    function open(token) {
      enter.call(this, create2(token), token);
      if (and) and.call(this, token);
    }
  }
  function buffer2() {
    this.stack.push({ type: "fragment", children: [] });
  }
  function enter(node2, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    ok(parent, "expected `parent`");
    ok("children" in parent, "expected `parent`");
    parent.children.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token, errorHandler]);
    node2.position = { start: point3(token.start) };
    return node2;
  }
  function closer(and) {
    return close;
    function close(token) {
      if (and) and.call(this, token);
      exit2.call(this, token);
    }
  }
  function exit2(token, onExitError) {
    const node2 = this.stack.pop();
    ok(node2, "expected `node`");
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error(
        "Cannot close `" + token.type + "` (" + stringifyPosition2({ start: token.start, end: token.end }) + "): its not open"
      );
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }
    ok(node2.type !== "fragment", "unexpected fragment `exit`ed");
    ok(node2.position, "expected `position` to be defined");
    node2.position.end = point3(token.end);
    return node2;
  }
  function resume() {
    return toString(this.stack.pop());
  }
  function onenterlistordered() {
    setData("expectingFirstListItemValue", true);
  }
  function onenterlistitemvalue(token) {
    if (getData("expectingFirstListItemValue")) {
      const ancestor = this.stack[this.stack.length - 2];
      ok(ancestor, "expected nodes on stack");
      ok(ancestor.type === "list", "expected list on stack");
      ancestor.start = Number.parseInt(
        this.sliceSerialize(token),
        constants.numericBaseDecimal
      );
      setData("expectingFirstListItemValue");
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.meta = data2;
  }
  function onexitcodefencedfence() {
    if (getData("flowCodeInside")) return;
    this.buffer();
    setData("flowCodeInside", true);
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    setData("flowCodeInside");
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.url = data2;
  }
  function onexitatxheadingsequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "heading", "expected heading on stack");
    if (!node2.depth) {
      const depth = this.sliceSerialize(token).length;
      ok(
        depth === 1 || depth === 2 || depth === 3 || depth === 4 || depth === 5 || depth === 6,
        "expected `depth` between `1` and `6`"
      );
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    setData("setextHeadingSlurpLineEnding", true);
  }
  function onexitsetextheadinglinesequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "heading", "expected heading on stack");
    node2.depth = this.sliceSerialize(token).charCodeAt(0) === codes.equalsTo ? 1 : 2;
  }
  function onexitsetextheading() {
    setData("setextHeadingSlurpLineEnding");
  }
  function onenterdata(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok("children" in node2, "expected parent on stack");
    let tail = node2.children[node2.children.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text4();
      tail.position = { start: point3(token.start) };
      node2.children.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    ok(tail, "expected a `node` to be on the stack");
    ok("value" in tail, "expected a `literal` to be on the stack");
    ok(tail.position, "expected `node` to have an open position");
    tail.value += this.sliceSerialize(token);
    tail.position.end = point3(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    ok(context, "expected `node`");
    if (getData("atHardBreak")) {
      ok("children" in context, "expected `parent`");
      const tail = context.children[context.children.length - 1];
      ok(tail.position, "expected tail to have a starting position");
      tail.position.end = point3(token.end);
      setData("atHardBreak");
      return;
    }
    if (!getData("setextHeadingSlurpLineEnding") && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    setData("atHardBreak", true);
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "html", "expected html on stack");
    node2.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "html", "expected html on stack");
    node2.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "inlineCode", "expected inline code on stack");
    node2.value = data2;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    if (getData("inReference")) {
      const referenceType = getData("referenceType") || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    setData("referenceType");
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "image", "expected image on stack");
    if (getData("inReference")) {
      const referenceType = getData("referenceType") || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    setData("referenceType");
  }
  function onexitlabeltext(token) {
    const string3 = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    ok(ancestor, "expected ancestor on stack");
    ok(
      ancestor.type === "image" || ancestor.type === "link",
      "expected image or link on stack"
    );
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    ok(fragment, "expected node on stack");
    ok(fragment.type === "fragment", "expected fragment on stack");
    const value2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    setData("inReference", true);
    if (node2.type === "link") {
      const children = fragment.children;
      node2.children = children;
    } else {
      node2.alt = value2;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    node2.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    node2.title = data2;
  }
  function onexitresource() {
    setData("inReference");
  }
  function onenterreference() {
    setData("referenceType", "collapsed");
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image reference or link reference on stack"
    );
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
    setData("referenceType", "full");
  }
  function onexitcharacterreferencemarker(token) {
    ok(
      token.type === "characterReferenceMarkerNumeric" || token.type === "characterReferenceMarkerHexadecimal"
    );
    setData("characterReferenceType", token.type);
  }
  function onexitcharacterreferencevalue(token) {
    const data2 = this.sliceSerialize(token);
    const type2 = getData("characterReferenceType");
    let value2;
    if (type2) {
      value2 = decodeNumericCharacterReference(
        data2,
        type2 === types2.characterReferenceMarkerNumeric ? constants.numericBaseDecimal : constants.numericBaseHexadecimal
      );
      setData("characterReferenceType");
    } else {
      const result = decodeNamedCharacterReference(data2);
      ok(result !== false, "expected reference to decode");
      value2 = result;
    }
    const tail = this.stack.pop();
    ok(tail, "expected `node`");
    ok(tail.position, "expected `node.position`");
    ok("value" in tail, "expected `node.value`");
    tail.value += value2;
    tail.position.end = point3(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    node2.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    node2.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return { type: "blockquote", children: [] };
  }
  function codeFlow() {
    return { type: "code", lang: null, meta: null, value: "" };
  }
  function codeText2() {
    return { type: "inlineCode", value: "" };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis2() {
    return { type: "emphasis", children: [] };
  }
  function heading2() {
    return { type: "heading", depth: void 0, children: [] };
  }
  function hardBreak2() {
    return { type: "break" };
  }
  function html4() {
    return { type: "html", value: "" };
  }
  function image2() {
    return { type: "image", title: null, url: "", alt: null };
  }
  function link2() {
    return { type: "link", title: null, url: "", children: [] };
  }
  function list3(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem2(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph2() {
    return { type: "paragraph", children: [] };
  }
  function strong2() {
    return { type: "strong", children: [] };
  }
  function text4() {
    return { type: "text", value: "" };
  }
  function thematicBreak3() {
    return { type: "thematicBreak" };
  }
}
function point3(d3) {
  return { line: d3.line, column: d3.column, offset: d3.offset };
}
function configure(combined, extensions) {
  let index3 = -1;
  while (++index3 < extensions.length) {
    const value2 = extensions[index3];
    if (Array.isArray(value2)) {
      configure(combined, value2);
    } else {
      extension(combined, value2);
    }
  }
}
function extension(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own2.call(extension2, key)) {
      if (key === "canContainEols") {
        const right = extension2[key];
        if (right) {
          combined[key].push(...right);
        }
      } else if (key === "transforms") {
        const right = extension2[key];
        if (right) {
          combined[key].push(...right);
        }
      } else if (key === "enter" || key === "exit") {
        const right = extension2[key];
        if (right) {
          Object.assign(combined[key], right);
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error(
      "Cannot close `" + left.type + "` (" + stringifyPosition2({ start: left.start, end: left.end }) + "): a different token (`" + right.type + "`, " + stringifyPosition2({ start: right.start, end: right.end }) + ") is open"
    );
  } else {
    throw new Error(
      "Cannot close document, a token (`" + right.type + "`, " + stringifyPosition2({ start: right.start, end: right.end }) + ") is still open"
    );
  }
}

// node_modules/remark-parse/lib/index.js
function remarkParse(options) {
  const parser = (doc) => {
    const settings = (
      /** @type {Options} */
      this.data("settings")
    );
    return fromMarkdown(
      doc,
      Object.assign({}, settings, options, {
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: this.data("micromarkExtensions") || [],
        mdastExtensions: this.data("fromMarkdownExtensions") || []
      })
    );
  };
  Object.assign(this, { Parser: parser });
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/blockquote.js
function blockquote(state, node2) {
  const result = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: state.wrap(state.all(node2), true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/break.js
function hardBreak(state, node2) {
  const result = { type: "element", tagName: "br", properties: {}, children: [] };
  state.patch(node2, result);
  return [state.applyData(node2, result), { type: "text", value: "\n" }];
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/code.js
function code(state, node2) {
  const value2 = node2.value ? node2.value + "\n" : "";
  const lang = node2.lang ? node2.lang.match(/^[^ \t]+(?=[ \t]|$)/) : null;
  const properties = {};
  if (lang) {
    properties.className = ["language-" + lang];
  }
  let result = {
    type: "element",
    tagName: "code",
    properties,
    children: [{ type: "text", value: value2 }]
  };
  if (node2.meta) {
    result.data = { meta: node2.meta };
  }
  state.patch(node2, result);
  result = state.applyData(node2, result);
  result = { type: "element", tagName: "pre", properties: {}, children: [result] };
  state.patch(node2, result);
  return result;
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/delete.js
function strikethrough(state, node2) {
  const result = {
    type: "element",
    tagName: "del",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/emphasis.js
function emphasis(state, node2) {
  const result = {
    type: "element",
    tagName: "em",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/remark-rehype/node_modules/micromark-util-symbol/codes.js
var codes2 = (
  /** @type {const} */
  {
    carriageReturn: -5,
    lineFeed: -4,
    carriageReturnLineFeed: -3,
    horizontalTab: -2,
    virtualSpace: -1,
    eof: null,
    nul: 0,
    soh: 1,
    stx: 2,
    etx: 3,
    eot: 4,
    enq: 5,
    ack: 6,
    bel: 7,
    bs: 8,
    ht: 9,
    // `\t`
    lf: 10,
    // `\n`
    vt: 11,
    // `\v`
    ff: 12,
    // `\f`
    cr: 13,
    // `\r`
    so: 14,
    si: 15,
    dle: 16,
    dc1: 17,
    dc2: 18,
    dc3: 19,
    dc4: 20,
    nak: 21,
    syn: 22,
    etb: 23,
    can: 24,
    em: 25,
    sub: 26,
    esc: 27,
    fs: 28,
    gs: 29,
    rs: 30,
    us: 31,
    space: 32,
    exclamationMark: 33,
    // `!`
    quotationMark: 34,
    // `"`
    numberSign: 35,
    // `#`
    dollarSign: 36,
    // `$`
    percentSign: 37,
    // `%`
    ampersand: 38,
    // `&`
    apostrophe: 39,
    // `'`
    leftParenthesis: 40,
    // `(`
    rightParenthesis: 41,
    // `)`
    asterisk: 42,
    // `*`
    plusSign: 43,
    // `+`
    comma: 44,
    // `,`
    dash: 45,
    // `-`
    dot: 46,
    // `.`
    slash: 47,
    // `/`
    digit0: 48,
    // `0`
    digit1: 49,
    // `1`
    digit2: 50,
    // `2`
    digit3: 51,
    // `3`
    digit4: 52,
    // `4`
    digit5: 53,
    // `5`
    digit6: 54,
    // `6`
    digit7: 55,
    // `7`
    digit8: 56,
    // `8`
    digit9: 57,
    // `9`
    colon: 58,
    // `:`
    semicolon: 59,
    // `;`
    lessThan: 60,
    // `<`
    equalsTo: 61,
    // `=`
    greaterThan: 62,
    // `>`
    questionMark: 63,
    // `?`
    atSign: 64,
    // `@`
    uppercaseA: 65,
    // `A`
    uppercaseB: 66,
    // `B`
    uppercaseC: 67,
    // `C`
    uppercaseD: 68,
    // `D`
    uppercaseE: 69,
    // `E`
    uppercaseF: 70,
    // `F`
    uppercaseG: 71,
    // `G`
    uppercaseH: 72,
    // `H`
    uppercaseI: 73,
    // `I`
    uppercaseJ: 74,
    // `J`
    uppercaseK: 75,
    // `K`
    uppercaseL: 76,
    // `L`
    uppercaseM: 77,
    // `M`
    uppercaseN: 78,
    // `N`
    uppercaseO: 79,
    // `O`
    uppercaseP: 80,
    // `P`
    uppercaseQ: 81,
    // `Q`
    uppercaseR: 82,
    // `R`
    uppercaseS: 83,
    // `S`
    uppercaseT: 84,
    // `T`
    uppercaseU: 85,
    // `U`
    uppercaseV: 86,
    // `V`
    uppercaseW: 87,
    // `W`
    uppercaseX: 88,
    // `X`
    uppercaseY: 89,
    // `Y`
    uppercaseZ: 90,
    // `Z`
    leftSquareBracket: 91,
    // `[`
    backslash: 92,
    // `\`
    rightSquareBracket: 93,
    // `]`
    caret: 94,
    // `^`
    underscore: 95,
    // `_`
    graveAccent: 96,
    // `` ` ``
    lowercaseA: 97,
    // `a`
    lowercaseB: 98,
    // `b`
    lowercaseC: 99,
    // `c`
    lowercaseD: 100,
    // `d`
    lowercaseE: 101,
    // `e`
    lowercaseF: 102,
    // `f`
    lowercaseG: 103,
    // `g`
    lowercaseH: 104,
    // `h`
    lowercaseI: 105,
    // `i`
    lowercaseJ: 106,
    // `j`
    lowercaseK: 107,
    // `k`
    lowercaseL: 108,
    // `l`
    lowercaseM: 109,
    // `m`
    lowercaseN: 110,
    // `n`
    lowercaseO: 111,
    // `o`
    lowercaseP: 112,
    // `p`
    lowercaseQ: 113,
    // `q`
    lowercaseR: 114,
    // `r`
    lowercaseS: 115,
    // `s`
    lowercaseT: 116,
    // `t`
    lowercaseU: 117,
    // `u`
    lowercaseV: 118,
    // `v`
    lowercaseW: 119,
    // `w`
    lowercaseX: 120,
    // `x`
    lowercaseY: 121,
    // `y`
    lowercaseZ: 122,
    // `z`
    leftCurlyBrace: 123,
    // `{`
    verticalBar: 124,
    // `|`
    rightCurlyBrace: 125,
    // `}`
    tilde: 126,
    // `~`
    del: 127,
    // Unicode Specials block.
    byteOrderMarker: 65279,
    // Unicode Specials block.
    replacementCharacter: 65533
    // ``
  }
);

// node_modules/remark-rehype/node_modules/micromark-util-character/dev/lib/unicode-punctuation-regex.js
var unicodePunctuationRegex2 = /[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;

// node_modules/remark-rehype/node_modules/micromark-util-character/dev/index.js
var asciiAlpha2 = regexCheck2(/[A-Za-z]/);
var asciiAlphanumeric2 = regexCheck2(/[\dA-Za-z]/);
var asciiAtext2 = regexCheck2(/[#-'*+\--9=?A-Z^-~]/);
var asciiDigit2 = regexCheck2(/\d/);
var asciiHexDigit2 = regexCheck2(/[\dA-Fa-f]/);
var asciiPunctuation2 = regexCheck2(/[!-/:-@[-`{-~]/);
var unicodePunctuation2 = regexCheck2(unicodePunctuationRegex2);
var unicodeWhitespace2 = regexCheck2(/\s/);
function regexCheck2(regex) {
  return check;
  function check(code2) {
    return code2 !== null && regex.test(String.fromCharCode(code2));
  }
}

// node_modules/remark-rehype/node_modules/micromark-util-symbol/values.js
var values2 = (
  /** @type {const} */
  {
    ht: "	",
    lf: "\n",
    cr: "\r",
    space: " ",
    exclamationMark: "!",
    quotationMark: '"',
    numberSign: "#",
    dollarSign: "$",
    percentSign: "%",
    ampersand: "&",
    apostrophe: "'",
    leftParenthesis: "(",
    rightParenthesis: ")",
    asterisk: "*",
    plusSign: "+",
    comma: ",",
    dash: "-",
    dot: ".",
    slash: "/",
    digit0: "0",
    digit1: "1",
    digit2: "2",
    digit3: "3",
    digit4: "4",
    digit5: "5",
    digit6: "6",
    digit7: "7",
    digit8: "8",
    digit9: "9",
    colon: ":",
    semicolon: ";",
    lessThan: "<",
    equalsTo: "=",
    greaterThan: ">",
    questionMark: "?",
    atSign: "@",
    uppercaseA: "A",
    uppercaseB: "B",
    uppercaseC: "C",
    uppercaseD: "D",
    uppercaseE: "E",
    uppercaseF: "F",
    uppercaseG: "G",
    uppercaseH: "H",
    uppercaseI: "I",
    uppercaseJ: "J",
    uppercaseK: "K",
    uppercaseL: "L",
    uppercaseM: "M",
    uppercaseN: "N",
    uppercaseO: "O",
    uppercaseP: "P",
    uppercaseQ: "Q",
    uppercaseR: "R",
    uppercaseS: "S",
    uppercaseT: "T",
    uppercaseU: "U",
    uppercaseV: "V",
    uppercaseW: "W",
    uppercaseX: "X",
    uppercaseY: "Y",
    uppercaseZ: "Z",
    leftSquareBracket: "[",
    backslash: "\\",
    rightSquareBracket: "]",
    caret: "^",
    underscore: "_",
    graveAccent: "`",
    lowercaseA: "a",
    lowercaseB: "b",
    lowercaseC: "c",
    lowercaseD: "d",
    lowercaseE: "e",
    lowercaseF: "f",
    lowercaseG: "g",
    lowercaseH: "h",
    lowercaseI: "i",
    lowercaseJ: "j",
    lowercaseK: "k",
    lowercaseL: "l",
    lowercaseM: "m",
    lowercaseN: "n",
    lowercaseO: "o",
    lowercaseP: "p",
    lowercaseQ: "q",
    lowercaseR: "r",
    lowercaseS: "s",
    lowercaseT: "t",
    lowercaseU: "u",
    lowercaseV: "v",
    lowercaseW: "w",
    lowercaseX: "x",
    lowercaseY: "y",
    lowercaseZ: "z",
    leftCurlyBrace: "{",
    verticalBar: "|",
    rightCurlyBrace: "}",
    tilde: "~",
    replacementCharacter: ""
  }
);

// node_modules/remark-rehype/node_modules/micromark-util-sanitize-uri/dev/index.js
function normalizeUri(value2) {
  const result = [];
  let index3 = -1;
  let start2 = 0;
  let skip = 0;
  while (++index3 < value2.length) {
    const code2 = value2.charCodeAt(index3);
    let replace = "";
    if (code2 === codes2.percentSign && asciiAlphanumeric2(value2.charCodeAt(index3 + 1)) && asciiAlphanumeric2(value2.charCodeAt(index3 + 2))) {
      skip = 2;
    } else if (code2 < 128) {
      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code2))) {
        replace = String.fromCharCode(code2);
      }
    } else if (code2 > 55295 && code2 < 57344) {
      const next = value2.charCodeAt(index3 + 1);
      if (code2 < 56320 && next > 56319 && next < 57344) {
        replace = String.fromCharCode(code2, next);
        skip = 1;
      } else {
        replace = values2.replacementCharacter;
      }
    } else {
      replace = String.fromCharCode(code2);
    }
    if (replace) {
      result.push(value2.slice(start2, index3), encodeURIComponent(replace));
      start2 = index3 + skip + 1;
      replace = "";
    }
    if (skip) {
      index3 += skip;
      skip = 0;
    }
  }
  return result.join("") + value2.slice(start2);
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js
function footnoteReference(state, node2) {
  const id = String(node2.identifier).toUpperCase();
  const safeId = normalizeUri(id.toLowerCase());
  const index3 = state.footnoteOrder.indexOf(id);
  let counter;
  if (index3 === -1) {
    state.footnoteOrder.push(id);
    state.footnoteCounts[id] = 1;
    counter = state.footnoteOrder.length;
  } else {
    state.footnoteCounts[id]++;
    counter = index3 + 1;
  }
  const reuseCounter = state.footnoteCounts[id];
  const link2 = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + state.clobberPrefix + "fn-" + safeId,
      id: state.clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
      dataFootnoteRef: true,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(counter) }]
  };
  state.patch(node2, link2);
  const sup = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [link2]
  };
  state.patch(node2, sup);
  return state.applyData(node2, sup);
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/footnote.js
function footnote(state, node2) {
  const footnoteById = state.footnoteById;
  let no = 1;
  while (no in footnoteById) no++;
  const identifier = String(no);
  footnoteById[identifier] = {
    type: "footnoteDefinition",
    identifier,
    children: [{ type: "paragraph", children: node2.children }],
    position: node2.position
  };
  return footnoteReference(state, {
    type: "footnoteReference",
    identifier,
    position: node2.position
  });
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/heading.js
function heading(state, node2) {
  const result = {
    type: "element",
    tagName: "h" + node2.depth,
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/html.js
function html(state, node2) {
  if (state.dangerous) {
    const result = { type: "raw", value: node2.value };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  return null;
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/revert.js
function revert(state, node2) {
  const subtype = node2.referenceType;
  let suffix = "]";
  if (subtype === "collapsed") {
    suffix += "[]";
  } else if (subtype === "full") {
    suffix += "[" + (node2.label || node2.identifier) + "]";
  }
  if (node2.type === "imageReference") {
    return { type: "text", value: "![" + node2.alt + suffix };
  }
  const contents = state.all(node2);
  const head = contents[0];
  if (head && head.type === "text") {
    head.value = "[" + head.value;
  } else {
    contents.unshift({ type: "text", value: "[" });
  }
  const tail = contents[contents.length - 1];
  if (tail && tail.type === "text") {
    tail.value += suffix;
  } else {
    contents.push({ type: "text", value: suffix });
  }
  return contents;
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/image-reference.js
function imageReference(state, node2) {
  const def = state.definition(node2.identifier);
  if (!def) {
    return revert(state, node2);
  }
  const properties = { src: normalizeUri(def.url || ""), alt: node2.alt };
  if (def.title !== null && def.title !== void 0) {
    properties.title = def.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/image.js
function image(state, node2) {
  const properties = { src: normalizeUri(node2.url) };
  if (node2.alt !== null && node2.alt !== void 0) {
    properties.alt = node2.alt;
  }
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/inline-code.js
function inlineCode(state, node2) {
  const text4 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
  state.patch(node2, text4);
  const result = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [text4]
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/link-reference.js
function linkReference(state, node2) {
  const def = state.definition(node2.identifier);
  if (!def) {
    return revert(state, node2);
  }
  const properties = { href: normalizeUri(def.url || "") };
  if (def.title !== null && def.title !== void 0) {
    properties.title = def.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/link.js
function link(state, node2) {
  const properties = { href: normalizeUri(node2.url) };
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/list-item.js
function listItem(state, node2, parent) {
  const results = state.all(node2);
  const loose = parent ? listLoose(parent) : listItemLoose(node2);
  const properties = {};
  const children = [];
  if (typeof node2.checked === "boolean") {
    const head = results[0];
    let paragraph2;
    if (head && head.type === "element" && head.tagName === "p") {
      paragraph2 = head;
    } else {
      paragraph2 = { type: "element", tagName: "p", properties: {}, children: [] };
      results.unshift(paragraph2);
    }
    if (paragraph2.children.length > 0) {
      paragraph2.children.unshift({ type: "text", value: " " });
    }
    paragraph2.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: node2.checked, disabled: true },
      children: []
    });
    properties.className = ["task-list-item"];
  }
  let index3 = -1;
  while (++index3 < results.length) {
    const child = results[index3];
    if (loose || index3 !== 0 || child.type !== "element" || child.tagName !== "p") {
      children.push({ type: "text", value: "\n" });
    }
    if (child.type === "element" && child.tagName === "p" && !loose) {
      children.push(...child.children);
    } else {
      children.push(child);
    }
  }
  const tail = results[results.length - 1];
  if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
    children.push({ type: "text", value: "\n" });
  }
  const result = { type: "element", tagName: "li", properties, children };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function listLoose(node2) {
  let loose = false;
  if (node2.type === "list") {
    loose = node2.spread || false;
    const children = node2.children;
    let index3 = -1;
    while (!loose && ++index3 < children.length) {
      loose = listItemLoose(children[index3]);
    }
  }
  return loose;
}
function listItemLoose(node2) {
  const spread = node2.spread;
  return spread === void 0 || spread === null ? node2.children.length > 1 : spread;
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/list.js
function list2(state, node2) {
  const properties = {};
  const results = state.all(node2);
  let index3 = -1;
  if (typeof node2.start === "number" && node2.start !== 1) {
    properties.start = node2.start;
  }
  while (++index3 < results.length) {
    const child = results[index3];
    if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
      properties.className = ["contains-task-list"];
      break;
    }
  }
  const result = {
    type: "element",
    tagName: node2.ordered ? "ol" : "ul",
    properties,
    children: state.wrap(results, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/paragraph.js
function paragraph(state, node2) {
  const result = {
    type: "element",
    tagName: "p",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/root.js
function root(state, node2) {
  const result = { type: "root", children: state.wrap(state.all(node2)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/strong.js
function strong(state, node2) {
  const result = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/remark-rehype/node_modules/unist-util-position/lib/index.js
var pointStart = point4("start");
var pointEnd = point4("end");
function position3(node2) {
  return { start: pointStart(node2), end: pointEnd(node2) };
}
function point4(type2) {
  return point5;
  function point5(node2) {
    const point6 = node2 && node2.position && node2.position[type2] || {};
    return {
      // @ts-expect-error: in practice, null is allowed.
      line: point6.line || null,
      // @ts-expect-error: in practice, null is allowed.
      column: point6.column || null,
      // @ts-expect-error: in practice, null is allowed.
      offset: point6.offset > -1 ? point6.offset : null
    };
  }
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/table.js
function table(state, node2) {
  const rows = state.all(node2);
  const firstRow = rows.shift();
  const tableContent = [];
  if (firstRow) {
    const head = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: state.wrap([firstRow], true)
    };
    state.patch(node2.children[0], head);
    tableContent.push(head);
  }
  if (rows.length > 0) {
    const body = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: state.wrap(rows, true)
    };
    const start2 = pointStart(node2.children[1]);
    const end = pointEnd(node2.children[node2.children.length - 1]);
    if (start2.line && end.line) body.position = { start: start2, end };
    tableContent.push(body);
  }
  const result = {
    type: "element",
    tagName: "table",
    properties: {},
    children: state.wrap(tableContent, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/table-row.js
function tableRow(state, node2, parent) {
  const siblings = parent ? parent.children : void 0;
  const rowIndex = siblings ? siblings.indexOf(node2) : 1;
  const tagName = rowIndex === 0 ? "th" : "td";
  const align = parent && parent.type === "table" ? parent.align : void 0;
  const length = align ? align.length : node2.children.length;
  let cellIndex = -1;
  const cells = [];
  while (++cellIndex < length) {
    const cell = node2.children[cellIndex];
    const properties = {};
    const alignValue = align ? align[cellIndex] : void 0;
    if (alignValue) {
      properties.align = alignValue;
    }
    let result2 = { type: "element", tagName, properties, children: [] };
    if (cell) {
      result2.children = state.all(cell);
      state.patch(cell, result2);
      result2 = state.applyData(node2, result2);
    }
    cells.push(result2);
  }
  const result = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: state.wrap(cells, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/table-cell.js
function tableCell(state, node2) {
  const result = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/trim-lines/index.js
var tab = 9;
var space = 32;
function trimLines(value2) {
  const source = String(value2);
  const search2 = /\r?\n|\r/g;
  let match = search2.exec(source);
  let last = 0;
  const lines2 = [];
  while (match) {
    lines2.push(
      trimLine(source.slice(last, match.index), last > 0, true),
      match[0]
    );
    last = match.index + match[0].length;
    match = search2.exec(source);
  }
  lines2.push(trimLine(source.slice(last), last > 0, false));
  return lines2.join("");
}
function trimLine(value2, start2, end) {
  let startIndex = 0;
  let endIndex = value2.length;
  if (start2) {
    let code2 = value2.codePointAt(startIndex);
    while (code2 === tab || code2 === space) {
      startIndex++;
      code2 = value2.codePointAt(startIndex);
    }
  }
  if (end) {
    let code2 = value2.codePointAt(endIndex - 1);
    while (code2 === tab || code2 === space) {
      endIndex--;
      code2 = value2.codePointAt(endIndex - 1);
    }
  }
  return endIndex > startIndex ? value2.slice(startIndex, endIndex) : "";
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/text.js
function text3(state, node2) {
  const result = { type: "text", value: trimLines(String(node2.value)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js
function thematicBreak2(state, node2) {
  const result = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/handlers/index.js
var handlers = {
  blockquote,
  break: hardBreak,
  code,
  delete: strikethrough,
  emphasis,
  footnoteReference,
  footnote,
  heading,
  html,
  imageReference,
  image,
  inlineCode,
  linkReference,
  link,
  listItem,
  list: list2,
  paragraph,
  root,
  strong,
  table,
  tableCell,
  tableRow,
  text: text3,
  thematicBreak: thematicBreak2,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};
function ignore() {
  return null;
}

// node_modules/unist-util-visit/node_modules/unist-util-is/lib/index.js
var convert = (
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {AssertAnything}
   */
  function(test) {
    if (test === void 0 || test === null) {
      return ok2;
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks2 = [];
  let index3 = -1;
  while (++index3 < tests.length) {
    checks2[index3] = convert(tests[index3]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index4 = -1;
    while (++index4 < checks2.length) {
      if (checks2[index4].call(this, ...parameters)) return true;
    }
    return false;
  }
}
function propsFactory(check) {
  return castFactory(all3);
  function all3(node2) {
    let key;
    for (key in check) {
      if (node2[key] !== check[key]) return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type2);
  function type2(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory(check) {
  return assertion;
  function assertion(node2, ...parameters) {
    return Boolean(
      node2 && typeof node2 === "object" && "type" in node2 && // @ts-expect-error: fine.
      Boolean(check.call(this, node2, ...parameters))
    );
  }
}
function ok2() {
  return true;
}

// node_modules/unist-util-visit/node_modules/unist-util-visit-parents/lib/color.browser.js
function color(d3) {
  return d3;
}

// node_modules/unist-util-visit/node_modules/unist-util-visit-parents/lib/index.js
var CONTINUE = true;
var EXIT = false;
var SKIP = "skip";
var visitParents = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor<Node>} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    const is3 = convert(test);
    const step = reverse ? -1 : 1;
    factory(tree, void 0, [])();
    function factory(node2, index3, parents) {
      const value2 = node2 && typeof node2 === "object" ? node2 : {};
      if (typeof value2.type === "string") {
        const name2 = (
          // `hast`
          typeof value2.tagName === "string" ? value2.tagName : (
            // `xast`
            typeof value2.name === "string" ? value2.name : void 0
          )
        );
        Object.defineProperty(visit3, "name", {
          value: "node (" + color(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
        });
      }
      return visit3;
      function visit3() {
        let result = [];
        let subresult;
        let offset;
        let grandparents;
        if (!test || is3(node2, index3, parents[parents.length - 1] || null)) {
          result = toResult(visitor(node2, parents));
          if (result[0] === EXIT) {
            return result;
          }
        }
        if (node2.children && result[0] !== SKIP) {
          offset = (reverse ? node2.children.length : -1) + step;
          grandparents = parents.concat(node2);
          while (offset > -1 && offset < node2.children.length) {
            subresult = factory(node2.children[offset], offset, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
        return result;
      }
    }
  }
);
function toResult(value2) {
  if (Array.isArray(value2)) {
    return value2;
  }
  if (typeof value2 === "number") {
    return [CONTINUE, value2];
  }
  return [value2];
}

// node_modules/unist-util-visit/lib/index.js
var visit2 = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    visitParents(tree, test, overload, reverse);
    function overload(node2, parents) {
      const parent = parents[parents.length - 1];
      return visitor(
        node2,
        parent ? parent.children.indexOf(node2) : null,
        parent
      );
    }
  }
);

// node_modules/unist-util-generated/lib/index.js
function generated(node2) {
  return !node2 || !node2.position || !node2.position.start || !node2.position.start.line || !node2.position.start.column || !node2.position.end || !node2.position.end.line || !node2.position.end.column;
}

// node_modules/mdast-util-definitions/lib/index.js
var own3 = {}.hasOwnProperty;
function definitions2(tree) {
  const cache = /* @__PURE__ */ Object.create(null);
  if (!tree || !tree.type) {
    throw new Error("mdast-util-definitions expected node");
  }
  visit2(tree, "definition", (definition3) => {
    const id = clean(definition3.identifier);
    if (id && !own3.call(cache, id)) {
      cache[id] = definition3;
    }
  });
  return definition2;
  function definition2(identifier) {
    const id = clean(identifier);
    return id && own3.call(cache, id) ? cache[id] : null;
  }
}
function clean(value2) {
  return String(value2 || "").toUpperCase();
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/state.js
var own4 = {}.hasOwnProperty;
function createState(tree, options) {
  const settings = options || {};
  const dangerous = settings.allowDangerousHtml || false;
  const footnoteById = {};
  state.dangerous = dangerous;
  state.clobberPrefix = settings.clobberPrefix === void 0 || settings.clobberPrefix === null ? "user-content-" : settings.clobberPrefix;
  state.footnoteLabel = settings.footnoteLabel || "Footnotes";
  state.footnoteLabelTagName = settings.footnoteLabelTagName || "h2";
  state.footnoteLabelProperties = settings.footnoteLabelProperties || {
    className: ["sr-only"]
  };
  state.footnoteBackLabel = settings.footnoteBackLabel || "Back to content";
  state.unknownHandler = settings.unknownHandler;
  state.passThrough = settings.passThrough;
  state.handlers = { ...handlers, ...settings.handlers };
  state.definition = definitions2(tree);
  state.footnoteById = footnoteById;
  state.footnoteOrder = [];
  state.footnoteCounts = {};
  state.patch = patch;
  state.applyData = applyData;
  state.one = oneBound;
  state.all = allBound;
  state.wrap = wrap5;
  state.augment = augment;
  visit2(tree, "footnoteDefinition", (definition2) => {
    const id = String(definition2.identifier).toUpperCase();
    if (!own4.call(footnoteById, id)) {
      footnoteById[id] = definition2;
    }
  });
  return state;
  function augment(left, right) {
    if (left && "data" in left && left.data) {
      const data = left.data;
      if (data.hName) {
        if (right.type !== "element") {
          right = {
            type: "element",
            tagName: "",
            properties: {},
            children: []
          };
        }
        right.tagName = data.hName;
      }
      if (right.type === "element" && data.hProperties) {
        right.properties = { ...right.properties, ...data.hProperties };
      }
      if ("children" in right && right.children && data.hChildren) {
        right.children = data.hChildren;
      }
    }
    if (left) {
      const ctx = "type" in left ? left : { position: left };
      if (!generated(ctx)) {
        right.position = { start: pointStart(ctx), end: pointEnd(ctx) };
      }
    }
    return right;
  }
  function state(node2, tagName, props, children) {
    if (Array.isArray(props)) {
      children = props;
      props = {};
    }
    return augment(node2, {
      type: "element",
      tagName,
      properties: props || {},
      children: children || []
    });
  }
  function oneBound(node2, parent) {
    return one2(state, node2, parent);
  }
  function allBound(parent) {
    return all2(state, parent);
  }
}
function patch(from, to) {
  if (from.position) to.position = position3(from);
}
function applyData(from, to) {
  let result = to;
  if (from && from.data) {
    const hName = from.data.hName;
    const hChildren = from.data.hChildren;
    const hProperties = from.data.hProperties;
    if (typeof hName === "string") {
      if (result.type === "element") {
        result.tagName = hName;
      } else {
        result = {
          type: "element",
          tagName: hName,
          properties: {},
          children: []
        };
      }
    }
    if (result.type === "element" && hProperties) {
      result.properties = { ...result.properties, ...hProperties };
    }
    if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
      result.children = hChildren;
    }
  }
  return result;
}
function one2(state, node2, parent) {
  const type2 = node2 && node2.type;
  if (!type2) {
    throw new Error("Expected node, got `" + node2 + "`");
  }
  if (own4.call(state.handlers, type2)) {
    return state.handlers[type2](state, node2, parent);
  }
  if (state.passThrough && state.passThrough.includes(type2)) {
    return "children" in node2 ? { ...node2, children: all2(state, node2) } : node2;
  }
  if (state.unknownHandler) {
    return state.unknownHandler(state, node2, parent);
  }
  return defaultUnknownHandler(state, node2);
}
function all2(state, parent) {
  const values3 = [];
  if ("children" in parent) {
    const nodes = parent.children;
    let index3 = -1;
    while (++index3 < nodes.length) {
      const result = one2(state, nodes[index3], parent);
      if (result) {
        if (index3 && nodes[index3 - 1].type === "break") {
          if (!Array.isArray(result) && result.type === "text") {
            result.value = result.value.replace(/^\s+/, "");
          }
          if (!Array.isArray(result) && result.type === "element") {
            const head = result.children[0];
            if (head && head.type === "text") {
              head.value = head.value.replace(/^\s+/, "");
            }
          }
        }
        if (Array.isArray(result)) {
          values3.push(...result);
        } else {
          values3.push(result);
        }
      }
    }
  }
  return values3;
}
function defaultUnknownHandler(state, node2) {
  const data = node2.data || {};
  const result = "value" in node2 && !(own4.call(data, "hProperties") || own4.call(data, "hChildren")) ? { type: "text", value: node2.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: all2(state, node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function wrap5(nodes, loose) {
  const result = [];
  let index3 = -1;
  if (loose) {
    result.push({ type: "text", value: "\n" });
  }
  while (++index3 < nodes.length) {
    if (index3) result.push({ type: "text", value: "\n" });
    result.push(nodes[index3]);
  }
  if (loose && nodes.length > 0) {
    result.push({ type: "text", value: "\n" });
  }
  return result;
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/footer.js
function footer(state) {
  const listItems = [];
  let index3 = -1;
  while (++index3 < state.footnoteOrder.length) {
    const def = state.footnoteById[state.footnoteOrder[index3]];
    if (!def) {
      continue;
    }
    const content3 = state.all(def);
    const id = String(def.identifier).toUpperCase();
    const safeId = normalizeUri(id.toLowerCase());
    let referenceIndex = 0;
    const backReferences = [];
    while (++referenceIndex <= state.footnoteCounts[id]) {
      const backReference = {
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + state.clobberPrefix + "fnref-" + safeId + (referenceIndex > 1 ? "-" + referenceIndex : ""),
          dataFootnoteBackref: true,
          className: ["data-footnote-backref"],
          ariaLabel: state.footnoteBackLabel
        },
        children: [{ type: "text", value: "" }]
      };
      if (referenceIndex > 1) {
        backReference.children.push({
          type: "element",
          tagName: "sup",
          children: [{ type: "text", value: String(referenceIndex) }]
        });
      }
      if (backReferences.length > 0) {
        backReferences.push({ type: "text", value: " " });
      }
      backReferences.push(backReference);
    }
    const tail = content3[content3.length - 1];
    if (tail && tail.type === "element" && tail.tagName === "p") {
      const tailTail = tail.children[tail.children.length - 1];
      if (tailTail && tailTail.type === "text") {
        tailTail.value += " ";
      } else {
        tail.children.push({ type: "text", value: " " });
      }
      tail.children.push(...backReferences);
    } else {
      content3.push(...backReferences);
    }
    const listItem2 = {
      type: "element",
      tagName: "li",
      properties: { id: state.clobberPrefix + "fn-" + safeId },
      children: state.wrap(content3, true)
    };
    state.patch(def, listItem2);
    listItems.push(listItem2);
  }
  if (listItems.length === 0) {
    return;
  }
  return {
    type: "element",
    tagName: "section",
    properties: { dataFootnotes: true, className: ["footnotes"] },
    children: [
      {
        type: "element",
        tagName: state.footnoteLabelTagName,
        properties: {
          // To do: use structured clone.
          ...JSON.parse(JSON.stringify(state.footnoteLabelProperties)),
          id: "footnote-label"
        },
        children: [{ type: "text", value: state.footnoteLabel }]
      },
      { type: "text", value: "\n" },
      {
        type: "element",
        tagName: "ol",
        properties: {},
        children: state.wrap(listItems, true)
      },
      { type: "text", value: "\n" }
    ]
  };
}

// node_modules/remark-rehype/node_modules/mdast-util-to-hast/lib/index.js
function toHast(tree, options) {
  const state = createState(tree, options);
  const node2 = state.one(tree, null);
  const foot = footer(state);
  if (foot) {
    node2.children.push({ type: "text", value: "\n" }, foot);
  }
  return Array.isArray(node2) ? { type: "root", children: node2 } : node2;
}

// node_modules/remark-rehype/lib/index.js
var remarkRehype = (
  /** @type {(import('unified').Plugin<[Processor, Options?]|[null|undefined, Options?]|[Options]|[], MdastRoot>)} */
  function(destination, options) {
    return destination && "run" in destination ? bridge(destination, options) : mutate(destination || options);
  }
);
var lib_default = remarkRehype;
function bridge(destination, options) {
  return (node2, file, next) => {
    destination.run(toHast(node2, options), file, (error2) => {
      next(error2);
    });
  };
}
function mutate(options) {
  return (node2) => toHast(node2, options);
}

// node_modules/react-markdown/lib/react-markdown.js
var import_prop_types = __toESM(require_prop_types(), 1);

// node_modules/property-information/lib/util/schema.js
var Schema = class {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(property, normal, space2) {
    this.property = property;
    this.normal = normal;
    if (space2) {
      this.space = space2;
    }
  }
};
Schema.prototype.property = {};
Schema.prototype.normal = {};
Schema.prototype.space = null;

// node_modules/property-information/lib/util/merge.js
function merge2(definitions3, space2) {
  const property = {};
  const normal = {};
  let index3 = -1;
  while (++index3 < definitions3.length) {
    Object.assign(property, definitions3[index3].property);
    Object.assign(normal, definitions3[index3].normal);
  }
  return new Schema(property, normal, space2);
}

// node_modules/property-information/lib/normalize.js
function normalize2(value2) {
  return value2.toLowerCase();
}

// node_modules/property-information/lib/util/info.js
var Info = class {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(property, attribute) {
    this.property = property;
    this.attribute = attribute;
  }
};
Info.prototype.space = null;
Info.prototype.boolean = false;
Info.prototype.booleanish = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.number = false;
Info.prototype.commaSeparated = false;
Info.prototype.spaceSeparated = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.mustUseProperty = false;
Info.prototype.defined = false;

// node_modules/property-information/lib/util/types.js
var types_exports = {};
__export(types_exports, {
  boolean: () => boolean,
  booleanish: () => booleanish,
  commaOrSpaceSeparated: () => commaOrSpaceSeparated,
  commaSeparated: () => commaSeparated,
  number: () => number,
  overloadedBoolean: () => overloadedBoolean,
  spaceSeparated: () => spaceSeparated
});
var powers = 0;
var boolean = increment();
var booleanish = increment();
var overloadedBoolean = increment();
var number = increment();
var spaceSeparated = increment();
var commaSeparated = increment();
var commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}

// node_modules/property-information/lib/util/defined-info.js
var checks = Object.keys(types_exports);
var DefinedInfo = class extends Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(property, attribute, mask, space2) {
    let index3 = -1;
    super(property, attribute);
    mark(this, "space", space2);
    if (typeof mask === "number") {
      while (++index3 < checks.length) {
        const check = checks[index3];
        mark(this, checks[index3], (mask & types_exports[check]) === types_exports[check]);
      }
    }
  }
};
DefinedInfo.prototype.defined = true;
function mark(values3, key, value2) {
  if (value2) {
    values3[key] = value2;
  }
}

// node_modules/property-information/lib/util/create.js
var own5 = {}.hasOwnProperty;
function create(definition2) {
  const property = {};
  const normal = {};
  let prop;
  for (prop in definition2.properties) {
    if (own5.call(definition2.properties, prop)) {
      const value2 = definition2.properties[prop];
      const info = new DefinedInfo(
        prop,
        definition2.transform(definition2.attributes || {}, prop),
        value2,
        definition2.space
      );
      if (definition2.mustUseProperty && definition2.mustUseProperty.includes(prop)) {
        info.mustUseProperty = true;
      }
      property[prop] = info;
      normal[normalize2(prop)] = prop;
      normal[normalize2(info.attribute)] = prop;
    }
  }
  return new Schema(property, normal, definition2.space);
}

// node_modules/property-information/lib/xlink.js
var xlink = create({
  space: "xlink",
  transform(_, prop) {
    return "xlink:" + prop.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});

// node_modules/property-information/lib/xml.js
var xml = create({
  space: "xml",
  transform(_, prop) {
    return "xml:" + prop.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});

// node_modules/property-information/lib/util/case-sensitive-transform.js
function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}

// node_modules/property-information/lib/util/case-insensitive-transform.js
function caseInsensitiveTransform(attributes, property) {
  return caseSensitiveTransform(attributes, property.toLowerCase());
}

// node_modules/property-information/lib/xmlns.js
var xmlns = create({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: caseInsensitiveTransform,
  properties: { xmlns: null, xmlnsXLink: null }
});

// node_modules/property-information/lib/aria.js
var aria = create({
  transform(_, prop) {
    return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  }
});

// node_modules/property-information/lib/html.js
var html2 = create({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: null,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: boolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shadowRootClonable: boolean,
    shadowRootDelegatesFocus: boolean,
    shadowRootMode: null,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number,
    // `<img>` and `<object>`
    leftMargin: number,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number,
    // `<body>`
    marginWidth: number,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  }
});

// node_modules/property-information/lib/svg.js
var svg = create({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});

// node_modules/property-information/lib/find.js
var valid = /^data[-\w.:]+$/i;
var dash = /-[a-z]/g;
var cap = /[A-Z]/g;
function find2(schema, value2) {
  const normal = normalize2(value2);
  let prop = value2;
  let Type = Info;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value2)) {
    if (value2.charAt(4) === "-") {
      const rest = value2.slice(5).replace(dash, camelcase);
      prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value2.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value2 = "data" + dashes;
      }
    }
    Type = DefinedInfo;
  }
  return new Type(prop, value2);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}

// node_modules/property-information/lib/hast-to-react.js
var hastToReact = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
};

// node_modules/property-information/index.js
var html3 = merge2([xml, xlink, xmlns, aria, html2], "html");
var svg2 = merge2([xml, xlink, xmlns, aria, svg], "svg");

// node_modules/react-markdown/lib/rehype-filter.js
function rehypeFilter(options) {
  if (options.allowedElements && options.disallowedElements) {
    throw new TypeError(
      "Only one of `allowedElements` and `disallowedElements` should be defined"
    );
  }
  if (options.allowedElements || options.disallowedElements || options.allowElement) {
    return (tree) => {
      visit2(tree, "element", (node2, index3, parent_) => {
        const parent = (
          /** @type {Element|Root} */
          parent_
        );
        let remove;
        if (options.allowedElements) {
          remove = !options.allowedElements.includes(node2.tagName);
        } else if (options.disallowedElements) {
          remove = options.disallowedElements.includes(node2.tagName);
        }
        if (!remove && options.allowElement && typeof index3 === "number") {
          remove = !options.allowElement(node2, index3, parent);
        }
        if (remove && typeof index3 === "number") {
          if (options.unwrapDisallowed && node2.children) {
            parent.children.splice(index3, 1, ...node2.children);
          } else {
            parent.children.splice(index3, 1);
          }
          return index3;
        }
        return void 0;
      });
    };
  }
}

// node_modules/react-markdown/lib/ast-to-react.js
var import_react5 = __toESM(require_react(), 1);
var import_react_is = __toESM(require_react_is2(), 1);

// node_modules/hast-util-whitespace/index.js
function whitespace(thing) {
  const value2 = (
    // @ts-expect-error looks like a node.
    thing && typeof thing === "object" && thing.type === "text" ? (
      // @ts-expect-error looks like a text.
      thing.value || ""
    ) : thing
  );
  return typeof value2 === "string" && value2.replace(/[ \t\n\f\r]/g, "") === "";
}

// node_modules/space-separated-tokens/index.js
function parse5(value2) {
  const input = String(value2 || "").trim();
  return input ? input.split(/[ \t\n\r\f]+/g) : [];
}
function stringify3(values3) {
  return values3.join(" ").trim();
}

// node_modules/comma-separated-tokens/index.js
function parse6(value2) {
  const tokens = [];
  const input = String(value2 || "");
  let index3 = input.indexOf(",");
  let start2 = 0;
  let end = false;
  while (!end) {
    if (index3 === -1) {
      index3 = input.length;
      end = true;
    }
    const token = input.slice(start2, index3).trim();
    if (token || !end) {
      tokens.push(token);
    }
    start2 = index3 + 1;
    index3 = input.indexOf(",", start2);
  }
  return tokens;
}
function stringify4(values3, options) {
  const settings = options || {};
  const input = values3[values3.length - 1] === "" ? [...values3, ""] : values3;
  return input.join(
    (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
  ).trim();
}

// node_modules/style-to-object/index.mjs
var import_index2 = __toESM(require_style_to_object(), 1);
var style_to_object_default = import_index2.default;

// node_modules/react-markdown/lib/ast-to-react.js
var own6 = {}.hasOwnProperty;
var tableElements = /* @__PURE__ */ new Set(["table", "thead", "tbody", "tfoot", "tr"]);
function childrenToReact(context, node2) {
  const children = [];
  let childIndex = -1;
  let child;
  while (++childIndex < node2.children.length) {
    child = node2.children[childIndex];
    if (child.type === "element") {
      children.push(toReact(context, child, childIndex, node2));
    } else if (child.type === "text") {
      if (node2.type !== "element" || !tableElements.has(node2.tagName) || !whitespace(child)) {
        children.push(child.value);
      }
    } else if (child.type === "raw" && !context.options.skipHtml) {
      children.push(child.value);
    }
  }
  return children;
}
function toReact(context, node2, index3, parent) {
  const options = context.options;
  const transform = options.transformLinkUri === void 0 ? uriTransformer : options.transformLinkUri;
  const parentSchema = context.schema;
  const name2 = node2.tagName;
  const properties = {};
  let schema = parentSchema;
  let property;
  if (parentSchema.space === "html" && name2 === "svg") {
    schema = svg2;
    context.schema = schema;
  }
  if (node2.properties) {
    for (property in node2.properties) {
      if (own6.call(node2.properties, property)) {
        addProperty(properties, property, node2.properties[property], context);
      }
    }
  }
  if (name2 === "ol" || name2 === "ul") {
    context.listDepth++;
  }
  const children = childrenToReact(context, node2);
  if (name2 === "ol" || name2 === "ul") {
    context.listDepth--;
  }
  context.schema = parentSchema;
  const position4 = node2.position || {
    start: { line: null, column: null, offset: null },
    end: { line: null, column: null, offset: null }
  };
  const component = options.components && own6.call(options.components, name2) ? options.components[name2] : name2;
  const basic = typeof component === "string" || component === import_react5.default.Fragment;
  if (!import_react_is.default.isValidElementType(component)) {
    throw new TypeError(
      `Component for name \`${name2}\` not defined or is not renderable`
    );
  }
  properties.key = index3;
  if (name2 === "a" && options.linkTarget) {
    properties.target = typeof options.linkTarget === "function" ? options.linkTarget(
      String(properties.href || ""),
      node2.children,
      typeof properties.title === "string" ? properties.title : null
    ) : options.linkTarget;
  }
  if (name2 === "a" && transform) {
    properties.href = transform(
      String(properties.href || ""),
      node2.children,
      typeof properties.title === "string" ? properties.title : null
    );
  }
  if (!basic && name2 === "code" && parent.type === "element" && parent.tagName !== "pre") {
    properties.inline = true;
  }
  if (!basic && (name2 === "h1" || name2 === "h2" || name2 === "h3" || name2 === "h4" || name2 === "h5" || name2 === "h6")) {
    properties.level = Number.parseInt(name2.charAt(1), 10);
  }
  if (name2 === "img" && options.transformImageUri) {
    properties.src = options.transformImageUri(
      String(properties.src || ""),
      String(properties.alt || ""),
      typeof properties.title === "string" ? properties.title : null
    );
  }
  if (!basic && name2 === "li" && parent.type === "element") {
    const input = getInputElement(node2);
    properties.checked = input && input.properties ? Boolean(input.properties.checked) : null;
    properties.index = getElementsBeforeCount(parent, node2);
    properties.ordered = parent.tagName === "ol";
  }
  if (!basic && (name2 === "ol" || name2 === "ul")) {
    properties.ordered = name2 === "ol";
    properties.depth = context.listDepth;
  }
  if (name2 === "td" || name2 === "th") {
    if (properties.align) {
      if (!properties.style) properties.style = {};
      properties.style.textAlign = properties.align;
      delete properties.align;
    }
    if (!basic) {
      properties.isHeader = name2 === "th";
    }
  }
  if (!basic && name2 === "tr" && parent.type === "element") {
    properties.isHeader = Boolean(parent.tagName === "thead");
  }
  if (options.sourcePos) {
    properties["data-sourcepos"] = flattenPosition(position4);
  }
  if (!basic && options.rawSourcePos) {
    properties.sourcePosition = node2.position;
  }
  if (!basic && options.includeElementIndex) {
    properties.index = getElementsBeforeCount(parent, node2);
    properties.siblingCount = getElementsBeforeCount(parent);
  }
  if (!basic) {
    properties.node = node2;
  }
  return children.length > 0 ? import_react5.default.createElement(component, properties, children) : import_react5.default.createElement(component, properties);
}
function getInputElement(node2) {
  let index3 = -1;
  while (++index3 < node2.children.length) {
    const child = node2.children[index3];
    if (child.type === "element" && child.tagName === "input") {
      return child;
    }
  }
  return null;
}
function getElementsBeforeCount(parent, node2) {
  let index3 = -1;
  let count = 0;
  while (++index3 < parent.children.length) {
    if (parent.children[index3] === node2) break;
    if (parent.children[index3].type === "element") count++;
  }
  return count;
}
function addProperty(props, prop, value2, ctx) {
  const info = find2(ctx.schema, prop);
  let result = value2;
  if (result === null || result === void 0 || result !== result) {
    return;
  }
  if (Array.isArray(result)) {
    result = info.commaSeparated ? stringify4(result) : stringify3(result);
  }
  if (info.property === "style" && typeof result === "string") {
    result = parseStyle(result);
  }
  if (info.space && info.property) {
    props[own6.call(hastToReact, info.property) ? hastToReact[info.property] : info.property] = result;
  } else if (info.attribute) {
    props[info.attribute] = result;
  }
}
function parseStyle(value2) {
  const result = {};
  try {
    style_to_object_default(value2, iterator);
  } catch {
  }
  return result;
  function iterator(name2, v2) {
    const k = name2.slice(0, 4) === "-ms-" ? `ms-${name2.slice(4)}` : name2;
    result[k.replace(/-([a-z])/g, styleReplacer)] = v2;
  }
}
function styleReplacer(_, $1) {
  return $1.toUpperCase();
}
function flattenPosition(pos) {
  return [
    pos.start.line,
    ":",
    pos.start.column,
    "-",
    pos.end.line,
    ":",
    pos.end.column
  ].map(String).join("");
}

// node_modules/react-markdown/lib/react-markdown.js
var own7 = {}.hasOwnProperty;
var changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md";
var deprecated = {
  plugins: { to: "remarkPlugins", id: "change-plugins-to-remarkplugins" },
  renderers: { to: "components", id: "change-renderers-to-components" },
  astPlugins: { id: "remove-buggy-html-in-markdown-parser" },
  allowDangerousHtml: { id: "remove-buggy-html-in-markdown-parser" },
  escapeHtml: { id: "remove-buggy-html-in-markdown-parser" },
  source: { to: "children", id: "change-source-to-children" },
  allowNode: {
    to: "allowElement",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  allowedTypes: {
    to: "allowedElements",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  disallowedTypes: {
    to: "disallowedElements",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  includeNodeIndex: {
    to: "includeElementIndex",
    id: "change-includenodeindex-to-includeelementindex"
  }
};
function ReactMarkdown(options) {
  for (const key in deprecated) {
    if (own7.call(deprecated, key) && own7.call(options, key)) {
      const deprecation = deprecated[key];
      console.warn(
        `[react-markdown] Warning: please ${deprecation.to ? `use \`${deprecation.to}\` instead of` : "remove"} \`${key}\` (see <${changelog}#${deprecation.id}> for more info)`
      );
      delete deprecated[key];
    }
  }
  const processor = unified().use(remarkParse).use(options.remarkPlugins || []).use(lib_default, {
    ...options.remarkRehypeOptions,
    allowDangerousHtml: true
  }).use(options.rehypePlugins || []).use(rehypeFilter, options);
  const file = new VFile();
  if (typeof options.children === "string") {
    file.value = options.children;
  } else if (options.children !== void 0 && options.children !== null) {
    console.warn(
      `[react-markdown] Warning: please pass a string as \`children\` (not: \`${options.children}\`)`
    );
  }
  const hastNode = processor.runSync(processor.parse(file), file);
  if (hastNode.type !== "root") {
    throw new TypeError("Expected a `root` node");
  }
  let result = import_react6.default.createElement(
    import_react6.default.Fragment,
    {},
    childrenToReact({ options, schema: html3, listDepth: 0 }, hastNode)
  );
  if (options.className) {
    result = import_react6.default.createElement("div", { className: options.className }, result);
  }
  return result;
}
ReactMarkdown.propTypes = {
  // Core options:
  children: import_prop_types.default.string,
  // Layout options:
  className: import_prop_types.default.string,
  // Filter options:
  allowElement: import_prop_types.default.func,
  allowedElements: import_prop_types.default.arrayOf(import_prop_types.default.string),
  disallowedElements: import_prop_types.default.arrayOf(import_prop_types.default.string),
  unwrapDisallowed: import_prop_types.default.bool,
  // Plugin options:
  remarkPlugins: import_prop_types.default.arrayOf(
    import_prop_types.default.oneOfType([
      import_prop_types.default.object,
      import_prop_types.default.func,
      import_prop_types.default.arrayOf(
        import_prop_types.default.oneOfType([
          import_prop_types.default.bool,
          import_prop_types.default.string,
          import_prop_types.default.object,
          import_prop_types.default.func,
          import_prop_types.default.arrayOf(
            // prettier-ignore
            // type-coverage:ignore-next-line
            import_prop_types.default.any
          )
        ])
      )
    ])
  ),
  rehypePlugins: import_prop_types.default.arrayOf(
    import_prop_types.default.oneOfType([
      import_prop_types.default.object,
      import_prop_types.default.func,
      import_prop_types.default.arrayOf(
        import_prop_types.default.oneOfType([
          import_prop_types.default.bool,
          import_prop_types.default.string,
          import_prop_types.default.object,
          import_prop_types.default.func,
          import_prop_types.default.arrayOf(
            // prettier-ignore
            // type-coverage:ignore-next-line
            import_prop_types.default.any
          )
        ])
      )
    ])
  ),
  // Transform options:
  sourcePos: import_prop_types.default.bool,
  rawSourcePos: import_prop_types.default.bool,
  skipHtml: import_prop_types.default.bool,
  includeElementIndex: import_prop_types.default.bool,
  transformLinkUri: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.bool]),
  linkTarget: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.string]),
  transformImageUri: import_prop_types.default.func,
  components: import_prop_types.default.object
};

// node_modules/@copilotkit/react-core/dist/chunk-N4WEHORG.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
function ErrorToast({ errors }) {
  const errorsToRender = errors.map((error2, idx) => {
    var _a2, _b2, _c;
    const originalError = "extensions" in error2 ? (_a2 = error2.extensions) == null ? void 0 : _a2.originalError : {};
    const message2 = (_b2 = originalError == null ? void 0 : originalError.message) != null ? _b2 : error2.message;
    const code2 = "extensions" in error2 ? (_c = error2.extensions) == null ? void 0 : _c.code : null;
    return (0, import_jsx_runtime4.jsxs)(
      "div",
      {
        style: {
          marginTop: idx === 0 ? 0 : 10,
          marginBottom: 14
        },
        children: [
          (0, import_jsx_runtime4.jsx)(ExclamationMarkIcon, { style: { marginBottom: 4 } }),
          code2 && (0, import_jsx_runtime4.jsxs)(
            "div",
            {
              style: {
                fontWeight: "600",
                marginBottom: 4
              },
              children: [
                "Copilot Runtime Error:",
                " ",
                (0, import_jsx_runtime4.jsx)("span", { style: { fontFamily: "monospace", fontWeight: "normal" }, children: code2 })
              ]
            }
          ),
          (0, import_jsx_runtime4.jsx)(ReactMarkdown, { children: message2 })
        ]
      },
      idx
    );
  });
  return (0, import_jsx_runtime4.jsxs)(
    "div",
    {
      style: {
        fontSize: "13px",
        maxWidth: "600px"
      },
      children: [
        errorsToRender,
        (0, import_jsx_runtime4.jsx)("div", { style: { fontSize: "11px", opacity: 0.75 }, children: "NOTE: This error only displays during local development." })
      ]
    }
  );
}
function useErrorToast() {
  const { addToast } = useToast();
  return (0, import_react7.useCallback)(
    (error2) => {
      const errorId = error2.map((err) => {
        var _a2, _b2;
        const message2 = "extensions" in err ? ((_b2 = (_a2 = err.extensions) == null ? void 0 : _a2.originalError) == null ? void 0 : _b2.message) || err.message : err.message;
        const stack = err.stack || "";
        return btoa(message2 + stack).slice(0, 32);
      }).join("|");
      addToast({
        type: "error",
        id: errorId,
        // Toast libraries typically dedupe by id
        message: (0, import_jsx_runtime4.jsx)(ErrorToast, { errors: error2 })
      });
    },
    [addToast]
  );
}
function useAsyncCallback(callback, deps) {
  const addErrorToast = useErrorToast();
  return (0, import_react7.useCallback)((...args) => __async(this, null, function* () {
    try {
      return yield callback(...args);
    } catch (error2) {
      console.error("Error in async callback:", error2);
      addErrorToast([error2]);
      throw error2;
    }
  }), deps);
}

// node_modules/@copilotkit/react-core/dist/chunk-6ZLPNY7X.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
function UsageBanner({
  severity = Severity.CRITICAL,
  message: message2 = "",
  onClose,
  actions
}) {
  if (!message2 || !severity) {
    return null;
  }
  const themes = {
    [Severity.INFO]: {
      bg: "#f8fafc",
      border: "#e2e8f0",
      text: "#475569",
      accent: "#3b82f6"
    },
    [Severity.WARNING]: {
      bg: "#fffbeb",
      border: "#fbbf24",
      text: "#92400e",
      accent: "#f59e0b"
    },
    [Severity.CRITICAL]: {
      bg: "#fef2f2",
      border: "#fecaca",
      text: "#dc2626",
      accent: "#ef4444"
    }
  };
  const theme = themes[severity];
  return (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, { children: [
    (0, import_jsx_runtime5.jsx)("style", { children: `
          @keyframes slideUp {
            from { opacity: 0; transform: translateX(-50%) translateY(8px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
          }
          
          .usage-banner {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            width: min(600px, calc(100vw - 32px));
            z-index: 10000;
            animation: slideUp 0.2s cubic-bezier(0.16, 1, 0.3, 1);
          }
          
          .banner-content {
            background: linear-gradient(135deg, ${theme.bg} 0%, ${theme.bg}f5 100%);
            border: 1px solid ${theme.border};
            border-radius: 12px;
            padding: 18px 20px;
            box-shadow: 
              0 4px 24px rgba(0, 0, 0, 0.08),
              0 2px 8px rgba(0, 0, 0, 0.04),
              inset 0 1px 0 rgba(255, 255, 255, 0.7);
            display: flex;
            align-items: center;
            gap: 16px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            backdrop-filter: blur(12px);
            position: relative;
            overflow: hidden;
          }
          
          .banner-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, ${theme.accent}40, transparent);
          }
          
          .banner-message {
            color: ${theme.text};
            font-size: 14px;
            line-height: 1.5;
            font-weight: 500;
            flex: 1;
            letter-spacing: -0.01em;
          }
          
          .close-btn {
            background: rgba(0, 0, 0, 0.05);
            border: none;
            color: ${theme.text};
            cursor: pointer;
            padding: 0;
            border-radius: 6px;
            opacity: 0.6;
            transition: all 0.15s cubic-bezier(0.16, 1, 0.3, 1);
            font-size: 14px;
            line-height: 1;
            flex-shrink: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
          }
          
          .close-btn:hover {
            opacity: 1;
            background: rgba(0, 0, 0, 0.08);
            transform: scale(1.05);
          }
          
          .btn-primary {
            background: linear-gradient(135deg, ${theme.accent} 0%, ${theme.accent}e6 100%);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 18px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s cubic-bezier(0.16, 1, 0.3, 1);
            font-family: inherit;
            flex-shrink: 0;
            box-shadow: 
              0 2px 8px ${theme.accent}30,
              inset 0 1px 0 rgba(255, 255, 255, 0.2);
            letter-spacing: -0.01em;
          }
          
          .btn-primary:hover {
            transform: translateY(-1px) scale(1.02);
            box-shadow: 
              0 4px 12px ${theme.accent}40,
              inset 0 1px 0 rgba(255, 255, 255, 0.25);
          }
          
          .btn-primary:active {
            transform: translateY(0) scale(0.98);
            transition: all 0.08s cubic-bezier(0.16, 1, 0.3, 1);
          }
          
          @media (max-width: 640px) {
            .usage-banner {
              width: calc(100vw - 24px);
            }
            
            .banner-content {
              padding: 16px;
              gap: 12px;
            }
            
            .banner-message {
              font-size: 13px;
              line-height: 1.45;
            }
            
            .btn-primary {
              padding: 8px 14px;
              font-size: 12px;
            }
            
            .close-btn {
              width: 22px;
              height: 22px;
              font-size: 12px;
            }
          }
        ` }),
    (0, import_jsx_runtime5.jsx)("div", { className: "usage-banner", children: (0, import_jsx_runtime5.jsxs)("div", { className: "banner-content", children: [
      (0, import_jsx_runtime5.jsx)("div", { className: "banner-message", children: message2 }),
      (actions == null ? void 0 : actions.primary) && (0, import_jsx_runtime5.jsx)("button", { className: "btn-primary", onClick: actions.primary.onClick, children: actions.primary.label }),
      onClose && (0, import_jsx_runtime5.jsx)("button", { className: "close-btn", onClick: onClose, title: "Close", children: "" })
    ] }) })
  ] });
}
var getErrorActions = (error2) => {
  switch (error2.code) {
    case CopilotKitErrorCode.MISSING_PUBLIC_API_KEY_ERROR:
      return {
        primary: {
          label: "Show me how",
          onClick: () => window.open(
            "https://docs.copilotkit.ai/premium#how-do-i-get-access-to-premium-features",
            "_blank",
            "noopener,noreferrer"
          )
        }
      };
    case CopilotKitErrorCode.UPGRADE_REQUIRED_ERROR:
      return {
        primary: {
          label: "Upgrade",
          onClick: () => window.open("https://cloud.copilotkit.ai", "_blank", "noopener,noreferrer")
        }
      };
    default:
      return void 0;
  }
};

// node_modules/@copilotkit/react-core/dist/chunk-N4VN2B5S.mjs
var import_react8 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var statusChecker = new StatusChecker();
var CopilotErrorBoundary = class extends import_react8.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false
    };
  }
  static getDerivedStateFromError(error2) {
    return { hasError: true, error: error2 };
  }
  componentDidMount() {
    if (this.props.publicApiKey) {
      statusChecker.start(this.props.publicApiKey, (newStatus) => {
        this.setState((prevState) => {
          var _a2;
          if ((newStatus == null ? void 0 : newStatus.severity) !== ((_a2 = prevState.status) == null ? void 0 : _a2.severity)) {
            return { status: newStatus != null ? newStatus : void 0 };
          }
          return null;
        });
      });
    }
  }
  componentWillUnmount() {
    statusChecker.stop();
  }
  componentDidCatch(error2, errorInfo) {
    console.error("CopilotKit Error:", error2, errorInfo);
  }
  render() {
    var _a2, _b2, _c, _d;
    if (this.state.hasError) {
      if (this.state.error instanceof CopilotKitError) {
        return (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, { children: [
          this.props.children,
          this.props.showUsageBanner && (0, import_jsx_runtime6.jsx)(
            UsageBanner,
            {
              severity: (_b2 = (_a2 = this.state.status) == null ? void 0 : _a2.severity) != null ? _b2 : this.state.error.severity,
              message: (_d = (_c = this.state.status) == null ? void 0 : _c.message) != null ? _d : this.state.error.message,
              actions: getErrorActions(this.state.error)
            }
          )
        ] });
      }
      throw this.state.error;
    }
    return this.props.children;
  }
};

// node_modules/@copilotkit/react-core/dist/chunk-PIF5KJYI.mjs
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var ExclamationMarkTriangleIcon = () => (0, import_jsx_runtime7.jsx)(
  "svg",
  {
    width: "13.3967723px",
    height: "12px",
    viewBox: "0 0 13.3967723 12",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    children: (0, import_jsx_runtime7.jsx)("g", { id: "Page-1", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd", children: (0, import_jsx_runtime7.jsx)("g", { id: "exclamation-triangle", fill: "#CD2121", children: (0, import_jsx_runtime7.jsx)(
      "path",
      {
        d: "M5.39935802,0.75 C5.97670802,-0.25 7.42007802,-0.25 7.99742802,0.75 L13.193588,9.75 C13.770888,10.75 13.049288,12 11.894588,12 L1.50223802,12 C0.34753802,12 -0.37414898,10.75 0.20319802,9.75 L5.39935802,0.75 Z M6.69838802,2.5 C7.11260802,2.5 7.44838802,2.83579 7.44838802,3.25 L7.44838802,6.25 C7.44838802,6.66421 7.11260802,7 6.69838802,7 C6.28417802,7 5.94838802,6.66421 5.94838802,6.25 L5.94838802,3.25 C5.94838802,2.83579 6.28417802,2.5 6.69838802,2.5 Z M6.69838802,10.5 C7.25067802,10.5 7.69838802,10.0523 7.69838802,9.5 C7.69838802,8.9477 7.25067802,8.5 6.69838802,8.5 C6.14610802,8.5 5.69838802,8.9477 5.69838802,9.5 C5.69838802,10.0523 6.14610802,10.5 6.69838802,10.5 Z",
        id: "Shape"
      }
    ) }) })
  }
);
var CheckIcon = () => (0, import_jsx_runtime7.jsx)(
  "svg",
  {
    width: "14px",
    height: "14px",
    viewBox: "0 0 14 14",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    children: (0, import_jsx_runtime7.jsx)("g", { id: "Page-1", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd", children: (0, import_jsx_runtime7.jsx)("g", { id: "Group-2", transform: "translate(-118, 0)", fill: "#1BC030", fillRule: "nonzero", children: (0, import_jsx_runtime7.jsx)("g", { id: "Group", transform: "translate(118, 0)", children: (0, import_jsx_runtime7.jsx)(
      "path",
      {
        d: "M0,7 C0,3.13384615 3.13384615,0 7,0 C10.8661538,0 14,3.13384615 14,7 C14,10.8661538 10.8661538,14 7,14 C3.13384615,14 0,10.8661538 0,7 Z M9.59179487,5.69764103 C9.70905818,5.54139023 9.73249341,5.33388318 9.65303227,5.15541491 C9.57357113,4.97694665 9.40367989,4.85551619 9.20909814,4.83811118 C9.01451638,4.82070616 8.82577109,4.91005717 8.71589744,5.07158974 L6.39261538,8.32389744 L5.22666667,7.15794872 C5.01450582,6.96025518 4.68389046,6.9660885 4.47883563,7.17114332 C4.27378081,7.37619815 4.26794748,7.70681351 4.46564103,7.91897436 L6.08102564,9.53435897 C6.19289944,9.64614839 6.3482622,9.70310251 6.50588106,9.69010587 C6.66349993,9.67710922 6.80743532,9.59547613 6.89948718,9.46687179 L9.59179487,5.69764103 L9.59179487,5.69764103 Z",
        id: "Shape"
      }
    ) }) }) })
  }
);
var CopilotKitIcon = () => (0, import_jsx_runtime7.jsxs)(
  "svg",
  {
    width: "33px",
    height: "35px",
    viewBox: "0 0 33 35",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    children: [
      (0, import_jsx_runtime7.jsx)("title", { children: "bd5c9079-929b-4d55-bdc9-16d1c8181b71" }),
      (0, import_jsx_runtime7.jsx)("g", { id: "Page-1", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd", children: (0, import_jsx_runtime7.jsx)(
        "image",
        {
          x: "0",
          y: "0",
          width: "33",
          height: "35",
          xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAI0AAACXCAYAAAAoE9hYAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAjaADAAQAAAABAAAAlwAAAACI8Oz3AABAAElEQVR4Ae2dCYAlVXnvv6q79d7TMz37sIMgKKBCkLhkSKK4xJUMQVzAqJBgNDGJa2LsvJfERI0aiEbwRXnoQ2VYRASiQUFRUGQm7DAwzDBbT+/rvbfvXu/3P1V1+84CzEw3MNPD6a579nOqzvev73znO0t59rzZbQu88sXndp2w4gVLp5oG+6+47ivDu010kAb6B+lzP+Vjr1zZk0xV/ddMVIufap/34g+e+s9rX9351U1dT5npIIpMHkTPusePmto+tKhctVWPDW1/c27hIVNbCsFbCpa7/aR/f/SWFV2ZX974zsNG97iwOZjwedDshqiZlL3AD9JH9Y8PpTYMPJEuLj7+pclE5vBquXZ6MV/56Zu/ueGnmWpqzer3HzKym+xzPsib80+4lw/Y09Pjr7lm9GO+eR+eKI4tXdeRsomXv8a6Dj3eqn6iRoPl5qW83o60vyaT9O5IWPX2llrH+hsuXJbfy6oO2OTPg2Yn0p1/6ueWFK1wWTKReo1XDZoeqw7YxhcfYfNf9NtWSHTYVLVqxSAIqoFlU76NzEt6mzqSCQBkt3up1NrlHUdsXX22V92p2DnlfR40O5Az8N57+pfPgcv8YzLZdHjKS3i9uS1254Kitf3271qq81ATGkq1wPJCDVexEtS8oFZKpBLZeWl/w7yE98uUZ3cnLPhNefSFmx7s8Uo7VDEHPM+DpoGI71v5xaODkn02kUi9Ne03Jz3Ps2Jh3O4ubbCB006yzqNPsYrfYhbUrBwEBnZstBLYBFIzSDIXQB5LeOY3JXoXJv3/afP9H9dqdtv8XHb9mp5T5kQX9rwg3ACaaiF4ZcL3T0x6KQATaiNS6RZbmm+yib7tFiwfM7+1ySTYJACMuE6zktFP5X3PKgDIyoCnULFavrKs3/eW9af8N3qZRN9wU9N9R33hgZ8kveRvyuXs2g2fOGW8oeoDyvk8p4nI9Z7f/eLyZMn/AkR9azrR3ASvMHgJsXRD2X67q3nUci87yVoPOQluk4apBI7blNVVkSyLXRHrURZYiwlAdF8EhmFqaV5RL+XnM+nEffN8W2OJxG2e1R5MpPz++dUFxWMP+3lh9dln7/fy0POggZYaMT3xo67XpnzvX1PJzPFJP2PIusAFonNVK1P2QOEJ23z0Qms/+dVWycwHNDUHnBJJCoBl3PVQ5HDAIZD8rrvCcragUI0BRGCSpk95401pf327F/w64QcP1FLN92Rq3qZM81h2xchUaeVnVpZ6PE8w3K/M86CBHBe86tKlQa3wlwk/+cFUoqVZXVMAKAQYcRSDbn3ZrfZAe8EqLz/dMguPtrKHqEuUZBsxkzxgEbcpi7u4rPw4O/KL7MrAvwOPQCSOFHEg870KHKevxfc2pBOJe2F066pWe6g5mehrSVo2KLdM+C21wvoPHV225xhIBz1oVq26KjGvt/+Nnnl/m0o2n5pI0IeIsIDGWVBedr44bg9Vttn2E4+wjhecYuVMZ8hAAIp6InGbCTBQhJuEeCOQsJDjqDxd8mPrR7ZAFaeJw0URBGlL+oVEwgaafX+T79umivkbkKWeyPjJrS1+ZSRhifFMMjNR7U5MPLHp8JL1PHsc6aAXhDu2TnQGvvdKRkwvSAIYDw5SC2ADIp4jJDaOTLLJFpeabWRgwCrLRiyZ7rAy7ECDJQ8wpEjVjLuMQFxVRknLngrA9uVXObgVF0S2hGgVoHAllRGwwq6sqeoFh2a5LGGvskStAAcc8xLFrRXP206Ovlott63Sm3y8LbOud8nFj/UlvMmxtnRtbM0FLys8k9xId3zQGsdl+gdP84PEF1KJ9OmpRMa1RbUmqom44jL6Q36hK8kWRuy+1KBNnPhCaznyZVZJNiPritMg9wCKEnaWrHnyqedxQBHbESAcR1GxKjcs3rlxOqOw3RnlazQRxgBFYAl/Cq40giy2vdn3NgaJxBMJv/ZgS8bvbc/4A8lydaw14eeqqdzEmgtPKTcWMxP3Qc1p2scmFyc8/3UJL/FiAcZHlpGAK/2MBOHQhFSSnNOUarPu8pils0PGINxGLAND8WEEGLhJAnw0wT2qcJIC+R1DcdxF8VySdxxnaSw7dquQnYyqhnOFJrZJrywBBVdqLVaxFtCwAg53qiWq5UzCHylXaqMTU9brIw+1+tbfWWldd9IXHxpIJoLBZCY9kilXpyrJYi7d3zGx8jOH77WwHd9JdGMHj9Wz8tZkf/Dwa7wg8Zl0svk0N2KCEkwQOOA4ARhWEY+iZNdqZZsIhm3By5qtdNwLbU1hqY0DH1FQHMdxGzhDEaJOYGsILkZDIeFVd8dhje0dgaExqE6dyOGsRrfKacig7lBIFUABm+f7tWY/KACkQbA65vneIIL2cMazyXTCG0glElsyCZvgxZmyWmXKTyfGWpPJscHc1NT/jCUqlsoFJw4+UFm06RfFyuCjudtuu62i2g5aTjNU3rDISyTfgODruEw8YqqpxSGyGEIAAdQLiBDqpESNxQvm2wsOa7LtqSnLTObQu2QizqRoyTbkASxViJYjyPUJyurYjsrCTbyTYyL6h4THE/uJDRM2BDQ4w3RR+jjccbAozOV3Jfj5mteSD4LDCDrM5/6yPBDjvmoq4RUSXpBtTnilZq9aSfpW8CvVXD5ZG68EyUnzikzB1aqPZw4tVg77/bHjW4/+1etftfC2m29fPXRQgub8ld9sCqrVF9ItrUz56Rbf1/BZbCCkm7onEVI9QBgSERnCd3Q3WWtXxiaGxq00mbJUV4cFKPscJkiNvsXlaRYwAE4Wn4bkrkCVqyL147hPFC5rFyN2gXHCtHNEeRUWXWFhkd8VvEucerc06WSrRCwYjie6t3EPbRXJYAQmEdwD6irAHlO1YiWVG6mWhweCyuQAPGi8XCoUTignukdXrVp160EJmiYrLPH8zNmJZPK4FJzCGahO22F8GjjSz7gQhYdAgN1b17K0+anA+h7rs4lK3lo6llg1AWigiBchR9xJwHP5CM/icsARoJQmtgUc1SHryYyAFpvYraDYrbg4SRTmgxCN5gSSBD9pbBFawEmQWMl0aWSvzA5QvDR+ecqq+WFvcnBLakHvllStr8/aJkdtHiUUUi3ztle212657YbaQQeaj5x+VXMtUTwTAeVt6WQm6QMEJ/TSgHXahQigOSXjqF0VWbNMm29ti5JWypattGmK6YSCVQ8ftWSGlxYSSa5RcobwTjhOwWFaCUFWNsbAWlIR9kwCjgqOQCbSuYzOsfMPafl3ZmdbgS5MhAcouB04qE+gkdsBBDsGjGzlEagVnwjQAE1NWHmyz/L9W6za32udA+O2rNJirbVWeqiKsUykmEk0PZzIDj9AluCgAg0k9S5MfGthc83elkgmFkiRp0YV8eqACduUcHQwDgR6X3kLSdDayQiqw2x8O0SZzFirN27V0QFLdyxkGqnFEU7UV9oK2fRWCxut/IifFQCjgCNBuRYDh3BXue7jyYy7RyJ1K85oZkyzEPzwAOIYGsFpZkJ2IgKEezb8SivgiveF4CEsQNqaGrXSWJ8Vejdapr/fusbytqDSZIsSS6y9eR65zIa4ysZUv+fdc+zjfzF8n93hwOYiD4afj772Wy1NleC1NN1vo5eByYRDbPfC0+CiQf0XArtuRqo6JSBt+5KkJaBUdoChdaXZumrj1j/Ub7VFK8xvb7EahEnx45R7gEOE8slbBiQiXELgwV/ALwFZQ/NQz6N6n9owke7AoFSurDpAFB7etcLFcZwKAHcIFKUHLspPvYlakS5ozAqjvTbVu8FSA0O2aKJoi3ie7tQKa2lpRRkdCfe8LAlUEZVqYYzmeHC1hZOpBxWnqdUC1v4m/iKdTranWQgMDc2XAKg/GtsNanCLdYsAjjwkqjAMT6GA6VrhWxk2Md5XsXSiybqCVts+OGrFsUFrbetmxMTst/JTpt5yn7wChwRRAUplJumy1HUILJKPBRyNY52sjL07Q1Euj8qUkeW6HrnxxBwkjhdwZEIbENEFJUpTFoD27HCvFbc+YW2A5Yhszbr9DutuWmpNTa0Ai1K5r/Av5JJowkvmTW2s+JP3u0L5OWhA86HX35SplUY+7Cf8E1LpFIwDQroRDqSkoTRKEetmHR7ekIQSbBOMrKpQta2bkROcZnx7xfKjUsamrCPRZl3jfTY50GteN9r+FuCgMhxAICXFqEy3OoLy1V3pPwSMwBpWLZ2f3LEhiZI5IAloMgJjnF+RcbjSiZO4fxcuCKlAngfB1grIK/Snk8PbrYhgO28sZ0dMJW2hv9A62+ZZiukRdcVhlmnoqowqYGPWf6TcvPBXP/j5lwfdjfBzUIAGQdf7+GuvfmXF89+cTCctlQofO34z1RhqavACBWhw5yAMQjtdDeDpWIzg2BzY5GDNWClhgA+1Hl1UIWW5wSEWXTEf1dxOphQEFolpXBAjW7/wHziZuAs1qR6MMEvRrttQikbj8hMQhyJ94Qu7HuVxBlvgCWP0q1rgKuWSBVMjlh/aYtnBXkv3D1k7XdBR1Ywt9hdYZ0snwm0IFpW/Q91hMa5eacdZlDYy0dZ5N8nqiDooQPPRM7+1MKglP5FOp+enm3lkNQwm5Cw0GlTQCMq9o7ghr2siyTxV1LySYzqXI//AcRhkGC+g+WjDUgBkHtxmYGzMSsN9TiD2mf2uggpxMRFXLc3cUESEEDghgNwtuHjpRwQmmYhmYeRufqNbdzHqfuSXwG7VogXFrFUmBy0/0mvV7b0WjIzb8nxgy4M2m5/qthZGeX4Cbqjn1Z/yycSFOpsf/qUZ94JqrZhKPjbc5K8JE4a/cx40LLBKTt6ReT3d9avTzSjjkChdt+QaLXzrpcF1wq7ai3Z0RFX7QHGPvqa5kxEQ3dPUeGBTYyRwxJKdtLYkXVRx0gYGB6y6iHmpjLiNhOgQMFiOQAKPAykEk1v0chexZHBhOJwJ+RRORdUpKmcoa4U5NEpDM1cRV5m04ni/FYe2W7m/zzLjWQeWRV6HdaQ6rJmJVZ/u1IFBRYYFO1fdqxuN6nIvj+7aD4rFVGLNkYmugUbUzHnQTNx53Akpz7sg1YQkk0YqgJ+H8oC4iwhH40RgUc+kPsNNJahrQigRdxGXSbUENrYJGqHiTdA1KU4FpJEJukttNtzP8HUZ3GbeYt7mZleJ4wAqEmKE77YIE5JGdTaCwgHJxUYpuBclCQEUcir5fdWLkFWVrJIdtfJIv1WHByw5NGYLciVbWEpZZ6Lb2ptaLEUXZCz1kOFp+FUJDWYH7w4emqEWMO0wNpH07/7x6h2XoM5p0Hx81VWdXs7eiT7m5AzL3xKMTQUUdqY4sKgdJew64KhNFYkRR1D70mx0TTXrXEY4tMoOkLaSABSKUxrgBQtrS7VaW27MxuA2vOLmt2gSUybkIGrkGBTKJtDKFnBc3bjjYTJOZxSve3BCrgthIF8uWA2uUpoYtiKCbW1o2NKjE7aARcrd1SYE825ra251Qrp7OygkBIsrIPpxJVO2HnJXE4bqt0Yvm+hdUq49uHOqOQuaq1iR9z9Tidf4SW9VpjnZlExBFtqrsa0cRlzDRsDRyAl2o7UzbrgK98+g0GtfUbXCJFsrhxBEWU7nqE5aAUHD8wyg6co328TgsFXGUfY1tQMmlPdwK3Evx8lAgMgVcphpUmqorwgXF1HHhRHicx+1aokeKM88F0AZHbTKQJ+lhsdtXrZkXeWkdVm7tdL9ZFLN4IR7E71VXvQCREWG4c5DAqXZyYTSEVHcj56fOyz5yeTdR1ZO7N0p6dwdPd1v6eOTyeCdybS/nG4pVlk0PD/N5Bo3bmc1Jk1FmJvxFjtgLNzazfRBR2AjjyWskhfnEcHV6iAqIk6CuaeuRLsNTgzaFAJxav5S85sBjeJdsQIMHkz4GwHIhfBDmjicjXe85GyBqbIeOTdu+fEhFHGMdgcHLc1weUGuZvMrSevwu6wZoGgdkBsyx2WHBYUPFZe/O5REcTFYKMSlEmicWI4OkvHi2p7bzqCD3tHMSU7zyVU3LfRrpYsYXr8i1ZxMSSejFzo2cbtGlKq/lSEXQNjkha0BGI9epm0p4ABA+UHkoarPPBPkr6LJVSNja1gqrW97upPh96Rt6N1urUsPtWQLs98RIWJIqD7VLWCGwItvCqmH1YLqfkqUMQVQ8qNDVgQoLcMT1pkvA5S0dRrzQckWOBkLxugW4+dw9/0UwIifuw6QOK0A3eBWV+gGAXqmlD+YSgR3xnkb7TkHGinxMlZ6jZ/wzkg2JeZruFxv3YhGcUM5rwjoiCgOE3KEkAPR7bTUrKUbjfAUr90EsgxlaSMAEqJLGwKHRVt0VSzkctrVvmFGMSN91rxghdWSmnESaaOKHUmoI7olx1UQamsMlYu5UZtATikPDVkwzJrAyZItoN6FNea42EPeJK7CCEgz7SoxBF0jKZ/MHT+t4nX/8b04r0JcRtn6cxyRBqCre7jW5W90kTv9zDnQdDRPnYbk8X64zFHwGMY5NEpMpPjhd9dwIKdODLnpJZrnMzrqrDBNwGLzfMK0ikIAc1wI8IiANbiYdDnS6XQ2zbdulHyD2/ssWDFuibZFACQUe52conopIKE1yBW4CkCZHB+0yf5tDJWHLDmaQzYKrLuGUJuErySZB0Kv4lR60TPoHp/ckAgT/k67ph8XWEx7SEdK9x/mYFEIL0CVZ2HGPOn/8pLVF+W+ah90ZTb+zCnQfHbV9UcXzT6EHPNbmUwyqW5F635l1NhqGicghm2l4GkD0WUECqXxEElaFtGAaWalWasmfY1AI3rXmPnTdINPFyYAJdRdVRPWyjzOolKXjaBUq2aHAQ2b6ihIJaMoM5/5nwpD5SxAGUf2ybLV1x+atA7mgA5FWzs/iZySbrWMFrgzVHb3q3vSje3WhMQOf5Ug8tcDYn9kuzJwu/84LLRBE8HcqcceC98rsWbkbkJ2W/WcAU3Pqv+aX/HLLHnwXpnJpFrontxb5cAStlPYqFEzNLxwLrzuJ17LFvxMzdJdyBkVFPPZFAKwdDyARfKOZFUpBLnEZRicAhwAxNqE7nK3LSzkrDAG56CLYt0tKycnbAoheWRgK9MQfVYcGKb7KdqSYsq6mfSchwKuKd0cDpUhXdhNToMlJq+j+c4/jc8Wxe3ITfR4KkGgCI1zRQ88XXYoz/BUzJr7m8e9zC5D7Sj73Bg9reSMvIRfXIle4Wy4zCJkDxn3jG7YNN1a0dskZMRtGUeqWTFiC4wX0m10TS1VlGhMWE6FmmTpZcIph2nQ+Exfo22PgIQiEC3swrFWe2yg35q6nrBaqslGezfZ8JYt5g1OWDtrKw9HTulKzLOOTAeykHZBTAu17qYh3PRdhSHR3cWeuh0/ZxwQ5uOX528sI+QiYarpmCi1aytAA4dVe/mp5G8OO+29w3bzH8fF7mDPCU7zu0tfeiyPegES/ylpZrClxHPtoEfVyEncBVvvbtjIalS8siLbuaNmFm6aOljRlq5ZaYQhFENcFL8ug+ve6pyGSUkaWmGsObZiscDWXOSUYNIe2bjdmkf7bSkASQ+X7egiM8upZdbGNEMKIMG2VCB3FLI+9xs6XWhjnNy6zfjXOeMfFxHDIEwVpozcWHFsY34XVo+j9WiIqqYlCNPJFj09vCFPYg5o0EAs7+/P++EhiVrij9C5vTrdFHMEnlYNQkOEoMCDCZU1zqmWCbkN3kjTLhcA4BewpLoqbmhdmUwbq/yYoIzIq26JRG7GmpFPqVK0bClrfbkR24hi7/HJEdvC0LmA/DI6mbeXJA61o1qOZQjO/A9iuTTJ8KUQaJSjTqHeEYW3Gd1gBCjdkDN6ILmVKEy4U/IwWZy2MY1LGIJU0a5diFfbhIDSL92wx4vi+1kv5d3ZUNguzgMaNB9/3w9Y5pJaGST8d6QyfjOXk/xdo6pBXKO4VgoZjUNQ2AZyat2LjAvG7/Ih4CZbWBfbzFAa7lArhKv1xBgEFu2+rARFy5VzNsTa2s0IvJsZBT2SnbTxEkBDj2IdC0AGfdwkW3gZJje3tMNYWKCFMKRhti5BsOZeZoFQdTeAJ8KJu0d3X7z0Lkye+FKeaRPf/nRI+HDT4QKJ66SiJCFQXH+sRFGdcOm+TN5/bLqcXV0HLGgu/tBNmeKU9zLGtB9JphNHp5vYEk+35AyNowZXs8Rt7GIIDBVh9eCoRaJ0+JQu2Va2RKbK4iW6EVT1ASegTbGgSRxlOwDZlh+3zZNjtrlQsCGwEWiolV4MWFhAnG6jAPwsVTC40PrCmB3v51HKcRiSph64PMlB/GllnxZ8aWmE6+Lc3TSAJ7ofETa877jH0F26J3I59FP3OUcEiCgwhE88ixUGht10mFOpxf30C6zue8n85rF6wbtxHLCgKU3VXuR56Q8m0t5JDjCsb3ENETWUQCPkqLHVaDFYGruoKIkShk0DvTy6IYGGiR+WU1dtmC24A+heNjD305ebsI1TU9bPot+a1MWsUWEPCxNUrQCFYbJUya4sFUStTfOsd2oTuzCz6F26HFjcUlDN7ZBEo68AdueAoy7L3YXyqvsLbyn+1R0Cs8i7Y2T8crjniTO4+3AxhAgwKjd6TnyhM/S7dkOY19kHTO7ed/ZOs9r1IiPHAQeanp7A7+q9ZQXnI14Ijd7MZCQbJQUYPRE/ssO2ICxunCiI8Ph9U5qQBEqs0U/FCkXOVGwuWmsr229zZfvJo5vtsW2j1lsqWS8cIvAARmYpi2vgJk1cblJSQBERucJ+JvRKUGrttqnJfttQHrblzYvAFF0XlYrTCBQ6ItRxGHEeaRNViitDb7zIHIbpDlVDaKZdcYieTn+hCW3llmJRvjAOl4uK4ndwh7XRzedGkxmt0ntKc8CBZsWWO+dNpr03JYLE21jsnQ71J9EzCiRyhu3iGsuBKfK7AZRC1S0w4ajRQplZ5ByzyGPoVrZnWZOyNGWLU122abBkN20bJxziq+vR3pUMRNcwyikCVSgEjFmCaOmCcET1GbPf4jYbSuP24sq4daOLEctz3I9kjFXIzv1oKtwBCcEYZ4AyKFxqGnOWqEjFkSesRw75wsrCl0ZhoZH0Mh3WmGZHt9K4MsXp/MTWfMp/PC7jyewDDjS5xOSbmDb862ST351i9zp7TONWCpuPVlCIGkO21Pfh8gQUdQixZTbxCySTpZwNMjk4MJVDkM3acKFko6R9w6GL3RLhe9nXlG89BjkF7iJVsBsiuxIpNJYtVFFYffgrj+KwxTF0QFL7IhsYGrX1pSFbkOkGb+zGFJX40b1LUeiKw+0EZMk9SiDZx8k6YcmkqkNEzxYSWnHh8+56H8TU7w1H+O8CXXAUJ25cQ12gEqeSTfd01vyRuMYnsw8o0Fz8J//9EkSAD6L1PTwJYKT1Vcvo+XdsiNAv9l5jWFyAm0wy2hlGhT9UyNoWB5KijZbLNoY2dwL5pOrNt/kL2m3pohZGRr5tmGqzcgtcxrU8JIqBImqFQ6mwTesVK0IX3EFEj8PhUOVUuz3CSVovas0h22ibS8htxFUc5pVFWFM3pXySdRzLoRjSqDj+wyKxZXYAxA5+F6uf6TRqI3c/LjhyRwGyqEA8jlMAHso35wthqif/PWBA80/v+NFxtYT32VTaf5l2FGhRlZ43bgyam7amy0E2qcJNsuhJJhjtDOQnbBvcZAMC7ASySQ6QTPocFcL6F/bZwkXocphBlnxy9ArPjpxfYBjt21iOUVM0H+W4h2QUBwaRL6KiKKwwGVFX4Y4IYh9RuA4+QrYZGN9k/aUR6+AELWaxiBah4u4oeo4IPO7tV/6o63Npo+JVQSj3uEpdfaoydjh3GEDbyBFxPpcmqieGn6J1gdhqKpktesHa3m1sZXgac0CA5h/OvfEw9JV/zl6j32FeiQVl6uvpbnhYrZovViocPz/lup3hKXU1OXuikLeREgIt5/pOIiOM1Uc7AokuuhwWT7kRj4hPH3ZIZ5GF2IH9bJKTEYuqg0uNGpv4tRc46pdr9dDr0hHnujKliQxbXEu5AbqoUTuktthamLmuiaCOrQAckklnFHajeKhHKhzFqBQtSXVdVgREt0Q1Kjp+aUKvOIraRHZ4425BWT1tFIY/XB0oh6Cr5abB9kTN37hy5fml2257b5Rj99Z+D5o3vvJPu1K11F966co7UulKE4p9G+folJw4STmPXJJ3INmIzmQE5RrnPpMiZXmUbJXUPAs00nEgkQDLiny0sg4Mje1Bq3UwQXlMpw40MntwnE1xVZpGSV2T4lDLytS163qDCXQUV2T0RjvCKtxFOKIwiWWV1gX2RLbPBovDdlgruxnDrW8h8URkygrntbCpTp/ucLsmKEpdl0pzjCeqRn7Vr+pCfIQhSqllGs5EQfIJn6olNnIpn2Qq1T2VTj7itdvAU00fxHn3a9CcfPjJ8w5rPuI9A1PbzimVi51BqmLDgKWvVGQYTBeEvqRAd1Ni3rWQaEV2oJthYTXqXIACSMRJJIy6N1+PPN1oYQOI2BhabymTk4e0VW2kmLCRPJzAvfrE1UEgtxJjZKvFGzmPinZpccR5lFbhcJagucsmc4O2qThih7QsYZ0Me79FcKWRgap65wUcBxbKdvIOaULlHyRXGsJd8VGeEDCuhPAnCog5TXxLcT3T6eFjBEqp5yAW+BvaptBG7oHZn0GTOGbx7523oTJ50SNDmxeNoJWtZjmGlX2NFRq8mumymgCiYa00sLFyzSnYePKYsE/ZCLSaXkHElRUdNZvHnNNdgxnLsWvSUUygcK3N6+jKU7kKkKfhcuBRuNiAwiNTdxKHLDOZbreHy5N2QpBlp2MLRUsSI1GUTgTWJWKKu6gLcfJLvegwratO96FwMii741VRUFy9bJWlKzQhUGKfbI3Yiik/V0wk7vO7DjvgQRM8Vhyd2pAoNnPyMmtVkENajmDR7pIQINopKOG0PhRWC3CpBWVcQ/Hj7DBoJ08YSIsmAMvCDg3JPbs/m7YJdU0OMFFhIVWi9Hhi6rrKFBldoo6jdpTGgUhh+HW/TV02PjEBlxyzhYDel7JQWXWP2OIOys5tOLc4jm5Doy11i47TCJeEx9xHwFIaGRUTG92KjIbtO5s4Lrxt1s/43lDKr25ZvOxlGns/raHV91sT9DWNPlhMdD8YdK5YwGTQChRlSZt3GNwFOUUngAkw7lKjisnGfmz16/V4+SOANYZFeY5tr9qZy3KOidzey0kQU3Autay7yOvKjfzOTZBr+TgM2xFWdqOJ4wlzZbE2h/XATdW8HdbcZk16EQjXX2yUTFMdApDcLhbbgSNGWD1eonJYtEup9Fw6W8/lVWSDCcNcDle+HliLyDgf8K5Uqnb1Z7/6ooGG5E/qVIvsv+aJJwp2z5U3WWv72VYr/aFN9F5rE5vZADQeDgudYAt4BAhdEnLdpbAoXPuU3F6lKI1LG8ULeKRf1lG2pc0Vewwu01/k7XdlNeSTXOTKiMpU2eJyse3c+OuAVJyjXkhFF44fjXCldT5LJ0q2tcicIN8SY4M91dFRcR/axOcuKfp4FCn/HDPVreCWgKt1yRHWqUNu0jgQCSjIQQ2AiYETxodgiYkt2anKNIaHYm+iKf34xg6USHtoePoDwPzg42xVsxvttA/dbi3jf8TTnmNNhZej2m9C6FVr08I7PcfO/sZotaYM/UAqWbVFbRVjVYXdk83YQFndHvEuDay9Xg4JXNdDPtkuImb98suQxhnCFeW6hihOfoGRaYWxXL89BmiOZolFSzKFXimqRFZcpHPjaYwTkFS+5Bl1UXLXbzDkOtN+F/mUPzryhB0V1c6p0hMZK+7xt6jip3zKwvebyF9fMsHXLL5hlfIfs1blf9lE/10cATbmliGIyLx54YU7JnyjHcc7QIRpFnN8yIs7SnwpzrdRQBOglQ25xO7KEDgVj63LsQPZevdiP/EhmyBMZUTl4XRpGP5PcbJELyqCYQ6yhvoht3EcI8zisvHjOISK436J3sEOuYfCwjziQKEH/9MZ8jjIaX2PZ+PoqB8+Jts28XTZ4nhqOsCMpu2vff8mVkJdworvj7Gr7DrO1ljP6YlFt/BJj6OWjC+1dnzFYbENK+9qqtjidMUGWHA1ykLvaSI35AspRhxlO7cIpCsGiuqLw2TLH4WFmaJ45acONtaNwC02s9amxKfspm8vBIfL4ooIgeM2+5HIyTqyuaa7pbCq8LGVSa6nNi6JmFgo0CPHeP0fOu31OrRrj8yB0T3t7lFuuFDs9HZ72xXrrDbyarjNWZZpp8tqXWGJJuYZIOhTGYiaYSvKoe1Fa+Z8+keRZ0bY3B8TLMy6EwXkdX2CfvAIGOFQh3C6IQWLEAp3XVXUjbnkhClOHIG93mOFNnucKY5jWsdtSTPDb0DEEh5XhDQ2MfG1/kbZXVdHVqVxpTpQhundL4nCdLoHZdiN0W05o6E8paj7TPqPe4nasNdT11rGiZ7U5jYOcHPdewbYCX+9lXP/m67qK5YbvQtBOWvxFErUuCGHoNWcX7bZgnTVjmsr8rabbc6nmZeKQbNjujqQ6nkb4sUmduAyalKuOK0DD2likMmW8pEuarBcse1wG2m5pzlHyFGUX7ka6w79UbeFR12USxdaSo2RJ3TFv64khbkLwGA7bDOOZzFrX7LWzNlee24OXE7T+IyXXSjW+pCt+spmjs68k/Nb/oCjFl7P9MGxcB6EZR7TNVj0CqrVMN18iuKIlhKqfUZNU2iQlUgTQGG0SzP9+sob5Rex5FTL1xNH71+sF3FR/LiylJ5L4BKf0KirqZNlGQP2KCdtHtWet84UxzlG0Uorp4rQr6rTj5TUTo2sYuMicbt5JOpVsulbElTCEggOMzhH+BMqDb0C2qmNNJ4GGnts5gZo4sdd/UGdKv9LO+c7G5nFXAt4Xm+18mtZjrnUMm7VeZzSncG7HMDMY2ri/mybbSsJWDS7QNNoYko4WxF1R+RuTAxVY9CIYKKy4/rKwxVTVMRn+F1iycR2phVG2EzXgbZY54y7w5IEAN2Gsqh4fhxIFOSKCiPcyeridOqvSORwKScZXT4VgAndzunKVPpoADjhJf2tRy1c/rTLIaLcztLtzz3z3Xf02pX+tRwT/WmE5L/laMubLTtWMdbPhC3rs64lsONai/RagW3MZfhUMqBRa4RUkWP6Upi7CHKcKPIrvbvwi3juoouLR1aKjLuuMGHkV1oEYuaj+jj/+/H8KKO3qWjwFwm6qoI/bSt23ZArSnGxXodY6nMDQul3qNN1cbofjG5XYNkBMApXGMN1nXaBSx8b692+h5pgMjgTVRF755LNKOuK89hZn7jailN/Z1PZ/wA4W20K+ZmhZlu6bIc2lyyL8DskDbATaKMmVsvGV2OTxMARG6iDJ04bZVAaZa6DRW4uNyRWYQ3x7FyYYpP/FhaGjZcmSCblHAAgfQgAgSbyk2+XYXYU56pTNXHZqgajandnNGpS90R521nQNrInM9uN5cyt7qnxyWL36rPVZa21VVdtgXK3o+N5F4fAvJYlLk2Lm8q2Ltdk2zTUfjITN3z9lRV1Yo9sJYj8sVPUcl1TFB/JUNRPWr3hURlab4yybwsfrdjMjoclLQsZ9Omo1iiZFp4rNT9RSY5RKr9L4yJCqGguqp4ovg/y7mzUQ4aLuJysNMRXY/ZKnlF5c5jT7NRcq88eZLvBj+HNn17k5y4+pXliq9ZybaBrGmZvk6P9Tll28IoQupyJHC4sJicRomRIzYizaDSmJtYVxUVZnT8afo8ycbkpN2l5lqRKGgmLmU4fc5i46sZqdiiWCPfn7sGl3uHH5aN8dU+UrqmYTfw+5R6nHQqIPHOf0zQ+9eqzx/He9+FLrk4vnld55UghsWLDEDsmp1i5ldEkJbFOWG3MtJPbpVFY5JDlOE89AozgdlhSGICRFbOBcAikAMKJYNKyyne+Hy1ut5ciFLdxKIDP+cTq/qS7ccfVqgg3naBuRfnCvA4b1K0wBwhsRTujNHVPFOaCiHAZbIqtP5tZhCROvFdGr8BBZW699dbkicuD5Qua/SNZzfLoyNjUFTaORplloiFd96BJRBBnIoes+GrM7igpikeRzo/b+VUAbk2E0lcO11K2MTvCJ5rzIQBII+yFspGyhFwEsVgZozRyRHHOdjH1sDid7EYTYWmCRSHDS5f27rEmOC6j8RHjsDltDw4ONhWrdhocet6ituBHr1pa+TBHZ15oYyM/sMmxKacUdEIszeCIFtk7t0pIuzDSuUWKiHKidiMw5HbdVBTu/LhdekiAhriGsu8xdnAOFkZDTqDYenI5VATAIVA53Y/cLlGYuJ4+TBGmicpRFhmnuIbTkK8frXDfhaGOK4zcw9+DDjTJZLIFQfCl1VrAunPv3ss+QZf1nbN/yjkhF1l29F9sfPQBy+c0Jo0IE7Wko9ROrVoPw6GWjLsphety42EcAowDErYDZJwgspnptpYuW4dq+hG2/1Y1H6X0AokECGyXXUW5K8zn3IpTOjzucvehREqrdNNGvVK4GJ8uzTM+zZzc40nK6VK4nUbPXHcDFr9SqRxCY57INcqZwI/Un3n12dvMy32BA4P/lhMT77RsljNZ1cqkCGlUT7qDo5EujekcRZWSQEc82XFzR2FxuGbItYOTI/M3cgxsluG35A5g4KoWYEKwyY7A0VB0XIyzwxoVS9roit3YAg4R2p0zwe3s8XII5YpN/BSxf07bq1evZoWVnc6RH13Yj4+Pjz+6wwN/6z05u3LV9cyef9ByY1+3iTGmJdjf4DSupBQRdmdcOD+OSBHK6mEK1xU1teM0uJ3fJaJEbA2/mxfaRnZUbM4NsRO0GHEK5eXfXZGbAMdV6vcSgksJXS0uGT8yO1rhO8CXEYnYNqIvxu2DOahAMzU11QJ3ORWt6gSNvratrW33W1CvfOc9lpv8rGVHLreJiXWWyzPEAjkiQESEXdrahfPTmCZ2i+Kuf1Fz61K6hkuFqR9qmccnkJvtMQ5GyvNR1R2AEqFBYXH20BH7VR7/9UtACsGl4p2h+9Q+dtJwFr/Xf2Lrwuc5Tdw2T2a3trYur1arL4fTIAQGvz77bLTGT2auffd2W7Lin21i8uOA57+wxzmkBv4uqu3GOLav8JB4O9gKE1gcl4ncrhy54wunzrZp6rYHJyetH27jdDaRvKLsEpEch4ltqB8CIyxeRYVriaNisZyJqpDlFHueN0YRA5sO1+mCe28OKj0NDXYyTXQonOZXuPuuvPLKbgRjtaU1NzcH5XI5gBvVWlr45Ioz/cxztt3+wVsmtk6M1y7kkIC3sqN/CTqdaDxMohhErhT5yRoDSG6o48LUxTnhxAWE+ZTX6V+IUyYNv9sWcA5Orz3Ad5uO7FzBclQ21gEOR+woq1LLiKs4GQVbbgnETn5XuP6iBPV00a1R2hBp+3p6znjylyasYre/BxtoTqUV0nCaZRDifACThRgiBaKLPkfKTplksgp42DXrhkIsBqwEX35ForRxohL8vD87nq+WFgfpJg4ShcAYtyvSucIfNw/owvUTEQ/AiLgiqOa9HAAcuCK3COyoTwLOEw7mL7ZMMcdWmnFbwL5zN9QW31H34hBAObo9QCevCncAoRwXzU/UDbk0qlZcK7SFUziNn2Bs74Kw9s4cNKC57rrrjmLk9HKBhIY/kmb6Yy69/2p2EU1tKqIoLPa6M2SgT3BYm1VWtQToeAq0dNF9uVYbH5TJXS67SBOZyFGPd4Wq4DiBbIFl2h87vWCR9fNNhIn1HExdnc/x9uF8lG7Ryc+AxTE4gUilCDwqS57GyxVNgACmFLJAHmVwOnZtn4bbKvKgAM1VV121BFnmUzzvcVz3crmDlQGIDF4xgBprs9ERiwI7GScDk1Bf/2ni+wicG+xtz9UWb8n7JxQttQDu5EAUZgzf6HoREMrRytmhR35RUIQOY2O/IuilWDbRn89b7zgfVm/tsm52j+quImi4Lq9+k3Rv4SOIy8Sh2tKrZwH/BE0Dk/q8gINUvN6SFwyHte3975wHzY9+9KPWycnJdwOGt3FtoYk+VyqV7uF7lgKIazE4kGttgOX8gCdu/V1atEYcIAnWDQcLb9sSvGG0kj43yLQuSzQxZI5yOdiERTtMhEtXQq7i6lQ/pTN7Q/Ustk57hOjufkIwlfj0YblvzI5bNmrz+eaCx+hKxavsEBtATgHiNtiO24glxrdOHep32epOEsEzrJ9MBTZcDKYT1b2e3Y4bY06DBg6TQBdzDiC4iLcwCSg+v3jx4mvPOOOMvVqpFjfWDnbPrUnbNvi4JYvb+PD2+63ZPwFpGt4NO4pfbdkCj+vwZMsfXTXS6UMLDjjq50jkgKQMmCofzqxk7OGJfju8HRmHbbyavKxzGweGMKnQxL+rSraMKwU0Obi4wJivBVOIY/29XaN7tG87LG3HX4FxzppUKvUqwPLnvN2Hcn0T8MwOYNRiPXw864SHtppNfZuz8D/HYvZ7rZDVhvBwxCSyiVharKVWlhucOLf84gisuHO23C4NNv/iHu7E0NaFdl+eswDdfBRfr3UgIF5JSO84jkuvfOqmoq4q9NbT1/OFoJ2k9IHLLrtgn4bbqluPMSfN97///dPgLD2A5TQa7SaG0n997rnn7l6Zt68tcNttgT1wTd7mv24d3+/awM7PZXCTQ9jsz7GAUBXqQE0uOWRHJhabXDw/zlZc7MDWnipYQgVO0+VX7AgA5Ou8Ypm4SNft4I2yxQxOCdQdxcaFg+Ua+7YxT6TS3nW3PXT85jh+b23he86Z73znO4cgp4jDvATArMX+l3e/+92Dz9iD3vbegrUd9d9WKn3acuO/tOwE81biOBFQZNUvHDu45W+4xHIcCyEPi83LbKx7iIOuJzgh1GkBxE30IPqJk7rs01xGcVGqMB1+QQi5h5G5n6ML3eeRk6qeU6ABHN7111+/jKmCv8J9JtdWrr/mOe8CPNOvnp58ts1lp5Ttu6vuYBh2nuUnvm6TfMa2iAZZxBUI1E2FntBfB0pEeQcU3AKaiyM55+5U25fa1rJn6ya3w8gKrgSV4/6UlfS6FBF2Q/jljsLljtfgsNOhwgEBfeVJjuOagZlToPnGN77Rxsjo3bTH22nAPMPo/0TT+xumC8JTJmbQUHuc9cqzNiGxfpYPPF3FUosx4zzAcLws6kW4xRlSVtTV5aiPHddSdzDG72SrS4c9nB3nuLhJkmi0FAJDqZXSXfzUw6NAFe1iZSNr8doUAz85WPYzz3MaNQ0jpXRnZ+dKnOdzLaQBvwWX+f6b3vSmfZqUo4x9N98+azufSv07lll8i5nyvLGTMhofhxSOS3bE5acOGr3DApDCFInhGLhKywLbNFVkemEYyCAQuwiAI5c8cdooXIFxUFyUhuTINlMsJB9uyXBo4QzMnOA0PT09SUCyEs7yYYByiEZJjJy+vm7dum0zaJuZZf02E575xN+z+uBiOA5fQ2WUL0ajFneElh05YjsGQT2B0iAQo6fJBhm7j/moXDkbxtbLCMuLweFsglxRcVcnP5Xzxbgsa423fWb1qr1e4umKiH4OeNAAEv+44447EtCcx3UKz/Vrwr6+ffv2rYDJDRcaH/hZdV/39mFrHf1nOM4VCMe9bimpE22guIguUye+wuSJUFVHAX52Y+boptahJR5mCYyOwQ35TPwbF6QiprmMC43qcSOoRJDztdm/Pt5Sir03B/SQG1D4rPk9DM5yAUD5Q+wnaLTP4/7FeeedN3MF3t6356451vywaC9541pWAU4hJB+PyrYjPHE0oqZQE4k6YWZ5dggACZBJ+h8+RNbNztClACilk0sbUqr7cfkas+N2XvQzVc5TZtJtg5/2b7z1AbYtz8Ac0JzmxBNP7GKk9BZAcjZgmaR7Wo0g/AsE373eljGDNnz6rFecN2Ktwf/hDJ3/sDyrAYsc0qBX33EWssf4cfKMSNLAbVS60rHWJs8JoY/nszbKclC3OS7mKkQrSZ3LqLzGy3lpJc+yfD5Rs9szMgcsaBB829DFnEFTXEBjcS6sfZvrShR4QzNqkWcmc2CXsYDdz1/KN5b/3vLjD7JlhsXrcI86cUV1Ko9VvXVAKRCDQFxt6eagggob61h8zvcewhiXqZ5NgQ48ziH4SQB2807VZCIxWPWTM1ZwHpCg0d4lGuJUGucD2EuxfwrHueqhh6TW34/NFech49Su4YtzX0XOuZdj7nRWv6gcAcZRPASO4zaQpw4euig20o0y0bU+N+Y+h+g6nyire+q4HDyhMyqPKuAyZbjTMMfZz2i4rXoOONBEcszhAOUi7v80QHM7XdJlXV1djzzngq9a9OmMOI7mq4LSP8Jt1jJfxcJ1cRwIXDcRsR0vUbjAw8Vx+YU036LS8JuTJmp8OEScxAFEyZSt7ncuF6bRAGmKLJfoP+oFR+zxKZ7129nJccCB5vjjj18AYN7Pc6zk2owccyVLFe5i5nqfJ+B2apNn3vv/3jXBQUs/snJBHOduN9GpZRnhImDsCDQCSoiE8J50GBK7Mcc4nmQzQnGhogOswplvBxeXzSHHpQ+5DWxGs+OeX/CT/uBDPatn3E4HFGjgKlooJRnmQuws9v/Bvn6/E3xDEj/17zfeMsln7a62aulfAM1dVpjgWHboGQPFcZcYPLENufiud45lEo9PTfLtqlE3/Bau6sYlFZfB8OOG2jgZOfHVB7+/x2auhjigQHPNNde8Hs7yp4Cnmesq3FcBmL06L67euPuDQ8egTIz/xCr5r6AE/CVTD3RVmq+CLI19joOAYADX0EfGMvNsG/h6YmoMQSUWiIl2gIkezLmFmgg4vpUtU9vnhVeNzXXAgOa73/3uS7nxf4W7aKPbDwDNV1atWtXf+DAHpPsH75u0tqOv4uiKv7Pc8N0ccVtyi7PUVYnbxEhwIMLvuqgOG7ZmW883N3MsQJehXUgppPAfTWC6CMVxJRNe0a/5s6KKOCBAw/B6OdMCHwUox/D8a+iSPg9gttJQvEdzwGiGvCP/K6vlP2VT479hQRefx4tkHAcekT02uPWNbw4M6CtVrZ/TQStwm52NQOTQoghOtMc7Ua66HQg7J91r/34PGuljaIAeuqI383QjAOZvzzrrrN8QpkHB3DE6veGq993KKsA/s8nBtZYfroSrACGRk3MiW2Bw3KbLtgRpewidTY7DkELZGV4jfOmS5Txy8M2MpD9cSo3Mig5rvwbNTTfd1AFI/gwOI43vFNdfApifuxaZqz+r33sPXOYDVhy+ybIDJY62DUFTR4M4CGTTgQF8CmhzLs/OBfR1Wl/sTAgcB5gIQAjBZfzjR3YdO6PZ7bjJ91vQXHrppSmWaGqK4N08cBJO838BzHfiG5/T9jXn3cdxth+zwtgvOJ0UGUf79SGVgOMunl4fRgM02ziXbxNnEZeqnFQaN0oEFlmR7lD910hTW3JGs9tx8fV64oD9wb777rtT3d3dr2SN719wP4cAnKtwSwiOX6f94Taf2XtY/b51KADfj3zzAwTkbP2jIa7vERwgHcPvLF/91XzUiOajtNCKGCcQi7J4aDuSesXxpnTv2T0n7Cr87MNT7Heg4SH99evXHwtn+RNAcjT+texR+uI555zTtw/Pd2BnWf2BjaxiYKdD/haG5EXXVemJ6tyGk1OY8d4mgXhq1A2/HVKUJH5yJD/2QpW2tjbPeM4pLnK/Ag0A8W644YbD0PB+iBs8A9Dcj/1v/f39j+CeW4JvTIGns2uta5l2YBXgxK02NVZAGRjlABY65JpVfUMcT/Lw5BAfgmVEHaMF2zn5SQReaXmBY9FnyexXoOHQoW7mkd4Kl3kDAMpxXQ6Afn7hhe7bB7P0yAdYMfpU0eD2h+mePsfSil9YcRLgRKKJOI4+H42yb91Ugc8ojjDgqkSMyEEmfFjPKouL5bkHGnYRtMNN3s5T/jE2gyb/CkBz/dvfzuq3g93c1lPh4wl3mhX/HuBwPuB4Ify2ldgIAjHf/O6rpuxxDkMq1VCQR3jhTAqt0QtqST872pTao+9T7klT7xechqUOTcVi8VRAci7XMgBzA9zmahR4TwMYLVdzS9b25FkP7DSXs7eqNX23Vae+xiKu2wFPNFdFE+gwJD7OsYHdmDouPxwy8bjIwFpNU04lx29rmzcrOho14nMOGkCSGBoaeilA0UTkidzTHbi/Pjo6+vRyjPTBPXqvDiLg+PNvsXL2S8yOr7VitA1Yw+/WbtM3eDbwwfiKht8M0aUvZ0qBMwtsPO+VZmXe6TkHDYDxrr322hVwlXNw/y6gecQPgm/PmzfvwT2SYzSN0CMBWc1zkJjVTNCmAr7xUPxPRlQPWYnja8VS+KJLiQ/bP8p3FnLgQy2iRqFxau1BbfwN4/lZUeyplZ9TTnPzzTd3CzCA5TzuJY8m9GvJTOamWTnVQU83V42+a1UofA/h+AuMqNbBcdxyUJ0O+mC+ZBvz6onCAwOSCb86lkkNHr9y5aytBnjOQBNpfF8Hh5HgW+S6KlWt/tdb3sI6k+fN07fAzR9Gmzf1A5ZVfN2KE4+yoMst0MqyHHQDx+VX2fwgblMtVmvrzB87my+bP32he5biOQGNdkMuXLhQSzU/gvyyCMBcwxrfr775He+YNQl/zx7/AE/1/Y8wxZ34GjLOxVYYGXQHPbYu4kt5Ods63GfjQzn26RWqI9kC0vHsdeHPCWgAymFMC/w1oNFSh/8BNF9/61vfuhlb3fDzZm9aQF8NLvlXwmmuhePwpTGzIfZ9r9n2BPvzsoy3a7WWoDor62ji23rWQSMuQ+V/x/VmrvU80+eYiFwLYGaNfcYPd9DYN140yofPPmfDG2+xie3lWmnK1kz22mTAAq2E1U4qyDF75lkFDVMELXCZv4HDvBOQ9HL9K7qYH83e4xzEJd34kQ1WGu9h1d+vmY+qjLDGZlupnyF3rZaoZQ9MTiMOw1m9bwQwfw5pRwHMN4eHh6/Ffr5Lmi2s//xLzNVV/5GTuB7TUopNfMK5EBSC3tK6Ge9AaLzFZ4XTaKTEHNLvUPFnuJoAzreQaS5GF/PsHwPS+PRz0X3b5/8LBc0/Waq1b1Mlx1ddttXK2dKs6WjUZGykeWaNNrcxUjqaLbQfo2s6Ghnm1wDoq8wpPXPHmT2zj7T/l95WXG3WeWS+OPmn94ysH1lYHpw1HY0e/hkHDZv0BRQNrV8Fh1lHd/RJAPPo/t/yB/Ad3nxJ0Y78/X8rtrTlHh0fmN8/8eCsraV5xkGD4KulDu8CLK+nskGA8xVGSnccwORAN8881yU3p21kUTvatBZLsn2xorNWOc4zz+mMLfoKrRa2/LBgz+X5OBtuGbdTz7rOVrzpdeObDk/Y+JWz1uyM6p8Zg+DbCVfRnNInsPkChfd5OM7lbG6bVdQ/M3e/m1Lf+qV5fIliMWfFHM4moqM5xeE4y3CMQ1NzYJm2wFo7OAY2U2ODtdZdbkDRdpclyttsuGOLXXLMrMoUu7m73Qe95/qXWNvCf2dy8wZr7fyqXfLyWVlT84x0T9/85jc5893eyPUBwMK8vX2DL5t8lyWbe/0N6N23xrMYeuY/LrVycaVlx1/J6iaUkd4S7EVcXey99gFPn7W0P2qdS8atfd6xrNs9kinmPODZzDrLrdaZ+4V98r5f8ZGDe+wTR+3Tl9z2+Wlbuk5iH/cpgJrZzMIm67l1tTs0e58LDDPOOmjgMMwIJE6Gq5xHFccCmu9zXc35dwPYB44CDwHebvd+xyrls+AaK+Eeh9I3taJi1ZcqioxQWPhd+xWzzL9kbcuj7tvICf94SzWfy0lXK0l7MmlOwH6J+ZU38E3MX9qn197AUYn32RdOmlVl25NiQPUHJZSpwdHcy/m2tXoPaR9+0vR7GDHr3RMnhb+YkZLO8X0H1294Gf/q8MMPX3vKKewiPFDMmy7lTI9+VhEGf0Vj68st4pyh4YOphP+QaeX/NK/0sBpEFgAADklJREFUMJ+2HrebL9HC3cBWfbHZjn31MvNSfwygLiJkXpRLuyik4n8c+4eWrHzLek7dEMU9M9YFl6as9oIfcDzt63Rr/HNaQO3Llkl90b56xoyUfbPKaeAyC9G/vFOCL1zlcbjN11Hg3f+Hf/iHBw5gTv9Is031nQeBL6ArOllzOdPGk2xyBcdk/ocNLthga3Zau7z6LzW03WCfuvvf4TbowALAY4sIYwW4deE+GXupVdKL7W/u/4b944vvxv8MmcO6WUpzBEDhNsTga53Mc59mU7UX4Fk7k0pnTbnHR7jmAZazAMq7uKES7n/js343XnDBBQ06Aq2w07WfmlUApm3+e1hm9FfQma6FW3XbRWT7PId/I8eDfMFeXn1sF8BMPxKqtVO2W6LwWWSaf5sOdq4kwFlO9/ZONLf/2z629pSd4mfPW0suRK5awAVeYHQ1dauVY1i89TLqnxENZgU0F198cQZB99VwFx1nxvJ4+wFd1I/WrFkzQhi8MTaN7jhsP7FXXZWwye6z2BbyAQTcQwFLKjxkiCZyuxsTD8FhvmArrXePhtI9jFRSua+BuyvdE6oV4pYIgnbe/ldb0vuofew3v/WMvEjVYrMFZT5qBWAct5FdhesFJ9nZqztm0uozBo0E32XLlkng/VNu5Hiu23BfgeC7dffHme2nwJlc/1sMpz8AWF4MWAAMPYqOYtXF4btcl9mhC+7eI8DEFOk5XSdp9gCWh+KgyBbr4uNQ9iZOxPqUffpejoqd2du/U/l8K6raBEiSIZcBMDqFolptY7vvEZaxhbuk34uAGcs0jJRWIMd8GKCcSb1aG/MlZJhf78U9PPdJ3/TFE2jMD9FzvgLOIKSE9xQzcc/7obUccjkndO6lbMYL8g/2mP3NPf8L4HydtxyFYGTYXYJfwHkLZ4VM2MfXfhb3jEc2cfGAfz7PlHL+WK4J9GUyZKua11lPtw+OGXEauMx8uqM/YYR0NnXfi30xe7DZn3MAmTO/OJ9GfAcc5XVwk4Q7GFpfwk3wPsFwmDHuI/wfbPUMPspRnfwxQsW/AxxO86Rt3JlmOOIuK7C3w93eaT0b49HWzBvQq4jT+G5jnY5lm77SgHR6NLgPNe0zaK644opW6tNSh/O5pGn8LkLw9w+oAxN7+LxyxnshBPt9AIKyTkCJLoEmwfHgfupmu+EvfrMPbTud5fHttE/iSsDyqAOMwKIBTQygmvQ/wR+xSPwVdsHdIXeYzr1vLr4NDVDYL0e3pCPZBBon37CrLlHM7FuhYS5aZu+N5Bi4ihaFf5pLH7O4hk36l7MofM81niKYPZG2sbEma+EhauWSNf1kfK9khr2/9R1z3Pu1bvOb0WPUXuwiNFIKHfRQcnvDfG7nu1HgvlvaWvuxX2xi4/X/pby/oRtEEBZiGkwNBZyh2+m07Whu75ux5haZARmGSgCN0Kn6wjrZP+eO12qofO+c+wQaqngZYNGc0nKu1QDoKwCm/ymrvvixjPUNz7OAYw6migssdy/DwWAJE37L2bCDWj79gI2/9nvIjc/O3JSUX2Opl9Cwr6MRW0KQ6Aki4LDJjC7r+9bkrXnK59rTyM+9ImufvPc6vofNMDt4K9k0/J42jqDe79EmD9kYuh7jd2+MBOnGkWrAl8VqfCtX4w7Np8Y2IjLA3UvZbMcb2WvQ6FN/AOWvKeZEuiN96u8bCL5PL8BtzR9u1eTbzK8ei5ywnDdgKfSZTzmdNF4L153sS5bS6dkRoifbqbfwKrqf42hVqm3kMnjN30b3dJU1TarrnQUD1TIbN3MQ47fgNCcBnGMcaBqBY3yfx/Pegrx8tV0QrLXLvL0lrh4iLLFUZs7PCb5hUJ3TMAVS9fMzeaC9kmkk+LKA6nwqfDNgeRz70rGxsT0TfINSNw3yHh7pfFD/GuwXkX8ZVyv04q92KIR6kZ1/64yENMp7eiOdTM1fDmAAjd8WCr+8P6Ecg53mbUz82CY67jadhTdbpueIgiWaf4mi7Sbe/smwu4DGjqDQW9itBUcR8EfWsgaN7l6YkMtMQzCoLUY/g0KP7knf/XYKvipyTrWfCdihvSh5l6R7DBp9FJ3c5wOWD2Bn1SXxJbfVe7R9VtWWkw9y93fIOW30jPHFzLGh8JrXccR0/DPk6rI29pa+HKH3ZIATjpJ2sP2NTFJ+305tnf2Ne+vvH2Mn22rA8Us4Dksp4iYQeHDXkPU8NMYBXdW+GvdSVF7gwAJO3CcRdTxJrcJZJNV7ranct69FK98egUZrfCcmJs6gWzqfaz7XdwHN6jPPPHPPZ2u//JIxCPQdeMrgNFCiW3e44ajKgI98JbguCGZnBLH7lvHYALwEUPwe3KTDjZY8uExdkecjy6R+akHq/hkLo7urX0KxZR8EHNfCcXrr70y9+yBToKUXtXfbRx5U9733pjK8AMCc5BR6bqhNlSGn2cqnEdfa6o/M6FtYewQadC+/A4f5c+5ek103I8t8jiWbe78bspyD03hXcOnolF2wQwCsufZ6a1172N631B7muOBSBNDUqbwvrI9JcCs0wQ5XYhtE+6G1pQH3M2S+fMaYeW0/pFu6lmsYAPHY1KU2cV0UdtVexYHUf7RPd1AtvhzQSGEZg4Wy2TAXwOmrrXfxwKppn83Tgoaj5Y8EMNpvrRHT3Vz/weq7zftU45d+WxuM/5O8DzxJ/gwN9wpU679tH/rVjOZHnqR8XvLlCIgG61d3uIuR8u0X7JF+yC77g6ldYmczYNsDA7SFhvP/TZ15B5gdScncUe0Cu+jOF+5VtW/7d7hM7e2M0pQ/BE0AKmtVXobqLdbRtfcv+0438JSg0TeuAYkmIV9Hvn6mDD7LuTG371TG3nlbXrqOB7qYTDvqdDT14qZfvOVoMc9lRZxmY5/y/vauYlKvvDVpSWZ5fT1PAJvZ2TDcNQjZlt0y07dx55J38aubmte2BmL+G0LCLcRPj2jqXVWgebBP2EV3Ldkl/+4CJMsUS+9BZnqD647qk5W1IdryOsu3/ATNNn3VzMyTEoWRkr7cdhbFn82ldSTfRF/0sz0WfJ/svnrUNVV+AlGucSCpg0UZeNU45AjrdJR9Z9nHHtodN3iykp8+/KjBDqYM3kUdu5breehFvNVWTd8xqyOmp7orHdE6OXUPz3spXdRPsAvcW0MO13/+PnLeR+2iW58aOCt7kpbf8ka4yZ8CmIUNXKaM+wYr175pt31wz2XQhrvY2blb0ACYNAlfA0j0QdFuhN6vcX1v1j6RM+9Hm61UgdsE97pOPH6z1F7h1cHw/F0cFXa2ffzuGU2u7fDABZ+XANaNNi+uKLTRswc15oeqV9mxf/DsKBfjG7v8jILNP4W67ZNclwMadR+0glQuzrUMgZnZ95Z/tT+7c6VJKdlopNR76+eOspbWv0Hw/Ree4xiAQwlOOOqnvP9A4P8ne1VpvSutMe8+uqM7m84NSDwWVL0CYfeTXL9LzI3Ynz766KPXz+qSzQ+hIU6Ov49+/dO8/bu+RRwwCIE3AZ6PWnXwBrvkDTNb0f/e7x/CyOF6Sj2ZFm14bqHUbjev8k/WMvmTZ43LTDd56FLXkj601RbYK63iv5F2+S2AcxLPH4LE8wF2sInrGk4w/5mNPz5skxNo1UuvACTSJAOWGnKgG3kiL9nPWE/z/6yS+oXNP3psNrql+JYbGi8Muvrqq4/B9VnA8xbsn8FhPnP//fffufu1MXEx+2h/4r4u+uB3kPszEHORYBKayCHLQ6VetY+wMPvHprdyX8253/s6Wd/vXuKw3LCkIHiEsI9ZJXnTbDbsvt5mPd/5t84zf+p0Dpx+JUA5HtnmSPQsyxlRsbOAD3SX8nyyuYImneUVQXWCUddDPMd6wu5AEXy7/eRT+J8ZUwcNIPG/973vHYGw+wGquojrcUZMn2DJ5m1veMMM3/KnuveP3NFsXvIsVNt/AWc5CSaw49RGSGA0mN7lVit8ybqXj1jP4XCdPRg2inW/7fJOa2mSJvrz3Abdrti2jNb7Bg/TU33VxgevsJs/PDNOFhb6zPyKC6WGOmy82MX9L4GrMAXCbLXnw4+10L06yJqu7XbaSPbZmPB1oIm6pPl0Q1oUrp0EnAjpfxXAXApgJp6Zlmgotae3xUa2vQau8nc0AtsumIPZnfGC/7IqK+iK5TtQyo3YpS/TScsRW9opg5YYlO5fYKX0ByjzgwBEanUSOTEui2MDjf0vlrLr7VvvmRUBcac7mLNeBxqNlADJmTzlPwMYzXlcgv8yttBufdaeXBynhsIt8OEK3qupVyOcpnr9Dhruh1EOKnjztT2Ds1ja+q0yPm5fOp2uCwD1MKzesLnTyv6plHUuwDiH8FAu0CIoC6SFvZH837ar3ill4+5BV6/4ecfOLeBAw/HyryLiMwDmFdg3Min5aTS+Tz9zvXNps+H/s18fwQ7FcwDOayDosXAHWLIH54l0Nlrn4oRkLR1g9BX4t8I81iAbPW5VvgE5NbyMyf8zzKsySnL5NXMspd0w9v3cIvM+CMSr39s3G7d7MJbhwWUWIrt8hYeXAu9ndFGfZ2j9C8Lizv/Zb5ce5qEm7j2cibbT6cN/i+7qOMAxDzejA38hdiu6CKYDYBLVWolRQh9bMzZYOcdHtQqHErYEQHEmqgMWk3TeFgDzU5jKf9v3znv02X+guVVjEsFXH+A6kcdaD1Aub29v//VzChi1b49X4vdRhLr11vsHN1pz7Qj8bDKrLULpdyJzKocw1OwCKBm2zYKPCh1PiQ87sujILdnw1gKQrQiMDNmTj5nP0P2F714fHlStCp43M2kBT2t9EXjfBlBydEu37Pfn+J7/zXkIt50IxO3oK1rgKgEaU5YYAJhaUOCLawjufOW8i0Pnlm1/bo/7mAll9uO8/x9teQya14m6TgAAAABJRU5ErkJggg=="
        }
      ) })
    ]
  }
);

// node_modules/@copilotkit/react-core/dist/chunk-OKCYPO4I.mjs
var import_react9 = __toESM(require_react(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
function DeveloperConsoleModal({ isOpen, onClose, hasApiKey }) {
  const context = useCopilotContext();
  const messagesContext = useCopilotMessagesContext();
  const [activeTab, setActiveTab] = (0, import_react9.useState)("actions");
  (0, import_react9.useEffect)(() => {
    const handleEscape = (e3) => {
      if (e3.key === "Escape") {
        onClose();
      }
    };
    if (isOpen) {
      document.addEventListener("keydown", handleEscape);
      document.body.style.overflow = "hidden";
    }
    return () => {
      document.removeEventListener("keydown", handleEscape);
      document.body.style.overflow = "unset";
    };
  }, [isOpen, onClose]);
  if (!isOpen)
    return null;
  const displayContext = hasApiKey ? context : {
    actions: {
      search_web: { name: "search_web", description: "Search the web for information" },
      send_email: { name: "send_email", description: "Send an email to a contact" },
      create_document: { name: "create_document", description: "Create a new document" },
      analyze_code: {
        name: "analyze_code",
        description: "Analyze code for issues and improvements"
      },
      generate_tests: {
        name: "generate_tests",
        description: "Generate unit tests for functions"
      }
    },
    getAllContext: () => [
      {
        content: "User preferences: dark mode enabled, TypeScript preferred",
        metadata: { source: "settings" }
      },
      {
        content: "Current project: Building a React application with CopilotKit",
        metadata: { source: "project" }
      },
      {
        content: "Recent activity: Implemented authentication system",
        metadata: { source: "activity" }
      },
      {
        content: "Development environment: VS Code, Node.js 18, React 18",
        metadata: { source: "environment" }
      }
    ],
    coagentStates: {
      "main-agent": { status: "active", lastUpdate: Date.now() },
      "code-assistant": { status: "active", lastUpdate: Date.now() - 15e3 },
      "search-agent": { status: "idle", lastUpdate: Date.now() - 6e4 }
    },
    getDocumentsContext: () => [
      {
        content: "README.md: Project setup and installation instructions",
        metadata: { type: "documentation" }
      },
      {
        content: "API Documentation: CopilotKit integration guide",
        metadata: { type: "documentation" }
      },
      {
        content: "package.json: Project dependencies and scripts",
        metadata: { type: "configuration" }
      }
    ]
  };
  const displayMessagesContext = hasApiKey ? messagesContext : {
    messages: [
      {
        id: "1",
        role: "user",
        content: "Help me implement a todo list with drag and drop functionality"
      },
      {
        id: "2",
        role: "assistant",
        content: "I'll help you create a todo list with drag and drop. Let me start by setting up the basic components and then add the drag and drop functionality using React DnD."
      },
      { id: "3", role: "user", content: "Can you also add priority levels and due dates?" },
      {
        id: "4",
        role: "assistant",
        content: "Absolutely! I'll enhance the todo items with priority levels (high, medium, low) and due date functionality. This will make your todo list much more powerful for task management."
      },
      { id: "5", role: "user", content: "Perfect! How about adding categories or tags?" }
    ]
  };
  return (0, import_jsx_runtime8.jsx)(
    "div",
    {
      style: {
        position: "fixed",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        zIndex: 9999,
        backgroundColor: "rgba(0, 0, 0, 0.3)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        padding: "16px"
      },
      onClick: onClose,
      children: (0, import_jsx_runtime8.jsxs)(
        "div",
        {
          style: {
            width: "1152px",
            maxWidth: "95vw",
            height: "80vh",
            backgroundColor: "white",
            borderRadius: "12px",
            boxShadow: "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
            display: "flex",
            flexDirection: "column",
            overflow: "hidden",
            position: "relative"
          },
          onClick: (e3) => e3.stopPropagation(),
          children: [
            (0, import_jsx_runtime8.jsxs)(
              "div",
              {
                style: {
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "space-between",
                  padding: "24px",
                  borderBottom: "1px solid #e5e7eb",
                  minHeight: "73px",
                  flexShrink: 0,
                  filter: !hasApiKey ? "blur(0.3px)" : "none",
                  opacity: !hasApiKey ? 0.95 : 1
                },
                children: [
                  (0, import_jsx_runtime8.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: "12px" }, children: [
                    (0, import_jsx_runtime8.jsx)(CopilotKitIcon, {}),
                    (0, import_jsx_runtime8.jsx)(
                      "h1",
                      {
                        style: {
                          fontWeight: "bold",
                          fontSize: "20px",
                          color: "#1f2937",
                          margin: 0
                        },
                        children: "Inspector"
                      }
                    ),
                    (0, import_jsx_runtime8.jsxs)(
                      "span",
                      {
                        style: {
                          fontSize: "14px",
                          color: "#6b7280",
                          backgroundColor: "#f3f4f6",
                          padding: "4px 8px",
                          borderRadius: "4px"
                        },
                        children: [
                          "v",
                          COPILOTKIT_VERSION
                        ]
                      }
                    )
                  ] }),
                  (0, import_jsx_runtime8.jsx)(
                    "button",
                    {
                      onClick: onClose,
                      style: {
                        color: "#9ca3af",
                        fontSize: "24px",
                        fontWeight: "300",
                        border: "none",
                        background: "none",
                        cursor: "pointer",
                        padding: "4px"
                      },
                      onMouseEnter: (e3) => e3.currentTarget.style.color = "#4b5563",
                      onMouseLeave: (e3) => e3.currentTarget.style.color = "#9ca3af",
                      children: ""
                    }
                  )
                ]
              }
            ),
            (0, import_jsx_runtime8.jsx)(
              "div",
              {
                style: {
                  display: "flex",
                  borderBottom: "1px solid #e5e7eb",
                  backgroundColor: "#f9fafb",
                  minHeight: "50px",
                  flexShrink: 0,
                  filter: !hasApiKey ? "blur(0.3px)" : "none",
                  opacity: !hasApiKey ? 0.9 : 1
                },
                children: [
                  { id: "actions", label: "Actions", count: Object.keys(displayContext.actions).length },
                  { id: "readables", label: "Readables", count: displayContext.getAllContext().length },
                  {
                    id: "agent",
                    label: "Agent Status",
                    count: Object.keys(displayContext.coagentStates).length
                  },
                  { id: "messages", label: "Messages", count: displayMessagesContext.messages.length },
                  {
                    id: "context",
                    label: "Context",
                    count: displayContext.getDocumentsContext([]).length
                  }
                ].map((tab2) => (0, import_jsx_runtime8.jsxs)(
                  "button",
                  {
                    onClick: () => setActiveTab(tab2.id),
                    style: {
                      padding: "12px 24px",
                      fontSize: "14px",
                      fontWeight: "500",
                      border: "none",
                      cursor: "pointer",
                      backgroundColor: activeTab === tab2.id ? "white" : "transparent",
                      color: activeTab === tab2.id ? "#2563eb" : "#6b7280",
                      borderBottom: activeTab === tab2.id ? "2px solid #2563eb" : "none",
                      transition: "all 0.2s"
                    },
                    onMouseEnter: (e3) => {
                      if (activeTab !== tab2.id) {
                        e3.currentTarget.style.color = "#1f2937";
                        e3.currentTarget.style.backgroundColor = "#f3f4f6";
                      }
                    },
                    onMouseLeave: (e3) => {
                      if (activeTab !== tab2.id) {
                        e3.currentTarget.style.color = "#6b7280";
                        e3.currentTarget.style.backgroundColor = "transparent";
                      }
                    },
                    children: [
                      tab2.label,
                      tab2.count > 0 && (0, import_jsx_runtime8.jsx)(
                        "span",
                        {
                          style: {
                            marginLeft: "8px",
                            backgroundColor: "#e5e7eb",
                            color: "#374151",
                            padding: "2px 8px",
                            borderRadius: "9999px",
                            fontSize: "12px"
                          },
                          children: tab2.count
                        }
                      )
                    ]
                  },
                  tab2.id
                ))
              }
            ),
            (0, import_jsx_runtime8.jsxs)(
              "div",
              {
                style: {
                  height: "calc(100% - 142px)",
                  overflow: "auto",
                  padding: "24px",
                  backgroundColor: "#f9fafb",
                  filter: !hasApiKey ? "blur(0.3px)" : "none",
                  opacity: !hasApiKey ? 0.85 : 1
                },
                children: [
                  activeTab === "actions" && (0, import_jsx_runtime8.jsx)(ActionsTab, { context: displayContext }),
                  activeTab === "readables" && (0, import_jsx_runtime8.jsx)(ReadablesTab, { context: displayContext }),
                  activeTab === "agent" && (0, import_jsx_runtime8.jsx)(AgentStatusTab, { context: displayContext }),
                  activeTab === "messages" && (0, import_jsx_runtime8.jsx)(MessagesTab, { messagesContext: displayMessagesContext }),
                  activeTab === "context" && (0, import_jsx_runtime8.jsx)(ContextTab, { context: displayContext })
                ]
              }
            ),
            (0, import_jsx_runtime8.jsxs)(
              "div",
              {
                style: {
                  padding: "16px 24px",
                  borderTop: "1px solid #e5e7eb",
                  backgroundColor: "white",
                  display: "flex",
                  justifyContent: "space-between",
                  alignItems: "center",
                  minHeight: "57px",
                  flexShrink: 0,
                  filter: !hasApiKey ? "blur(0.3px)" : "none",
                  opacity: !hasApiKey ? 0.9 : 1
                },
                children: [
                  (0, import_jsx_runtime8.jsx)("div", { style: { fontSize: "14px", color: "#6b7280" }, children: (0, import_jsx_runtime8.jsx)(
                    "a",
                    {
                      href: "https://github.com/CopilotKit/CopilotKit/issues",
                      target: "_blank",
                      rel: "noopener noreferrer",
                      style: { color: "#2563eb", textDecoration: "none" },
                      onMouseEnter: (e3) => e3.currentTarget.style.textDecoration = "underline",
                      onMouseLeave: (e3) => e3.currentTarget.style.textDecoration = "none",
                      children: "Report an issue"
                    }
                  ) }),
                  (0, import_jsx_runtime8.jsx)("div", { style: { fontSize: "14px", color: "#6b7280" }, children: (0, import_jsx_runtime8.jsx)(
                    "a",
                    {
                      href: "https://mcp.copilotkit.ai/",
                      target: "_blank",
                      rel: "noopener noreferrer",
                      style: { color: "#2563eb", textDecoration: "none" },
                      onMouseEnter: (e3) => e3.currentTarget.style.textDecoration = "underline",
                      onMouseLeave: (e3) => e3.currentTarget.style.textDecoration = "none",
                      children: "Add MCP Server "
                    }
                  ) })
                ]
              }
            ),
            !hasApiKey && (0, import_jsx_runtime8.jsx)(
              "div",
              {
                style: {
                  position: "absolute",
                  top: 0,
                  left: 0,
                  right: 0,
                  bottom: 0,
                  backgroundColor: "rgba(255, 255, 255, 0.2)",
                  backdropFilter: "blur(2px)",
                  WebkitBackdropFilter: "blur(2px)",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  borderRadius: "12px",
                  zIndex: 10
                },
                onClick: (e3) => e3.stopPropagation(),
                children: (0, import_jsx_runtime8.jsxs)(
                  "button",
                  {
                    onClick: () => window.open("https://cloud.copilotkit.ai/sign-in", "_blank"),
                    style: {
                      // Following button system specifications
                      height: "48px",
                      padding: "12px 24px",
                      backgroundColor: "#030507",
                      // textPrimary token
                      color: "#FFFFFF",
                      borderRadius: "12px",
                      // Medium radius token
                      border: "none",
                      cursor: "pointer",
                      fontSize: "14px",
                      // Medium Semi Bold typography
                      fontWeight: "600",
                      fontFamily: "'Plus Jakarta Sans', -apple-system, BlinkMacSystemFont, sans-serif",
                      lineHeight: "22px",
                      boxShadow: "0 4px 16px rgba(3, 5, 7, 0.2), 0 1px 3px rgba(3, 5, 7, 0.1)",
                      transition: "all 200ms ease",
                      // 200ms ease as per specs
                      display: "inline-flex",
                      alignItems: "center",
                      gap: "8px",
                      textTransform: "uppercase",
                      letterSpacing: "0.5px"
                    },
                    onMouseEnter: (e3) => {
                      e3.currentTarget.style.backgroundColor = "#575758";
                      e3.currentTarget.style.transform = "translateY(-1px)";
                      e3.currentTarget.style.boxShadow = "0 6px 20px rgba(3, 5, 7, 0.25), 0 2px 4px rgba(3, 5, 7, 0.15)";
                    },
                    onMouseLeave: (e3) => {
                      e3.currentTarget.style.backgroundColor = "#030507";
                      e3.currentTarget.style.transform = "translateY(0)";
                      e3.currentTarget.style.boxShadow = "0 4px 16px rgba(3, 5, 7, 0.2), 0 1px 3px rgba(3, 5, 7, 0.1)";
                    },
                    onMouseDown: (e3) => {
                      e3.currentTarget.style.backgroundColor = "#858589";
                      e3.currentTarget.style.transform = "translateY(0)";
                    },
                    onMouseUp: (e3) => {
                      e3.currentTarget.style.backgroundColor = "#575758";
                      e3.currentTarget.style.transform = "translateY(-1px)";
                    },
                    onFocus: (e3) => {
                      e3.currentTarget.style.outline = "2px solid #BEC9FF";
                      e3.currentTarget.style.outlineOffset = "2px";
                    },
                    onBlur: (e3) => {
                      e3.currentTarget.style.outline = "none";
                    },
                    children: [
                      "Get License Key",
                      (0, import_jsx_runtime8.jsx)("span", { style: { fontSize: "16px", marginLeft: "-4px" }, children: "" })
                    ]
                  }
                )
              }
            )
          ]
        }
      )
    }
  );
}
function ActionsTab({ context }) {
  const actions = Object.values(context.actions);
  if (actions.length === 0) {
    return (0, import_jsx_runtime8.jsxs)("div", { style: { textAlign: "center", padding: "48px 0", color: "#6b7280" }, children: [
      (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "18px", margin: "0 0 8px 0" }, children: "No actions available" }),
      (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "14px", margin: 0 }, children: "Actions will appear here when registered" })
    ] });
  }
  return (0, import_jsx_runtime8.jsx)("div", { style: { display: "flex", flexDirection: "column", gap: "16px" }, children: actions.map((action, index3) => (0, import_jsx_runtime8.jsx)(
    "div",
    {
      style: {
        backgroundColor: "white",
        padding: "16px",
        borderRadius: "8px",
        boxShadow: "0 1px 3px 0 rgba(0, 0, 0, 0.1)",
        border: "1px solid #e5e7eb"
      },
      children: (0, import_jsx_runtime8.jsxs)(
        "div",
        {
          style: { display: "flex", alignItems: "flex-start", justifyContent: "space-between" },
          children: [
            (0, import_jsx_runtime8.jsxs)("div", { style: { flex: 1 }, children: [
              (0, import_jsx_runtime8.jsx)("h3", { style: { fontWeight: "600", color: "#1f2937", margin: "0 0 4px 0" }, children: action.name }),
              action.description && (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "14px", color: "#4b5563", margin: "0 0 12px 0" }, children: action.description }),
              action.parameters && action.parameters.length > 0 && (0, import_jsx_runtime8.jsxs)("div", { style: { marginTop: "12px" }, children: [
                (0, import_jsx_runtime8.jsx)(
                  "p",
                  {
                    style: {
                      fontSize: "12px",
                      fontWeight: "500",
                      color: "#6b7280",
                      textTransform: "uppercase",
                      margin: "0 0 4px 0"
                    },
                    children: "Parameters:"
                  }
                ),
                (0, import_jsx_runtime8.jsx)("div", { style: { display: "flex", flexDirection: "column", gap: "4px" }, children: action.parameters.map((param, pIndex) => (0, import_jsx_runtime8.jsxs)("div", { style: { fontSize: "14px" }, children: [
                  (0, import_jsx_runtime8.jsx)("span", { style: { fontFamily: "monospace", color: "#374151" }, children: param.name }),
                  param.required && (0, import_jsx_runtime8.jsx)("span", { style: { marginLeft: "4px", fontSize: "12px", color: "#ef4444" }, children: "*required" }),
                  param.type && (0, import_jsx_runtime8.jsxs)("span", { style: { marginLeft: "8px", fontSize: "12px", color: "#6b7280" }, children: [
                    "(",
                    param.type,
                    ")"
                  ] })
                ] }, pIndex)) })
              ] })
            ] }),
            (0, import_jsx_runtime8.jsx)("div", { style: { marginLeft: "16px" }, children: action.status === "available" ? (0, import_jsx_runtime8.jsx)(CheckIcon, {}) : (0, import_jsx_runtime8.jsx)(ExclamationMarkTriangleIcon, {}) })
          ]
        }
      )
    },
    index3
  )) });
}
function ReadablesTab({ context }) {
  const readables = context.getAllContext();
  if (readables.length === 0) {
    return (0, import_jsx_runtime8.jsxs)("div", { style: { textAlign: "center", padding: "48px 0", color: "#6b7280" }, children: [
      (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "18px", margin: "0 0 8px 0" }, children: "No readable context available" }),
      (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "14px", margin: 0 }, children: "Readable context will appear here when provided" })
    ] });
  }
  return (0, import_jsx_runtime8.jsx)("div", { style: { display: "flex", flexDirection: "column", gap: "16px" }, children: readables.map((readable, index3) => (0, import_jsx_runtime8.jsx)(
    "div",
    {
      style: {
        backgroundColor: "white",
        padding: "16px",
        borderRadius: "8px",
        boxShadow: "0 1px 3px 0 rgba(0, 0, 0, 0.1)",
        border: "1px solid #e5e7eb"
      },
      children: (0, import_jsx_runtime8.jsx)(
        "div",
        {
          style: { display: "flex", alignItems: "flex-start", justifyContent: "space-between" },
          children: (0, import_jsx_runtime8.jsxs)("div", { style: { flex: 1 }, children: [
            (0, import_jsx_runtime8.jsx)("h3", { style: { fontWeight: "600", color: "#1f2937", margin: "0 0 4px 0" }, children: readable.name || `Readable ${index3 + 1}` }),
            readable.description && (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "14px", color: "#4b5563", margin: "0 0 12px 0" }, children: readable.description }),
            readable.value && (0, import_jsx_runtime8.jsx)(
              "pre",
              {
                style: {
                  marginTop: "12px",
                  padding: "8px",
                  backgroundColor: "#f9fafb",
                  borderRadius: "4px",
                  fontSize: "12px",
                  overflowX: "auto",
                  margin: "12px 0 0 0"
                },
                children: JSON.stringify(readable.value, null, 2)
              }
            )
          ] })
        }
      )
    },
    index3
  )) });
}
function AgentStatusTab({ context }) {
  const agentStates = context.coagentStates || {};
  const agentStateEntries = Object.entries(agentStates);
  if (agentStateEntries.length === 0) {
    return (0, import_jsx_runtime8.jsxs)("div", { style: { textAlign: "center", padding: "48px 0", color: "#6b7280" }, children: [
      (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "18px", margin: "0 0 8px 0" }, children: "No agent states available" }),
      (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "14px", margin: 0 }, children: "Agent states will appear here when agents are active" })
    ] });
  }
  return (0, import_jsx_runtime8.jsx)("div", { style: { display: "flex", flexDirection: "column", gap: "24px" }, children: agentStateEntries.map(([agentName, state]) => (0, import_jsx_runtime8.jsxs)(
    "div",
    {
      style: {
        backgroundColor: "white",
        padding: "24px",
        borderRadius: "8px",
        boxShadow: "0 1px 3px 0 rgba(0, 0, 0, 0.1)",
        border: "1px solid #e5e7eb"
      },
      children: [
        (0, import_jsx_runtime8.jsxs)(
          "div",
          {
            style: {
              display: "flex",
              alignItems: "center",
              justifyContent: "space-between",
              marginBottom: "16px"
            },
            children: [
              (0, import_jsx_runtime8.jsx)("h3", { style: { fontWeight: "600", fontSize: "18px", color: "#1f2937", margin: 0 }, children: agentName }),
              (0, import_jsx_runtime8.jsx)(
                "span",
                {
                  style: {
                    padding: "4px 12px",
                    borderRadius: "9999px",
                    fontSize: "12px",
                    fontWeight: "500",
                    backgroundColor: state.status === "running" ? "#dcfce7" : state.status === "complete" ? "#dbeafe" : "#f3f4f6",
                    color: state.status === "running" ? "#166534" : state.status === "complete" ? "#1e40af" : "#1f2937"
                  },
                  children: state.status || "idle"
                }
              )
            ]
          }
        ),
        state.state && (0, import_jsx_runtime8.jsxs)("div", { style: { marginBottom: "12px" }, children: [
          (0, import_jsx_runtime8.jsx)(
            "p",
            {
              style: {
                fontSize: "12px",
                fontWeight: "500",
                color: "#6b7280",
                textTransform: "uppercase",
                margin: "0 0 4px 0"
              },
              children: "Current State:"
            }
          ),
          (0, import_jsx_runtime8.jsx)(
            "pre",
            {
              style: {
                padding: "12px",
                backgroundColor: "#f9fafb",
                borderRadius: "4px",
                fontSize: "12px",
                overflowX: "auto",
                margin: 0
              },
              children: JSON.stringify(state.state, null, 2)
            }
          )
        ] }),
        state.running && (0, import_jsx_runtime8.jsxs)(
          "div",
          {
            style: {
              marginTop: "16px",
              display: "flex",
              alignItems: "center",
              fontSize: "14px",
              color: "#4b5563"
            },
            children: [
              (0, import_jsx_runtime8.jsx)("div", { style: { marginRight: "8px" }, children: (0, import_jsx_runtime8.jsxs)(
                "svg",
                {
                  width: "16",
                  height: "16",
                  viewBox: "0 0 16 16",
                  style: { animation: "spin 1s linear infinite" },
                  children: [
                    (0, import_jsx_runtime8.jsx)("style", { children: `@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }` }),
                    (0, import_jsx_runtime8.jsx)(
                      "circle",
                      {
                        cx: "8",
                        cy: "8",
                        r: "6",
                        fill: "none",
                        stroke: "#4b5563",
                        strokeWidth: "2",
                        strokeDasharray: "9 3"
                      }
                    )
                  ]
                }
              ) }),
              (0, import_jsx_runtime8.jsx)("span", { children: "Agent is currently running..." })
            ]
          }
        )
      ]
    },
    agentName
  )) });
}
function MessagesTab({ messagesContext }) {
  const messages = messagesContext.messages || [];
  if (messages.length === 0) {
    return (0, import_jsx_runtime8.jsxs)("div", { style: { textAlign: "center", padding: "48px 0", color: "#6b7280" }, children: [
      (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "18px", margin: "0 0 8px 0" }, children: "No messages yet" }),
      (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "14px", margin: 0 }, children: "Messages will appear here as the conversation progresses" })
    ] });
  }
  return (0, import_jsx_runtime8.jsx)("div", { style: { display: "flex", flexDirection: "column", gap: "16px" }, children: messages.map((message2, index3) => (0, import_jsx_runtime8.jsxs)(
    "div",
    {
      style: {
        padding: "16px",
        borderRadius: "8px",
        backgroundColor: message2.role === "user" ? "#eff6ff" : message2.role === "assistant" ? "#f9fafb" : "#fefce8",
        border: `1px solid ${message2.role === "user" ? "#c7d2fe" : message2.role === "assistant" ? "#e5e7eb" : "#fde047"}`,
        marginLeft: message2.role === "user" ? "48px" : "0",
        marginRight: message2.role === "assistant" ? "48px" : "0"
      },
      children: [
        (0, import_jsx_runtime8.jsxs)(
          "div",
          {
            style: {
              display: "flex",
              alignItems: "flex-start",
              justifyContent: "space-between",
              marginBottom: "8px"
            },
            children: [
              (0, import_jsx_runtime8.jsx)(
                "span",
                {
                  style: {
                    fontWeight: "500",
                    fontSize: "14px",
                    color: "#374151",
                    textTransform: "capitalize"
                  },
                  children: message2.role || "system"
                }
              ),
              message2.timestamp && (0, import_jsx_runtime8.jsx)("span", { style: { fontSize: "12px", color: "#6b7280" }, children: new Date(message2.timestamp).toLocaleTimeString() })
            ]
          }
        ),
        (0, import_jsx_runtime8.jsx)("div", { style: { fontSize: "14px", color: "#1f2937", whiteSpace: "pre-wrap" }, children: message2.content || "" })
      ]
    },
    index3
  )) });
}
function ContextTab({ context }) {
  const documents2 = context.getDocumentsContext([]);
  if (documents2.length === 0) {
    return (0, import_jsx_runtime8.jsxs)("div", { style: { textAlign: "center", padding: "48px 0", color: "#6b7280" }, children: [
      (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "18px", margin: "0 0 8px 0" }, children: "No document context available" }),
      (0, import_jsx_runtime8.jsx)("p", { style: { fontSize: "14px", margin: 0 }, children: "Document context will appear here when provided" })
    ] });
  }
  return (0, import_jsx_runtime8.jsx)("div", { style: { display: "flex", flexDirection: "column", gap: "16px" }, children: documents2.map((doc, index3) => (0, import_jsx_runtime8.jsxs)(
    "div",
    {
      style: {
        backgroundColor: "white",
        padding: "16px",
        borderRadius: "8px",
        boxShadow: "0 1px 3px 0 rgba(0, 0, 0, 0.1)",
        border: "1px solid #e5e7eb"
      },
      children: [
        (0, import_jsx_runtime8.jsx)("h3", { style: { fontWeight: "600", color: "#1f2937", margin: "0 0 8px 0" }, children: doc.name || `Document ${index3 + 1}` }),
        doc.content && (0, import_jsx_runtime8.jsx)(
          "pre",
          {
            style: {
              padding: "12px",
              backgroundColor: "#f9fafb",
              borderRadius: "4px",
              fontSize: "12px",
              overflowX: "auto",
              margin: 0
            },
            children: doc.content
          }
        )
      ]
    },
    index3
  )) });
}

// node_modules/@copilotkit/react-core/dist/chunk-DXEQPN43.mjs
var import_react10 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var INSPECTOR_HIDE_KEY = "cpk:inspector:hidden";
function ConsoleTrigger({ position: position4 = "bottom-right" }) {
  const context = useCopilotContext();
  const hasApiKey = Boolean(context.copilotApiConfig.publicApiKey);
  const [isModalOpen, setIsModalOpen] = (0, import_react10.useState)(false);
  const [isHovered, setIsHovered] = (0, import_react10.useState)(false);
  const [isDragging, setIsDragging] = (0, import_react10.useState)(false);
  const [buttonPosition, setButtonPosition] = (0, import_react10.useState)(null);
  const [mounted, setMounted] = (0, import_react10.useState)(false);
  const [isHidden, setIsHidden] = (0, import_react10.useState)(false);
  const dragRef = (0, import_react10.useRef)(null);
  const buttonRef = (0, import_react10.useRef)(null);
  (0, import_react10.useEffect)(() => {
    setMounted(true);
    try {
      const hidden = typeof window !== "undefined" ? localStorage.getItem(INSPECTOR_HIDE_KEY) : null;
      if (hidden === "1" || hidden === "true") {
        setIsHidden(true);
      }
    } catch (e3) {
    }
    if (typeof window !== "undefined" && !buttonPosition) {
      const buttonSize = 60;
      const margin = 24;
      const initialPosition = {
        x: margin,
        y: window.innerHeight - buttonSize - margin
      };
      setButtonPosition(initialPosition);
    }
  }, [position4]);
  const handleMouseDown = (e3) => {
    e3.preventDefault();
    if (!buttonPosition)
      return;
    dragRef.current = {
      startX: e3.clientX,
      startY: e3.clientY,
      buttonX: buttonPosition.x,
      buttonY: buttonPosition.y
    };
    setIsDragging(true);
  };
  (0, import_react10.useEffect)(() => {
    if (!isDragging)
      return;
    const handleMouseMove = (e3) => {
      e3.preventDefault();
      e3.stopPropagation();
      if (!dragRef.current)
        return;
      const deltaX = e3.clientX - dragRef.current.startX;
      const deltaY = e3.clientY - dragRef.current.startY;
      let newX = dragRef.current.buttonX + deltaX;
      let newY = dragRef.current.buttonY + deltaY;
      newX = Math.max(0, Math.min(newX, window.innerWidth - 60));
      newY = Math.max(0, Math.min(newY, window.innerHeight - 60));
      setButtonPosition({ x: newX, y: newY });
    };
    const handleMouseUp = (e3) => {
      e3.preventDefault();
      e3.stopPropagation();
      setIsDragging(false);
      dragRef.current = null;
    };
    document.addEventListener("mousemove", handleMouseMove, { capture: true, passive: false });
    document.addEventListener("mouseup", handleMouseUp, { capture: true, passive: false });
    return () => {
      document.removeEventListener("mousemove", handleMouseMove, { capture: true });
      document.removeEventListener("mouseup", handleMouseUp, { capture: true });
    };
  }, [isDragging]);
  if (!mounted || !buttonPosition || isHidden) {
    return null;
  }
  return (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [
    (0, import_jsx_runtime9.jsxs)(
      "button",
      {
        ref: buttonRef,
        onClick: (e3) => {
          if (!isDragging) {
            if (e3.metaKey || e3.altKey) {
              try {
                localStorage.setItem(INSPECTOR_HIDE_KEY, "1");
              } catch (e22) {
              }
              setIsHidden(true);
              return;
            }
            setIsModalOpen(true);
          }
        },
        onContextMenu: (e3) => {
          e3.preventDefault();
          try {
            localStorage.setItem(INSPECTOR_HIDE_KEY, "1");
          } catch (e22) {
          }
          setIsHidden(true);
        },
        onMouseDown: handleMouseDown,
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
        style: {
          position: "fixed",
          left: `${buttonPosition.x}px`,
          top: `${buttonPosition.y}px`,
          zIndex: 2147483647,
          width: "60px",
          height: "60px",
          background: isDragging ? "#000000" : isHovered ? "#111111" : "#000000",
          color: "white",
          borderRadius: "50%",
          boxShadow: isDragging ? "0 8px 32px rgba(0, 0, 0, 0.6), 0 4px 16px rgba(0, 0, 0, 0.4)" : isHovered ? "0 12px 40px rgba(0, 0, 0, 0.7), 0 6px 20px rgba(0, 0, 0, 0.5)" : "0 6px 20px rgba(0, 0, 0, 0.5), 0 3px 10px rgba(0, 0, 0, 0.3)",
          transition: isDragging ? "none" : "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          border: "none",
          cursor: isDragging ? "grabbing" : "grab",
          opacity: 1,
          userSelect: "none",
          transform: isDragging ? "scale(1.05)" : isHovered ? "scale(1.1)" : "scale(1)",
          backdropFilter: "blur(10px)",
          pointerEvents: "auto",
          isolation: "isolate"
        },
        title: hasApiKey ? "Open Inspector (Drag to move)" : "Inspector (License Key Required, Drag to move)",
        children: [
          (0, import_jsx_runtime9.jsx)(
            "div",
            {
              onClick: (e3) => {
                e3.preventDefault();
                e3.stopPropagation();
                try {
                  localStorage.setItem(INSPECTOR_HIDE_KEY, "1");
                } catch (e22) {
                }
                setIsHidden(true);
              },
              style: {
                position: "absolute",
                bottom: "2px",
                right: "2px",
                width: "20px",
                height: "20px",
                borderRadius: "50%",
                background: "#ffffff",
                color: "#ef4444",
                fontSize: "14px",
                lineHeight: "18px",
                textAlign: "center",
                boxShadow: "0 2px 6px rgba(0,0,0,0.35)",
                cursor: "pointer",
                border: "1px solid #e5e7eb",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                zIndex: 1
              },
              title: "Hide Inspector",
              children: ""
            }
          ),
          (0, import_jsx_runtime9.jsx)(
            "div",
            {
              style: {
                width: "28px",
                height: "28px",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                filter: "drop-shadow(0 2px 4px rgba(0,0,0,0.2))"
              },
              children: (0, import_jsx_runtime9.jsx)(CopilotKitIcon, {})
            }
          ),
          !hasApiKey && (0, import_jsx_runtime9.jsx)(
            "div",
            {
              style: {
                position: "absolute",
                top: "-2px",
                right: "-2px",
                width: "18px",
                height: "18px",
                background: "linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%)",
                borderRadius: "50%",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                boxShadow: "0 2px 8px rgba(255, 107, 107, 0.4)",
                border: "2px solid white"
              },
              children: (0, import_jsx_runtime9.jsx)("span", { style: { fontSize: "10px", color: "white", fontWeight: "bold" }, children: "!" })
            }
          )
        ]
      }
    ),
    (0, import_jsx_runtime9.jsx)(
      DeveloperConsoleModal,
      {
        isOpen: isModalOpen,
        onClose: () => setIsModalOpen(false),
        hasApiKey
      }
    )
  ] });
}

// node_modules/@copilotkit/react-core/dist/chunk-RKTVJRK7.mjs
var import_react11 = __toESM(require_react(), 1);
var removeNode = (nodes, id) => {
  return nodes.reduce((result, node2) => {
    if (node2.id !== id) {
      const newNode = __spreadProps(__spreadValues({}, node2), { children: removeNode(node2.children, id) });
      result.push(newNode);
    }
    return result;
  }, []);
};
var addNode = (nodes, newNode, parentId) => {
  if (!parentId) {
    return [...nodes, newNode];
  }
  return nodes.map((node2) => {
    if (node2.id === parentId) {
      return __spreadProps(__spreadValues({}, node2), { children: [...node2.children, newNode] });
    } else if (node2.children.length) {
      return __spreadProps(__spreadValues({}, node2), { children: addNode(node2.children, newNode, parentId) });
    }
    return node2;
  });
};
var treeIndentationRepresentation = (index3, indentLevel) => {
  if (indentLevel === 0) {
    return (index3 + 1).toString();
  } else if (indentLevel === 1) {
    return String.fromCharCode(65 + index3);
  } else if (indentLevel === 2) {
    return String.fromCharCode(97 + index3);
  } else {
    return "-";
  }
};
var printNode = (node2, prefix = "", indentLevel = 0) => {
  const indent2 = " ".repeat(3).repeat(indentLevel);
  const prefixPlusIndentLength = prefix.length + indent2.length;
  const subsequentLinesPrefix = " ".repeat(prefixPlusIndentLength);
  const valueLines = node2.value.split("\n");
  const outputFirstLine = `${indent2}${prefix}${valueLines[0]}`;
  const outputSubsequentLines = valueLines.slice(1).map((line2) => `${subsequentLinesPrefix}${line2}`).join("\n");
  let output = `${outputFirstLine}
`;
  if (outputSubsequentLines) {
    output += `${outputSubsequentLines}
`;
  }
  const childPrePrefix = " ".repeat(prefix.length);
  node2.children.forEach(
    (child, index3) => output += printNode(
      child,
      `${childPrePrefix}${treeIndentationRepresentation(index3, indentLevel + 1)}. `,
      indentLevel + 1
    )
  );
  return output;
};
function treeReducer(state, action) {
  switch (action.type) {
    case "ADD_NODE": {
      const { value: value2, parentId, id: newNodeId } = action;
      const newNode = {
        id: newNodeId,
        value: value2,
        children: [],
        categories: new Set(action.categories)
      };
      try {
        return addNode(state, newNode, parentId);
      } catch (error2) {
        console.error(`Error while adding node with id ${newNodeId}: ${error2}`);
        return state;
      }
    }
    case "REMOVE_NODE":
      return removeNode(state, action.id);
    default:
      return state;
  }
}
var useTree = () => {
  const [tree, dispatch2] = (0, import_react11.useReducer)(treeReducer, []);
  const addElement = (0, import_react11.useCallback)(
    (value2, categories, parentId) => {
      const newNodeId = randomId();
      dispatch2({
        type: "ADD_NODE",
        value: value2,
        parentId,
        id: newNodeId,
        categories
      });
      return newNodeId;
    },
    []
  );
  const removeElement = (0, import_react11.useCallback)((id) => {
    dispatch2({ type: "REMOVE_NODE", id });
  }, []);
  const getAllElements = (0, import_react11.useCallback)(() => {
    return tree;
  }, [tree]);
  const printTree = (0, import_react11.useCallback)(
    (categories) => {
      const categoriesSet = new Set(categories);
      let output = "";
      tree.forEach((node2, index3) => {
        if (!setsHaveIntersection(categoriesSet, node2.categories)) {
          return;
        }
        if (index3 !== 0) {
          output += "\n";
        }
        output += printNode(node2, `${treeIndentationRepresentation(index3, 0)}. `);
      });
      return output;
    },
    [tree]
  );
  return { tree, addElement, printTree, removeElement, getAllElements };
};
var use_tree_default = useTree;
function setsHaveIntersection(setA, setB) {
  const [smallerSet, largerSet] = setA.size <= setB.size ? [setA, setB] : [setB, setA];
  for (let item of smallerSet) {
    if (largerSet.has(item)) {
      return true;
    }
  }
  return false;
}

// node_modules/@copilotkit/react-core/dist/chunk-5FHSUKQL.mjs
var import_react12 = __toESM(require_react(), 1);
var useFlatCategoryStore = () => {
  const [elements, dispatch2] = (0, import_react12.useReducer)(flatCategoryStoreReducer, /* @__PURE__ */ new Map());
  const addElement = (0, import_react12.useCallback)((value2, categories) => {
    const newId = randomId();
    dispatch2({
      type: "ADD_ELEMENT",
      value: value2,
      id: newId,
      categories
    });
    return newId;
  }, []);
  const removeElement = (0, import_react12.useCallback)((id) => {
    dispatch2({ type: "REMOVE_ELEMENT", id });
  }, []);
  const allElements = (0, import_react12.useCallback)(
    (categories) => {
      const categoriesSet = new Set(categories);
      const result = [];
      elements.forEach((element2) => {
        if (setsHaveIntersection2(categoriesSet, element2.categories)) {
          result.push(element2.value);
        }
      });
      return result;
    },
    [elements]
  );
  return { addElement, removeElement, allElements };
};
var use_flat_category_store_default = useFlatCategoryStore;
function flatCategoryStoreReducer(state, action) {
  switch (action.type) {
    case "ADD_ELEMENT": {
      const { value: value2, id, categories } = action;
      const newElement = {
        id,
        value: value2,
        categories: new Set(categories)
      };
      const newState = new Map(state);
      newState.set(id, newElement);
      return newState;
    }
    case "REMOVE_ELEMENT": {
      const newState = new Map(state);
      newState.delete(action.id);
      return newState;
    }
    default:
      return state;
  }
}
function setsHaveIntersection2(setA, setB) {
  const [smallerSet, largerSet] = setA.size <= setB.size ? [setA, setB] : [setB, setA];
  for (let item of smallerSet) {
    if (largerSet.has(item)) {
      return true;
    }
  }
  return false;
}

// node_modules/@copilotkit/react-core/dist/chunk-6ESSSQ7Q.mjs
var import_react13 = __toESM(require_react(), 1);
var useCopilotRuntimeClient = (options) => {
  const { setBannerError } = useToast();
  const _a2 = options, { showDevConsole, onError } = _a2, runtimeOptions = __objRest(_a2, ["showDevConsole", "onError"]);
  const lastStructuredErrorRef = (0, import_react13.useRef)(null);
  const traceUIError = (error2, originalError) => __async(void 0, null, function* () {
    try {
      const errorEvent = {
        type: "error",
        timestamp: Date.now(),
        context: {
          source: "ui",
          request: {
            operation: "runtimeClient",
            url: runtimeOptions.url,
            startTime: Date.now()
          },
          technical: {
            environment: "browser",
            userAgent: typeof navigator !== "undefined" ? navigator.userAgent : void 0,
            stackTrace: originalError instanceof Error ? originalError.stack : void 0
          }
        },
        error: error2
      };
      yield onError(errorEvent);
    } catch (error22) {
      console.error("Error in onError handler:", error22);
    }
  });
  const runtimeClient = (0, import_react13.useMemo)(() => {
    return new CopilotRuntimeClient(__spreadProps(__spreadValues({}, runtimeOptions), {
      handleGQLErrors: (error2) => {
        var _a22;
        if ((_a22 = error2.graphQLErrors) == null ? void 0 : _a22.length) {
          const graphQLErrors = error2.graphQLErrors;
          const routeError = (gqlError) => {
            const extensions = gqlError.extensions;
            const visibility = extensions == null ? void 0 : extensions.visibility;
            if (visibility === ErrorVisibility.SILENT) {
              console.error("CopilotKit Silent Error:", gqlError.message);
              return;
            }
            const now = Date.now();
            const errorMessage = gqlError.message;
            if (lastStructuredErrorRef.current && lastStructuredErrorRef.current.message === errorMessage && now - lastStructuredErrorRef.current.timestamp < 150) {
              return;
            }
            lastStructuredErrorRef.current = { message: errorMessage, timestamp: now };
            const ckError = createStructuredError(gqlError);
            if (ckError) {
              setBannerError(ckError);
              traceUIError(ckError, gqlError);
            } else {
              const fallbackError = new CopilotKitError({
                message: gqlError.message,
                code: CopilotKitErrorCode.UNKNOWN
              });
              setBannerError(fallbackError);
              traceUIError(fallbackError, gqlError);
            }
          };
          graphQLErrors.forEach(routeError);
        } else {
          const fallbackError = new CopilotKitError({
            message: (error2 == null ? void 0 : error2.message) || String(error2),
            code: CopilotKitErrorCode.UNKNOWN
          });
          setBannerError(fallbackError);
          traceUIError(fallbackError, error2);
        }
      },
      handleGQLWarning: (message2) => {
        console.warn(message2);
        const warningError = new CopilotKitError({
          message: message2,
          code: CopilotKitErrorCode.UNKNOWN
        });
        setBannerError(warningError);
      }
    }));
  }, [runtimeOptions, setBannerError, onError]);
  return runtimeClient;
};
function createStructuredError(gqlError) {
  var _a2, _b2, _c;
  const extensions = gqlError.extensions;
  const originalError = extensions == null ? void 0 : extensions.originalError;
  const message2 = (originalError == null ? void 0 : originalError.message) || gqlError.message;
  const code2 = extensions == null ? void 0 : extensions.code;
  if (code2) {
    return new CopilotKitError({ message: message2, code: code2 });
  }
  if ((_a2 = originalError == null ? void 0 : originalError.stack) == null ? void 0 : _a2.includes("CopilotApiDiscoveryError")) {
    return new CopilotKitApiDiscoveryError({ message: message2 });
  }
  if ((_b2 = originalError == null ? void 0 : originalError.stack) == null ? void 0 : _b2.includes("CopilotKitRemoteEndpointDiscoveryError")) {
    return new CopilotKitRemoteEndpointDiscoveryError({ message: message2 });
  }
  if ((_c = originalError == null ? void 0 : originalError.stack) == null ? void 0 : _c.includes("CopilotKitAgentDiscoveryError")) {
    return new CopilotKitAgentDiscoveryError({
      agentName: "",
      availableAgents: []
    });
  }
  return null;
}

// node_modules/@copilotkit/react-core/dist/chunk-CI4KD357.mjs
var import_react14 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var reloadSuggestions = (context, chatSuggestionConfiguration, setCurrentSuggestions, abortControllerRef) => __async(void 0, null, function* () {
  const abortController = abortControllerRef.current;
  if (abortController == null ? void 0 : abortController.signal.aborted) {
    return;
  }
  const setSuggestionsIfNotAborted = (suggestions) => {
    if (!(abortController == null ? void 0 : abortController.signal.aborted) && abortControllerRef.current === abortController) {
      setCurrentSuggestions(suggestions);
    }
  };
  try {
    const tools = JSON.stringify(
      Object.values(context.actions).map((action) => ({
        name: action.name,
        description: action.description,
        jsonSchema: JSON.stringify(actionParametersToJsonSchema(action.parameters))
      }))
    );
    const allSuggestions = [];
    let hasSuccessfulSuggestions = false;
    let hasErrors = false;
    let lastError = null;
    const enabledConfigs = Object.values(chatSuggestionConfiguration).filter(
      (config) => config.instructions && config.instructions.trim().length > 0
    );
    if (enabledConfigs.length === 0) {
      return;
    }
    setSuggestionsIfNotAborted([]);
    for (const config of enabledConfigs) {
      if (abortController == null ? void 0 : abortController.signal.aborted) {
        setSuggestionsIfNotAborted([]);
        return;
      }
      try {
        const result = yield extract2({
          context,
          instructions: "Suggest what the user could say next. Provide clear, highly relevant suggestions. Do not literally suggest function calls. ",
          data: `${config.instructions}

Available tools: ${tools}

`,
          requestType: CopilotRequestType.Task,
          parameters: [
            {
              name: "suggestions",
              type: "object[]",
              attributes: [
                {
                  name: "title",
                  description: "The title of the suggestion. This is shown as a button and should be short.",
                  type: "string"
                },
                {
                  name: "message",
                  description: "The message to send when the suggestion is clicked. This should be a clear, complete sentence and will be sent as an instruction to the AI.",
                  type: "string"
                }
              ]
            }
          ],
          include: {
            messages: true,
            readable: true
          },
          abortSignal: abortController == null ? void 0 : abortController.signal,
          stream: ({ status, args }) => {
            if (abortController == null ? void 0 : abortController.signal.aborted) {
              return;
            }
            const suggestions = args.suggestions || [];
            const newSuggestions = [];
            for (let i3 = 0; i3 < suggestions.length; i3++) {
              if (config.maxSuggestions !== void 0 && i3 >= config.maxSuggestions) {
                break;
              }
              const suggestion = suggestions[i3];
              if (!suggestion || typeof suggestion !== "object") {
                continue;
              }
              const { title, message: message2 } = suggestion;
              const hasValidTitle = title && typeof title === "string" && title.trim().length > 0;
              const hasValidMessage = message2 && typeof message2 === "string" && message2.trim().length > 0;
              if (!hasValidTitle) {
                continue;
              }
              const partial = i3 === suggestions.length - 1 && status !== "complete";
              newSuggestions.push({
                title: title.trim(),
                message: hasValidMessage ? message2.trim() : "",
                // Use title as fallback
                partial,
                className: config.className
              });
            }
            setSuggestionsIfNotAborted([...allSuggestions, ...newSuggestions]);
          }
        });
        if ((result == null ? void 0 : result.suggestions) && Array.isArray(result.suggestions)) {
          const validSuggestions = result.suggestions.filter(
            (suggestion) => suggestion && typeof suggestion.title === "string" && suggestion.title.trim().length > 0
          ).map((suggestion) => ({
            title: suggestion.title.trim(),
            message: suggestion.message && typeof suggestion.message === "string" && suggestion.message.trim() ? suggestion.message.trim() : suggestion.title.trim()
          }));
          if (validSuggestions.length > 0) {
            allSuggestions.push(...validSuggestions);
            hasSuccessfulSuggestions = true;
          }
        }
      } catch (error2) {
        hasErrors = true;
        lastError = error2 instanceof Error ? error2 : new Error(String(error2));
      }
    }
    if (hasSuccessfulSuggestions && allSuggestions.length > 0) {
      const uniqueSuggestions = allSuggestions.filter(
        (suggestion, index3, self) => index3 === self.findIndex((s) => s.message === suggestion.message)
      );
      setSuggestionsIfNotAborted(uniqueSuggestions);
    } else if (hasErrors) {
      const errorMessage = lastError ? lastError.message : "Failed to generate suggestions due to API errors";
      throw new Error(errorMessage);
    }
  } catch (error2) {
    throw error2;
  }
});
function CopilotKit(_a2) {
  var _b2 = _a2, { children } = _b2, props = __objRest(_b2, ["children"]);
  const enabled = shouldShowDevConsole(props.showDevConsole);
  const publicApiKey = props.publicApiKey || props.publicLicenseKey;
  return (0, import_jsx_runtime10.jsx)(ToastProvider, { enabled, children: (0, import_jsx_runtime10.jsx)(CopilotErrorBoundary, { publicApiKey, showUsageBanner: enabled, children: (0, import_jsx_runtime10.jsx)(CopilotKitInternal, __spreadProps(__spreadValues({}, props), { children })) }) });
}
function CopilotKitInternal(cpkProps) {
  var _b2;
  const _a2 = cpkProps, { children } = _a2, props = __objRest(_a2, ["children"]);
  validateProps(cpkProps);
  const publicApiKey = props.publicLicenseKey || props.publicApiKey;
  const chatApiEndpoint = props.runtimeUrl || COPILOT_CLOUD_CHAT_URL;
  const [actions, setActions] = (0, import_react14.useState)({});
  const [coAgentStateRenders, setCoAgentStateRenders] = (0, import_react14.useState)({});
  const chatComponentsCache = (0, import_react14.useRef)({
    actions: {},
    coAgentStateRenders: {}
  });
  const { addElement, removeElement, printTree, getAllElements } = use_tree_default();
  const [isLoading, setIsLoading] = (0, import_react14.useState)(false);
  const [chatInstructions, setChatInstructions] = (0, import_react14.useState)("");
  const [authStates, setAuthStates] = (0, import_react14.useState)({});
  const [extensions, setExtensions] = (0, import_react14.useState)({});
  const [additionalInstructions, setAdditionalInstructions] = (0, import_react14.useState)([]);
  const {
    addElement: addDocument,
    removeElement: removeDocument,
    allElements: allDocuments
  } = use_flat_category_store_default();
  const setAction = (0, import_react14.useCallback)((id, action) => {
    setActions((prevPoints) => {
      return __spreadProps(__spreadValues({}, prevPoints), {
        [id]: action
      });
    });
  }, []);
  const removeAction = (0, import_react14.useCallback)((id) => {
    setActions((prevPoints) => {
      const newPoints = __spreadValues({}, prevPoints);
      delete newPoints[id];
      return newPoints;
    });
  }, []);
  const setCoAgentStateRender = (0, import_react14.useCallback)((id, stateRender) => {
    setCoAgentStateRenders((prevPoints) => {
      return __spreadProps(__spreadValues({}, prevPoints), {
        [id]: stateRender
      });
    });
  }, []);
  const removeCoAgentStateRender = (0, import_react14.useCallback)((id) => {
    setCoAgentStateRenders((prevPoints) => {
      const newPoints = __spreadValues({}, prevPoints);
      delete newPoints[id];
      return newPoints;
    });
  }, []);
  const getContextString = (0, import_react14.useCallback)(
    (documents2, categories) => {
      const documentsString = documents2.map((document4) => {
        return `${document4.name} (${document4.sourceApplication}):
${document4.getContents()}`;
      }).join("\n\n");
      const nonDocumentStrings = printTree(categories);
      return `${documentsString}

${nonDocumentStrings}`;
    },
    [printTree]
  );
  const addContext = (0, import_react14.useCallback)(
    (context, parentId, categories = defaultCopilotContextCategories) => {
      return addElement(context, categories, parentId);
    },
    [addElement]
  );
  const removeContext = (0, import_react14.useCallback)(
    (id) => {
      removeElement(id);
    },
    [removeElement]
  );
  const getAllContext = (0, import_react14.useCallback)(() => {
    return getAllElements();
  }, [getAllElements]);
  const getFunctionCallHandler = (0, import_react14.useCallback)(
    (customEntryPoints) => {
      return entryPointsToFunctionCallHandler(Object.values(customEntryPoints || actions));
    },
    [actions]
  );
  const getDocumentsContext = (0, import_react14.useCallback)(
    (categories) => {
      return allDocuments(categories);
    },
    [allDocuments]
  );
  const addDocumentContext = (0, import_react14.useCallback)(
    (documentPointer, categories = defaultCopilotContextCategories) => {
      return addDocument(documentPointer, categories);
    },
    [addDocument]
  );
  const removeDocumentContext = (0, import_react14.useCallback)(
    (documentId) => {
      removeDocument(documentId);
    },
    [removeDocument]
  );
  const copilotApiConfig = (0, import_react14.useMemo)(() => {
    var _a22, _b22;
    let cloud = void 0;
    if (publicApiKey) {
      cloud = {
        guardrails: {
          input: {
            restrictToTopic: {
              enabled: Boolean(props.guardrails_c),
              validTopics: ((_a22 = props.guardrails_c) == null ? void 0 : _a22.validTopics) || [],
              invalidTopics: ((_b22 = props.guardrails_c) == null ? void 0 : _b22.invalidTopics) || []
            }
          }
        }
      };
    }
    return __spreadProps(__spreadValues({
      publicApiKey
    }, cloud ? { cloud } : {}), {
      chatApiEndpoint,
      headers: props.headers || {},
      properties: props.properties || {},
      transcribeAudioUrl: props.transcribeAudioUrl,
      textToSpeechUrl: props.textToSpeechUrl,
      credentials: props.credentials
    });
  }, [
    publicApiKey,
    props.headers,
    props.properties,
    props.transcribeAudioUrl,
    props.textToSpeechUrl,
    props.credentials,
    props.cloudRestrictToTopic,
    props.guardrails_c
  ]);
  const headers = (0, import_react14.useMemo)(() => {
    const authHeaders = Object.values(authStates || {}).reduce((acc, state) => {
      if (state.status === "authenticated" && state.authHeaders) {
        return __spreadValues(__spreadValues({}, acc), Object.entries(state.authHeaders).reduce(
          (headers2, [key, value2]) => __spreadProps(__spreadValues({}, headers2), {
            [key.startsWith("X-Custom-") ? key : `X-Custom-${key}`]: value2
          }),
          {}
        ));
      }
      return acc;
    }, {});
    return __spreadValues(__spreadValues(__spreadValues({}, copilotApiConfig.headers || {}), copilotApiConfig.publicApiKey ? { [COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: copilotApiConfig.publicApiKey } : {}), authHeaders);
  }, [copilotApiConfig.headers, copilotApiConfig.publicApiKey, authStates]);
  const [internalErrorHandlers, _setInternalErrorHandler] = (0, import_react14.useState)({});
  const setInternalErrorHandler = (0, import_react14.useCallback)((handler) => {
    _setInternalErrorHandler((prev) => __spreadValues(__spreadValues({}, prev), handler));
  }, []);
  const removeInternalErrorHandler = (0, import_react14.useCallback)((key) => {
    _setInternalErrorHandler((prev) => {
      const _a22 = prev, { [key]: _removed } = _a22, rest = __objRest(_a22, [__restKey(key)]);
      return rest;
    });
  }, []);
  const onErrorRef = (0, import_react14.useRef)(props.onError);
  (0, import_react14.useEffect)(() => {
    onErrorRef.current = props.onError;
  }, [props.onError]);
  const internalHandlersRef = (0, import_react14.useRef)({});
  (0, import_react14.useEffect)(() => {
    internalHandlersRef.current = internalErrorHandlers;
  }, [internalErrorHandlers]);
  const handleErrors = (0, import_react14.useCallback)(
    (error2) => __async(this, null, function* () {
      if (copilotApiConfig.publicApiKey && onErrorRef.current) {
        try {
          yield onErrorRef.current(error2);
        } catch (e3) {
          console.error("Error in public onError handler:", e3);
        }
      }
      const handlers2 = Object.values(internalHandlersRef.current);
      yield Promise.all(
        handlers2.map(
          (h2) => Promise.resolve(h2(error2)).catch(
            (e3) => console.error("Error in internal error handler:", e3)
          )
        )
      );
    }),
    [copilotApiConfig.publicApiKey]
  );
  const runtimeClient = useCopilotRuntimeClient({
    url: copilotApiConfig.chatApiEndpoint,
    publicApiKey,
    headers,
    credentials: copilotApiConfig.credentials,
    showDevConsole: shouldShowDevConsole(props.showDevConsole),
    onError: handleErrors
  });
  const [chatSuggestionConfiguration, setChatSuggestionConfiguration] = (0, import_react14.useState)({});
  const addChatSuggestionConfiguration = (0, import_react14.useCallback)(
    (id, suggestion) => {
      setChatSuggestionConfiguration((prev) => __spreadProps(__spreadValues({}, prev), { [id]: suggestion }));
    },
    [setChatSuggestionConfiguration]
  );
  const removeChatSuggestionConfiguration = (0, import_react14.useCallback)(
    (id) => {
      setChatSuggestionConfiguration((prev) => {
        const _a22 = prev, { [id]: _ } = _a22, rest = __objRest(_a22, [__restKey(id)]);
        return rest;
      });
    },
    [setChatSuggestionConfiguration]
  );
  const [availableAgents, setAvailableAgents] = (0, import_react14.useState)([]);
  const [coagentStates, setCoagentStates] = (0, import_react14.useState)({});
  const coagentStatesRef = (0, import_react14.useRef)({});
  const setCoagentStatesWithRef = (0, import_react14.useCallback)(
    (value2) => {
      const newValue = typeof value2 === "function" ? value2(coagentStatesRef.current) : value2;
      coagentStatesRef.current = newValue;
      setCoagentStates((prev) => {
        return newValue;
      });
    },
    []
  );
  const hasLoadedAgents = (0, import_react14.useRef)(false);
  (0, import_react14.useEffect)(() => {
    if (hasLoadedAgents.current)
      return;
    const fetchData = () => __async(this, null, function* () {
      var _a22;
      const result = yield runtimeClient.availableAgents();
      if ((_a22 = result.data) == null ? void 0 : _a22.availableAgents) {
        setAvailableAgents(result.data.availableAgents.agents);
      }
      hasLoadedAgents.current = true;
    });
    void fetchData();
  }, []);
  let initialAgentSession = null;
  if (props.agent) {
    initialAgentSession = {
      agentName: props.agent
    };
  }
  const [agentSession, setAgentSession] = (0, import_react14.useState)(initialAgentSession);
  (0, import_react14.useEffect)(() => {
    if (props.agent) {
      setAgentSession({
        agentName: props.agent
      });
    } else {
      setAgentSession(null);
    }
  }, [props.agent]);
  const [internalThreadId, setInternalThreadId] = (0, import_react14.useState)(props.threadId || randomUUID2());
  const setThreadId = (0, import_react14.useCallback)(
    (value2) => {
      if (props.threadId) {
        throw new Error("Cannot call setThreadId() when threadId is provided via props.");
      }
      setInternalThreadId(value2);
    },
    [props.threadId]
  );
  (0, import_react14.useEffect)(() => {
    if (props.threadId !== void 0) {
      setInternalThreadId(props.threadId);
    }
  }, [props.threadId]);
  const [runId, setRunId] = (0, import_react14.useState)(null);
  const chatAbortControllerRef = (0, import_react14.useRef)(null);
  const showDevConsole = shouldShowDevConsole(props.showDevConsole);
  const [langGraphInterruptActions, _setLangGraphInterruptAction] = (0, import_react14.useState)({});
  const setLangGraphInterruptAction = (0, import_react14.useCallback)(
    (threadId, action) => {
      _setLangGraphInterruptAction((prev) => {
        var _a22, _b22, _c;
        if (action == null)
          return __spreadProps(__spreadValues({}, prev), {
            [threadId]: null
          });
        let event = (_a22 = prev[threadId]) == null ? void 0 : _a22.event;
        if (action.event) {
          event = __spreadValues(__spreadValues({}, ((_b22 = prev[threadId]) == null ? void 0 : _b22.event) || {}), action.event);
        }
        return __spreadProps(__spreadValues({}, prev), {
          [threadId]: __spreadProps(__spreadValues(__spreadValues({}, (_c = prev[threadId]) != null ? _c : {}), action), { event })
        });
      });
    },
    []
  );
  const removeLangGraphInterruptAction = (0, import_react14.useCallback)((threadId) => {
    setLangGraphInterruptAction(threadId, null);
  }, []);
  const memoizedChildren = (0, import_react14.useMemo)(() => children, [children]);
  const [bannerError, setBannerError] = (0, import_react14.useState)(null);
  const agentLock = (0, import_react14.useMemo)(() => {
    var _a22;
    return (_a22 = props.agent) != null ? _a22 : null;
  }, [props.agent]);
  const forwardedParameters = (0, import_react14.useMemo)(
    () => {
      var _a22;
      return (_a22 = props.forwardedParameters) != null ? _a22 : {};
    },
    [props.forwardedParameters]
  );
  const updateExtensions = (0, import_react14.useCallback)(
    (newExtensions) => {
      setExtensions((prev) => {
        const resolved = typeof newExtensions === "function" ? newExtensions(prev) : newExtensions;
        const isSameLength = Object.keys(resolved).length === Object.keys(prev).length;
        const isEqual = isSameLength && // @ts-ignore
        Object.entries(resolved).every(([key, value2]) => prev[key] === value2);
        return isEqual ? prev : resolved;
      });
    },
    [setExtensions]
  );
  const updateAuthStates = (0, import_react14.useCallback)(
    (newAuthStates) => {
      setAuthStates((prev) => {
        const resolved = typeof newAuthStates === "function" ? newAuthStates(prev) : newAuthStates;
        const isSameLength = Object.keys(resolved).length === Object.keys(prev).length;
        const isEqual = isSameLength && // @ts-ignore
        Object.entries(resolved).every(([key, value2]) => prev[key] === value2);
        return isEqual ? prev : resolved;
      });
    },
    [setAuthStates]
  );
  return (0, import_jsx_runtime10.jsxs)(
    CopilotContext.Provider,
    {
      value: {
        actions,
        chatComponentsCache,
        getFunctionCallHandler,
        setAction,
        removeAction,
        coAgentStateRenders,
        setCoAgentStateRender,
        removeCoAgentStateRender,
        getContextString,
        addContext,
        removeContext,
        getAllContext,
        getDocumentsContext,
        addDocumentContext,
        removeDocumentContext,
        copilotApiConfig,
        isLoading,
        setIsLoading,
        chatSuggestionConfiguration,
        addChatSuggestionConfiguration,
        removeChatSuggestionConfiguration,
        chatInstructions,
        setChatInstructions,
        additionalInstructions,
        setAdditionalInstructions,
        showDevConsole,
        coagentStates,
        setCoagentStates,
        coagentStatesRef,
        setCoagentStatesWithRef,
        agentSession,
        setAgentSession,
        runtimeClient,
        forwardedParameters,
        agentLock,
        threadId: internalThreadId,
        setThreadId,
        runId,
        setRunId,
        chatAbortControllerRef,
        availableAgents,
        authConfig_c: props.authConfig_c,
        authStates_c: authStates,
        setAuthStates_c: updateAuthStates,
        extensions,
        setExtensions: updateExtensions,
        langGraphInterruptAction: (_b2 = langGraphInterruptActions[internalThreadId]) != null ? _b2 : null,
        setLangGraphInterruptAction,
        removeLangGraphInterruptAction,
        bannerError,
        setBannerError,
        onError: handleErrors,
        internalErrorHandlers,
        setInternalErrorHandler,
        removeInternalErrorHandler
      },
      children: [
        (0, import_jsx_runtime10.jsx)(MessagesTapProvider, { children: (0, import_jsx_runtime10.jsxs)(CopilotMessages, { children: [
          memoizedChildren,
          showDevConsole && (0, import_jsx_runtime10.jsx)(ConsoleTrigger, {})
        ] }) }),
        bannerError && showDevConsole && (0, import_jsx_runtime10.jsx)(
          UsageBanner,
          {
            severity: bannerError.severity,
            message: bannerError.message,
            onClose: () => setBannerError(null),
            actions: getErrorActions(bannerError)
          }
        )
      ]
    }
  );
}
var defaultCopilotContextCategories = ["global"];
function entryPointsToFunctionCallHandler(actions) {
  return (_0) => __async(this, [_0], function* ({ name: name2, args }) {
    let actionsByFunctionName = {};
    for (let action2 of actions) {
      actionsByFunctionName[action2.name] = action2;
    }
    const action = actionsByFunctionName[name2];
    let result = void 0;
    if (action) {
      yield new Promise((resolve, reject) => {
        (0, import_react_dom.flushSync)(() => __async(this, null, function* () {
          var _a2;
          try {
            result = yield (_a2 = action.handler) == null ? void 0 : _a2.call(action, args);
            resolve();
          } catch (error2) {
            reject(error2);
          }
        }));
      });
      yield new Promise((resolve) => setTimeout(resolve, 20));
    }
    return result;
  });
}
function formatFeatureName(featureName) {
  return featureName.replace(/_c$/, "").split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(" ");
}
function validateProps(props) {
  const cloudFeatures = Object.keys(props).filter((key) => key.endsWith("_c"));
  const hasApiKey = props.publicApiKey || props.publicLicenseKey;
  if (!props.runtimeUrl && !hasApiKey) {
    throw new ConfigurationError(
      "Missing required prop: 'runtimeUrl' or 'publicApiKey' or 'publicLicenseKey'"
    );
  }
  if (cloudFeatures.length > 0 && !hasApiKey) {
    throw new MissingPublicApiKeyError(
      `Missing required prop: 'publicApiKey' or 'publicLicenseKey' to use cloud features: ${cloudFeatures.map(formatFeatureName).join(", ")}`
    );
  }
}
function extract2(_0) {
  return __async(this, arguments, function* ({
    context,
    instructions,
    parameters,
    include,
    data,
    abortSignal,
    stream,
    requestType = CopilotRequestType.Task,
    forwardedParameters
  }) {
    var _a2, _b2;
    const { messages } = context;
    const action = {
      name: "extract",
      description: instructions,
      parameters,
      handler: (args) => {
      }
    };
    const includeReadable = (_a2 = include == null ? void 0 : include.readable) != null ? _a2 : false;
    const includeMessages = (_b2 = include == null ? void 0 : include.messages) != null ? _b2 : false;
    let contextString = "";
    if (data) {
      contextString = (typeof data === "string" ? data : JSON.stringify(data)) + "\n\n";
    }
    if (includeReadable) {
      contextString += context.getContextString([], defaultCopilotContextCategories);
    }
    const systemMessage = new TextMessage({
      content: makeSystemMessage(contextString, instructions),
      role: Role.System
    });
    const instructionsMessage = new TextMessage({
      content: makeInstructionsMessage(instructions),
      role: Role.User
    });
    const response = context.runtimeClient.asStream(
      context.runtimeClient.generateCopilotResponse({
        data: {
          frontend: {
            actions: [
              {
                name: action.name,
                description: action.description || "",
                jsonSchema: JSON.stringify(actionParametersToJsonSchema(action.parameters || []))
              }
            ],
            url: window.location.href
          },
          messages: convertMessagesToGqlInput(
            includeMessages ? [systemMessage, instructionsMessage, ...filterAgentStateMessages(messages)] : [systemMessage, instructionsMessage]
          ),
          metadata: {
            requestType
          },
          forwardedParameters: __spreadProps(__spreadValues({}, forwardedParameters != null ? forwardedParameters : {}), {
            toolChoice: "function",
            toolChoiceFunctionName: action.name
          })
        },
        properties: context.copilotApiConfig.properties,
        signal: abortSignal
      })
    );
    const reader = response.getReader();
    let isInitial = true;
    let actionExecutionMessage = void 0;
    while (true) {
      const { done, value: value2 } = yield reader.read();
      if (done) {
        break;
      }
      if (abortSignal == null ? void 0 : abortSignal.aborted) {
        throw new Error("Aborted");
      }
      actionExecutionMessage = convertGqlOutputToMessages(
        value2.generateCopilotResponse.messages
      ).find((msg) => msg.isActionExecutionMessage());
      if (!actionExecutionMessage) {
        continue;
      }
      stream == null ? void 0 : stream({
        status: isInitial ? "initial" : "inProgress",
        args: actionExecutionMessage.arguments
      });
      isInitial = false;
    }
    if (!actionExecutionMessage) {
      throw new Error("extract() failed: No function call occurred");
    }
    stream == null ? void 0 : stream({
      status: "complete",
      args: actionExecutionMessage.arguments
    });
    return actionExecutionMessage.arguments;
  });
}
function makeInstructionsMessage(instructions) {
  return `
The user has given you the following task to complete:

\`\`\`
${instructions}
\`\`\`

Any additional messages provided are for providing context only and should not be used to ask questions or engage in conversation.
`;
}
function makeSystemMessage(contextString, instructions) {
  return `
Please act as an efficient, competent, conscientious, and industrious professional assistant.

Help the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.
Always be polite and respectful, and prefer brevity over verbosity.

The user has provided you with the following context:
\`\`\`
${contextString}
\`\`\`

They have also provided you with a function called extract you MUST call to initiate actions on their behalf.

Please assist them as best you can.

This is not a conversation, so please do not ask questions. Just call the function without saying anything else.
`;
}

// node_modules/@copilotkit/react-core/dist/chunk-N5HOP3PG.mjs
var CopilotTask = class {
  constructor(config) {
    this.instructions = config.instructions;
    this.actions = config.actions || [];
    this.includeCopilotReadable = config.includeCopilotReadable !== false;
    this.includeCopilotActions = config.includeCopilotActions !== false;
    this.forwardedParameters = config.forwardedParameters;
  }
  /**
   * Run the task.
   * @param context The CopilotContext to use for the task. Use `useCopilotContext` to obtain the current context.
   * @param data The data to use for the task.
   */
  run(context, data) {
    return __async(this, null, function* () {
      var _a2, _b2, _c;
      const actions = this.includeCopilotActions ? Object.assign({}, context.actions) : {};
      for (const fn of this.actions) {
        actions[fn.name] = fn;
      }
      let contextString = "";
      if (data) {
        contextString = (typeof data === "string" ? data : JSON.stringify(data)) + "\n\n";
      }
      if (this.includeCopilotReadable) {
        contextString += context.getContextString([], defaultCopilotContextCategories);
      }
      const systemMessage = new TextMessage({
        content: taskSystemMessage(contextString, this.instructions),
        role: Role.System
      });
      const messages = [systemMessage];
      const runtimeClient = new CopilotRuntimeClient({
        url: context.copilotApiConfig.chatApiEndpoint,
        publicApiKey: context.copilotApiConfig.publicApiKey,
        headers: context.copilotApiConfig.headers,
        credentials: context.copilotApiConfig.credentials
      });
      const response = yield runtimeClient.generateCopilotResponse({
        data: {
          frontend: {
            actions: processActionsForRuntimeRequest(Object.values(actions)),
            url: window.location.href
          },
          messages: convertMessagesToGqlInput(filterAgentStateMessages(messages)),
          metadata: {
            requestType: CopilotRequestType.Task
          },
          forwardedParameters: __spreadValues({
            // if forwardedParameters is provided, use it
            toolChoice: "required"
          }, (_a2 = this.forwardedParameters) != null ? _a2 : {})
        },
        properties: context.copilotApiConfig.properties
      }).toPromise();
      const functionCallHandler = context.getFunctionCallHandler(actions);
      const functionCalls = convertGqlOutputToMessages(
        ((_c = (_b2 = response.data) == null ? void 0 : _b2.generateCopilotResponse) == null ? void 0 : _c.messages) || []
      ).filter((m) => m.isActionExecutionMessage());
      for (const functionCall of functionCalls) {
        yield functionCallHandler({
          messages,
          name: functionCall.name,
          args: functionCall.arguments
        });
      }
    });
  }
};
function taskSystemMessage(contextString, instructions) {
  return `
Please act as an efficient, competent, conscientious, and industrious professional assistant.

Help the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.
Always be polite and respectful, and prefer brevity over verbosity.

The user has provided you with the following context:
\`\`\`
${contextString}
\`\`\`

They have also provided you with functions you can call to initiate actions on their behalf.

Please assist them as best you can.

This is not a conversation, so please do not ask questions. Just call a function without saying anything else.

The user has given you the following task to complete:

\`\`\`
${instructions}
\`\`\`
`;
}

// node_modules/@copilotkit/react-core/dist/chunk-ZVOLWJCY.mjs
var import_react15 = __toESM(require_react(), 1);
var InterruptRenderer = ({ event, result, render, resolve }) => {
  return render({ event, result, resolve });
};
function useLangGraphInterruptRender() {
  const { langGraphInterruptAction, setLangGraphInterruptAction, agentSession, threadId } = useCopilotContext();
  const responseRef = import_react15.default.useRef();
  const resolveInterrupt = (0, import_react15.useCallback)(
    (response) => {
      responseRef.current = response;
      setTimeout(() => {
        setLangGraphInterruptAction(threadId, { event: { response } });
      }, 0);
    },
    [setLangGraphInterruptAction, threadId]
  );
  if (!langGraphInterruptAction || !langGraphInterruptAction.event || !langGraphInterruptAction.render)
    return null;
  const { render, handler, event, enabled } = langGraphInterruptAction;
  const conditionsMet = !agentSession || !enabled ? true : enabled({ eventValue: event.value, agentMetadata: agentSession });
  if (!conditionsMet) {
    return null;
  }
  let result = null;
  if (handler) {
    result = handler({
      event,
      resolve: resolveInterrupt
    });
  }
  return import_react15.default.createElement(InterruptRenderer, {
    event,
    result,
    render,
    resolve: resolveInterrupt
  });
}

// node_modules/@copilotkit/react-core/dist/chunk-OT5NHMEC.mjs
var import_react16 = __toESM(require_react(), 1);
var import_react_dom2 = __toESM(require_react_dom(), 1);
function useChat(options) {
  const {
    messages,
    setMessages,
    makeSystemMessageCallback,
    copilotConfig,
    setIsLoading,
    initialMessages,
    isLoading,
    actions,
    onFunctionCall,
    onCoAgentStateRender,
    setCoagentStatesWithRef,
    coagentStatesRef,
    agentSession,
    setAgentSession,
    threadId,
    setThreadId,
    runId,
    setRunId,
    chatAbortControllerRef,
    agentLock,
    extensions,
    setExtensions,
    langGraphInterruptAction,
    setLangGraphInterruptAction,
    disableSystemMessage = false
  } = options;
  const runChatCompletionRef = (0, import_react16.useRef)();
  const addErrorToast = useErrorToast();
  const { setBannerError } = useToast();
  const { onError, showDevConsole, getAllContext } = useCopilotContext();
  const copilotReadableContext = getAllContext();
  const context = (0, import_react16.useMemo)(
    () => copilotReadableContext.map((contextItem) => {
      const [description, ...valueParts] = contextItem.value.split(":");
      return {
        description: description.trim(),
        value: valueParts.join(":").trim()
      };
    }),
    [copilotReadableContext]
  );
  const traceUIError = (error2, originalError) => __async(this, null, function* () {
    try {
      const traceEvent = {
        type: "error",
        timestamp: Date.now(),
        context: {
          source: "ui",
          request: {
            operation: "useChatCompletion",
            url: copilotConfig.chatApiEndpoint,
            startTime: Date.now()
          },
          technical: {
            environment: "browser",
            userAgent: typeof navigator !== "undefined" ? navigator.userAgent : void 0,
            stackTrace: originalError instanceof Error ? originalError.stack : void 0
          }
        },
        error: error2
      };
      yield onError(traceEvent);
    } catch (traceError) {
      console.error("Error in use-chat onError handler:", traceError);
    }
  });
  const agentSessionRef = (0, import_react16.useRef)(agentSession);
  agentSessionRef.current = agentSession;
  const runIdRef = (0, import_react16.useRef)(runId);
  runIdRef.current = runId;
  const extensionsRef = (0, import_react16.useRef)(extensions);
  extensionsRef.current = extensions;
  const publicApiKey = copilotConfig.publicApiKey;
  const headers = __spreadValues(__spreadValues({}, copilotConfig.headers || {}), publicApiKey ? { [COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: publicApiKey } : {});
  const runtimeClient = useCopilotRuntimeClient({
    url: copilotConfig.chatApiEndpoint,
    publicApiKey: copilotConfig.publicApiKey,
    headers,
    credentials: copilotConfig.credentials,
    showDevConsole,
    onError
  });
  const pendingAppendsRef = (0, import_react16.useRef)([]);
  const runChatCompletion = useAsyncCallback(
    (previousMessages) => __async(this, null, function* () {
      var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;
      setIsLoading(true);
      const interruptEvent = langGraphInterruptAction == null ? void 0 : langGraphInterruptAction.event;
      if ((interruptEvent == null ? void 0 : interruptEvent.name) === MetaEventName.LangGraphInterruptEvent && (interruptEvent == null ? void 0 : interruptEvent.value) && !(interruptEvent == null ? void 0 : interruptEvent.response) && agentSessionRef.current) {
        addErrorToast([
          new Error(
            "A message was sent while interrupt is active. This will cause failure on the agent side"
          )
        ]);
      }
      let newMessages = [
        new TextMessage({
          content: "",
          role: Role.Assistant
        })
      ];
      chatAbortControllerRef.current = new AbortController();
      setMessages([...previousMessages, ...newMessages]);
      const messagesWithContext = disableSystemMessage ? [...initialMessages || [], ...previousMessages] : [makeSystemMessageCallback(), ...initialMessages || [], ...previousMessages];
      const finalProperties = __spreadValues({}, copilotConfig.properties || {});
      let mcpServersToUse = null;
      if (copilotConfig.mcpServers && Array.isArray(copilotConfig.mcpServers) && copilotConfig.mcpServers.length > 0) {
        mcpServersToUse = copilotConfig.mcpServers;
      } else if (((_a2 = copilotConfig.properties) == null ? void 0 : _a2.mcpServers) && Array.isArray(copilotConfig.properties.mcpServers) && copilotConfig.properties.mcpServers.length > 0) {
        mcpServersToUse = copilotConfig.properties.mcpServers;
      }
      if (mcpServersToUse) {
        finalProperties.mcpServers = mcpServersToUse;
        copilotConfig.mcpServers = mcpServersToUse;
      }
      const isAgentRun = agentSessionRef.current !== null;
      const stream = runtimeClient.asStream(
        runtimeClient.generateCopilotResponse({
          data: __spreadProps(__spreadValues(__spreadProps(__spreadValues({
            frontend: {
              actions: processActionsForRuntimeRequest(actions),
              url: window.location.href
            },
            threadId,
            runId: runIdRef.current,
            extensions: extensionsRef.current,
            metaEvents: composeAndFlushMetaEventsInput([langGraphInterruptAction == null ? void 0 : langGraphInterruptAction.event]),
            messages: convertMessagesToGqlInput(filterAgentStateMessages(messagesWithContext))
          }, copilotConfig.cloud ? {
            cloud: __spreadValues({}, ((_d = (_c = (_b2 = copilotConfig.cloud.guardrails) == null ? void 0 : _b2.input) == null ? void 0 : _c.restrictToTopic) == null ? void 0 : _d.enabled) ? {
              guardrails: {
                inputValidationRules: {
                  allowList: copilotConfig.cloud.guardrails.input.restrictToTopic.validTopics,
                  denyList: copilotConfig.cloud.guardrails.input.restrictToTopic.invalidTopics
                }
              }
            } : {})
          } : {}), {
            metadata: {
              requestType: CopilotRequestType.Chat
            }
          }), agentSessionRef.current ? {
            agentSession: agentSessionRef.current
          } : {}), {
            agentStates: Object.values(coagentStatesRef.current).map((state) => {
              const stateObject = {
                agentName: state.name,
                state: JSON.stringify(state.state)
              };
              if (state.config !== void 0) {
                stateObject.config = JSON.stringify(state.config);
              }
              return stateObject;
            }),
            forwardedParameters: options.forwardedParameters || {},
            context
          }),
          properties: finalProperties,
          signal: (_e = chatAbortControllerRef.current) == null ? void 0 : _e.signal
        })
      );
      const guardrailsEnabled = ((_h = (_g = (_f = copilotConfig.cloud) == null ? void 0 : _f.guardrails) == null ? void 0 : _g.input) == null ? void 0 : _h.restrictToTopic.enabled) || false;
      const reader = stream.getReader();
      let executedCoAgentStateRenders = [];
      let followUp = void 0;
      let messages2 = [];
      let syncedMessages = [];
      let interruptMessages = [];
      try {
        while (true) {
          let done, value2;
          try {
            const readResult = yield reader.read();
            done = readResult.done;
            value2 = readResult.value;
          } catch (readError) {
            break;
          }
          if (done) {
            if (chatAbortControllerRef.current.signal.aborted) {
              return [];
            }
            break;
          }
          if (!(value2 == null ? void 0 : value2.generateCopilotResponse)) {
            continue;
          }
          runIdRef.current = value2.generateCopilotResponse.runId || null;
          extensionsRef.current = CopilotRuntimeClient.removeGraphQLTypename(
            value2.generateCopilotResponse.extensions || {}
          );
          setRunId(runIdRef.current);
          setExtensions(extensionsRef.current);
          let rawMessagesResponse = value2.generateCopilotResponse.messages;
          const metaEvents = (_j = (_i = value2.generateCopilotResponse) == null ? void 0 : _i.metaEvents) != null ? _j : [];
          (metaEvents != null ? metaEvents : []).forEach((ev) => {
            if (ev.name === MetaEventName.LangGraphInterruptEvent) {
              let eventValue = langGraphInterruptEvent(ev).value;
              eventValue = parseJson(eventValue, eventValue);
              setLangGraphInterruptAction(threadId, {
                event: __spreadProps(__spreadValues({}, langGraphInterruptEvent(ev)), {
                  value: eventValue
                })
              });
            }
            if (ev.name === MetaEventName.CopilotKitLangGraphInterruptEvent) {
              const data = ev.data;
              rawMessagesResponse = [...rawMessagesResponse, ...data.messages];
              interruptMessages = convertGqlOutputToMessages(
                // @ts-ignore
                filterAdjacentAgentStateMessages(data.messages)
              );
            }
          });
          messages2 = convertGqlOutputToMessages(
            filterAdjacentAgentStateMessages(rawMessagesResponse)
          );
          newMessages = [];
          if (((_k = value2.generateCopilotResponse.status) == null ? void 0 : _k.__typename) === "FailedResponseStatus" && value2.generateCopilotResponse.status.reason === "GUARDRAILS_VALIDATION_FAILED") {
            const guardrailsReason = ((_l = value2.generateCopilotResponse.status.details) == null ? void 0 : _l.guardrailsReason) || "";
            newMessages = [
              new TextMessage({
                role: MessageRole.Assistant,
                content: guardrailsReason
              })
            ];
            const guardrailsError = new CopilotKitError({
              message: `Guardrails validation failed: ${guardrailsReason}`,
              code: CopilotKitErrorCode.MISUSE
            });
            yield traceUIError(guardrailsError, {
              statusReason: value2.generateCopilotResponse.status.reason,
              statusDetails: value2.generateCopilotResponse.status.details
            });
            setMessages([...previousMessages, ...newMessages]);
            break;
          }
          if (((_m = value2.generateCopilotResponse.status) == null ? void 0 : _m.__typename) === "FailedResponseStatus" && value2.generateCopilotResponse.status.reason === "UNKNOWN_ERROR") {
            const errorMessage = ((_n = value2.generateCopilotResponse.status.details) == null ? void 0 : _n.description) || "An unknown error occurred";
            const statusDetails = value2.generateCopilotResponse.status.details;
            const originalError = (statusDetails == null ? void 0 : statusDetails.originalError) || (statusDetails == null ? void 0 : statusDetails.error);
            const originalCode = (originalError == null ? void 0 : originalError.code) || ((_o = originalError == null ? void 0 : originalError.extensions) == null ? void 0 : _o.code);
            const originalSeverity = (originalError == null ? void 0 : originalError.severity) || ((_p = originalError == null ? void 0 : originalError.extensions) == null ? void 0 : _p.severity);
            const originalVisibility = (originalError == null ? void 0 : originalError.visibility) || ((_q = originalError == null ? void 0 : originalError.extensions) == null ? void 0 : _q.visibility);
            let errorCode = CopilotKitErrorCode.NETWORK_ERROR;
            if (originalCode && Object.values(CopilotKitErrorCode).includes(originalCode)) {
              errorCode = originalCode;
            }
            const structuredError = new CopilotKitError({
              message: errorMessage,
              code: errorCode,
              severity: originalSeverity,
              visibility: originalVisibility
            });
            setBannerError(structuredError);
            yield traceUIError(structuredError, {
              statusReason: value2.generateCopilotResponse.status.reason,
              statusDetails: value2.generateCopilotResponse.status.details,
              originalErrorCode: originalCode,
              preservedStructure: !!originalCode
            });
            setIsLoading(false);
            throw new Error(structuredError.message);
          } else if (messages2.length > 0) {
            newMessages = [...messages2];
            for (const message2 of messages2) {
              if (message2.isAgentStateMessage() && !message2.active && !executedCoAgentStateRenders.includes(message2.id) && onCoAgentStateRender) {
                if (guardrailsEnabled && value2.generateCopilotResponse.status === void 0) {
                  break;
                }
                yield onCoAgentStateRender({
                  name: message2.agentName,
                  nodeName: message2.nodeName,
                  state: message2.state
                });
                executedCoAgentStateRenders.push(message2.id);
              }
            }
            const lastAgentStateMessage = [...messages2].reverse().find((message2) => message2.isAgentStateMessage());
            if (lastAgentStateMessage) {
              if (lastAgentStateMessage.state.messages && lastAgentStateMessage.state.messages.length > 0) {
                syncedMessages = loadMessagesFromJsonRepresentation(
                  lastAgentStateMessage.state.messages
                );
              }
              setCoagentStatesWithRef((prevAgentStates) => {
                var _a22;
                return __spreadProps(__spreadValues({}, prevAgentStates), {
                  [lastAgentStateMessage.agentName]: {
                    name: lastAgentStateMessage.agentName,
                    state: lastAgentStateMessage.state,
                    running: lastAgentStateMessage.running,
                    active: lastAgentStateMessage.active,
                    threadId: lastAgentStateMessage.threadId,
                    nodeName: lastAgentStateMessage.nodeName,
                    runId: lastAgentStateMessage.runId,
                    // Preserve existing config from previous state
                    config: (_a22 = prevAgentStates[lastAgentStateMessage.agentName]) == null ? void 0 : _a22.config
                  }
                });
              });
              if (lastAgentStateMessage.running) {
                setAgentSession({
                  threadId: lastAgentStateMessage.threadId,
                  agentName: lastAgentStateMessage.agentName,
                  nodeName: lastAgentStateMessage.nodeName
                });
              } else {
                if (agentLock) {
                  setAgentSession({
                    threadId: randomId(),
                    agentName: agentLock,
                    nodeName: void 0
                  });
                } else {
                  setAgentSession(null);
                }
              }
            }
          }
          if (newMessages.length > 0) {
            setMessages([...previousMessages, ...newMessages]);
          }
        }
        let finalMessages = constructFinalMessages(
          [...syncedMessages, ...interruptMessages],
          previousMessages,
          newMessages
        );
        let didExecuteAction = false;
        const executeActionFromMessage = (currentAction, actionMessage) => __async(this, null, function* () {
          var _a22;
          const isInterruptAction = interruptMessages.find((m) => m.id === actionMessage.id);
          followUp = (_a22 = currentAction == null ? void 0 : currentAction.followUp) != null ? _a22 : !isInterruptAction;
          if (currentAction == null ? void 0 : currentAction._setActivatingMessageId) {
            currentAction._setActivatingMessageId(actionMessage.id);
          }
          const resultMessage = yield executeAction({
            onFunctionCall,
            message: actionMessage,
            chatAbortControllerRef,
            onError: (error2) => {
              addErrorToast([error2]);
              console.error(`Failed to execute action ${actionMessage.name}: ${error2}`);
            },
            setMessages,
            getFinalMessages: () => finalMessages,
            isRenderAndWait: (currentAction == null ? void 0 : currentAction._isRenderAndWait) || false
          });
          didExecuteAction = true;
          const messageIndex = finalMessages.findIndex((msg) => msg.id === actionMessage.id);
          finalMessages.splice(messageIndex + 1, 0, resultMessage);
          if (currentAction == null ? void 0 : currentAction._isRenderAndWait) {
            const messagesForImmediateUpdate = [...finalMessages];
            (0, import_react_dom2.flushSync)(() => {
              setMessages(messagesForImmediateUpdate);
            });
          }
          if (currentAction == null ? void 0 : currentAction._setActivatingMessageId) {
            currentAction._setActivatingMessageId(null);
          }
          return resultMessage;
        });
        if (onFunctionCall) {
          const lastMessages = [];
          for (let i3 = finalMessages.length - 1; i3 >= 0; i3--) {
            const message2 = finalMessages[i3];
            if ((message2.isActionExecutionMessage() || message2.isResultMessage()) && message2.status.code !== MessageStatusCode.Pending) {
              lastMessages.unshift(message2);
            } else if (!message2.isAgentStateMessage()) {
              break;
            }
          }
          for (const message2 of lastMessages) {
            setMessages(finalMessages);
            const action = actions.find(
              (action2) => action2.name === message2.name
            );
            if (action && action.available === "frontend") {
              continue;
            }
            const currentResultMessagePairedFeAction = message2.isResultMessage() ? getPairedFeAction(actions, message2) : null;
            if (action && message2.isActionExecutionMessage()) {
              const isRenderAndWaitAction = (action == null ? void 0 : action._isRenderAndWait) || false;
              const alreadyProcessed = isRenderAndWaitAction && finalMessages.some(
                (fm) => fm.isResultMessage() && fm.actionExecutionId === message2.id
              );
              if (alreadyProcessed) {
              } else {
                const resultMessage = yield executeActionFromMessage(
                  action,
                  message2
                );
                const pairedFeAction = getPairedFeAction(actions, resultMessage);
                if (pairedFeAction) {
                  const newExecutionMessage = new ActionExecutionMessage({
                    name: pairedFeAction.name,
                    arguments: parseJson(resultMessage.result, resultMessage.result),
                    status: message2.status,
                    createdAt: message2.createdAt,
                    parentMessageId: message2.parentMessageId
                  });
                  yield executeActionFromMessage(pairedFeAction, newExecutionMessage);
                }
              }
            } else if (message2.isResultMessage() && currentResultMessagePairedFeAction) {
              const newExecutionMessage = new ActionExecutionMessage({
                name: currentResultMessagePairedFeAction.name,
                arguments: parseJson(message2.result, message2.result),
                status: message2.status,
                createdAt: message2.createdAt
              });
              finalMessages.push(newExecutionMessage);
              yield executeActionFromMessage(
                currentResultMessagePairedFeAction,
                newExecutionMessage
              );
            }
          }
          setMessages(finalMessages);
        }
        if (followUp !== false && (didExecuteAction || // the last message is a server side result
        !isAgentRun && finalMessages.length && finalMessages[finalMessages.length - 1].isResultMessage()) && // the user did not stop generation
        !((_r = chatAbortControllerRef.current) == null ? void 0 : _r.signal.aborted)) {
          yield new Promise((resolve) => setTimeout(resolve, 10));
          return yield runChatCompletionRef.current(finalMessages);
        } else if ((_s = chatAbortControllerRef.current) == null ? void 0 : _s.signal.aborted) {
          const repairedMessages = finalMessages.filter((message2, actionExecutionIndex) => {
            if (message2.isActionExecutionMessage()) {
              return finalMessages.find(
                (msg, resultIndex) => msg.isResultMessage() && msg.actionExecutionId === message2.id && resultIndex === actionExecutionIndex + 1
              );
            }
            return true;
          });
          const repairedMessageIds = repairedMessages.map((message2) => message2.id);
          setMessages(repairedMessages);
          if ((_t = agentSessionRef.current) == null ? void 0 : _t.nodeName) {
            setAgentSession({
              threadId: agentSessionRef.current.threadId,
              agentName: agentSessionRef.current.agentName,
              nodeName: "__end__"
            });
          }
          return newMessages.filter((message2) => repairedMessageIds.includes(message2.id));
        } else {
          return newMessages.slice();
        }
      } finally {
        setIsLoading(false);
      }
    }),
    [
      messages,
      setMessages,
      makeSystemMessageCallback,
      copilotConfig,
      setIsLoading,
      initialMessages,
      isLoading,
      actions,
      onFunctionCall,
      onCoAgentStateRender,
      setCoagentStatesWithRef,
      coagentStatesRef,
      agentSession,
      setAgentSession,
      disableSystemMessage,
      context
    ]
  );
  runChatCompletionRef.current = runChatCompletion;
  const runChatCompletionAndHandleFunctionCall = useAsyncCallback(
    (messages2) => __async(this, null, function* () {
      yield runChatCompletionRef.current(messages2);
    }),
    [messages]
  );
  (0, import_react16.useEffect)(() => {
    if (!isLoading && pendingAppendsRef.current.length > 0) {
      const pending = pendingAppendsRef.current.splice(0);
      const followUp = pending.some((p2) => p2.followUp);
      const newMessages = [...messages, ...pending.map((p2) => p2.message)];
      setMessages(newMessages);
      if (followUp) {
        runChatCompletionAndHandleFunctionCall(newMessages);
      }
    }
  }, [isLoading, messages, setMessages, runChatCompletionAndHandleFunctionCall]);
  const composeAndFlushMetaEventsInput = (0, import_react16.useCallback)(
    (metaEvents) => {
      return metaEvents.reduce((acc, event) => {
        if (!event)
          return acc;
        switch (event.name) {
          case MetaEventName.LangGraphInterruptEvent:
            if (event.response) {
              setLangGraphInterruptAction(threadId, null);
              const value2 = event.value;
              return [
                ...acc,
                {
                  name: event.name,
                  value: typeof value2 === "string" ? value2 : JSON.stringify(value2),
                  response: typeof event.response === "string" ? event.response : JSON.stringify(event.response)
                }
              ];
            }
            return acc;
          default:
            return acc;
        }
      }, []);
    },
    [setLangGraphInterruptAction]
  );
  const append = useAsyncCallback(
    (message2, options2) => __async(this, null, function* () {
      var _a2;
      const followUp = (_a2 = options2 == null ? void 0 : options2.followUp) != null ? _a2 : true;
      if (isLoading) {
        pendingAppendsRef.current.push({ message: message2, followUp });
        return;
      }
      const newMessages = [...messages, message2];
      setMessages(newMessages);
      if (followUp) {
        return runChatCompletionAndHandleFunctionCall(newMessages);
      }
    }),
    [isLoading, messages, setMessages, runChatCompletionAndHandleFunctionCall]
  );
  const reload = useAsyncCallback(
    (reloadMessageId) => __async(this, null, function* () {
      if (isLoading || messages.length === 0) {
        return;
      }
      const reloadMessageIndex = messages.findIndex((msg) => msg.id === reloadMessageId);
      if (reloadMessageIndex === -1) {
        console.warn(`Message with id ${reloadMessageId} not found`);
        return;
      }
      const reloadMessageRole = messages[reloadMessageIndex].role;
      if (reloadMessageRole !== MessageRole.Assistant) {
        console.warn(`Regenerate cannot be performed on ${reloadMessageRole} role`);
        return;
      }
      let historyCutoff = [messages[0]];
      if (messages.length > 2 && reloadMessageIndex !== 0) {
        const lastUserMessageBeforeRegenerate = messages.slice(0, reloadMessageIndex).reverse().find(
          (msg) => (
            // @ts-expect-error -- message has role
            msg.role === MessageRole.User
          )
        );
        const indexOfLastUserMessageBeforeRegenerate = messages.findIndex(
          (msg) => msg.id === lastUserMessageBeforeRegenerate.id
        );
        historyCutoff = messages.slice(0, indexOfLastUserMessageBeforeRegenerate + 1);
      } else if (messages.length > 2 && reloadMessageIndex === 0) {
        historyCutoff = [messages[0], messages[1]];
      }
      setMessages(historyCutoff);
      return runChatCompletionAndHandleFunctionCall(historyCutoff);
    }),
    [isLoading, messages, setMessages, runChatCompletionAndHandleFunctionCall]
  );
  const stop = () => {
    var _a2;
    (_a2 = chatAbortControllerRef.current) == null ? void 0 : _a2.abort("Stop was called");
  };
  return {
    append,
    reload,
    stop,
    runChatCompletion: () => runChatCompletionRef.current(messages)
  };
}
function constructFinalMessages(syncedMessages, previousMessages, newMessages) {
  const finalMessages = syncedMessages.length > 0 ? [...syncedMessages] : [...previousMessages, ...newMessages];
  if (syncedMessages.length > 0) {
    const messagesWithAgentState = [...previousMessages, ...newMessages];
    let previousMessageId = void 0;
    for (const message2 of messagesWithAgentState) {
      if (message2.isAgentStateMessage()) {
        const index3 = finalMessages.findIndex((msg) => msg.id === previousMessageId);
        if (index3 !== -1) {
          finalMessages.splice(index3 + 1, 0, message2);
        }
      }
      previousMessageId = message2.id;
    }
  }
  return finalMessages;
}
function executeAction(_0) {
  return __async(this, arguments, function* ({
    onFunctionCall,
    message: message2,
    chatAbortControllerRef,
    onError,
    setMessages,
    getFinalMessages,
    isRenderAndWait
  }) {
    let result;
    let error2 = null;
    const currentMessagesForHandler = getFinalMessages();
    const handlerReturnedPromise = onFunctionCall({
      messages: currentMessagesForHandler,
      name: message2.name,
      args: message2.arguments
    });
    if (isRenderAndWait) {
      const currentMessagesForRender = getFinalMessages();
      (0, import_react_dom2.flushSync)(() => {
        setMessages([...currentMessagesForRender]);
      });
    }
    try {
      result = yield Promise.race([
        handlerReturnedPromise,
        // Await the promise returned by the handler
        new Promise(
          (resolve) => {
            var _a2;
            return (_a2 = chatAbortControllerRef.current) == null ? void 0 : _a2.signal.addEventListener(
              "abort",
              () => resolve("Operation was aborted by the user")
            );
          }
        ),
        // if the user stopped generation, we also abort consecutive actions
        new Promise((resolve) => {
          var _a2;
          if ((_a2 = chatAbortControllerRef.current) == null ? void 0 : _a2.signal.aborted) {
            resolve("Operation was aborted by the user");
          }
        })
      ]);
    } catch (e3) {
      onError(e3);
    }
    return new ResultMessage({
      id: "result-" + message2.id,
      result: ResultMessage.encodeResult(
        error2 ? {
          content: result,
          error: JSON.parse(JSON.stringify(error2, Object.getOwnPropertyNames(error2)))
        } : result
      ),
      actionExecutionId: message2.id,
      actionName: message2.name
    });
  });
}
function getPairedFeAction(actions, message2) {
  let actionName = null;
  if (message2.isActionExecutionMessage()) {
    actionName = message2.name;
  } else if (message2.isResultMessage()) {
    actionName = message2.actionName;
  }
  return actions.find(
    (action) => action.name === actionName && action.available === "frontend" || action.pairedAction === actionName
  );
}

// node_modules/@copilotkit/react-core/dist/chunk-QHCLJODF.mjs
var import_react17 = __toESM(require_react(), 1);
var globalSuggestionPromise = null;
function useCopilotChat(options = {}) {
  var _a2;
  const makeSystemMessage2 = (_a2 = options.makeSystemMessage) != null ? _a2 : defaultSystemMessage;
  const {
    getContextString,
    getFunctionCallHandler,
    copilotApiConfig,
    isLoading,
    setIsLoading,
    chatInstructions,
    actions,
    coagentStatesRef,
    setCoagentStatesWithRef,
    coAgentStateRenders,
    agentSession,
    setAgentSession,
    forwardedParameters,
    agentLock,
    threadId,
    setThreadId,
    runId,
    setRunId,
    chatAbortControllerRef,
    extensions,
    setExtensions,
    langGraphInterruptAction,
    setLangGraphInterruptAction,
    chatSuggestionConfiguration,
    runtimeClient
  } = useCopilotContext();
  const { messages, setMessages, suggestions, setSuggestions } = useCopilotMessagesContext();
  const [mcpServers, setLocalMcpServers] = (0, import_react17.useState)([]);
  const suggestionsAbortControllerRef = (0, import_react17.useRef)(null);
  const isLoadingSuggestionsRef = (0, import_react17.useRef)(false);
  const abortSuggestions = (0, import_react17.useCallback)(
    (clear = true) => {
      var _a22;
      (_a22 = suggestionsAbortControllerRef.current) == null ? void 0 : _a22.abort("suggestions aborted by user");
      suggestionsAbortControllerRef.current = null;
      if (clear) {
        setSuggestions([]);
      }
    },
    [setSuggestions]
  );
  const stableContext = (0, import_react17.useMemo)(() => {
    return {
      actions,
      copilotApiConfig,
      chatSuggestionConfiguration,
      messages,
      setMessages,
      getContextString,
      runtimeClient
    };
  }, [
    JSON.stringify(Object.keys(actions)),
    copilotApiConfig.chatApiEndpoint,
    messages.length,
    Object.keys(chatSuggestionConfiguration).length
  ]);
  const generateSuggestionsFunc = (0, import_react17.useCallback)(() => __async(this, null, function* () {
    if (globalSuggestionPromise) {
      return globalSuggestionPromise;
    }
    globalSuggestionPromise = (() => __async(this, null, function* () {
      try {
        abortSuggestions();
        isLoadingSuggestionsRef.current = true;
        suggestionsAbortControllerRef.current = new AbortController();
        setSuggestions([]);
        yield reloadSuggestions(
          stableContext,
          chatSuggestionConfiguration,
          setSuggestions,
          suggestionsAbortControllerRef
        );
      } catch (error2) {
        throw error2;
      } finally {
        isLoadingSuggestionsRef.current = false;
        globalSuggestionPromise = null;
      }
    }))();
    return globalSuggestionPromise;
  }), [stableContext, chatSuggestionConfiguration, setSuggestions, abortSuggestions]);
  const resetSuggestions = (0, import_react17.useCallback)(() => {
    setSuggestions([]);
  }, [setSuggestions]);
  (0, import_react17.useEffect)(() => {
    if (mcpServers.length > 0) {
      const serversCopy = [...mcpServers];
      copilotApiConfig.mcpServers = serversCopy;
      if (!copilotApiConfig.properties) {
        copilotApiConfig.properties = {};
      }
      copilotApiConfig.properties.mcpServers = serversCopy;
    }
  }, [mcpServers, copilotApiConfig]);
  const setMcpServers = (0, import_react17.useCallback)((servers) => {
    setLocalMcpServers(servers);
  }, []);
  const onCoAgentStateRender = useAsyncCallback(
    (args) => __async(this, null, function* () {
      var _a22;
      const { name: name2, nodeName, state } = args;
      let action = Object.values(coAgentStateRenders).find(
        (action2) => action2.name === name2 && action2.nodeName === nodeName
      );
      if (!action) {
        action = Object.values(coAgentStateRenders).find(
          (action2) => action2.name === name2 && !action2.nodeName
        );
      }
      if (action) {
        yield (_a22 = action.handler) == null ? void 0 : _a22.call(action, { state, nodeName });
      }
    }),
    [coAgentStateRenders]
  );
  const makeSystemMessageCallback = (0, import_react17.useCallback)(() => {
    const systemMessageMaker = makeSystemMessage2 || defaultSystemMessage;
    const contextString = getContextString([], defaultCopilotContextCategories);
    return new TextMessage({
      content: systemMessageMaker(contextString, chatInstructions),
      role: Role.System
    });
  }, [getContextString, makeSystemMessage2, chatInstructions]);
  const deleteMessage = (0, import_react17.useCallback)(
    (messageId) => {
      setMessages((prev) => prev.filter((message2) => message2.id !== messageId));
    },
    [setMessages]
  );
  const { append, reload, stop, runChatCompletion } = useChat(__spreadProps(__spreadValues({}, options), {
    actions: Object.values(actions),
    copilotConfig: copilotApiConfig,
    initialMessages: aguiToGQL(options.initialMessages || []),
    onFunctionCall: getFunctionCallHandler(),
    onCoAgentStateRender,
    messages,
    setMessages,
    makeSystemMessageCallback,
    isLoading,
    setIsLoading,
    coagentStatesRef,
    setCoagentStatesWithRef,
    agentSession,
    setAgentSession,
    forwardedParameters,
    threadId,
    setThreadId,
    runId,
    setRunId,
    chatAbortControllerRef,
    agentLock,
    extensions,
    setExtensions,
    langGraphInterruptAction,
    setLangGraphInterruptAction,
    disableSystemMessage: options.disableSystemMessage
  }));
  const latestAppend = useUpdatedRef(append);
  const latestAppendFunc = useAsyncCallback(
    (message2, options2) => __async(this, null, function* () {
      abortSuggestions(options2 == null ? void 0 : options2.clearSuggestions);
      return yield latestAppend.current(message2, options2);
    }),
    [latestAppend]
  );
  const latestSendMessageFunc = useAsyncCallback(
    (message2, options2) => __async(this, null, function* () {
      abortSuggestions(options2 == null ? void 0 : options2.clearSuggestions);
      return yield latestAppend.current(aguiToGQL([message2])[0], options2);
    }),
    [latestAppend]
  );
  const latestReload = useUpdatedRef(reload);
  const latestReloadFunc = useAsyncCallback(
    (messageId) => __async(this, null, function* () {
      return yield latestReload.current(messageId);
    }),
    [latestReload]
  );
  const latestStop = useUpdatedRef(stop);
  const latestStopFunc = (0, import_react17.useCallback)(() => {
    return latestStop.current();
  }, [latestStop]);
  const latestDelete = useUpdatedRef(deleteMessage);
  const latestDeleteFunc = (0, import_react17.useCallback)(
    (messageId) => {
      return latestDelete.current(messageId);
    },
    [latestDelete]
  );
  const latestSetMessages = useUpdatedRef(setMessages);
  const latestSetMessagesFunc = (0, import_react17.useCallback)(
    (messages2) => {
      if (messages2.every((message2) => message2 instanceof Message)) {
        return latestSetMessages.current(messages2);
      }
      return latestSetMessages.current(aguiToGQL(messages2));
    },
    [latestSetMessages]
  );
  const latestRunChatCompletion = useUpdatedRef(runChatCompletion);
  const latestRunChatCompletionFunc = useAsyncCallback(() => __async(this, null, function* () {
    return yield latestRunChatCompletion.current();
  }), [latestRunChatCompletion]);
  const reset = (0, import_react17.useCallback)(() => {
    latestStopFunc();
    setMessages([]);
    setRunId(null);
    setCoagentStatesWithRef({});
    let initialAgentSession = null;
    if (agentLock) {
      initialAgentSession = {
        agentName: agentLock
      };
    }
    setAgentSession(initialAgentSession);
    resetSuggestions();
  }, [
    latestStopFunc,
    setMessages,
    setThreadId,
    setCoagentStatesWithRef,
    setAgentSession,
    agentLock,
    resetSuggestions
  ]);
  const latestReset = useUpdatedRef(reset);
  const latestResetFunc = (0, import_react17.useCallback)(() => {
    return latestReset.current();
  }, [latestReset]);
  const interrupt = useLangGraphInterruptRender();
  return {
    visibleMessages: messages,
    messages: gqlToAGUI(messages, actions, coAgentStateRenders),
    sendMessage: latestSendMessageFunc,
    appendMessage: latestAppendFunc,
    setMessages: latestSetMessagesFunc,
    reloadMessages: latestReloadFunc,
    stopGeneration: latestStopFunc,
    reset: latestResetFunc,
    deleteMessage: latestDeleteFunc,
    runChatCompletion: latestRunChatCompletionFunc,
    isLoading,
    mcpServers,
    setMcpServers,
    suggestions,
    setSuggestions,
    generateSuggestions: generateSuggestionsFunc,
    resetSuggestions,
    isLoadingSuggestions: isLoadingSuggestionsRef.current,
    interrupt
  };
}
function useUpdatedRef(value2) {
  const ref = (0, import_react17.useRef)(value2);
  (0, import_react17.useEffect)(() => {
    ref.current = value2;
  }, [value2]);
  return ref;
}
function defaultSystemMessage(contextString, additionalInstructions) {
  return `
Please act as an efficient, competent, conscientious, and industrious professional assistant.

Help the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.
Always be polite and respectful, and prefer brevity over verbosity.

The user has provided you with the following context:
\`\`\`
${contextString}
\`\`\`

They have also provided you with functions you can call to initiate actions on their behalf, or functions you can call to receive more information.

Please assist them as best you can.

You can ask them for clarifying questions if needed, but don't be annoying about it. If you can reasonably 'fill in the blanks' yourself, do so.

If you would like to call a function, call it without saying anything else.
In case of a function error:
- If this error stems from incorrect function parameters or syntax, you may retry with corrected arguments.
- If the error's source is unclear or seems unrelated to your input, do not attempt further retries.
` + (additionalInstructions ? `

${additionalInstructions}` : "");
}

// node_modules/@copilotkit/react-core/dist/chunk-U3DQY67T.mjs
var import_react18 = __toESM(require_react(), 1);
function useLangGraphInterrupt(action, dependencies) {
  var _a2;
  const {
    setLangGraphInterruptAction,
    removeLangGraphInterruptAction,
    langGraphInterruptAction,
    threadId
  } = (0, import_react18.useContext)(CopilotContext);
  const { runChatCompletion } = useCopilotChat();
  const { addToast } = useToast();
  const actionId = dataToUUID(JSON.stringify(action), "lgAction");
  const hasAction = (0, import_react18.useMemo)(
    () => Boolean(langGraphInterruptAction == null ? void 0 : langGraphInterruptAction.id),
    [langGraphInterruptAction]
  );
  const isCurrentAction = (0, import_react18.useMemo)(
    () => (langGraphInterruptAction == null ? void 0 : langGraphInterruptAction.id) && (langGraphInterruptAction == null ? void 0 : langGraphInterruptAction.id) === actionId,
    [langGraphInterruptAction]
  );
  (0, import_react18.useEffect)(() => {
    var _a22;
    if (hasAction && isCurrentAction && ((_a22 = langGraphInterruptAction == null ? void 0 : langGraphInterruptAction.event) == null ? void 0 : _a22.response)) {
      runChatCompletion();
    }
  }, [(_a2 = langGraphInterruptAction == null ? void 0 : langGraphInterruptAction.event) == null ? void 0 : _a2.response, runChatCompletion, hasAction, isCurrentAction]);
  (0, import_react18.useEffect)(() => {
    if (!action)
      return;
    if (hasAction && !isCurrentAction && !action.enabled) {
      addToast({
        type: "warning",
        message: "An action is already registered for the interrupt event"
      });
      return;
    }
    if (hasAction && isCurrentAction) {
      return;
    }
    setLangGraphInterruptAction(threadId, __spreadProps(__spreadValues({}, action), { id: actionId }));
  }, [
    action,
    hasAction,
    isCurrentAction,
    setLangGraphInterruptAction,
    removeLangGraphInterruptAction,
    threadId,
    ...dependencies || []
  ]);
}

// node_modules/@copilotkit/react-core/dist/chunk-BBUQMG45.mjs
var import_react19 = __toESM(require_react(), 1);
function useMakeCopilotDocumentReadable(document4, categories, dependencies = []) {
  const { addDocumentContext, removeDocumentContext } = useCopilotContext();
  const idRef = (0, import_react19.useRef)();
  (0, import_react19.useEffect)(() => {
    const id = addDocumentContext(document4, categories);
    idRef.current = id;
    return () => {
      removeDocumentContext(id);
    };
  }, [addDocumentContext, removeDocumentContext, ...dependencies]);
  return idRef.current;
}

// node_modules/@copilotkit/react-core/dist/chunk-T3376SZS.mjs
var import_react20 = __toESM(require_react(), 1);
function useCopilotAction(action, dependencies) {
  const { setAction, removeAction, actions, chatComponentsCache } = useCopilotContext();
  const idRef = (0, import_react20.useRef)(randomId());
  const renderAndWaitRef = (0, import_react20.useRef)(null);
  const activatingMessageIdRef = (0, import_react20.useRef)(null);
  const { addToast } = useToast();
  action = __spreadValues({}, action);
  if (
    // renderAndWaitForResponse is not available for catch all actions
    isFrontendAction(action) && // check if renderAndWaitForResponse is set
    (action.renderAndWait || action.renderAndWaitForResponse)
  ) {
    action._isRenderAndWait = true;
    const renderAndWait = action.renderAndWait || action.renderAndWaitForResponse;
    action.renderAndWait = void 0;
    action.renderAndWaitForResponse = void 0;
    action._setActivatingMessageId = (id) => {
      activatingMessageIdRef.current = id;
    };
    action.handler = useAsyncCallback(() => __async(this, null, function* () {
      const currentActivatingId = activatingMessageIdRef.current;
      let resolve;
      let reject;
      const promise = new Promise((resolvePromise, rejectPromise) => {
        resolve = resolvePromise;
        reject = rejectPromise;
      });
      renderAndWaitRef.current = {
        promise,
        resolve,
        reject,
        messageId: currentActivatingId
      };
      const result = yield promise;
      return result;
    }), []);
    action.render = (props) => {
      const currentRenderMessageId = props.messageId;
      let status = props.status;
      if (props.status === "executing") {
        if (!renderAndWaitRef.current || !renderAndWaitRef.current.promise) {
          status = "inProgress";
        } else if (renderAndWaitRef.current.messageId !== currentRenderMessageId && activatingMessageIdRef.current !== currentRenderMessageId) {
          status = "inProgress";
        }
      }
      const waitProps = {
        status,
        args: props.args,
        result: props.result,
        // handler and respond should only be provided if this is the truly active instance
        // and its promise infrastructure is ready.
        handler: status === "executing" && renderAndWaitRef.current && renderAndWaitRef.current.messageId === currentRenderMessageId ? renderAndWaitRef.current.resolve : void 0,
        respond: status === "executing" && renderAndWaitRef.current && renderAndWaitRef.current.messageId === currentRenderMessageId ? renderAndWaitRef.current.resolve : void 0
      };
      const isNoArgsRenderWait = (_fn) => {
        var _a2;
        return ((_a2 = action.parameters) == null ? void 0 : _a2.length) === 0;
      };
      if (renderAndWait) {
        if (isNoArgsRenderWait(renderAndWait)) {
          return renderAndWait(waitProps);
        } else {
          return renderAndWait(waitProps);
        }
      }
      return (0, import_react20.createElement)(import_react20.Fragment);
    };
  }
  if (dependencies === void 0) {
    if (actions[idRef.current]) {
      if (isFrontendAction(action)) {
        actions[idRef.current].handler = action.handler;
      }
      if (typeof action.render === "function") {
        if (chatComponentsCache.current !== null) {
          chatComponentsCache.current.actions[action.name] = action.render;
        }
      }
    }
  }
  (0, import_react20.useEffect)(() => {
    const hasDuplicate = Object.values(actions).some(
      (otherAction) => otherAction.name === action.name && otherAction !== actions[idRef.current]
    );
    if (hasDuplicate) {
      addToast({
        type: "warning",
        message: `Found an already registered action with name ${action.name}.`,
        id: `dup-action-${action.name}`
      });
    }
  }, [actions]);
  (0, import_react20.useEffect)(() => {
    setAction(idRef.current, action);
    if (chatComponentsCache.current !== null && action.render !== void 0) {
      chatComponentsCache.current.actions[action.name] = action.render;
    }
    return () => {
      removeAction(idRef.current);
    };
  }, [
    setAction,
    removeAction,
    isFrontendAction(action) ? action.description : void 0,
    action.name,
    isFrontendAction(action) ? action.disabled : void 0,
    isFrontendAction(action) ? action.available : void 0,
    // This should be faster than deep equality checking
    // In addition, all major JS engines guarantee the order of object keys
    JSON.stringify(isFrontendAction(action) ? action.parameters : []),
    // include render only if it's a string
    typeof action.render === "string" ? action.render : void 0,
    // dependencies set by the developer
    ...dependencies || []
  ]);
}
function isFrontendAction(action) {
  return action.name !== "*";
}

// node_modules/@copilotkit/react-core/dist/chunk-AKR2SSUJ.mjs
function useRenderToolCall(tool, dependencies) {
  useCopilotAction(
    __spreadProps(__spreadValues({}, tool), {
      available: tool.available === "disabled" ? tool.available : "frontend"
    }),
    dependencies
  );
}

// node_modules/@copilotkit/react-core/dist/chunk-HDOG2RTM.mjs
var import_react21 = __toESM(require_react(), 1);
function convertToJSON(description, value2) {
  return `${description}: ${typeof value2 === "string" ? value2 : JSON.stringify(value2)}`;
}
function useCopilotReadable({
  description,
  value: value2,
  parentId,
  categories,
  convert: convert2,
  available = "enabled"
}, dependencies) {
  const { addContext, removeContext } = useCopilotContext();
  const idRef = (0, import_react21.useRef)();
  convert2 = convert2 || convertToJSON;
  const information = convert2(description, value2);
  (0, import_react21.useEffect)(() => {
    if (available === "disabled")
      return;
    const id = addContext(information, parentId, categories);
    idRef.current = id;
    return () => {
      removeContext(id);
    };
  }, [available, information, parentId, addContext, removeContext, ...dependencies || []]);
  return idRef.current;
}

// node_modules/@copilotkit/react-core/dist/chunk-MQYWH4E6.mjs
function useDefaultTool(tool, dependencies) {
  useCopilotAction(__spreadProps(__spreadValues({}, tool), { name: "*" }), dependencies);
}

// node_modules/@copilotkit/react-core/dist/chunk-6GPVUMBU.mjs
function useFrontendTool(tool, dependencies) {
  useCopilotAction(tool, dependencies);
}

// node_modules/@copilotkit/react-core/dist/chunk-EVVO67QO.mjs
function useHumanInTheLoop(tool, dependencies) {
  const _a2 = tool, { render } = _a2, toolRest = __objRest(_a2, ["render"]);
  useCopilotAction(
    __spreadProps(__spreadValues({}, toolRest), {
      available: tool.available === "disabled" ? tool.available : "remote",
      renderAndWaitForResponse: render
    }),
    dependencies
  );
}

// node_modules/@copilotkit/react-core/dist/chunk-GT5WI3AF.mjs
var import_react22 = __toESM(require_react(), 1);
function useCoAgentStateRender(action, dependencies) {
  const {
    setCoAgentStateRender,
    removeCoAgentStateRender,
    coAgentStateRenders,
    chatComponentsCache,
    availableAgents
  } = (0, import_react22.useContext)(CopilotContext);
  const idRef = (0, import_react22.useRef)(randomId());
  const { setBannerError, addToast } = useToast();
  (0, import_react22.useEffect)(() => {
    if ((availableAgents == null ? void 0 : availableAgents.length) && !availableAgents.some((a2) => a2.name === action.name)) {
      const message2 = `(useCoAgentStateRender): Agent "${action.name}" not found. Make sure the agent exists and is properly configured.`;
      const agentError = new CopilotKitAgentDiscoveryError({
        agentName: action.name,
        availableAgents: availableAgents.map((a2) => ({ name: a2.name, id: a2.id }))
      });
      setBannerError(agentError);
    }
  }, [availableAgents]);
  const key = `${action.name}-${action.nodeName || "global"}`;
  if (dependencies === void 0) {
    if (coAgentStateRenders[idRef.current]) {
      coAgentStateRenders[idRef.current].handler = action.handler;
      if (typeof action.render === "function") {
        if (chatComponentsCache.current !== null) {
          chatComponentsCache.current.coAgentStateRenders[key] = action.render;
        }
      }
    }
  }
  (0, import_react22.useEffect)(() => {
    const currentId = idRef.current;
    const hasDuplicate = Object.entries(coAgentStateRenders).some(([id, otherAction]) => {
      if (id === currentId)
        return false;
      if (otherAction.name !== action.name)
        return false;
      const hasNodeName = !!action.nodeName;
      const hasOtherNodeName = !!otherAction.nodeName;
      if (!hasNodeName && !hasOtherNodeName)
        return true;
      if (hasNodeName !== hasOtherNodeName)
        return false;
      return action.nodeName === otherAction.nodeName;
    });
    if (hasDuplicate) {
      const message2 = action.nodeName ? `Found multiple state renders for agent ${action.name} and node ${action.nodeName}. State renders might get overridden` : `Found multiple state renders for agent ${action.name}. State renders might get overridden`;
      addToast({
        type: "warning",
        message: message2,
        id: `dup-action-${action.name}`
      });
    }
  }, [coAgentStateRenders]);
  (0, import_react22.useEffect)(() => {
    setCoAgentStateRender(idRef.current, action);
    if (chatComponentsCache.current !== null && action.render !== void 0) {
      chatComponentsCache.current.coAgentStateRenders[key] = action.render;
    }
    return () => {
      removeCoAgentStateRender(idRef.current);
    };
  }, [
    setCoAgentStateRender,
    removeCoAgentStateRender,
    action.name,
    // include render only if it's a string
    typeof action.render === "string" ? action.render : void 0,
    // dependencies set by the developer
    ...dependencies || []
  ]);
}

// node_modules/@copilotkit/react-core/dist/chunk-QV5SBF2S.mjs
var import_react23 = __toESM(require_react(), 1);
function useCoAgent(options) {
  const context = useCopilotContext();
  const { availableAgents, onError } = context;
  const { setBannerError } = useToast();
  const lastLoadedThreadId = (0, import_react23.useRef)();
  const lastLoadedState = (0, import_react23.useRef)();
  const { name: name2 } = options;
  (0, import_react23.useEffect)(() => {
    if ((availableAgents == null ? void 0 : availableAgents.length) && !availableAgents.some((a2) => a2.name === name2)) {
      const message2 = `(useCoAgent): Agent "${name2}" not found. Make sure the agent exists and is properly configured.`;
      console.warn(message2);
      const agentError = new CopilotKitAgentDiscoveryError({
        agentName: name2,
        availableAgents: availableAgents.map((a2) => ({ name: a2.name, id: a2.id }))
      });
      setBannerError(agentError);
    }
  }, [availableAgents]);
  const { getMessagesFromTap } = useMessagesTap();
  const { coagentStates, coagentStatesRef, setCoagentStatesWithRef, threadId, copilotApiConfig } = context;
  const { sendMessage, runChatCompletion } = useCopilotChat();
  const headers = __spreadValues({}, copilotApiConfig.headers || {});
  const runtimeClient = useCopilotRuntimeClient({
    url: copilotApiConfig.chatApiEndpoint,
    publicApiKey: copilotApiConfig.publicApiKey,
    headers,
    credentials: copilotApiConfig.credentials,
    showDevConsole: context.showDevConsole,
    onError
  });
  const setState = (0, import_react23.useCallback)(
    (newState) => {
      let coagentState = getCoagentState({ coagentStates, name: name2, options });
      const updatedState = typeof newState === "function" ? newState(coagentState.state) : newState;
      setCoagentStatesWithRef(__spreadProps(__spreadValues({}, coagentStatesRef.current), {
        [name2]: __spreadProps(__spreadValues({}, coagentState), {
          state: updatedState
        })
      }));
    },
    [coagentStates, name2]
  );
  (0, import_react23.useEffect)(() => {
    const fetchAgentState = () => __async(this, null, function* () {
      var _a2, _b2, _c, _d;
      if (!threadId || threadId === lastLoadedThreadId.current)
        return;
      const result = yield runtimeClient.loadAgentState({
        threadId,
        agentName: name2
      });
      if (result.error) {
        return;
      }
      const newState = (_b2 = (_a2 = result.data) == null ? void 0 : _a2.loadAgentState) == null ? void 0 : _b2.state;
      if (newState === lastLoadedState.current)
        return;
      if (((_d = (_c = result.data) == null ? void 0 : _c.loadAgentState) == null ? void 0 : _d.threadExists) && newState && newState != "{}") {
        lastLoadedState.current = newState;
        lastLoadedThreadId.current = threadId;
        const fetchedState = parseJson(newState, {});
        isExternalStateManagement(options) ? options.setState(fetchedState) : setState(fetchedState);
      }
    });
    void fetchAgentState();
  }, [threadId]);
  (0, import_react23.useEffect)(() => {
    if (isExternalStateManagement(options)) {
      setState(options.state);
    } else if (coagentStates[name2] === void 0) {
      setState(options.initialState === void 0 ? {} : options.initialState);
    }
  }, [
    isExternalStateManagement(options) ? JSON.stringify(options.state) : void 0,
    // reset initialstate on reset
    coagentStates[name2] === void 0
  ]);
  (0, import_react23.useEffect)(() => {
    const newConfig = options.config ? options.config : options.configurable ? { configurable: options.configurable } : void 0;
    if (newConfig === void 0)
      return;
    setCoagentStatesWithRef((prev) => {
      var _a2;
      const existing = (_a2 = prev[name2]) != null ? _a2 : {
        name: name2,
        state: isInternalStateManagementWithInitial(options) ? options.initialState : {},
        config: {},
        running: false,
        active: false,
        threadId: void 0,
        nodeName: void 0,
        runId: void 0
      };
      if (JSON.stringify(existing.config) === JSON.stringify(newConfig)) {
        return prev;
      }
      return __spreadProps(__spreadValues({}, prev), {
        [name2]: __spreadProps(__spreadValues({}, existing), {
          config: newConfig
        })
      });
    });
  }, [JSON.stringify(options.config), JSON.stringify(options.configurable)]);
  const runAgentCallback = useAsyncCallback(
    (hint) => __async(this, null, function* () {
      yield runAgent(name2, context, getMessagesFromTap(), sendMessage, runChatCompletion, hint);
    }),
    [name2, context, sendMessage, runChatCompletion]
  );
  return (0, import_react23.useMemo)(() => {
    const coagentState = getCoagentState({ coagentStates, name: name2, options });
    return {
      name: name2,
      nodeName: coagentState.nodeName,
      threadId: coagentState.threadId,
      running: coagentState.running,
      state: coagentState.state,
      setState: isExternalStateManagement(options) ? options.setState : setState,
      start: () => startAgent(name2, context),
      stop: () => stopAgent(name2, context),
      run: runAgentCallback
    };
  }, [name2, coagentStates, options, setState, runAgentCallback]);
}
function startAgent(name2, context) {
  const { setAgentSession } = context;
  setAgentSession({
    agentName: name2
  });
}
function stopAgent(name2, context) {
  const { agentSession, setAgentSession } = context;
  if (agentSession && agentSession.agentName === name2) {
    setAgentSession(null);
    context.setCoagentStates((prevAgentStates) => {
      return __spreadProps(__spreadValues({}, prevAgentStates), {
        [name2]: __spreadProps(__spreadValues({}, prevAgentStates[name2]), {
          running: false,
          active: false,
          threadId: void 0,
          nodeName: void 0,
          runId: void 0
        })
      });
    });
  } else {
    console.warn(`No agent session found for ${name2}`);
  }
}
function runAgent(name2, context, messages, sendMessage, runChatCompletion, hint) {
  return __async(this, null, function* () {
    var _a2, _b2;
    const { agentSession, setAgentSession } = context;
    if (!agentSession || agentSession.agentName !== name2) {
      setAgentSession({
        agentName: name2
      });
    }
    let previousState = null;
    for (let i3 = messages.length - 1; i3 >= 0; i3--) {
      const message2 = messages[i3];
      if (message2.isAgentStateMessage() && message2.agentName === name2) {
        previousState = message2.state;
      }
    }
    let state = ((_b2 = (_a2 = context.coagentStatesRef.current) == null ? void 0 : _a2[name2]) == null ? void 0 : _b2.state) || {};
    if (hint) {
      const hintMessage = hint({ previousState, currentState: state });
      if (hintMessage) {
        yield sendMessage(hintMessage);
      } else {
        yield runChatCompletion();
      }
    } else {
      yield runChatCompletion();
    }
  });
}
var isExternalStateManagement = (options) => {
  return "state" in options && "setState" in options;
};
var isInternalStateManagementWithInitial = (options) => {
  return "initialState" in options;
};
var getCoagentState = ({
  coagentStates,
  name: name2,
  options
}) => {
  if (coagentStates[name2]) {
    return coagentStates[name2];
  } else {
    return {
      name: name2,
      state: isInternalStateManagementWithInitial(options) ? options.initialState : {},
      config: options.config ? options.config : options.configurable ? { configurable: options.configurable } : {},
      running: false,
      active: false,
      threadId: void 0,
      nodeName: void 0,
      runId: void 0
    };
  }
};

// node_modules/@copilotkit/react-core/dist/chunk-MGWRDFBE.mjs
var import_react24 = __toESM(require_react(), 1);
function useCopilotAdditionalInstructions({ instructions, available = "enabled" }, dependencies) {
  const { setAdditionalInstructions } = useCopilotContext();
  (0, import_react24.useEffect)(() => {
    if (available === "disabled")
      return;
    setAdditionalInstructions((prevInstructions) => [...prevInstructions || [], instructions]);
    return () => {
      setAdditionalInstructions(
        (prevInstructions) => (prevInstructions == null ? void 0 : prevInstructions.filter((instruction) => instruction !== instructions)) || []
      );
    };
  }, [available, instructions, setAdditionalInstructions, ...dependencies || []]);
}

// node_modules/@copilotkit/react-core/dist/chunk-U7QULEVO.mjs
var import_react25 = __toESM(require_react(), 1);
var import_react26 = __toESM(require_react(), 1);
function useCopilotAuthenticatedAction_c(action, dependencies) {
  const { authConfig_c, authStates_c, setAuthStates_c } = useCopilotContext();
  const pendingActionRef = (0, import_react25.useRef)(null);
  const executeAction2 = (0, import_react25.useCallback)(
    (props) => {
      if (typeof action.render === "function") {
        return action.render(props);
      }
      return action.render || import_react26.default.createElement(import_react25.Fragment);
    },
    [action]
  );
  const wrappedRender = (0, import_react25.useCallback)(
    (props) => {
      const isAuthenticated = Object.values(authStates_c || {}).some(
        (state) => state.status === "authenticated"
      );
      if (!isAuthenticated) {
        pendingActionRef.current = props;
        return (authConfig_c == null ? void 0 : authConfig_c.SignInComponent) ? import_react26.default.createElement(authConfig_c.SignInComponent, {
          onSignInComplete: (authState) => {
            setAuthStates_c == null ? void 0 : setAuthStates_c((prev) => __spreadProps(__spreadValues({}, prev), { [action.name]: authState }));
            if (pendingActionRef.current) {
              executeAction2(pendingActionRef.current);
              pendingActionRef.current = null;
            }
          }
        }) : import_react26.default.createElement(import_react25.Fragment);
      }
      return executeAction2(props);
    },
    [action, authStates_c, setAuthStates_c]
  );
  useCopilotAction(
    __spreadProps(__spreadValues({}, action), {
      render: wrappedRender
    }),
    dependencies
  );
}

// node_modules/@copilotkit/react-core/dist/chunk-4BHIQMN6.mjs
var import_react27 = __toESM(require_react(), 1);
var createNonFunctionalReturn = () => ({
  visibleMessages: [],
  messages: [],
  sendMessage: () => __async(void 0, null, function* () {
  }),
  appendMessage: () => __async(void 0, null, function* () {
  }),
  setMessages: () => {
  },
  deleteMessage: () => {
  },
  reloadMessages: () => __async(void 0, null, function* () {
  }),
  stopGeneration: () => {
  },
  reset: () => {
  },
  isLoading: false,
  runChatCompletion: () => __async(void 0, null, function* () {
    return [];
  }),
  mcpServers: [],
  setMcpServers: () => {
  },
  suggestions: [],
  setSuggestions: () => {
  },
  generateSuggestions: () => __async(void 0, null, function* () {
  }),
  resetSuggestions: () => {
  },
  isLoadingSuggestions: false,
  interrupt: null
});
function useCopilotChatHeadless_c(options = {}) {
  const { copilotApiConfig, setBannerError } = useCopilotContext();
  const hasPublicApiKey = Boolean(copilotApiConfig.publicApiKey);
  const internalResult = useCopilotChat(options);
  (0, import_react27.useEffect)(() => {
    if (!hasPublicApiKey) {
      setBannerError(
        new CopilotKitError({
          message: (
            // add link to documentation here
            "You're using useCopilotChatHeadless_c, a premium-only feature, which offers extensive headless chat capabilities. To continue, you'll need to provide a free public license key."
          ),
          code: CopilotKitErrorCode.MISSING_PUBLIC_API_KEY_ERROR,
          severity: Severity.WARNING,
          visibility: ErrorVisibility.BANNER
        })
      );
      styledConsole.logCopilotKitPlatformMessage();
    } else {
      setBannerError(null);
    }
  }, [hasPublicApiKey]);
  if (hasPublicApiKey) {
    return internalResult;
  }
  return createNonFunctionalReturn();
}

// node_modules/@copilotkit/react-core/dist/chunk-X7MJWPI7.mjs
function useCopilotChat2(options = {}) {
  const {
    visibleMessages,
    appendMessage,
    reloadMessages,
    stopGeneration,
    reset,
    isLoading,
    runChatCompletion,
    mcpServers,
    setMcpServers
  } = useCopilotChat(options);
  return {
    visibleMessages,
    appendMessage,
    reloadMessages,
    stopGeneration,
    reset,
    isLoading,
    runChatCompletion,
    mcpServers,
    setMcpServers
  };
}

// node_modules/@copilotkit/react-core/dist/chunk-2IDV5OHF.mjs
var SUGGESTION_RETRY_CONFIG = {
  MAX_RETRIES: 3,
  COOLDOWN_MS: 5e3
  // 5 seconds
};

export {
  isMacOS,
  COPILOTKIT_VERSION,
  Severity,
  ErrorVisibility,
  CopilotKitErrorCode,
  CopilotKitError,
  styledConsole,
  randomId,
  aguiToGQL,
  gqlToAGUI,
  shouldShowDevConsole,
  CopilotContext,
  useCopilotContext,
  CopilotMessagesContext,
  useCopilotMessagesContext,
  bail,
  require_extend,
  isPlainObject2 as isPlainObject,
  trough,
  decodeNamedCharacterReference,
  require_browser2 as require_browser,
  trimLines,
  find2 as find,
  html3 as html,
  svg2 as svg,
  parse5 as parse,
  stringify3 as stringify,
  parse6 as parse2,
  stringify4 as stringify2,
  useCopilotRuntimeClient,
  reloadSuggestions,
  CopilotKit,
  defaultCopilotContextCategories,
  extract2 as extract,
  CopilotTask,
  useLangGraphInterruptRender,
  useCopilotChat,
  useLangGraphInterrupt,
  useMakeCopilotDocumentReadable,
  useCopilotAction,
  useRenderToolCall,
  useCopilotReadable,
  useDefaultTool,
  useFrontendTool,
  useHumanInTheLoop,
  useCoAgentStateRender,
  useCoAgent,
  startAgent,
  stopAgent,
  runAgent,
  useCopilotAdditionalInstructions,
  useCopilotAuthenticatedAction_c,
  useCopilotChatHeadless_c,
  useCopilotChat2,
  SUGGESTION_RETRY_CONFIG
};
/*! Bundled license information:

is-buffer/index.js:
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=chunk-R3LX4ASM.js.map
