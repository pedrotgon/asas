"use client";
import {
  require_refractor
} from "./chunk-ZGQ2QBYO.js";
import "./chunk-JADTH4ZJ.js";
import "./chunk-E6HVTXRL.js";
import "./chunk-YJNNP4H4.js";
import "./chunk-PL4QSEJ6.js";
import "./chunk-NVCQQKUT.js";
import "./chunk-VMKCK3E6.js";
import {
  require_core as require_core2
} from "./chunk-VIX2NEPS.js";
import "./chunk-HH73HBQ7.js";
import "./chunk-H2HEVB6V.js";
import "./chunk-CSL7MD6M.js";
import "./chunk-3YMB7E3J.js";
import "./chunk-3TNIY7WE.js";
import "./chunk-LJ3JCXF4.js";
import "./chunk-7Z7DGMC4.js";
import "./chunk-FYPISN7T.js";
import "./chunk-PHDAUTJD.js";
import "./chunk-ERWKKQ33.js";
import "./chunk-A7MZBQFF.js";
import "./chunk-PHVOCZME.js";
import "./chunk-NXG74OPU.js";
import "./chunk-2DD5Y3NH.js";
import "./chunk-R4CXUG56.js";
import "./chunk-RYN2M5GM.js";
import "./chunk-BIIPCQLV.js";
import "./chunk-NEHYPAFF.js";
import "./chunk-PUY5L4US.js";
import "./chunk-TNSVPIEY.js";
import "./chunk-KWADEFA7.js";
import "./chunk-KIOIFAZB.js";
import "./chunk-RGFOE3C3.js";
import "./chunk-LSREKQMP.js";
import "./chunk-PHICMJ6S.js";
import "./chunk-TRV3YWWV.js";
import "./chunk-JPQAQXQX.js";
import "./chunk-TLZHVJT7.js";
import "./chunk-TTMQ57IP.js";
import "./chunk-D2MXWPPK.js";
import "./chunk-5MH6PD4G.js";
import "./chunk-WT375OUJ.js";
import "./chunk-26DYETYL.js";
import "./chunk-Y6RZZ4YJ.js";
import "./chunk-OQSVZDIV.js";
import "./chunk-WNQZN655.js";
import "./chunk-TEEGURQG.js";
import "./chunk-BNN3RKLV.js";
import "./chunk-PFQQSBC4.js";
import "./chunk-44PM6JZ2.js";
import "./chunk-TKYRNNXA.js";
import "./chunk-QGXBBYQD.js";
import "./chunk-NSOUSXSN.js";
import "./chunk-HN2G5MN4.js";
import "./chunk-IW77PXDR.js";
import "./chunk-CBATITVK.js";
import "./chunk-TJ6KII3I.js";
import "./chunk-AVOD4GQX.js";
import "./chunk-OD7EEHWD.js";
import "./chunk-GLUDJXPU.js";
import "./chunk-4SCI2P7S.js";
import "./chunk-YTACR3OE.js";
import "./chunk-TKTWEFMC.js";
import "./chunk-WI4NJN4B.js";
import "./chunk-J22OT3MS.js";
import "./chunk-LACYRYHE.js";
import "./chunk-KH7EGQ5C.js";
import "./chunk-VVXAMETF.js";
import "./chunk-3QSS4RWW.js";
import "./chunk-4GDOHNHJ.js";
import "./chunk-ATOW6OUV.js";
import "./chunk-PG27DIIX.js";
import "./chunk-4P6LKXFS.js";
import "./chunk-NWWUFYMS.js";
import "./chunk-YKRWLDFT.js";
import "./chunk-A2VFZSEE.js";
import "./chunk-OBSWZS3T.js";
import "./chunk-E3PFHAUM.js";
import "./chunk-UDILF5H5.js";
import "./chunk-E2X5CZGK.js";
import "./chunk-MBIBHBYF.js";
import "./chunk-6UJ2GT3X.js";
import "./chunk-L7HTVONA.js";
import "./chunk-CU6ZRONT.js";
import "./chunk-C34MLNUC.js";
import "./chunk-WNZHQRUT.js";
import "./chunk-57S647LH.js";
import "./chunk-MVPG4AW7.js";
import "./chunk-XVAHADZV.js";
import "./chunk-WZ5FWC22.js";
import "./chunk-SAUD6BLM.js";
import "./chunk-C7REEVOL.js";
import "./chunk-N7BPYJIH.js";
import "./chunk-5ORVU5QH.js";
import "./chunk-MEAJRWIB.js";
import "./chunk-SSIGOI33.js";
import "./chunk-OWKSNOMP.js";
import "./chunk-JWSHFKUW.js";
import "./chunk-DKRPQPRG.js";
import "./chunk-ZTAFJ2ZB.js";
import "./chunk-4Z7QPJNS.js";
import "./chunk-SCAL724G.js";
import "./chunk-ZM2NKCOA.js";
import "./chunk-E4ORAU23.js";
import "./chunk-LLGY3ZAJ.js";
import "./chunk-EDVB4HLR.js";
import "./chunk-DSPMIA5Z.js";
import "./chunk-77XFVLON.js";
import "./chunk-GON6WLT3.js";
import "./chunk-PQOLJ5U7.js";
import "./chunk-334D6VBW.js";
import "./chunk-5UWLQWSH.js";
import "./chunk-H7PE2THU.js";
import "./chunk-ZSFZI5AK.js";
import "./chunk-JYSSBLOD.js";
import "./chunk-J2I3G24N.js";
import "./chunk-HR5TSY65.js";
import "./chunk-U7EXNBZL.js";
import "./chunk-Y3SMKXKW.js";
import "./chunk-VSENTCSA.js";
import "./chunk-OOT5KNNJ.js";
import "./chunk-TW33VQLR.js";
import "./chunk-UGTJ6ZJE.js";
import "./chunk-TRDBFDYB.js";
import "./chunk-3GPY6CTM.js";
import "./chunk-E6HCGE5M.js";
import "./chunk-BVYRMULO.js";
import "./chunk-EAZUD7I4.js";
import "./chunk-PP6UP6BO.js";
import "./chunk-UPQGYS6B.js";
import "./chunk-GU46MBMH.js";
import "./chunk-B2SC7TFM.js";
import "./chunk-MMZ65UP5.js";
import "./chunk-3NLFEE5Y.js";
import "./chunk-5EJICO5E.js";
import "./chunk-II5CCYS6.js";
import "./chunk-2LWDKAJ5.js";
import "./chunk-P5BVBE22.js";
import "./chunk-FLMSNFJU.js";
import "./chunk-W7MKDB4Y.js";
import "./chunk-GJF7DJED.js";
import "./chunk-GHRVQSLF.js";
import "./chunk-3XYCWUMA.js";
import "./chunk-U6CGDS2N.js";
import "./chunk-ESH645SS.js";
import "./chunk-U6RCQOIN.js";
import "./chunk-CJ2IUTKS.js";
import "./chunk-PY7OS25T.js";
import "./chunk-3NF7XT6M.js";
import "./chunk-MB4QRSL6.js";
import "./chunk-WCFEASLU.js";
import "./chunk-NFU63SGO.js";
import "./chunk-TFDVKH77.js";
import "./chunk-H6VZSLJX.js";
import "./chunk-3BYOXPUE.js";
import "./chunk-AH47KTEZ.js";
import "./chunk-BQB33DOB.js";
import "./chunk-TH32UZP5.js";
import "./chunk-VNB3KKBA.js";
import "./chunk-E4OQAOFI.js";
import "./chunk-LLWXQGA2.js";
import "./chunk-Z3EIXO2M.js";
import "./chunk-WPSGBMCQ.js";
import "./chunk-W3F6FYNY.js";
import "./chunk-WNZEMEM5.js";
import "./chunk-XVDTK3DJ.js";
import "./chunk-Q36Y46LZ.js";
import "./chunk-IFPF336U.js";
import "./chunk-SLRPQDDS.js";
import "./chunk-VWK5EK7J.js";
import "./chunk-POBUJH23.js";
import "./chunk-7PQKN5H5.js";
import "./chunk-UBUK2YIJ.js";
import "./chunk-M6LTYMAO.js";
import "./chunk-L6X47FL6.js";
import "./chunk-BW3KGTGI.js";
import "./chunk-WLIZJETH.js";
import "./chunk-SUW65ISR.js";
import "./chunk-BOJTM7GA.js";
import "./chunk-L7OTEF6V.js";
import "./chunk-4I7O4UIK.js";
import "./chunk-6STE2VEQ.js";
import "./chunk-JG2KFBB6.js";
import "./chunk-AWUGRKBC.js";
import "./chunk-7M5VT7NG.js";
import "./chunk-GB3NVV52.js";
import "./chunk-X2T22RJW.js";
import "./chunk-L6QEYEJX.js";
import "./chunk-L32AZS5W.js";
import "./chunk-UJ5EKDZL.js";
import "./chunk-E5H57TG4.js";
import "./chunk-I5SOMTQL.js";
import "./chunk-GHIAT5FT.js";
import "./chunk-XPYWVGMP.js";
import "./chunk-BLHXY6K4.js";
import "./chunk-FYHIYN3V.js";
import "./chunk-EWRQUYL4.js";
import "./chunk-HXE2HFDZ.js";
import "./chunk-CG2FF4UQ.js";
import "./chunk-753NST3N.js";
import "./chunk-M6XJSHYA.js";
import "./chunk-P2MVDTJT.js";
import "./chunk-7YLWERTX.js";
import "./chunk-EN4VABSE.js";
import "./chunk-ISVF2UBL.js";
import "./chunk-LJZRBTF5.js";
import "./chunk-WXYJXJ3U.js";
import "./chunk-CM7DOW4V.js";
import "./chunk-PD6QI5QZ.js";
import "./chunk-PHLMGMY7.js";
import "./chunk-3OMF4FVZ.js";
import "./chunk-SIN5YILY.js";
import "./chunk-QDL7DYBE.js";
import "./chunk-4I6KMYOP.js";
import "./chunk-2OWXHBA7.js";
import "./chunk-GUADCN2J.js";
import "./chunk-BOPNZDVJ.js";
import "./chunk-DBJCF7J2.js";
import "./chunk-47ZF3B6L.js";
import "./chunk-WW7TYDCT.js";
import "./chunk-V5QEMNUV.js";
import "./chunk-NA4VAMCW.js";
import "./chunk-2KM4F6OT.js";
import "./chunk-KFQQVWK7.js";
import "./chunk-T7ZW4AWV.js";
import "./chunk-BYW6WLW7.js";
import "./chunk-CAUDTURW.js";
import "./chunk-XXPOTRNO.js";
import "./chunk-M5YKBRVY.js";
import "./chunk-GP3UZ7NZ.js";
import "./chunk-PUUWCQJ7.js";
import "./chunk-CGH77XVV.js";
import "./chunk-IDG65YG3.js";
import "./chunk-BKLKDGNP.js";
import "./chunk-IBO7TNRS.js";
import "./chunk-RJ2MTRR3.js";
import "./chunk-JGLQRKTB.js";
import "./chunk-DPI5FEM3.js";
import "./chunk-FYIV3GHN.js";
import "./chunk-INBGDXN3.js";
import "./chunk-STVHGCWO.js";
import "./chunk-2VHV627K.js";
import "./chunk-4PI6H756.js";
import "./chunk-PKYJQ6AZ.js";
import "./chunk-TDPKGJAT.js";
import "./chunk-CEUBSEDH.js";
import "./chunk-DMZOYGV3.js";
import "./chunk-3IUL67IG.js";
import "./chunk-7523ED7W.js";
import "./chunk-52LIBEEW.js";
import "./chunk-C5A3WVOR.js";
import "./chunk-M7ZTGUQZ.js";
import "./chunk-YP3MYW7K.js";
import "./chunk-V356MQSK.js";
import "./chunk-IUYXBFPU.js";
import "./chunk-2KF442JS.js";
import "./chunk-D6B7QBWJ.js";
import "./chunk-UZGQMZPM.js";
import "./chunk-RR2SQICA.js";
import "./chunk-TIT5GXJV.js";
import "./chunk-H4EBI5SH.js";
import "./chunk-VRT6S6P3.js";
import "./chunk-ZEBLQ6GI.js";
import "./chunk-NPC6ZDKY.js";
import "./chunk-IKD2NAMQ.js";
import "./chunk-57ONH532.js";
import "./chunk-KLJWBZWG.js";
import "./chunk-3ECRSE2Q.js";
import "./chunk-H5UNBIKV.js";
import "./chunk-YBJOISC7.js";
import "./chunk-42JBK27U.js";
import "./chunk-IGVUAXLS.js";
import "./chunk-EXNUB2MV.js";
import "./chunk-CUW2BT3I.js";
import {
  require_zephir
} from "./chunk-U52SMMM5.js";
import "./chunk-J76WHRJU.js";
import "./chunk-6IKAH4KI.js";
import "./chunk-NI4U54NR.js";
import "./chunk-XYZYI2W7.js";
import "./chunk-3HILYIHI.js";
import "./chunk-U52RJTUO.js";
import "./chunk-RQNPNGXA.js";
import {
  require_vbscript
} from "./chunk-2GFKRJLY.js";
import {
  require_vbscript_html
} from "./chunk-6JMPQET5.js";
import {
  require_verilog
} from "./chunk-BIYJX43H.js";
import {
  require_vhdl
} from "./chunk-4ASNWRIM.js";
import {
  require_vim
} from "./chunk-IQS3AWH7.js";
import {
  require_x86asm
} from "./chunk-XDXUNZQM.js";
import {
  require_xl
} from "./chunk-SWWZH66D.js";
import {
  require_xquery
} from "./chunk-XYZHGK45.js";
import {
  require_tap
} from "./chunk-KH4K22OI.js";
import {
  require_tcl
} from "./chunk-D2AMX3GD.js";
import {
  require_thrift
} from "./chunk-OUYBEBWW.js";
import {
  require_tp
} from "./chunk-LQB6LMKH.js";
import {
  require_twig
} from "./chunk-54CWWGT7.js";
import {
  require_typescript
} from "./chunk-CZSOZX3Q.js";
import {
  require_vala
} from "./chunk-63G36THA.js";
import {
  require_vbnet
} from "./chunk-UAVQBYV3.js";
import {
  require_stan
} from "./chunk-X6QPLGUD.js";
import {
  require_stata
} from "./chunk-6TESQKDQ.js";
import {
  require_step21
} from "./chunk-WMRTBP5V.js";
import {
  require_stylus
} from "./chunk-ZIZED36V.js";
import {
  require_subunit
} from "./chunk-YEJSRXY6.js";
import {
  require_swift
} from "./chunk-2V3VQMH6.js";
import {
  require_taggerscript
} from "./chunk-TSVCF5IE.js";
import {
  require_yaml
} from "./chunk-2GX566XT.js";
import {
  require_scss
} from "./chunk-ZF6C4GAA.js";
import {
  require_shell
} from "./chunk-VXCQMC6T.js";
import {
  require_smali
} from "./chunk-R4O7BGLI.js";
import {
  require_smalltalk
} from "./chunk-MOV2PD3I.js";
import {
  require_sml
} from "./chunk-QMAIX6WL.js";
import {
  require_sqf
} from "./chunk-6LSSHYRK.js";
import {
  require_sql_more
} from "./chunk-O2ODXE4E.js";
import {
  require_sql
} from "./chunk-M6DDGKZQ.js";
import {
  require_routeros
} from "./chunk-2EMKMSUT.js";
import {
  require_rsl
} from "./chunk-U2GGNSUN.js";
import {
  require_ruleslanguage
} from "./chunk-ZQ5ZAYX6.js";
import {
  require_rust
} from "./chunk-RHIQQ5TP.js";
import {
  require_sas
} from "./chunk-CZ2QY4CU.js";
import {
  require_scala
} from "./chunk-AGNPSM4T.js";
import {
  require_scheme
} from "./chunk-DULRPDND.js";
import {
  require_scilab
} from "./chunk-5F55LZI6.js";
import {
  require_python
} from "./chunk-ZSFVSMTJ.js";
import {
  require_python_repl
} from "./chunk-5GPF6X5W.js";
import {
  require_q
} from "./chunk-7XMPBDJB.js";
import {
  require_qml
} from "./chunk-LBT5WTCZ.js";
import {
  require_r
} from "./chunk-DIWVYORO.js";
import {
  require_reasonml
} from "./chunk-P3GX7R43.js";
import {
  require_rib
} from "./chunk-5DD3AQAR.js";
import {
  require_roboconf
} from "./chunk-NZ7PQC5D.js";
import {
  require_powershell
} from "./chunk-DETM5UDV.js";
import {
  require_processing
} from "./chunk-XB6Z3UOQ.js";
import {
  require_profile
} from "./chunk-ROVIPQZ5.js";
import {
  require_prolog
} from "./chunk-CNMIGBDW.js";
import {
  require_properties
} from "./chunk-VWXE5Z2D.js";
import {
  require_protobuf
} from "./chunk-DJ3MZXLJ.js";
import {
  require_puppet
} from "./chunk-OPVD7GUK.js";
import {
  require_purebasic
} from "./chunk-BA6OZ3WE.js";
import {
  require_oxygene
} from "./chunk-CKTV5UFO.js";
import {
  require_parser3
} from "./chunk-VB4SZPMG.js";
import {
  require_pf
} from "./chunk-I3M5JVTG.js";
import {
  require_pgsql
} from "./chunk-FGXR6EQB.js";
import {
  require_php
} from "./chunk-X6N5N6KS.js";
import {
  require_php_template
} from "./chunk-AGB7LJQJ.js";
import {
  require_plaintext
} from "./chunk-IDH62FRG.js";
import {
  require_pony
} from "./chunk-I5OVVE7A.js";
import {
  require_nginx
} from "./chunk-QFJM2EIN.js";
import {
  require_nim
} from "./chunk-VBIMGZQT.js";
import {
  require_nix
} from "./chunk-FM6OIUQL.js";
import {
  require_node_repl
} from "./chunk-Y2C65RKU.js";
import {
  require_nsis
} from "./chunk-AEYESOMB.js";
import {
  require_objectivec
} from "./chunk-6CDU47UL.js";
import {
  require_ocaml
} from "./chunk-GBCGOFKA.js";
import {
  require_openscad
} from "./chunk-PTVH3RZ2.js";
import {
  require_mercury
} from "./chunk-5VV57LJE.js";
import {
  require_mipsasm
} from "./chunk-5K2IDDWK.js";
import {
  require_mizar
} from "./chunk-34TTLPHD.js";
import {
  require_perl
} from "./chunk-7M7LLPLQ.js";
import {
  require_mojolicious
} from "./chunk-D2GH7DKM.js";
import {
  require_monkey
} from "./chunk-6TYDPRNL.js";
import {
  require_moonscript
} from "./chunk-NHLZROEZ.js";
import {
  require_n1ql
} from "./chunk-Q73KWKYE.js";
import {
  require_llvm
} from "./chunk-ZP32W5YZ.js";
import {
  require_lsl
} from "./chunk-23ZOA763.js";
import {
  require_lua
} from "./chunk-CDPAH6N5.js";
import {
  require_makefile
} from "./chunk-AV24W7PL.js";
import {
  require_mathematica
} from "./chunk-Q5EDUZTT.js";
import {
  require_matlab
} from "./chunk-T7RQK7RX.js";
import {
  require_maxima
} from "./chunk-OVYSCUXQ.js";
import {
  require_mel
} from "./chunk-UVWQO3PI.js";
import {
  require_lasso
} from "./chunk-KJSVAGME.js";
import {
  require_latex
} from "./chunk-CAWUGNFA.js";
import {
  require_ldif
} from "./chunk-3EQ2QM72.js";
import {
  require_leaf
} from "./chunk-3THE3UG7.js";
import {
  require_less
} from "./chunk-FK4H6DQS.js";
import {
  require_lisp
} from "./chunk-CZ22OGOV.js";
import {
  require_livecodeserver
} from "./chunk-3YL7C3Z4.js";
import {
  require_livescript
} from "./chunk-OEX2DEFU.js";
import {
  require_isbl
} from "./chunk-AHNKOP3P.js";
import {
  require_java
} from "./chunk-5LCIONGW.js";
import {
  require_javascript
} from "./chunk-3HDZE5BL.js";
import {
  require_jboss_cli
} from "./chunk-H7MC6UKO.js";
import {
  require_json
} from "./chunk-4K3UEB4W.js";
import {
  require_julia
} from "./chunk-I7TWQJ6O.js";
import {
  require_julia_repl
} from "./chunk-EQWWTNBB.js";
import {
  require_kotlin
} from "./chunk-P6FLZ45R.js";
import {
  require_haxe
} from "./chunk-JT2O3YUM.js";
import {
  require_hsp
} from "./chunk-MRHQD3CO.js";
import {
  require_htmlbars
} from "./chunk-2P5XTEPM.js";
import {
  require_http
} from "./chunk-PDGJM4CP.js";
import {
  require_hy
} from "./chunk-XTTF7N6F.js";
import {
  require_inform7
} from "./chunk-ZTKA7X3O.js";
import {
  require_ini
} from "./chunk-NQTGQS6D.js";
import {
  require_irpf90
} from "./chunk-YUKVMHQK.js";
import {
  require_gml
} from "./chunk-3Z76AAQT.js";
import {
  require_go
} from "./chunk-2X2HVCB6.js";
import {
  require_golo
} from "./chunk-PHNROWKN.js";
import {
  require_gradle
} from "./chunk-UYX5F32U.js";
import {
  require_groovy
} from "./chunk-XNQPVHZY.js";
import {
  require_haml
} from "./chunk-HHZDJ2X2.js";
import {
  require_handlebars
} from "./chunk-MO6ERC6Y.js";
import {
  require_haskell
} from "./chunk-FHJNLZUC.js";
import {
  require_flix
} from "./chunk-VTRIPEMN.js";
import {
  require_fortran
} from "./chunk-URAZOIOU.js";
import {
  require_fsharp
} from "./chunk-FBCHMILR.js";
import {
  require_gams
} from "./chunk-RTA4X4N6.js";
import {
  require_gauss
} from "./chunk-IQTQSO4U.js";
import {
  require_gcode
} from "./chunk-NYJEWUQD.js";
import {
  require_gherkin
} from "./chunk-ETI2LCQC.js";
import {
  require_glsl
} from "./chunk-3OMFQECI.js";
import {
  require_elixir
} from "./chunk-KVR7ULTV.js";
import {
  require_elm
} from "./chunk-5NVU2I3C.js";
import {
  require_ruby
} from "./chunk-4DZVTZUL.js";
import {
  require_erb
} from "./chunk-AXHHUI46.js";
import {
  require_erlang_repl
} from "./chunk-USYT3SUU.js";
import {
  require_erlang
} from "./chunk-IN6NVO2E.js";
import {
  require_excel
} from "./chunk-6LERK7IR.js";
import {
  require_fix
} from "./chunk-2CH47MM5.js";
import {
  require_django
} from "./chunk-2CZBIVWD.js";
import {
  require_dns
} from "./chunk-HG6O6HX7.js";
import {
  require_dockerfile
} from "./chunk-MFXITOF5.js";
import {
  require_dos
} from "./chunk-ITYPCJD5.js";
import {
  require_dsconfig
} from "./chunk-6VDSYOOZ.js";
import {
  require_dts
} from "./chunk-VPLWOGY7.js";
import {
  require_dust
} from "./chunk-24RXYIKB.js";
import {
  require_ebnf
} from "./chunk-7MF3DGFM.js";
import {
  require_csharp
} from "./chunk-BSRIQZRD.js";
import {
  require_csp
} from "./chunk-3OLBAALK.js";
import {
  require_css
} from "./chunk-4SO3ODAG.js";
import {
  require_d
} from "./chunk-P2CEUNLI.js";
import {
  require_markdown
} from "./chunk-VJX45KVO.js";
import {
  require_dart
} from "./chunk-BZ2Q5PWP.js";
import {
  require_delphi
} from "./chunk-3AFCLIQ4.js";
import {
  require_diff
} from "./chunk-2AIHSD4J.js";
import {
  require_clojure_repl
} from "./chunk-CU6OPMXS.js";
import {
  require_cmake
} from "./chunk-JOZPKIF2.js";
import {
  require_coffeescript
} from "./chunk-W6FYGKFX.js";
import {
  require_coq
} from "./chunk-IJSHRP4Y.js";
import {
  require_cos
} from "./chunk-L2ROJRQK.js";
import {
  require_cpp
} from "./chunk-F4ZLYZZL.js";
import {
  require_crmsh
} from "./chunk-EGDO3SOK.js";
import {
  require_crystal
} from "./chunk-PNNL3FLA.js";
import {
  require_brainfuck
} from "./chunk-7ILCNONI.js";
import {
  require_c_like
} from "./chunk-4KTG47LK.js";
import {
  require_c as require_c2
} from "./chunk-VKVNM5WK.js";
import {
  require_cal
} from "./chunk-I6TQGZ7F.js";
import {
  require_capnproto
} from "./chunk-EBXSPRGL.js";
import {
  require_ceylon
} from "./chunk-XHKA4NAL.js";
import {
  require_clean
} from "./chunk-UQFBUIIT.js";
import {
  require_clojure
} from "./chunk-Y2DRMDYL.js";
import {
  require_autohotkey
} from "./chunk-5STOVMUH.js";
import {
  require_autoit
} from "./chunk-RJVXSCH5.js";
import {
  require_avrasm
} from "./chunk-ZTQY7IFM.js";
import {
  require_awk
} from "./chunk-XDAAQVYQ.js";
import {
  require_axapta
} from "./chunk-C7BR6PVZ.js";
import {
  require_bash
} from "./chunk-3T3VPSVZ.js";
import {
  require_basic
} from "./chunk-OHEJMYNE.js";
import {
  require_bnf
} from "./chunk-VDKD45ZG.js";
import {
  require_apache
} from "./chunk-LCTZEFYQ.js";
import {
  require_applescript
} from "./chunk-FY2ZWSTL.js";
import {
  require_arcade
} from "./chunk-6U5L5BYK.js";
import {
  require_arduino
} from "./chunk-YJHWTMNU.js";
import {
  require_armasm
} from "./chunk-2XU52EJX.js";
import {
  require_xml
} from "./chunk-WCCBXOHS.js";
import {
  require_asciidoc
} from "./chunk-5FXRZNBH.js";
import {
  require_aspectj
} from "./chunk-MQ5P7EQA.js";
import {
  require_core
} from "./chunk-MKVQBFXD.js";
import {
  require_c
} from "./chunk-ESRWMJAN.js";
import {
  require_abnf
} from "./chunk-7V56YIYS.js";
import {
  require_accesslog
} from "./chunk-N4D54WOM.js";
import {
  require_actionscript
} from "./chunk-5PFNRTVL.js";
import {
  require_ada
} from "./chunk-XJMXPZQE.js";
import {
  require_angelscript
} from "./chunk-G7QKT5RQ.js";
import {
  COPILOTKIT_VERSION,
  CopilotKitError,
  CopilotKitErrorCode,
  ErrorVisibility,
  Severity,
  aguiToGQL,
  bail,
  decodeNamedCharacterReference,
  defaultCopilotContextCategories,
  find,
  gqlToAGUI,
  html,
  isMacOS,
  isPlainObject,
  parse,
  parse2,
  randomId,
  require_browser,
  require_extend,
  runAgent,
  shouldShowDevConsole,
  stopAgent,
  stringify,
  stringify2,
  styledConsole,
  svg,
  trimLines,
  trough,
  useCopilotChat,
  useCopilotContext,
  useCopilotMessagesContext
} from "./chunk-R3LX4ASM.js";
import {
  require_jsx_runtime
} from "./chunk-OT5EQO2H.js";
import {
  require_react_dom
} from "./chunk-WRD5HZVH.js";
import {
  require_react
} from "./chunk-OU5AQDZK.js";
import "./chunk-K5BDOZIP.js";
import {
  __commonJS,
  __export,
  __publicField,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js
var require_use_sync_external_store_with_selector_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js"(exports) {
    "use strict";
    (function() {
      function is2(x10, y10) {
        return x10 === y10 && (0 !== x10 || 1 / x10 === 1 / y10) || x10 !== x10 && y10 !== y10;
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React12 = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is2, useSyncExternalStore = React12.useSyncExternalStore, useRef13 = React12.useRef, useEffect18 = React12.useEffect, useMemo8 = React12.useMemo, useDebugValue = React12.useDebugValue;
      exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
        var instRef = useRef13(null);
        if (null === instRef.current) {
          var inst = { hasValue: false, value: null };
          instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo8(
          function() {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual && inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual(currentSelection, nextSnapshot))
                    return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
              }
              currentSelection = memoizedSelection;
              if (objectIs(memoizedSnapshot, nextSnapshot))
                return currentSelection;
              var nextSelection = selector(nextSnapshot);
              if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
                return memoizedSnapshot = nextSnapshot, currentSelection;
              memoizedSnapshot = nextSnapshot;
              return memoizedSelection = nextSelection;
            }
            var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function() {
                return memoizedSelector(getSnapshot());
              },
              null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              }
            ];
          },
          [getSnapshot, getServerSnapshot, selector, isEqual]
        );
        var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
        useEffect18(
          function() {
            inst.hasValue = true;
            inst.value = value;
          },
          [value]
        );
        useDebugValue(value);
        return value;
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/use-sync-external-store/with-selector.js
var require_with_selector = __commonJS({
  "node_modules/use-sync-external-store/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_with_selector_development();
    }
  }
});

// node_modules/lowlight/index.js
var require_lowlight = __commonJS({
  "node_modules/lowlight/index.js"(exports, module) {
    "use strict";
    var low = require_core();
    module.exports = low;
    low.registerLanguage("1c", require_c());
    low.registerLanguage("abnf", require_abnf());
    low.registerLanguage(
      "accesslog",
      require_accesslog()
    );
    low.registerLanguage(
      "actionscript",
      require_actionscript()
    );
    low.registerLanguage("ada", require_ada());
    low.registerLanguage(
      "angelscript",
      require_angelscript()
    );
    low.registerLanguage("apache", require_apache());
    low.registerLanguage(
      "applescript",
      require_applescript()
    );
    low.registerLanguage("arcade", require_arcade());
    low.registerLanguage("arduino", require_arduino());
    low.registerLanguage("armasm", require_armasm());
    low.registerLanguage("xml", require_xml());
    low.registerLanguage("asciidoc", require_asciidoc());
    low.registerLanguage("aspectj", require_aspectj());
    low.registerLanguage(
      "autohotkey",
      require_autohotkey()
    );
    low.registerLanguage("autoit", require_autoit());
    low.registerLanguage("avrasm", require_avrasm());
    low.registerLanguage("awk", require_awk());
    low.registerLanguage("axapta", require_axapta());
    low.registerLanguage("bash", require_bash());
    low.registerLanguage("basic", require_basic());
    low.registerLanguage("bnf", require_bnf());
    low.registerLanguage(
      "brainfuck",
      require_brainfuck()
    );
    low.registerLanguage("c-like", require_c_like());
    low.registerLanguage("c", require_c2());
    low.registerLanguage("cal", require_cal());
    low.registerLanguage(
      "capnproto",
      require_capnproto()
    );
    low.registerLanguage("ceylon", require_ceylon());
    low.registerLanguage("clean", require_clean());
    low.registerLanguage("clojure", require_clojure());
    low.registerLanguage(
      "clojure-repl",
      require_clojure_repl()
    );
    low.registerLanguage("cmake", require_cmake());
    low.registerLanguage(
      "coffeescript",
      require_coffeescript()
    );
    low.registerLanguage("coq", require_coq());
    low.registerLanguage("cos", require_cos());
    low.registerLanguage("cpp", require_cpp());
    low.registerLanguage("crmsh", require_crmsh());
    low.registerLanguage("crystal", require_crystal());
    low.registerLanguage("csharp", require_csharp());
    low.registerLanguage("csp", require_csp());
    low.registerLanguage("css", require_css());
    low.registerLanguage("d", require_d());
    low.registerLanguage("markdown", require_markdown());
    low.registerLanguage("dart", require_dart());
    low.registerLanguage("delphi", require_delphi());
    low.registerLanguage("diff", require_diff());
    low.registerLanguage("django", require_django());
    low.registerLanguage("dns", require_dns());
    low.registerLanguage(
      "dockerfile",
      require_dockerfile()
    );
    low.registerLanguage("dos", require_dos());
    low.registerLanguage("dsconfig", require_dsconfig());
    low.registerLanguage("dts", require_dts());
    low.registerLanguage("dust", require_dust());
    low.registerLanguage("ebnf", require_ebnf());
    low.registerLanguage("elixir", require_elixir());
    low.registerLanguage("elm", require_elm());
    low.registerLanguage("ruby", require_ruby());
    low.registerLanguage("erb", require_erb());
    low.registerLanguage(
      "erlang-repl",
      require_erlang_repl()
    );
    low.registerLanguage("erlang", require_erlang());
    low.registerLanguage("excel", require_excel());
    low.registerLanguage("fix", require_fix());
    low.registerLanguage("flix", require_flix());
    low.registerLanguage("fortran", require_fortran());
    low.registerLanguage("fsharp", require_fsharp());
    low.registerLanguage("gams", require_gams());
    low.registerLanguage("gauss", require_gauss());
    low.registerLanguage("gcode", require_gcode());
    low.registerLanguage("gherkin", require_gherkin());
    low.registerLanguage("glsl", require_glsl());
    low.registerLanguage("gml", require_gml());
    low.registerLanguage("go", require_go());
    low.registerLanguage("golo", require_golo());
    low.registerLanguage("gradle", require_gradle());
    low.registerLanguage("groovy", require_groovy());
    low.registerLanguage("haml", require_haml());
    low.registerLanguage(
      "handlebars",
      require_handlebars()
    );
    low.registerLanguage("haskell", require_haskell());
    low.registerLanguage("haxe", require_haxe());
    low.registerLanguage("hsp", require_hsp());
    low.registerLanguage("htmlbars", require_htmlbars());
    low.registerLanguage("http", require_http());
    low.registerLanguage("hy", require_hy());
    low.registerLanguage("inform7", require_inform7());
    low.registerLanguage("ini", require_ini());
    low.registerLanguage("irpf90", require_irpf90());
    low.registerLanguage("isbl", require_isbl());
    low.registerLanguage("java", require_java());
    low.registerLanguage(
      "javascript",
      require_javascript()
    );
    low.registerLanguage(
      "jboss-cli",
      require_jboss_cli()
    );
    low.registerLanguage("json", require_json());
    low.registerLanguage("julia", require_julia());
    low.registerLanguage(
      "julia-repl",
      require_julia_repl()
    );
    low.registerLanguage("kotlin", require_kotlin());
    low.registerLanguage("lasso", require_lasso());
    low.registerLanguage("latex", require_latex());
    low.registerLanguage("ldif", require_ldif());
    low.registerLanguage("leaf", require_leaf());
    low.registerLanguage("less", require_less());
    low.registerLanguage("lisp", require_lisp());
    low.registerLanguage(
      "livecodeserver",
      require_livecodeserver()
    );
    low.registerLanguage(
      "livescript",
      require_livescript()
    );
    low.registerLanguage("llvm", require_llvm());
    low.registerLanguage("lsl", require_lsl());
    low.registerLanguage("lua", require_lua());
    low.registerLanguage("makefile", require_makefile());
    low.registerLanguage(
      "mathematica",
      require_mathematica()
    );
    low.registerLanguage("matlab", require_matlab());
    low.registerLanguage("maxima", require_maxima());
    low.registerLanguage("mel", require_mel());
    low.registerLanguage("mercury", require_mercury());
    low.registerLanguage("mipsasm", require_mipsasm());
    low.registerLanguage("mizar", require_mizar());
    low.registerLanguage("perl", require_perl());
    low.registerLanguage(
      "mojolicious",
      require_mojolicious()
    );
    low.registerLanguage("monkey", require_monkey());
    low.registerLanguage(
      "moonscript",
      require_moonscript()
    );
    low.registerLanguage("n1ql", require_n1ql());
    low.registerLanguage("nginx", require_nginx());
    low.registerLanguage("nim", require_nim());
    low.registerLanguage("nix", require_nix());
    low.registerLanguage(
      "node-repl",
      require_node_repl()
    );
    low.registerLanguage("nsis", require_nsis());
    low.registerLanguage(
      "objectivec",
      require_objectivec()
    );
    low.registerLanguage("ocaml", require_ocaml());
    low.registerLanguage("openscad", require_openscad());
    low.registerLanguage("oxygene", require_oxygene());
    low.registerLanguage("parser3", require_parser3());
    low.registerLanguage("pf", require_pf());
    low.registerLanguage("pgsql", require_pgsql());
    low.registerLanguage("php", require_php());
    low.registerLanguage(
      "php-template",
      require_php_template()
    );
    low.registerLanguage(
      "plaintext",
      require_plaintext()
    );
    low.registerLanguage("pony", require_pony());
    low.registerLanguage(
      "powershell",
      require_powershell()
    );
    low.registerLanguage(
      "processing",
      require_processing()
    );
    low.registerLanguage("profile", require_profile());
    low.registerLanguage("prolog", require_prolog());
    low.registerLanguage(
      "properties",
      require_properties()
    );
    low.registerLanguage("protobuf", require_protobuf());
    low.registerLanguage("puppet", require_puppet());
    low.registerLanguage(
      "purebasic",
      require_purebasic()
    );
    low.registerLanguage("python", require_python());
    low.registerLanguage(
      "python-repl",
      require_python_repl()
    );
    low.registerLanguage("q", require_q());
    low.registerLanguage("qml", require_qml());
    low.registerLanguage("r", require_r());
    low.registerLanguage("reasonml", require_reasonml());
    low.registerLanguage("rib", require_rib());
    low.registerLanguage("roboconf", require_roboconf());
    low.registerLanguage("routeros", require_routeros());
    low.registerLanguage("rsl", require_rsl());
    low.registerLanguage(
      "ruleslanguage",
      require_ruleslanguage()
    );
    low.registerLanguage("rust", require_rust());
    low.registerLanguage("sas", require_sas());
    low.registerLanguage("scala", require_scala());
    low.registerLanguage("scheme", require_scheme());
    low.registerLanguage("scilab", require_scilab());
    low.registerLanguage("scss", require_scss());
    low.registerLanguage("shell", require_shell());
    low.registerLanguage("smali", require_smali());
    low.registerLanguage(
      "smalltalk",
      require_smalltalk()
    );
    low.registerLanguage("sml", require_sml());
    low.registerLanguage("sqf", require_sqf());
    low.registerLanguage("sql_more", require_sql_more());
    low.registerLanguage("sql", require_sql());
    low.registerLanguage("stan", require_stan());
    low.registerLanguage("stata", require_stata());
    low.registerLanguage("step21", require_step21());
    low.registerLanguage("stylus", require_stylus());
    low.registerLanguage("subunit", require_subunit());
    low.registerLanguage("swift", require_swift());
    low.registerLanguage(
      "taggerscript",
      require_taggerscript()
    );
    low.registerLanguage("yaml", require_yaml());
    low.registerLanguage("tap", require_tap());
    low.registerLanguage("tcl", require_tcl());
    low.registerLanguage("thrift", require_thrift());
    low.registerLanguage("tp", require_tp());
    low.registerLanguage("twig", require_twig());
    low.registerLanguage(
      "typescript",
      require_typescript()
    );
    low.registerLanguage("vala", require_vala());
    low.registerLanguage("vbnet", require_vbnet());
    low.registerLanguage("vbscript", require_vbscript());
    low.registerLanguage(
      "vbscript-html",
      require_vbscript_html()
    );
    low.registerLanguage("verilog", require_verilog());
    low.registerLanguage("vhdl", require_vhdl());
    low.registerLanguage("vim", require_vim());
    low.registerLanguage("x86asm", require_x86asm());
    low.registerLanguage("xl", require_xl());
    low.registerLanguage("xquery", require_xquery());
    low.registerLanguage("zephir", require_zephir());
  }
});

// node_modules/style-to-js/node_modules/inline-style-parser/index.js
var require_inline_style_parser = __commonJS({
  "node_modules/style-to-js/node_modules/inline-style-parser/index.js"(exports, module) {
    var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
    var NEWLINE_REGEX = /\n/g;
    var WHITESPACE_REGEX = /^\s*/;
    var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
    var COLON_REGEX = /^:\s*/;
    var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
    var SEMICOLON_REGEX = /^[;\s]*/;
    var TRIM_REGEX = /^\s+|\s+$/g;
    var NEWLINE = "\n";
    var FORWARD_SLASH = "/";
    var ASTERISK = "*";
    var EMPTY_STRING = "";
    var TYPE_COMMENT = "comment";
    var TYPE_DECLARATION = "declaration";
    module.exports = function(style2, options) {
      if (typeof style2 !== "string") {
        throw new TypeError("First argument must be a string");
      }
      if (!style2) return [];
      options = options || {};
      var lineno = 1;
      var column = 1;
      function updatePosition(str) {
        var lines = str.match(NEWLINE_REGEX);
        if (lines) lineno += lines.length;
        var i16 = str.lastIndexOf(NEWLINE);
        column = ~i16 ? str.length - i16 : column + str.length;
      }
      function position4() {
        var start2 = { line: lineno, column };
        return function(node2) {
          node2.position = new Position(start2);
          whitespace2();
          return node2;
        };
      }
      function Position(start2) {
        this.start = start2;
        this.end = { line: lineno, column };
        this.source = options.source;
      }
      Position.prototype.content = style2;
      var errorsList = [];
      function error2(msg) {
        var err = new Error(
          options.source + ":" + lineno + ":" + column + ": " + msg
        );
        err.reason = msg;
        err.filename = options.source;
        err.line = lineno;
        err.column = column;
        err.source = style2;
        if (options.silent) {
          errorsList.push(err);
        } else {
          throw err;
        }
      }
      function match(re5) {
        var m10 = re5.exec(style2);
        if (!m10) return;
        var str = m10[0];
        updatePosition(str);
        style2 = style2.slice(str.length);
        return m10;
      }
      function whitespace2() {
        match(WHITESPACE_REGEX);
      }
      function comments(rules) {
        var c21;
        rules = rules || [];
        while (c21 = comment3()) {
          if (c21 !== false) {
            rules.push(c21);
          }
        }
        return rules;
      }
      function comment3() {
        var pos = position4();
        if (FORWARD_SLASH != style2.charAt(0) || ASTERISK != style2.charAt(1)) return;
        var i16 = 2;
        while (EMPTY_STRING != style2.charAt(i16) && (ASTERISK != style2.charAt(i16) || FORWARD_SLASH != style2.charAt(i16 + 1))) {
          ++i16;
        }
        i16 += 2;
        if (EMPTY_STRING === style2.charAt(i16 - 1)) {
          return error2("End of comment missing");
        }
        var str = style2.slice(2, i16 - 2);
        column += 2;
        updatePosition(str);
        style2 = style2.slice(i16);
        column += 2;
        return pos({
          type: TYPE_COMMENT,
          comment: str
        });
      }
      function declaration() {
        var pos = position4();
        var prop = match(PROPERTY_REGEX);
        if (!prop) return;
        comment3();
        if (!match(COLON_REGEX)) return error2("property missing ':'");
        var val = match(VALUE_REGEX);
        var ret = pos({
          type: TYPE_DECLARATION,
          property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
          value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
        });
        match(SEMICOLON_REGEX);
        return ret;
      }
      function declarations() {
        var decls = [];
        comments(decls);
        var decl;
        while (decl = declaration()) {
          if (decl !== false) {
            decls.push(decl);
            comments(decls);
          }
        }
        return decls;
      }
      whitespace2();
      return declarations();
    };
    function trim(str) {
      return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
    }
  }
});

// node_modules/style-to-js/node_modules/style-to-object/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/style-to-js/node_modules/style-to-object/cjs/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = StyleToObject;
    var inline_style_parser_1 = __importDefault(require_inline_style_parser());
    function StyleToObject(style2, iterator) {
      let styleObject = null;
      if (!style2 || typeof style2 !== "string") {
        return styleObject;
      }
      const declarations = (0, inline_style_parser_1.default)(style2);
      const hasIterator = typeof iterator === "function";
      declarations.forEach((declaration) => {
        if (declaration.type !== "declaration") {
          return;
        }
        const { property, value } = declaration;
        if (hasIterator) {
          iterator(property, value, declaration);
        } else if (value) {
          styleObject = styleObject || {};
          styleObject[property] = value;
        }
      });
      return styleObject;
    }
  }
});

// node_modules/style-to-js/cjs/utilities.js
var require_utilities = __commonJS({
  "node_modules/style-to-js/cjs/utilities.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.camelCase = void 0;
    var CUSTOM_PROPERTY_REGEX = /^--[a-zA-Z0-9_-]+$/;
    var HYPHEN_REGEX = /-([a-z])/g;
    var NO_HYPHEN_REGEX = /^[^-]+$/;
    var VENDOR_PREFIX_REGEX = /^-(webkit|moz|ms|o|khtml)-/;
    var MS_VENDOR_PREFIX_REGEX = /^-(ms)-/;
    var skipCamelCase = function(property) {
      return !property || NO_HYPHEN_REGEX.test(property) || CUSTOM_PROPERTY_REGEX.test(property);
    };
    var capitalize = function(match, character) {
      return character.toUpperCase();
    };
    var trimHyphen = function(match, prefix) {
      return "".concat(prefix, "-");
    };
    var camelCase = function(property, options) {
      if (options === void 0) {
        options = {};
      }
      if (skipCamelCase(property)) {
        return property;
      }
      property = property.toLowerCase();
      if (options.reactCompat) {
        property = property.replace(MS_VENDOR_PREFIX_REGEX, trimHyphen);
      } else {
        property = property.replace(VENDOR_PREFIX_REGEX, trimHyphen);
      }
      return property.replace(HYPHEN_REGEX, capitalize);
    };
    exports.camelCase = camelCase;
  }
});

// node_modules/style-to-js/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/style-to-js/cjs/index.js"(exports, module) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var style_to_object_1 = __importDefault(require_cjs());
    var utilities_1 = require_utilities();
    function StyleToJS(style2, options) {
      var output = {};
      if (!style2 || typeof style2 !== "string") {
        return output;
      }
      (0, style_to_object_1.default)(style2, function(property, value) {
        if (property && value) {
          output[(0, utilities_1.camelCase)(property, options)] = value;
        }
      });
      return output;
    }
    StyleToJS.default = StyleToJS;
    module.exports = StyleToJS;
  }
});

// node_modules/@copilotkit/react-ui/dist/chunk-XWG3L6QC.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var OpenIcon = (0, import_jsx_runtime.jsx)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    width: "24",
    height: "24",
    children: (0, import_jsx_runtime.jsx)("g", { transform: "translate(24, 0) scale(-1, 1)", children: (0, import_jsx_runtime.jsx)(
      "path",
      {
        fillRule: "evenodd",
        d: "M5.337 21.718a6.707 6.707 0 01-.533-.074.75.75 0 01-.44-1.223 3.73 3.73 0 00.814-1.686c.023-.115-.022-.317-.254-.543C3.274 16.587 2.25 14.41 2.25 12c0-5.03 4.428-9 9.75-9s9.75 3.97 9.75 9c0 5.03-4.428 9-9.75 9-.833 0-1.643-.097-2.417-.279a6.721 6.721 0 01-4.246.997z",
        clipRule: "evenodd"
      }
    ) })
  }
);
var CloseIcon = (0, import_jsx_runtime.jsx)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: "1.5",
    stroke: "currentColor",
    width: "24",
    height: "24",
    children: (0, import_jsx_runtime.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M19.5 8.25l-7.5 7.5-7.5-7.5" })
  }
);
var HeaderCloseIcon = (0, import_jsx_runtime.jsx)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: "1.5",
    stroke: "currentColor",
    width: "24",
    height: "24",
    children: (0, import_jsx_runtime.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M6 18L18 6M6 6l12 12" })
  }
);
var SendIcon = (0, import_jsx_runtime.jsx)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: "1.5",
    stroke: "currentColor",
    width: "24",
    height: "24",
    children: (0, import_jsx_runtime.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M12 19V5m0 0l-7 7m7-7l7 7" })
  }
);
var MicrophoneIcon = (0, import_jsx_runtime.jsx)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: "1.5",
    stroke: "currentColor",
    width: "24",
    height: "24",
    children: (0, import_jsx_runtime.jsx)(
      "path",
      {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M12 18.75a6 6 0 006-6v-1.5m-6 7.5a6 6 0 01-6-6v-1.5m6 7.5v3.75m-3.75 0h7.5M12 15.75a3 3 0 01-3-3V4.5a3 3 0 116 0v8.25a3 3 0 01-3 3z"
      }
    )
  }
);
var StopIcon = (0, import_jsx_runtime.jsx)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: "1.5",
    stroke: "currentColor",
    width: "24",
    height: "24",
    children: (0, import_jsx_runtime.jsx)(
      "path",
      {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M5.25 7.5A2.25 2.25 0 017.5 5.25h9a2.25 2.25 0 012.25 2.25v9a2.25 2.25 0 01-2.25 2.25h-9a2.25 2.25 0 01-2.25-2.25v-9z"
      }
    )
  }
);
var RegenerateIcon = (0, import_jsx_runtime.jsx)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: "2",
    stroke: "currentColor",
    width: "16",
    height: "16",
    style: { minWidth: "16px", minHeight: "16px" },
    children: (0, import_jsx_runtime.jsx)(
      "path",
      {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0l3.181 3.183a8.25 8.25 0 0013.803-3.7M4.031 9.865a8.25 8.25 0 0113.803-3.7l3.181 3.182m0-4.991v4.99"
      }
    )
  }
);
var CopyIcon = (0, import_jsx_runtime.jsx)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: "2",
    stroke: "currentColor",
    width: "16",
    height: "16",
    style: { minWidth: "16px", minHeight: "16px" },
    children: (0, import_jsx_runtime.jsx)(
      "path",
      {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 01-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 011.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 00-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 01-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 00-3.375-3.375h-1.5a1.125 1.125 0 01-1.125-1.125v-1.5a3.375 3.375 0 00-3.375-3.375H9.75"
      }
    )
  }
);
var SmallSpinnerIcon = (0, import_jsx_runtime.jsx)("span", { className: "copilotKitSpinner", style: { width: "13px", height: "13px" } });
var SpinnerIcon = (0, import_jsx_runtime.jsx)("span", { className: "copilotKitSpinner", style: { width: "24px", height: "24px" } });
var ActivityIcon = (0, import_jsx_runtime.jsxs)("div", { style: { display: "flex", alignItems: "center", gap: "4px" }, children: [
  (0, import_jsx_runtime.jsx)("span", { className: "copilotKitActivityDot", style: { animationDelay: "0s" } }),
  (0, import_jsx_runtime.jsx)("span", { className: "copilotKitActivityDot", style: { animationDelay: "0.2s" } }),
  (0, import_jsx_runtime.jsx)("span", { className: "copilotKitActivityDot", style: { animationDelay: "0.4s" } })
] });
var ThumbsUpIcon = (0, import_jsx_runtime.jsx)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: "2",
    stroke: "currentColor",
    width: "16",
    height: "16",
    style: { minWidth: "16px", minHeight: "16px" },
    children: (0, import_jsx_runtime.jsx)(
      "path",
      {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M6.633 10.5c.806 0 1.533-.446 2.031-1.08a9.041 9.041 0 012.861-2.4c.723-.384 1.35-.956 1.653-1.715a4.498 4.498 0 00.322-1.672V3a.75.75 0 01.75-.75A2.25 2.25 0 0116.5 4.5c0 1.152-.26 2.243-.723 3.218-.266.558.107 1.282.725 1.282h3.126c1.026 0 1.945.694 2.054 1.715.045.422.068.85.068 1.285a11.95 11.95 0 01-2.649 7.521c-.388.482-.987.729-1.605.729H13.48c-.483 0-.964-.078-1.423-.23l-3.114-1.04a4.501 4.501 0 00-1.423-.23H5.904M14.25 9h2.25M5.904 18.75c.083.205.173.405.27.602.197.4-.078.898-.523.898h-.908c-.889 0-1.713-.518-1.972-1.368a12 12 0 01-.521-3.507c0-1.553.295-3.036.831-4.398C3.387 10.203 4.167 9.75 5 9.75h1.053c.472 0 .745.556.5.96a8.958 8.958 0 00-1.302 4.665c0 1.194.232 2.333.654 3.375z"
      }
    )
  }
);
var ThumbsDownIcon = (0, import_jsx_runtime.jsx)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: "2",
    stroke: "currentColor",
    width: "16",
    height: "16",
    style: { minWidth: "16px", minHeight: "16px" },
    children: (0, import_jsx_runtime.jsx)(
      "path",
      {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M7.5 15h2.25m8.024-9.75c.011.05.028.1.052.148.591 1.2.924 2.55.924 3.977a8.96 8.96 0 01-.999 4.125m.023-8.25c-.076-.365.183-.75.575-.75h.908c.889 0 1.713.518 1.972 1.368.339 1.11.521 2.287.521 3.507 0 1.553-.295 3.036-.831 4.398C20.613 14.547 19.833 15 19 15h-1.053c-.472 0-.745-.556-.5-.96a8.95 8.95 0 00.303-.54m.023-8.25H16.48a4.5 4.5 0 01-1.423-.23l-3.114-1.04a4.5 4.5 0 00-1.423-.23H6.504c-.618 0-1.217.247-1.605.729A11.95 11.95 0 002.25 12c0 .434.023.863.068 1.285C2.427 14.306 3.346 15 4.372 15h3.126c.618 0 .991.724.725 1.282A7.471 7.471 0 007.5 19.5a2.25 2.25 0 002.25 2.25.75.75 0 00.75-.75v-.633c0-.573.11-1.14.322-1.672.304-.76.93-1.33 1.653-1.715a9.04 9.04 0 002.86-2.4c.498-.634 1.226-1.08 2.032-1.08h.384"
      }
    )
  }
);
var DownloadIcon = (0, import_jsx_runtime.jsx)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: "2",
    stroke: "currentColor",
    width: "16",
    height: "16",
    style: { minWidth: "16px", minHeight: "16px" },
    children: (0, import_jsx_runtime.jsx)(
      "path",
      {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3"
      }
    )
  }
);
var UploadIcon = (0, import_jsx_runtime.jsx)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: "1.5",
    stroke: "currentColor",
    width: "24",
    height: "24",
    children: (0, import_jsx_runtime.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M12 4.5v15m7.5-7.5h-15" })
  }
);
var CheckIcon = (0, import_jsx_runtime.jsx)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: "2",
    stroke: "currentColor",
    width: "16",
    height: "16",
    style: { minWidth: "16px", minHeight: "16px" },
    children: (0, import_jsx_runtime.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M4.5 12.75l6 6 9-13.5" })
  }
);

// node_modules/@copilotkit/react-ui/dist/chunk-MRXNTQOX.mjs
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a28, b14) => {
  for (var prop in b14 || (b14 = {}))
    if (__hasOwnProp.call(b14, prop))
      __defNormalProp(a28, prop, b14[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b14)) {
      if (__propIsEnum.call(b14, prop))
        __defNormalProp(a28, prop, b14[prop]);
    }
  return a28;
};
var __spreadProps = (a28, b14) => __defProps(a28, __getOwnPropDescs(b14));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e9) {
        reject(e9);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e9) {
        reject(e9);
      }
    };
    var step = (x10) => x10.done ? resolve(x10.value) : Promise.resolve(x10.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/@copilotkit/react-ui/dist/chunk-IEMQ2SQW.mjs
var import_react = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var ChatContext = import_react.default.createContext(void 0);
function useChatContext() {
  const context = import_react.default.useContext(ChatContext);
  if (context === void 0) {
    throw new Error(
      "Context not found. Did you forget to wrap your app in a <ChatContextProvider> component?"
    );
  }
  return context;
}
var ChatContextProvider = ({
  // temperature,
  // instructions,
  // maxFeedback,
  labels,
  icons,
  children,
  open: open2,
  setOpen
}) => {
  const memoizedLabels = (0, import_react.useMemo)(
    () => __spreadValues(__spreadValues({}, {
      initial: "",
      title: "CopilotKit",
      placeholder: "Type a message...",
      error: " An error occurred. Please try again.",
      stopGenerating: "Stop generating",
      regenerateResponse: "Regenerate response",
      copyToClipboard: "Copy to clipboard",
      thumbsUp: "Thumbs up",
      thumbsDown: "Thumbs down",
      copied: "Copied!"
    }), labels),
    [labels]
  );
  const memoizedIcons = (0, import_react.useMemo)(
    () => __spreadValues(__spreadValues({}, {
      openIcon: OpenIcon,
      closeIcon: CloseIcon,
      headerCloseIcon: HeaderCloseIcon,
      sendIcon: SendIcon,
      activityIcon: ActivityIcon,
      spinnerIcon: SpinnerIcon,
      stopIcon: StopIcon,
      regenerateIcon: RegenerateIcon,
      pushToTalkIcon: MicrophoneIcon,
      copyIcon: CopyIcon,
      thumbsUpIcon: ThumbsUpIcon,
      thumbsDownIcon: ThumbsDownIcon,
      uploadIcon: UploadIcon
    }), icons),
    [icons]
  );
  const context = (0, import_react.useMemo)(
    () => ({
      labels: memoizedLabels,
      icons: memoizedIcons,
      open: open2,
      setOpen
    }),
    [memoizedLabels, memoizedIcons, open2, setOpen]
  );
  return (0, import_jsx_runtime2.jsx)(ChatContext.Provider, { value: context, children });
};

// node_modules/@copilotkit/react-ui/dist/chunk-C3GSYRC3.mjs
var import_react2 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var Window = ({
  children,
  clickOutsideToClose,
  shortcut,
  hitEscapeToClose
}) => {
  const windowRef = import_react2.default.useRef(null);
  const context = useCopilotContext();
  const { open: open2, setOpen } = useChatContext();
  const handleClickOutside = (0, import_react2.useCallback)(
    (event) => {
      var _a2;
      if (!clickOutsideToClose) {
        return;
      }
      const parentElement = (_a2 = windowRef.current) == null ? void 0 : _a2.parentElement;
      let className = "";
      if (event.target instanceof HTMLElement) {
        className = event.target.className;
      }
      if (open2 && parentElement && !parentElement.contains(event.target) && // prevent closing the window when clicking on the debug menu
      !className.includes("copilotKitDebugMenu")) {
        setOpen(false);
      }
    },
    [clickOutsideToClose, open2, setOpen]
  );
  const handleKeyDown = (0, import_react2.useCallback)(
    (event) => {
      var _a2;
      const target = event.target;
      const isInput = target.tagName === "INPUT" || target.tagName === "SELECT" || target.tagName === "TEXTAREA" || target.isContentEditable;
      const isDescendantOfWrapper = (_a2 = windowRef.current) == null ? void 0 : _a2.contains(target);
      if (open2 && event.key === "Escape" && (!isInput || isDescendantOfWrapper) && hitEscapeToClose) {
        setOpen(false);
      } else if (event.key === shortcut && (isMacOS() && event.metaKey || !isMacOS() && event.ctrlKey) && (!isInput || isDescendantOfWrapper)) {
        setOpen(!open2);
      }
    },
    [hitEscapeToClose, shortcut, open2, setOpen]
  );
  const adjustForMobile = (0, import_react2.useCallback)(() => {
    const copilotKitWindow = windowRef.current;
    const vv = window.visualViewport;
    if (!copilotKitWindow || !vv) {
      return;
    }
    if (window.innerWidth < 640 && open2) {
      copilotKitWindow.style.height = `${vv.height}px`;
      copilotKitWindow.style.left = `${vv.offsetLeft}px`;
      copilotKitWindow.style.top = `${vv.offsetTop}px`;
      document.body.style.position = "fixed";
      document.body.style.width = "100%";
      document.body.style.height = `${window.innerHeight}px`;
      document.body.style.overflow = "hidden";
      document.body.style.touchAction = "none";
      document.body.addEventListener("touchmove", preventScroll, {
        passive: false
      });
    } else {
      copilotKitWindow.style.height = "";
      copilotKitWindow.style.left = "";
      copilotKitWindow.style.top = "";
      document.body.style.position = "";
      document.body.style.height = "";
      document.body.style.width = "";
      document.body.style.overflow = "";
      document.body.style.top = "";
      document.body.style.touchAction = "";
      document.body.removeEventListener("touchmove", preventScroll);
    }
  }, [open2]);
  (0, import_react2.useEffect)(() => {
    document.addEventListener("mousedown", handleClickOutside);
    document.addEventListener("keydown", handleKeyDown);
    if (window.visualViewport) {
      window.visualViewport.addEventListener("resize", adjustForMobile);
      adjustForMobile();
    }
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
      document.removeEventListener("keydown", handleKeyDown);
      if (window.visualViewport) {
        window.visualViewport.removeEventListener("resize", adjustForMobile);
      }
    };
  }, [adjustForMobile, handleClickOutside, handleKeyDown]);
  return (0, import_jsx_runtime3.jsx)("div", { className: `copilotKitWindow ${open2 ? " open" : ""}`, ref: windowRef, children });
};
var preventScroll = (event) => {
  let targetElement = event.target;
  const hasParentWithClass = (element5, className) => {
    while (element5 && element5 !== document.body) {
      if (element5.classList.contains(className)) {
        return true;
      }
      element5 = element5.parentElement;
    }
    return false;
  };
  if (!hasParentWithClass(targetElement, "copilotKitMessages")) {
    event.preventDefault();
  }
};

// node_modules/@copilotkit/react-ui/dist/chunk-Q5V6S67N.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var ExclamationMarkTriangleIcon = (0, import_jsx_runtime4.jsx)(
  "svg",
  {
    width: "13.3967723px",
    height: "12px",
    viewBox: "0 0 13.3967723 12",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    children: (0, import_jsx_runtime4.jsx)("g", { id: "Page-1", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd", children: (0, import_jsx_runtime4.jsx)("g", { id: "exclamation-triangle", fill: "#CD2121", children: (0, import_jsx_runtime4.jsx)(
      "path",
      {
        d: "M5.39935802,0.75 C5.97670802,-0.25 7.42007802,-0.25 7.99742802,0.75 L13.193588,9.75 C13.770888,10.75 13.049288,12 11.894588,12 L1.50223802,12 C0.34753802,12 -0.37414898,10.75 0.20319802,9.75 L5.39935802,0.75 Z M6.69838802,2.5 C7.11260802,2.5 7.44838802,2.83579 7.44838802,3.25 L7.44838802,6.25 C7.44838802,6.66421 7.11260802,7 6.69838802,7 C6.28417802,7 5.94838802,6.66421 5.94838802,6.25 L5.94838802,3.25 C5.94838802,2.83579 6.28417802,2.5 6.69838802,2.5 Z M6.69838802,10.5 C7.25067802,10.5 7.69838802,10.0523 7.69838802,9.5 C7.69838802,8.9477 7.25067802,8.5 6.69838802,8.5 C6.14610802,8.5 5.69838802,8.9477 5.69838802,9.5 C5.69838802,10.0523 6.14610802,10.5 6.69838802,10.5 Z",
        id: "Shape"
      }
    ) }) })
  }
);
var ExclamationMarkIcon = (0, import_jsx_runtime4.jsx)(
  "svg",
  {
    width: "14px",
    height: "14px",
    viewBox: "0 0 14 14",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    children: (0, import_jsx_runtime4.jsx)("g", { id: "Page-1", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd", children: (0, import_jsx_runtime4.jsx)("g", { id: "exclamation-circle", fill: "#EC662C", children: (0, import_jsx_runtime4.jsx)(
      "path",
      {
        d: "M7,14 C10.866,14 14,10.866 14,7 C14,3.13401 10.866,0 7,0 C3.13401,0 0,3.13401 0,7 C0,10.866 3.13401,14 7,14 Z M7,3 C7.41421,3 7.75,3.33579 7.75,3.75 L7.75,6.75 C7.75,7.16421 7.41421,7.5 7,7.5 C6.58579,7.5 6.25,7.16421 6.25,6.75 L6.25,3.75 C6.25,3.33579 6.58579,3 7,3 Z M7,11 C7.55228,11 8,10.5523 8,10 C8,9.4477 7.55228,9 7,9 C6.44772,9 6,9.4477 6,10 C6,10.5523 6.44772,11 7,11 Z",
        id: "Shape"
      }
    ) }) })
  }
);
var ChevronDownIcon = (0, import_jsx_runtime4.jsx)(
  "svg",
  {
    width: "7px",
    height: "4px",
    viewBox: "0 0 7 4",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "currentColor",
    children: (0, import_jsx_runtime4.jsx)("g", { id: "Page-1", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd", children: (0, import_jsx_runtime4.jsx)("g", { id: "Group", fill: "currentColor", fillRule: "nonzero", children: (0, import_jsx_runtime4.jsx)(
      "path",
      {
        d: "M3.71690723,3.90271086 C3.59268176,4.03242971 3.39143629,4.03242971 3.26721082,3.90271086 L0.0853966595,0.57605615 C-0.0314221035,0.444981627 -0.0279751448,0.240725043 0.0931934622,0.114040675 C0.214362069,-0.0126436935 0.409725445,-0.0162475626 0.535093061,0.105888951 L3.49205902,3.19746006 L6.44902499,0.105888951 C6.52834574,0.0168884389 6.64780588,-0.0197473458 6.7605411,0.0103538404 C6.87327633,0.0404550266 6.96130636,0.132492308 6.99009696,0.250359396 C7.01888756,0.368226483 6.98384687,0.493124608 6.89872139,0.57605615 L3.71690723,3.90271086 Z",
        id: "Path"
      }
    ) }) })
  }
);
var CheckIcon2 = (0, import_jsx_runtime4.jsx)(
  "svg",
  {
    width: "14px",
    height: "14px",
    viewBox: "0 0 14 14",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    children: (0, import_jsx_runtime4.jsx)("g", { id: "Page-1", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd", children: (0, import_jsx_runtime4.jsx)("g", { id: "Group-2", transform: "translate(-118, 0)", fill: "#1BC030", fillRule: "nonzero", children: (0, import_jsx_runtime4.jsx)("g", { id: "Group", transform: "translate(118, 0)", children: (0, import_jsx_runtime4.jsx)(
      "path",
      {
        d: "M0,7 C0,3.13384615 3.13384615,0 7,0 C10.8661538,0 14,3.13384615 14,7 C14,10.8661538 10.8661538,14 7,14 C3.13384615,14 0,10.8661538 0,7 Z M9.59179487,5.69764103 C9.70905818,5.54139023 9.73249341,5.33388318 9.65303227,5.15541491 C9.57357113,4.97694665 9.40367989,4.85551619 9.20909814,4.83811118 C9.01451638,4.82070616 8.82577109,4.91005717 8.71589744,5.07158974 L6.39261538,8.32389744 L5.22666667,7.15794872 C5.01450582,6.96025518 4.68389046,6.9660885 4.47883563,7.17114332 C4.27378081,7.37619815 4.26794748,7.70681351 4.46564103,7.91897436 L6.08102564,9.53435897 C6.19289944,9.64614839 6.3482622,9.70310251 6.50588106,9.69010587 C6.66349993,9.67710922 6.80743532,9.59547613 6.89948718,9.46687179 L9.59179487,5.69764103 L9.59179487,5.69764103 Z",
        id: "Shape"
      }
    ) }) }) })
  }
);
var CopilotKitIcon = (0, import_jsx_runtime4.jsxs)(
  "svg",
  {
    width: "33px",
    height: "35px",
    viewBox: "0 0 33 35",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    children: [
      (0, import_jsx_runtime4.jsx)("title", { children: "bd5c9079-929b-4d55-bdc9-16d1c8181b71" }),
      (0, import_jsx_runtime4.jsx)("g", { id: "Page-1", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd", children: (0, import_jsx_runtime4.jsx)(
        "image",
        {
          x: "0",
          y: "0",
          width: "33",
          height: "35",
          xlinkHref: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAI0AAACXCAYAAAAoE9hYAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAjaADAAQAAAABAAAAlwAAAACI8Oz3AABAAElEQVR4Ae2dCYAlVXnvv6q79d7TMz37sIMgKKBCkLhkSKK4xJUMQVzAqJBgNDGJa2LsvJfERI0aiEbwRXnoQ2VYRASiQUFRUGQm7DAwzDBbT+/rvbfvXu/3P1V1+84CzEw3MNPD6a579nOqzvev73znO0t59rzZbQu88sXndp2w4gVLp5oG+6+47ivDu010kAb6B+lzP+Vjr1zZk0xV/ddMVIufap/34g+e+s9rX9351U1dT5npIIpMHkTPusePmto+tKhctVWPDW1/c27hIVNbCsFbCpa7/aR/f/SWFV2ZX974zsNG97iwOZjwedDshqiZlL3AD9JH9Y8PpTYMPJEuLj7+pclE5vBquXZ6MV/56Zu/ueGnmWpqzer3HzKym+xzPsib80+4lw/Y09Pjr7lm9GO+eR+eKI4tXdeRsomXv8a6Dj3eqn6iRoPl5qW83o60vyaT9O5IWPX2llrH+hsuXJbfy6oO2OTPg2Yn0p1/6ueWFK1wWTKReo1XDZoeqw7YxhcfYfNf9NtWSHTYVLVqxSAIqoFlU76NzEt6mzqSCQBkt3up1NrlHUdsXX22V92p2DnlfR40O5Az8N57+pfPgcv8YzLZdHjKS3i9uS1254Kitf3271qq81ATGkq1wPJCDVexEtS8oFZKpBLZeWl/w7yE98uUZ3cnLPhNefSFmx7s8Uo7VDEHPM+DpoGI71v5xaODkn02kUi9Ne03Jz3Ps2Jh3O4ubbCB006yzqNPsYrfYhbUrBwEBnZstBLYBFIzSDIXQB5LeOY3JXoXJv3/afP9H9dqdtv8XHb9mp5T5kQX9rwg3ACaaiF4ZcL3T0x6KQATaiNS6RZbmm+yib7tFiwfM7+1ySTYJACMuE6zktFP5X3PKgDIyoCnULFavrKs3/eW9af8N3qZRN9wU9N9R33hgZ8kveRvyuXs2g2fOGW8oeoDyvk8p4nI9Z7f/eLyZMn/AkR9azrR3ASvMHgJsXRD2X67q3nUci87yVoPOQluk4apBI7blNVVkSyLXRHrURZYiwlAdF8EhmFqaV5RL+XnM+nEffN8W2OJxG2e1R5MpPz++dUFxWMP+3lh9dln7/fy0POggZYaMT3xo67XpnzvX1PJzPFJP2PIusAFonNVK1P2QOEJ23z0Qms/+dVWycwHNDUHnBJJCoBl3PVQ5HDAIZD8rrvCcragUI0BRGCSpk95401pf327F/w64QcP1FLN92Rq3qZM81h2xchUaeVnVpZ6PE8w3K/M86CBHBe86tKlQa3wlwk/+cFUoqVZXVMAKAQYcRSDbn3ZrfZAe8EqLz/dMguPtrKHqEuUZBsxkzxgEbcpi7u4rPw4O/KL7MrAvwOPQCSOFHEg870KHKevxfc2pBOJe2F066pWe6g5mehrSVo2KLdM+C21wvoPHV225xhIBz1oVq26KjGvt/+Nnnl/m0o2n5pI0IeIsIDGWVBedr44bg9Vttn2E4+wjhecYuVMZ8hAAIp6InGbCTBQhJuEeCOQsJDjqDxd8mPrR7ZAFaeJw0URBGlL+oVEwgaafX+T79umivkbkKWeyPjJrS1+ZSRhifFMMjNR7U5MPLHp8JL1PHsc6aAXhDu2TnQGvvdKRkwvSAIYDw5SC2ADIp4jJDaOTLLJFpeabWRgwCrLRiyZ7rAy7ECDJQ8wpEjVjLuMQFxVRknLngrA9uVXObgVF0S2hGgVoHAllRGwwq6sqeoFh2a5LGGvskStAAcc8xLFrRXP206Ovlott63Sm3y8LbOud8nFj/UlvMmxtnRtbM0FLys8k9xId3zQGsdl+gdP84PEF1KJ9OmpRMa1RbUmqom44jL6Q36hK8kWRuy+1KBNnPhCaznyZVZJNiPritMg9wCKEnaWrHnyqedxQBHbESAcR1GxKjcs3rlxOqOw3RnlazQRxgBFYAl/Cq40giy2vdn3NgaJxBMJv/ZgS8bvbc/4A8lydaw14eeqqdzEmgtPKTcWMxP3Qc1p2scmFyc8/3UJL/FiAcZHlpGAK/2MBOHQhFSSnNOUarPu8pils0PGINxGLAND8WEEGLhJAnw0wT2qcJIC+R1DcdxF8VySdxxnaSw7dquQnYyqhnOFJrZJrywBBVdqLVaxFtCwAg53qiWq5UzCHylXaqMTU9brIw+1+tbfWWldd9IXHxpIJoLBZCY9kilXpyrJYi7d3zGx8jOH77WwHd9JdGMHj9Wz8tZkf/Dwa7wg8Zl0svk0N2KCEkwQOOA4ARhWEY+iZNdqZZsIhm3By5qtdNwLbU1hqY0DH1FQHMdxGzhDEaJOYGsILkZDIeFVd8dhje0dgaExqE6dyOGsRrfKacig7lBIFUABm+f7tWY/KACkQbA65vneIIL2cMazyXTCG0glElsyCZvgxZmyWmXKTyfGWpPJscHc1NT/jCUqlsoFJw4+UFm06RfFyuCjudtuu62i2g5aTjNU3rDISyTfgODruEw8YqqpxSGyGEIAAdQLiBDqpESNxQvm2wsOa7LtqSnLTObQu2QizqRoyTbkASxViJYjyPUJyurYjsrCTbyTYyL6h4THE/uJDRM2BDQ4w3RR+jjccbAozOV3Jfj5mteSD4LDCDrM5/6yPBDjvmoq4RUSXpBtTnilZq9aSfpW8CvVXD5ZG68EyUnzikzB1aqPZw4tVg77/bHjW4/+1etftfC2m29fPXRQgub8ld9sCqrVF9ItrUz56Rbf1/BZbCCkm7onEVI9QBgSERnCd3Q3WWtXxiaGxq00mbJUV4cFKPscJkiNvsXlaRYwAE4Wn4bkrkCVqyL147hPFC5rFyN2gXHCtHNEeRUWXWFhkd8VvEucerc06WSrRCwYjie6t3EPbRXJYAQmEdwD6irAHlO1YiWVG6mWhweCyuQAPGi8XCoUTignukdXrVp160EJmiYrLPH8zNmJZPK4FJzCGahO22F8GjjSz7gQhYdAgN1b17K0+anA+h7rs4lK3lo6llg1AWigiBchR9xJwHP5CM/icsARoJQmtgUc1SHryYyAFpvYraDYrbg4SRTmgxCN5gSSBD9pbBFawEmQWMl0aWSvzA5QvDR+ecqq+WFvcnBLakHvllStr8/aJkdtHiUUUi3ztle212657YbaQQeaj5x+VXMtUTwTAeVt6WQm6QMEJ/TSgHXahQigOSXjqF0VWbNMm29ti5JWypattGmK6YSCVQ8ftWSGlxYSSa5RcobwTjhOwWFaCUFWNsbAWlIR9kwCjgqOQCbSuYzOsfMPafl3ZmdbgS5MhAcouB04qE+gkdsBBDsGjGzlEagVnwjQAE1NWHmyz/L9W6za32udA+O2rNJirbVWeqiKsUykmEk0PZzIDj9AluCgAg0k9S5MfGthc83elkgmFkiRp0YV8eqACduUcHQwDgR6X3kLSdDayQiqw2x8O0SZzFirN27V0QFLdyxkGqnFEU7UV9oK2fRWCxut/IifFQCjgCNBuRYDh3BXue7jyYy7RyJ1K85oZkyzEPzwAOIYGsFpZkJ2IgKEezb8SivgiveF4CEsQNqaGrXSWJ8Vejdapr/fusbytqDSZIsSS6y9eR65zIa4ysZUv+fdc+zjfzF8n93hwOYiD4afj772Wy1NleC1NN1vo5eByYRDbPfC0+CiQf0XArtuRqo6JSBt+5KkJaBUdoChdaXZumrj1j/Ub7VFK8xvb7EahEnx45R7gEOE8slbBiQiXELgwV/ALwFZQ/NQz6N6n9owke7AoFSurDpAFB7etcLFcZwKAHcIFKUHLspPvYlakS5ozAqjvTbVu8FSA0O2aKJoi3ie7tQKa2lpRRkdCfe8LAlUEZVqYYzmeHC1hZOpBxWnqdUC1v4m/iKdTranWQgMDc2XAKg/GtsNanCLdYsAjjwkqjAMT6GA6VrhWxk2Md5XsXSiybqCVts+OGrFsUFrbetmxMTst/JTpt5yn7wChwRRAUplJumy1HUILJKPBRyNY52sjL07Q1Euj8qUkeW6HrnxxBwkjhdwZEIbENEFJUpTFoD27HCvFbc+YW2A5Yhszbr9DutuWmpNTa0Ai1K5r/Av5JJowkvmTW2s+JP3u0L5OWhA86HX35SplUY+7Cf8E1LpFIwDQroRDqSkoTRKEetmHR7ekIQSbBOMrKpQta2bkROcZnx7xfKjUsamrCPRZl3jfTY50GteN9r+FuCgMhxAICXFqEy3OoLy1V3pPwSMwBpWLZ2f3LEhiZI5IAloMgJjnF+RcbjSiZO4fxcuCKlAngfB1grIK/Snk8PbrYhgO28sZ0dMJW2hv9A62+ZZiukRdcVhlmnoqowqYGPWf6TcvPBXP/j5lwfdjfBzUIAGQdf7+GuvfmXF89+cTCctlQofO34z1RhqavACBWhw5yAMQjtdDeDpWIzg2BzY5GDNWClhgA+1Hl1UIWW5wSEWXTEf1dxOphQEFolpXBAjW7/wHziZuAs1qR6MMEvRrttQikbj8hMQhyJ94Qu7HuVxBlvgCWP0q1rgKuWSBVMjlh/aYtnBXkv3D1k7XdBR1Ywt9hdYZ0snwm0IFpW/Q91hMa5eacdZlDYy0dZ5N8nqiDooQPPRM7+1MKglP5FOp+enm3lkNQwm5Cw0GlTQCMq9o7ghr2siyTxV1LySYzqXI//AcRhkGC+g+WjDUgBkHtxmYGzMSsN9TiD2mf2uggpxMRFXLc3cUESEEDghgNwtuHjpRwQmmYhmYeRufqNbdzHqfuSXwG7VogXFrFUmBy0/0mvV7b0WjIzb8nxgy4M2m5/qthZGeX4Cbqjn1Z/yycSFOpsf/qUZ94JqrZhKPjbc5K8JE4a/cx40LLBKTt6ReT3d9avTzSjjkChdt+QaLXzrpcF1wq7ai3Z0RFX7QHGPvqa5kxEQ3dPUeGBTYyRwxJKdtLYkXVRx0gYGB6y6iHmpjLiNhOgQMFiOQAKPAykEk1v0chexZHBhOJwJ+RRORdUpKmcoa4U5NEpDM1cRV5m04ni/FYe2W7m/zzLjWQeWRV6HdaQ6rJmJVZ/u1IFBRYYFO1fdqxuN6nIvj+7aD4rFVGLNkYmugUbUzHnQTNx53Akpz7sg1YQkk0YqgJ+H8oC4iwhH40RgUc+kPsNNJahrQigRdxGXSbUENrYJGqHiTdA1KU4FpJEJukttNtzP8HUZ3GbeYt7mZleJ4wAqEmKE77YIE5JGdTaCwgHJxUYpuBclCQEUcir5fdWLkFWVrJIdtfJIv1WHByw5NGYLciVbWEpZZ6Lb2ptaLEUXZCz1kOFp+FUJDWYH7w4emqEWMO0wNpH07/7x6h2XoM5p0Hx81VWdXs7eiT7m5AzL3xKMTQUUdqY4sKgdJew64KhNFYkRR1D70mx0TTXrXEY4tMoOkLaSABSKUxrgBQtrS7VaW27MxuA2vOLmt2gSUybkIGrkGBTKJtDKFnBc3bjjYTJOZxSve3BCrgthIF8uWA2uUpoYtiKCbW1o2NKjE7aARcrd1SYE825ra251Qrp7OygkBIsrIPpxJVO2HnJXE4bqt0Yvm+hdUq49uHOqOQuaq1iR9z9Tidf4SW9VpjnZlExBFtqrsa0cRlzDRsDRyAl2o7UzbrgK98+g0GtfUbXCJFsrhxBEWU7nqE5aAUHD8wyg6co328TgsFXGUfY1tQMmlPdwK3Evx8lAgMgVcphpUmqorwgXF1HHhRHicx+1aokeKM88F0AZHbTKQJ+lhsdtXrZkXeWkdVm7tdL9ZFLN4IR7E71VXvQCREWG4c5DAqXZyYTSEVHcj56fOyz5yeTdR1ZO7N0p6dwdPd1v6eOTyeCdybS/nG4pVlk0PD/N5Bo3bmc1Jk1FmJvxFjtgLNzazfRBR2AjjyWskhfnEcHV6iAqIk6CuaeuRLsNTgzaFAJxav5S85sBjeJdsQIMHkz4GwHIhfBDmjicjXe85GyBqbIeOTdu+fEhFHGMdgcHLc1weUGuZvMrSevwu6wZoGgdkBsyx2WHBYUPFZe/O5REcTFYKMSlEmicWI4OkvHi2p7bzqCD3tHMSU7zyVU3LfRrpYsYXr8i1ZxMSSejFzo2cbtGlKq/lSEXQNjkha0BGI9epm0p4ABA+UHkoarPPBPkr6LJVSNja1gqrW97upPh96Rt6N1urUsPtWQLs98RIWJIqD7VLWCGwItvCqmH1YLqfkqUMQVQ8qNDVgQoLcMT1pkvA5S0dRrzQckWOBkLxugW4+dw9/0UwIifuw6QOK0A3eBWV+gGAXqmlD+YSgR3xnkb7TkHGinxMlZ6jZ/wzkg2JeZruFxv3YhGcUM5rwjoiCgOE3KEkAPR7bTUrKUbjfAUr90EsgxlaSMAEqJLGwKHRVt0VSzkctrVvmFGMSN91rxghdWSmnESaaOKHUmoI7olx1UQamsMlYu5UZtATikPDVkwzJrAyZItoN6FNea42EPeJK7CCEgz7SoxBF0jKZ/MHT+t4nX/8b04r0JcRtn6cxyRBqCre7jW5W90kTv9zDnQdDRPnYbk8X64zFHwGMY5NEpMpPjhd9dwIKdODLnpJZrnMzrqrDBNwGLzfMK0ikIAc1wI8IiANbiYdDnS6XQ2zbdulHyD2/ssWDFuibZFACQUe52conopIKE1yBW4CkCZHB+0yf5tDJWHLDmaQzYKrLuGUJuErySZB0Kv4lR60TPoHp/ckAgT/k67ph8XWEx7SEdK9x/mYFEIL0CVZ2HGPOn/8pLVF+W+ah90ZTb+zCnQfHbV9UcXzT6EHPNbmUwyqW5F635l1NhqGicghm2l4GkD0WUECqXxEElaFtGAaWalWasmfY1AI3rXmPnTdINPFyYAJdRdVRPWyjzOolKXjaBUq2aHAQ2b6ihIJaMoM5/5nwpD5SxAGUf2ybLV1x+atA7mgA5FWzs/iZySbrWMFrgzVHb3q3vSje3WhMQOf5Ug8tcDYn9kuzJwu/84LLRBE8HcqcceC98rsWbkbkJ2W/WcAU3Pqv+aX/HLLHnwXpnJpFrontxb5cAStlPYqFEzNLxwLrzuJ17LFvxMzdJdyBkVFPPZFAKwdDyARfKOZFUpBLnEZRicAhwAxNqE7nK3LSzkrDAG56CLYt0tKycnbAoheWRgK9MQfVYcGKb7KdqSYsq6mfSchwKuKd0cDpUhXdhNToMlJq+j+c4/jc8Wxe3ITfR4KkGgCI1zRQ88XXYoz/BUzJr7m8e9zC5D7Sj73Bg9reSMvIRfXIle4Wy4zCJkDxn3jG7YNN1a0dskZMRtGUeqWTFiC4wX0m10TS1VlGhMWE6FmmTpZcIph2nQ+Exfo22PgIQiEC3swrFWe2yg35q6nrBaqslGezfZ8JYt5g1OWDtrKw9HTulKzLOOTAeykHZBTAu17qYh3PRdhSHR3cWeuh0/ZxwQ5uOX528sI+QiYarpmCi1aytAA4dVe/mp5G8OO+29w3bzH8fF7mDPCU7zu0tfeiyPegES/ylpZrClxHPtoEfVyEncBVvvbtjIalS8siLbuaNmFm6aOljRlq5ZaYQhFENcFL8ug+ve6pyGSUkaWmGsObZiscDWXOSUYNIe2bjdmkf7bSkASQ+X7egiM8upZdbGNEMKIMG2VCB3FLI+9xs6XWhjnNy6zfjXOeMfFxHDIEwVpozcWHFsY34XVo+j9WiIqqYlCNPJFj09vCFPYg5o0EAs7+/P++EhiVrij9C5vTrdFHMEnlYNQkOEoMCDCZU1zqmWCbkN3kjTLhcA4BewpLoqbmhdmUwbq/yYoIzIq26JRG7GmpFPqVK0bClrfbkR24hi7/HJEdvC0LmA/DI6mbeXJA61o1qOZQjO/A9iuTTJ8KUQaJSjTqHeEYW3Gd1gBCjdkDN6ILmVKEy4U/IwWZy2MY1LGIJU0a5diFfbhIDSL92wx4vi+1kv5d3ZUNguzgMaNB9/3w9Y5pJaGST8d6QyfjOXk/xdo6pBXKO4VgoZjUNQ2AZyat2LjAvG7/Ih4CZbWBfbzFAa7lArhKv1xBgEFu2+rARFy5VzNsTa2s0IvJsZBT2SnbTxEkBDj2IdC0AGfdwkW3gZJje3tMNYWKCFMKRhti5BsOZeZoFQdTeAJ8KJu0d3X7z0Lkye+FKeaRPf/nRI+HDT4QKJ66SiJCFQXH+sRFGdcOm+TN5/bLqcXV0HLGgu/tBNmeKU9zLGtB9JphNHp5vYEk+35AyNowZXs8Rt7GIIDBVh9eCoRaJ0+JQu2Va2RKbK4iW6EVT1ASegTbGgSRxlOwDZlh+3zZNjtrlQsCGwEWiolV4MWFhAnG6jAPwsVTC40PrCmB3v51HKcRiSph64PMlB/GllnxZ8aWmE6+Lc3TSAJ7ofETa877jH0F26J3I59FP3OUcEiCgwhE88ixUGht10mFOpxf30C6zue8n85rF6wbtxHLCgKU3VXuR56Q8m0t5JDjCsb3ENETWUQCPkqLHVaDFYGruoKIkShk0DvTy6IYGGiR+WU1dtmC24A+heNjD305ebsI1TU9bPot+a1MWsUWEPCxNUrQCFYbJUya4sFUStTfOsd2oTuzCz6F26HFjcUlDN7ZBEo68AdueAoy7L3YXyqvsLbyn+1R0Cs8i7Y2T8crjniTO4+3AxhAgwKjd6TnyhM/S7dkOY19kHTO7ed/ZOs9r1IiPHAQeanp7A7+q9ZQXnI14Ijd7MZCQbJQUYPRE/ssO2ICxunCiI8Ph9U5qQBEqs0U/FCkXOVGwuWmsr229zZfvJo5vtsW2j1lsqWS8cIvAARmYpi2vgJk1cblJSQBERucJ+JvRKUGrttqnJfttQHrblzYvAFF0XlYrTCBQ6ItRxGHEeaRNViitDb7zIHIbpDlVDaKZdcYieTn+hCW3llmJRvjAOl4uK4ndwh7XRzedGkxmt0ntKc8CBZsWWO+dNpr03JYLE21jsnQ71J9EzCiRyhu3iGsuBKfK7AZRC1S0w4ajRQplZ5ByzyGPoVrZnWZOyNGWLU122abBkN20bJxziq+vR3pUMRNcwyikCVSgEjFmCaOmCcET1GbPf4jYbSuP24sq4daOLEctz3I9kjFXIzv1oKtwBCcEYZ4AyKFxqGnOWqEjFkSesRw75wsrCl0ZhoZH0Mh3WmGZHt9K4MsXp/MTWfMp/PC7jyewDDjS5xOSbmDb862ST351i9zp7TONWCpuPVlCIGkO21Pfh8gQUdQixZTbxCySTpZwNMjk4MJVDkM3acKFko6R9w6GL3RLhe9nXlG89BjkF7iJVsBsiuxIpNJYtVFFYffgrj+KwxTF0QFL7IhsYGrX1pSFbkOkGb+zGFJX40b1LUeiKw+0EZMk9SiDZx8k6YcmkqkNEzxYSWnHh8+56H8TU7w1H+O8CXXAUJ25cQ12gEqeSTfd01vyRuMYnsw8o0Fz8J//9EkSAD6L1PTwJYKT1Vcvo+XdsiNAv9l5jWFyAm0wy2hlGhT9UyNoWB5KijZbLNoY2dwL5pOrNt/kL2m3pohZGRr5tmGqzcgtcxrU8JIqBImqFQ6mwTesVK0IX3EFEj8PhUOVUuz3CSVovas0h22ibS8htxFUc5pVFWFM3pXySdRzLoRjSqDj+wyKxZXYAxA5+F6uf6TRqI3c/LjhyRwGyqEA8jlMAHso35wthqif/PWBA80/v+NFxtYT32VTaf5l2FGhRlZ43bgyam7amy0E2qcJNsuhJJhjtDOQnbBvcZAMC7ASySQ6QTPocFcL6F/bZwkXocphBlnxy9ArPjpxfYBjt21iOUVM0H+W4h2QUBwaRL6KiKKwwGVFX4Y4IYh9RuA4+QrYZGN9k/aUR6+AELWaxiBah4u4oeo4IPO7tV/6o63Npo+JVQSj3uEpdfaoydjh3GEDbyBFxPpcmqieGn6J1gdhqKpktesHa3m1sZXgac0CA5h/OvfEw9JV/zl6j32FeiQVl6uvpbnhYrZovViocPz/lup3hKXU1OXuikLeREgIt5/pOIiOM1Uc7AokuuhwWT7kRj4hPH3ZIZ5GF2IH9bJKTEYuqg0uNGpv4tRc46pdr9dDr0hHnujKliQxbXEu5AbqoUTuktthamLmuiaCOrQAckklnFHajeKhHKhzFqBQtSXVdVgREt0Q1Kjp+aUKvOIraRHZ4425BWT1tFIY/XB0oh6Cr5abB9kTN37hy5fml2257b5Rj99Z+D5o3vvJPu1K11F966co7UulKE4p9G+folJw4STmPXJJ3INmIzmQE5RrnPpMiZXmUbJXUPAs00nEgkQDLiny0sg4Mje1Bq3UwQXlMpw40MntwnE1xVZpGSV2T4lDLytS163qDCXQUV2T0RjvCKtxFOKIwiWWV1gX2RLbPBovDdlgruxnDrW8h8URkygrntbCpTp/ucLsmKEpdl0pzjCeqRn7Vr+pCfIQhSqllGs5EQfIJn6olNnIpn2Qq1T2VTj7itdvAU00fxHn3a9CcfPjJ8w5rPuI9A1PbzimVi51BqmLDgKWvVGQYTBeEvqRAd1Ni3rWQaEV2oJthYTXqXIACSMRJJIy6N1+PPN1oYQOI2BhabymTk4e0VW2kmLCRPJzAvfrE1UEgtxJjZKvFGzmPinZpccR5lFbhcJagucsmc4O2qThih7QsYZ0Me79FcKWRgap65wUcBxbKdvIOaULlHyRXGsJd8VGeEDCuhPAnCog5TXxLcT3T6eFjBEqp5yAW+BvaptBG7oHZn0GTOGbx7523oTJ50SNDmxeNoJWtZjmGlX2NFRq8mumymgCiYa00sLFyzSnYePKYsE/ZCLSaXkHElRUdNZvHnNNdgxnLsWvSUUygcK3N6+jKU7kKkKfhcuBRuNiAwiNTdxKHLDOZbreHy5N2QpBlp2MLRUsSI1GUTgTWJWKKu6gLcfJLvegwratO96FwMii741VRUFy9bJWlKzQhUGKfbI3Yiik/V0wk7vO7DjvgQRM8Vhyd2pAoNnPyMmtVkENajmDR7pIQINopKOG0PhRWC3CpBWVcQ/Hj7DBoJ08YSIsmAMvCDg3JPbs/m7YJdU0OMFFhIVWi9Hhi6rrKFBldoo6jdpTGgUhh+HW/TV02PjEBlxyzhYDel7JQWXWP2OIOys5tOLc4jm5Doy11i47TCJeEx9xHwFIaGRUTG92KjIbtO5s4Lrxt1s/43lDKr25ZvOxlGns/raHV91sT9DWNPlhMdD8YdK5YwGTQChRlSZt3GNwFOUUngAkw7lKjisnGfmz16/V4+SOANYZFeY5tr9qZy3KOidzey0kQU3Autay7yOvKjfzOTZBr+TgM2xFWdqOJ4wlzZbE2h/XATdW8HdbcZk16EQjXX2yUTFMdApDcLhbbgSNGWD1eonJYtEup9Fw6W8/lVWSDCcNcDle+HliLyDgf8K5Uqnb1Z7/6ooGG5E/qVIvsv+aJJwp2z5U3WWv72VYr/aFN9F5rE5vZADQeDgudYAt4BAhdEnLdpbAoXPuU3F6lKI1LG8ULeKRf1lG2pc0Vewwu01/k7XdlNeSTXOTKiMpU2eJyse3c+OuAVJyjXkhFF44fjXCldT5LJ0q2tcicIN8SY4M91dFRcR/axOcuKfp4FCn/HDPVreCWgKt1yRHWqUNu0jgQCSjIQQ2AiYETxodgiYkt2anKNIaHYm+iKf34xg6USHtoePoDwPzg42xVsxvttA/dbi3jf8TTnmNNhZej2m9C6FVr08I7PcfO/sZotaYM/UAqWbVFbRVjVYXdk83YQFndHvEuDay9Xg4JXNdDPtkuImb98suQxhnCFeW6hihOfoGRaYWxXL89BmiOZolFSzKFXimqRFZcpHPjaYwTkFS+5Bl1UXLXbzDkOtN+F/mUPzryhB0V1c6p0hMZK+7xt6jip3zKwvebyF9fMsHXLL5hlfIfs1blf9lE/10cATbmliGIyLx54YU7JnyjHcc7QIRpFnN8yIs7SnwpzrdRQBOglQ25xO7KEDgVj63LsQPZevdiP/EhmyBMZUTl4XRpGP5PcbJELyqCYQ6yhvoht3EcI8zisvHjOISK436J3sEOuYfCwjziQKEH/9MZ8jjIaX2PZ+PoqB8+Jts28XTZ4nhqOsCMpu2vff8mVkJdworvj7Gr7DrO1ljP6YlFt/BJj6OWjC+1dnzFYbENK+9qqtjidMUGWHA1ykLvaSI35AspRhxlO7cIpCsGiuqLw2TLH4WFmaJ45acONtaNwC02s9amxKfspm8vBIfL4ooIgeM2+5HIyTqyuaa7pbCq8LGVSa6nNi6JmFgo0CPHeP0fOu31OrRrj8yB0T3t7lFuuFDs9HZ72xXrrDbyarjNWZZpp8tqXWGJJuYZIOhTGYiaYSvKoe1Fa+Z8+keRZ0bY3B8TLMy6EwXkdX2CfvAIGOFQh3C6IQWLEAp3XVXUjbnkhClOHIG93mOFNnucKY5jWsdtSTPDb0DEEh5XhDQ2MfG1/kbZXVdHVqVxpTpQhundL4nCdLoHZdiN0W05o6E8paj7TPqPe4nasNdT11rGiZ7U5jYOcHPdewbYCX+9lXP/m67qK5YbvQtBOWvxFErUuCGHoNWcX7bZgnTVjmsr8rabbc6nmZeKQbNjujqQ6nkb4sUmduAyalKuOK0DD2likMmW8pEuarBcse1wG2m5pzlHyFGUX7ka6w79UbeFR12USxdaSo2RJ3TFv64khbkLwGA7bDOOZzFrX7LWzNlee24OXE7T+IyXXSjW+pCt+spmjs68k/Nb/oCjFl7P9MGxcB6EZR7TNVj0CqrVMN18iuKIlhKqfUZNU2iQlUgTQGG0SzP9+sob5Rex5FTL1xNH71+sF3FR/LiylJ5L4BKf0KirqZNlGQP2KCdtHtWet84UxzlG0Uorp4rQr6rTj5TUTo2sYuMicbt5JOpVsulbElTCEggOMzhH+BMqDb0C2qmNNJ4GGnts5gZo4sdd/UGdKv9LO+c7G5nFXAt4Xm+18mtZjrnUMm7VeZzSncG7HMDMY2ri/mybbSsJWDS7QNNoYko4WxF1R+RuTAxVY9CIYKKy4/rKwxVTVMRn+F1iycR2phVG2EzXgbZY54y7w5IEAN2Gsqh4fhxIFOSKCiPcyeridOqvSORwKScZXT4VgAndzunKVPpoADjhJf2tRy1c/rTLIaLcztLtzz3z3Xf02pX+tRwT/WmE5L/laMubLTtWMdbPhC3rs64lsONai/RagW3MZfhUMqBRa4RUkWP6Upi7CHKcKPIrvbvwi3juoouLR1aKjLuuMGHkV1oEYuaj+jj/+/H8KKO3qWjwFwm6qoI/bSt23ZArSnGxXodY6nMDQul3qNN1cbofjG5XYNkBMApXGMN1nXaBSx8b692+h5pgMjgTVRF755LNKOuK89hZn7jailN/Z1PZ/wA4W20K+ZmhZlu6bIc2lyyL8DskDbATaKMmVsvGV2OTxMARG6iDJ04bZVAaZa6DRW4uNyRWYQ3x7FyYYpP/FhaGjZcmSCblHAAgfQgAgSbyk2+XYXYU56pTNXHZqgajandnNGpS90R521nQNrInM9uN5cyt7qnxyWL36rPVZa21VVdtgXK3o+N5F4fAvJYlLk2Lm8q2Ltdk2zTUfjITN3z9lRV1Yo9sJYj8sVPUcl1TFB/JUNRPWr3hURlab4yybwsfrdjMjoclLQsZ9Omo1iiZFp4rNT9RSY5RKr9L4yJCqGguqp4ovg/y7mzUQ4aLuJysNMRXY/ZKnlF5c5jT7NRcq88eZLvBj+HNn17k5y4+pXliq9ZybaBrGmZvk6P9Tll28IoQupyJHC4sJicRomRIzYizaDSmJtYVxUVZnT8afo8ycbkpN2l5lqRKGgmLmU4fc5i46sZqdiiWCPfn7sGl3uHH5aN8dU+UrqmYTfw+5R6nHQqIPHOf0zQ+9eqzx/He9+FLrk4vnld55UghsWLDEDsmp1i5ldEkJbFOWG3MtJPbpVFY5JDlOE89AozgdlhSGICRFbOBcAikAMKJYNKyyne+Hy1ut5ciFLdxKIDP+cTq/qS7ccfVqgg3naBuRfnCvA4b1K0wBwhsRTujNHVPFOaCiHAZbIqtP5tZhCROvFdGr8BBZW699dbkicuD5Qua/SNZzfLoyNjUFTaORplloiFd96BJRBBnIoes+GrM7igpikeRzo/b+VUAbk2E0lcO11K2MTvCJ5rzIQBII+yFspGyhFwEsVgZozRyRHHOdjH1sDid7EYTYWmCRSHDS5f27rEmOC6j8RHjsDltDw4ONhWrdhocet6ituBHr1pa+TBHZ15oYyM/sMmxKacUdEIszeCIFtk7t0pIuzDSuUWKiHKidiMw5HbdVBTu/LhdekiAhriGsu8xdnAOFkZDTqDYenI5VATAIVA53Y/cLlGYuJ4+TBGmicpRFhmnuIbTkK8frXDfhaGOK4zcw9+DDjTJZLIFQfCl1VrAunPv3ss+QZf1nbN/yjkhF1l29F9sfPQBy+c0Jo0IE7Wko9ROrVoPw6GWjLsphety42EcAowDErYDZJwgspnptpYuW4dq+hG2/1Y1H6X0AokECGyXXUW5K8zn3IpTOjzucvehREqrdNNGvVK4GJ8uzTM+zZzc40nK6VK4nUbPXHcDFr9SqRxCY57INcqZwI/Un3n12dvMy32BA4P/lhMT77RsljNZ1cqkCGlUT7qDo5EujekcRZWSQEc82XFzR2FxuGbItYOTI/M3cgxsluG35A5g4KoWYEKwyY7A0VB0XIyzwxoVS9roit3YAg4R2p0zwe3s8XII5YpN/BSxf07bq1evZoWVnc6RH13Yj4+Pjz+6wwN/6z05u3LV9cyef9ByY1+3iTGmJdjf4DSupBQRdmdcOD+OSBHK6mEK1xU1teM0uJ3fJaJEbA2/mxfaRnZUbM4NsRO0GHEK5eXfXZGbAMdV6vcSgksJXS0uGT8yO1rhO8CXEYnYNqIvxu2DOahAMzU11QJ3ORWt6gSNvratrW33W1CvfOc9lpv8rGVHLreJiXWWyzPEAjkiQESEXdrahfPTmCZ2i+Kuf1Fz61K6hkuFqR9qmccnkJvtMQ5GyvNR1R2AEqFBYXH20BH7VR7/9UtACsGl4p2h+9Q+dtJwFr/Xf2Lrwuc5Tdw2T2a3trYur1arL4fTIAQGvz77bLTGT2auffd2W7Lin21i8uOA57+wxzmkBv4uqu3GOLav8JB4O9gKE1gcl4ncrhy54wunzrZp6rYHJyetH27jdDaRvKLsEpEch4ltqB8CIyxeRYVriaNisZyJqpDlFHueN0YRA5sO1+mCe28OKj0NDXYyTXQonOZXuPuuvPLKbgRjtaU1NzcH5XI5gBvVWlr45Ioz/cxztt3+wVsmtk6M1y7kkIC3sqN/CTqdaDxMohhErhT5yRoDSG6o48LUxTnhxAWE+ZTX6V+IUyYNv9sWcA5Orz3Ad5uO7FzBclQ21gEOR+woq1LLiKs4GQVbbgnETn5XuP6iBPV00a1R2hBp+3p6znjylyasYre/BxtoTqUV0nCaZRDifACThRgiBaKLPkfKTplksgp42DXrhkIsBqwEX35ForRxohL8vD87nq+WFgfpJg4ShcAYtyvSucIfNw/owvUTEQ/AiLgiqOa9HAAcuCK3COyoTwLOEw7mL7ZMMcdWmnFbwL5zN9QW31H34hBAObo9QCevCncAoRwXzU/UDbk0qlZcK7SFUziNn2Bs74Kw9s4cNKC57rrrjmLk9HKBhIY/kmb6Yy69/2p2EU1tKqIoLPa6M2SgT3BYm1VWtQToeAq0dNF9uVYbH5TJXS67SBOZyFGPd4Wq4DiBbIFl2h87vWCR9fNNhIn1HExdnc/x9uF8lG7Ryc+AxTE4gUilCDwqS57GyxVNgACmFLJAHmVwOnZtn4bbKvKgAM1VV121BFnmUzzvcVz3crmDlQGIDF4xgBprs9ERiwI7GScDk1Bf/2ni+wicG+xtz9UWb8n7JxQttQDu5EAUZgzf6HoREMrRytmhR35RUIQOY2O/IuilWDbRn89b7zgfVm/tsm52j+quImi4Lq9+k3Rv4SOIy8Sh2tKrZwH/BE0Dk/q8gINUvN6SFwyHte3975wHzY9+9KPWycnJdwOGt3FtoYk+VyqV7uF7lgKIazE4kGttgOX8gCdu/V1atEYcIAnWDQcLb9sSvGG0kj43yLQuSzQxZI5yOdiERTtMhEtXQq7i6lQ/pTN7Q/Ustk57hOjufkIwlfj0YblvzI5bNmrz+eaCx+hKxavsEBtATgHiNtiO24glxrdOHep32epOEsEzrJ9MBTZcDKYT1b2e3Y4bY06DBg6TQBdzDiC4iLcwCSg+v3jx4mvPOOOMvVqpFjfWDnbPrUnbNvi4JYvb+PD2+63ZPwFpGt4NO4pfbdkCj+vwZMsfXTXS6UMLDjjq50jkgKQMmCofzqxk7OGJfju8HRmHbbyavKxzGweGMKnQxL+rSraMKwU0Obi4wJivBVOIY/29XaN7tG87LG3HX4FxzppUKvUqwPLnvN2Hcn0T8MwOYNRiPXw864SHtppNfZuz8D/HYvZ7rZDVhvBwxCSyiVharKVWlhucOLf84gisuHO23C4NNv/iHu7E0NaFdl+eswDdfBRfr3UgIF5JSO84jkuvfOqmoq4q9NbT1/OFoJ2k9IHLLrtgn4bbqluPMSfN97///dPgLD2A5TQa7SaG0n997rnn7l6Zt68tcNttgT1wTd7mv24d3+/awM7PZXCTQ9jsz7GAUBXqQE0uOWRHJhabXDw/zlZc7MDWnipYQgVO0+VX7AgA5Ou8Ypm4SNft4I2yxQxOCdQdxcaFg+Ua+7YxT6TS3nW3PXT85jh+b23he86Z73znO4cgp4jDvATArMX+l3e/+92Dz9iD3vbegrUd9d9WKn3acuO/tOwE81biOBFQZNUvHDu45W+4xHIcCyEPi83LbKx7iIOuJzgh1GkBxE30IPqJk7rs01xGcVGqMB1+QQi5h5G5n6ML3eeRk6qeU6ABHN7111+/jKmCv8J9JtdWrr/mOe8CPNOvnp58ts1lp5Ttu6vuYBh2nuUnvm6TfMa2iAZZxBUI1E2FntBfB0pEeQcU3AKaiyM55+5U25fa1rJn6ya3w8gKrgSV4/6UlfS6FBF2Q/jljsLljtfgsNOhwgEBfeVJjuOagZlToPnGN77Rxsjo3bTH22nAPMPo/0TT+xumC8JTJmbQUHuc9cqzNiGxfpYPPF3FUosx4zzAcLws6kW4xRlSVtTV5aiPHddSdzDG72SrS4c9nB3nuLhJkmi0FAJDqZXSXfzUw6NAFe1iZSNr8doUAz85WPYzz3MaNQ0jpXRnZ+dKnOdzLaQBvwWX+f6b3vSmfZqUo4x9N98+azufSv07lll8i5nyvLGTMhofhxSOS3bE5acOGr3DApDCFInhGLhKywLbNFVkemEYyCAQuwiAI5c8cdooXIFxUFyUhuTINlMsJB9uyXBo4QzMnOA0PT09SUCyEs7yYYByiEZJjJy+vm7dum0zaJuZZf02E575xN+z+uBiOA5fQ2WUL0ajFneElh05YjsGQT2B0iAQo6fJBhm7j/moXDkbxtbLCMuLweFsglxRcVcnP5Xzxbgsa423fWb1qr1e4umKiH4OeNAAEv+44447EtCcx3UKz/Vrwr6+ffv2rYDJDRcaH/hZdV/39mFrHf1nOM4VCMe9bimpE22guIguUye+wuSJUFVHAX52Y+boptahJR5mCYyOwQ35TPwbF6QiprmMC43qcSOoRJDztdm/Pt5Sir03B/SQG1D4rPk9DM5yAUD5Q+wnaLTP4/7FeeedN3MF3t6356451vywaC9541pWAU4hJB+PyrYjPHE0oqZQE4k6YWZ5dggACZBJ+h8+RNbNztClACilk0sbUqr7cfkas+N2XvQzVc5TZtJtg5/2b7z1AbYtz8Ac0JzmxBNP7GKk9BZAcjZgmaR7Wo0g/AsE373eljGDNnz6rFecN2Ktwf/hDJ3/sDyrAYsc0qBX33EWssf4cfKMSNLAbVS60rHWJs8JoY/nszbKclC3OS7mKkQrSZ3LqLzGy3lpJc+yfD5Rs9szMgcsaBB829DFnEFTXEBjcS6sfZvrShR4QzNqkWcmc2CXsYDdz1/KN5b/3vLjD7JlhsXrcI86cUV1Ko9VvXVAKRCDQFxt6eagggob61h8zvcewhiXqZ5NgQ48ziH4SQB2807VZCIxWPWTM1ZwHpCg0d4lGuJUGucD2EuxfwrHueqhh6TW34/NFech49Su4YtzX0XOuZdj7nRWv6gcAcZRPASO4zaQpw4euig20o0y0bU+N+Y+h+g6nyire+q4HDyhMyqPKuAyZbjTMMfZz2i4rXoOONBEcszhAOUi7v80QHM7XdJlXV1djzzngq9a9OmMOI7mq4LSP8Jt1jJfxcJ1cRwIXDcRsR0vUbjAw8Vx+YU036LS8JuTJmp8OEScxAFEyZSt7ncuF6bRAGmKLJfoP+oFR+zxKZ7129nJccCB5vjjj18AYN7Pc6zk2owccyVLFe5i5nqfJ+B2apNn3vv/3jXBQUs/snJBHOduN9GpZRnhImDsCDQCSoiE8J50GBK7Mcc4nmQzQnGhogOswplvBxeXzSHHpQ+5DWxGs+OeX/CT/uBDPatn3E4HFGjgKlooJRnmQuws9v/Bvn6/E3xDEj/17zfeMsln7a62aulfAM1dVpjgWHboGQPFcZcYPLENufiud45lEo9PTfLtqlE3/Bau6sYlFZfB8OOG2jgZOfHVB7+/x2auhjigQHPNNde8Hs7yp4Cnmesq3FcBmL06L67euPuDQ8egTIz/xCr5r6AE/CVTD3RVmq+CLI19joOAYADX0EfGMvNsG/h6YmoMQSUWiIl2gIkezLmFmgg4vpUtU9vnhVeNzXXAgOa73/3uS7nxf4W7aKPbDwDNV1atWtXf+DAHpPsH75u0tqOv4uiKv7Pc8N0ccVtyi7PUVYnbxEhwIMLvuqgOG7ZmW883N3MsQJehXUgppPAfTWC6CMVxJRNe0a/5s6KKOCBAw/B6OdMCHwUox/D8a+iSPg9gttJQvEdzwGiGvCP/K6vlP2VT479hQRefx4tkHAcekT02uPWNbw4M6CtVrZ/TQStwm52NQOTQoghOtMc7Ua66HQg7J91r/34PGuljaIAeuqI383QjAOZvzzrrrN8QpkHB3DE6veGq993KKsA/s8nBtZYfroSrACGRk3MiW2Bw3KbLtgRpewidTY7DkELZGV4jfOmS5Txy8M2MpD9cSo3Mig5rvwbNTTfd1AFI/gwOI43vFNdfApifuxaZqz+r33sPXOYDVhy+ybIDJY62DUFTR4M4CGTTgQF8CmhzLs/OBfR1Wl/sTAgcB5gIQAjBZfzjR3YdO6PZ7bjJ91vQXHrppSmWaGqK4N08cBJO838BzHfiG5/T9jXn3cdxth+zwtgvOJ0UGUf79SGVgOMunl4fRgM02ziXbxNnEZeqnFQaN0oEFlmR7lD910hTW3JGs9tx8fV64oD9wb777rtT3d3dr2SN719wP4cAnKtwSwiOX6f94Taf2XtY/b51KADfj3zzAwTkbP2jIa7vERwgHcPvLF/91XzUiOajtNCKGCcQi7J4aDuSesXxpnTv2T0n7Cr87MNT7Heg4SH99evXHwtn+RNAcjT+texR+uI555zTtw/Pd2BnWf2BjaxiYKdD/haG5EXXVemJ6tyGk1OY8d4mgXhq1A2/HVKUJH5yJD/2QpW2tjbPeM4pLnK/Ag0A8W644YbD0PB+iBs8A9Dcj/1v/f39j+CeW4JvTIGns2uta5l2YBXgxK02NVZAGRjlABY65JpVfUMcT/Lw5BAfgmVEHaMF2zn5SQReaXmBY9FnyexXoOHQoW7mkd4Kl3kDAMpxXQ6Afn7hhe7bB7P0yAdYMfpU0eD2h+mePsfSil9YcRLgRKKJOI4+H42yb91Ugc8ojjDgqkSMyEEmfFjPKouL5bkHGnYRtMNN3s5T/jE2gyb/CkBz/dvfzuq3g93c1lPh4wl3mhX/HuBwPuB4Ify2ldgIAjHf/O6rpuxxDkMq1VCQR3jhTAqt0QtqST872pTao+9T7klT7xechqUOTcVi8VRAci7XMgBzA9zmahR4TwMYLVdzS9b25FkP7DSXs7eqNX23Vae+xiKu2wFPNFdFE+gwJD7OsYHdmDouPxwy8bjIwFpNU04lx29rmzcrOho14nMOGkCSGBoaeilA0UTkidzTHbi/Pjo6+vRyjPTBPXqvDiLg+PNvsXL2S8yOr7VitA1Yw+/WbtM3eDbwwfiKht8M0aUvZ0qBMwtsPO+VZmXe6TkHDYDxrr322hVwlXNw/y6gecQPgm/PmzfvwT2SYzSN0CMBWc1zkJjVTNCmAr7xUPxPRlQPWYnja8VS+KJLiQ/bP8p3FnLgQy2iRqFxau1BbfwN4/lZUeyplZ9TTnPzzTd3CzCA5TzuJY8m9GvJTOamWTnVQU83V42+a1UofA/h+AuMqNbBcdxyUJ0O+mC+ZBvz6onCAwOSCb86lkkNHr9y5aytBnjOQBNpfF8Hh5HgW+S6KlWt/tdb3sI6k+fN07fAzR9Gmzf1A5ZVfN2KE4+yoMst0MqyHHQDx+VX2fwgblMtVmvrzB87my+bP32he5biOQGNdkMuXLhQSzU/gvyyCMBcwxrfr775He+YNQl/zx7/AE/1/Y8wxZ34GjLOxVYYGXQHPbYu4kt5Ods63GfjQzn26RWqI9kC0vHsdeHPCWgAymFMC/w1oNFSh/8BNF9/61vfuhlb3fDzZm9aQF8NLvlXwmmuhePwpTGzIfZ9r9n2BPvzsoy3a7WWoDor62ji23rWQSMuQ+V/x/VmrvU80+eYiFwLYGaNfcYPd9DYN140yofPPmfDG2+xie3lWmnK1kz22mTAAq2E1U4qyDF75lkFDVMELXCZv4HDvBOQ9HL9K7qYH83e4xzEJd34kQ1WGu9h1d+vmY+qjLDGZlupnyF3rZaoZQ9MTiMOw1m9bwQwfw5pRwHMN4eHh6/Ffr5Lmi2s//xLzNVV/5GTuB7TUopNfMK5EBSC3tK6Ge9AaLzFZ4XTaKTEHNLvUPFnuJoAzreQaS5GF/PsHwPS+PRz0X3b5/8LBc0/Waq1b1Mlx1ddttXK2dKs6WjUZGykeWaNNrcxUjqaLbQfo2s6Ghnm1wDoq8wpPXPHmT2zj7T/l95WXG3WeWS+OPmn94ysH1lYHpw1HY0e/hkHDZv0BRQNrV8Fh1lHd/RJAPPo/t/yB/Ad3nxJ0Y78/X8rtrTlHh0fmN8/8eCsraV5xkGD4KulDu8CLK+nskGA8xVGSnccwORAN8881yU3p21kUTvatBZLsn2xorNWOc4zz+mMLfoKrRa2/LBgz+X5OBtuGbdTz7rOVrzpdeObDk/Y+JWz1uyM6p8Zg+DbCVfRnNInsPkChfd5OM7lbG6bVdQ/M3e/m1Lf+qV5fIliMWfFHM4moqM5xeE4y3CMQ1NzYJm2wFo7OAY2U2ODtdZdbkDRdpclyttsuGOLXXLMrMoUu7m73Qe95/qXWNvCf2dy8wZr7fyqXfLyWVlT84x0T9/85jc5893eyPUBwMK8vX2DL5t8lyWbe/0N6N23xrMYeuY/LrVycaVlx1/J6iaUkd4S7EVcXey99gFPn7W0P2qdS8atfd6xrNs9kinmPODZzDrLrdaZ+4V98r5f8ZGDe+wTR+3Tl9z2+Wlbuk5iH/cpgJrZzMIm67l1tTs0e58LDDPOOmjgMMwIJE6Gq5xHFccCmu9zXc35dwPYB44CDwHebvd+xyrls+AaK+Eeh9I3taJi1ZcqioxQWPhd+xWzzL9kbcuj7tvICf94SzWfy0lXK0l7MmlOwH6J+ZU38E3MX9qn197AUYn32RdOmlVl25NiQPUHJZSpwdHcy/m2tXoPaR9+0vR7GDHr3RMnhb+YkZLO8X0H1294Gf/q8MMPX3vKKewiPFDMmy7lTI9+VhEGf0Vj68st4pyh4YOphP+QaeX/NK/0sBpEFgAADklJREFUMJ+2HrebL9HC3cBWfbHZjn31MvNSfwygLiJkXpRLuyik4n8c+4eWrHzLek7dEMU9M9YFl6as9oIfcDzt63Rr/HNaQO3Llkl90b56xoyUfbPKaeAyC9G/vFOCL1zlcbjN11Hg3f+Hf/iHBw5gTv9Is031nQeBL6ArOllzOdPGk2xyBcdk/ocNLthga3Zau7z6LzW03WCfuvvf4TbowALAY4sIYwW4deE+GXupVdKL7W/u/4b944vvxv8MmcO6WUpzBEDhNsTga53Mc59mU7UX4Fk7k0pnTbnHR7jmAZazAMq7uKES7n/js343XnDBBQ06Aq2w07WfmlUApm3+e1hm9FfQma6FW3XbRWT7PId/I8eDfMFeXn1sF8BMPxKqtVO2W6LwWWSaf5sOdq4kwFlO9/ZONLf/2z629pSd4mfPW0suRK5awAVeYHQ1dauVY1i89TLqnxENZgU0F198cQZB99VwFx1nxvJ4+wFd1I/WrFkzQhi8MTaN7jhsP7FXXZWwye6z2BbyAQTcQwFLKjxkiCZyuxsTD8FhvmArrXePhtI9jFRSua+BuyvdE6oV4pYIgnbe/ldb0vuofew3v/WMvEjVYrMFZT5qBWAct5FdhesFJ9nZqztm0uozBo0E32XLlkng/VNu5Hiu23BfgeC7dffHme2nwJlc/1sMpz8AWF4MWAAMPYqOYtXF4btcl9mhC+7eI8DEFOk5XSdp9gCWh+KgyBbr4uNQ9iZOxPqUffpejoqd2du/U/l8K6raBEiSIZcBMDqFolptY7vvEZaxhbuk34uAGcs0jJRWIMd8GKCcSb1aG/MlZJhf78U9PPdJ3/TFE2jMD9FzvgLOIKSE9xQzcc/7obUccjkndO6lbMYL8g/2mP3NPf8L4HydtxyFYGTYXYJfwHkLZ4VM2MfXfhb3jEc2cfGAfz7PlHL+WK4J9GUyZKua11lPtw+OGXEauMx8uqM/YYR0NnXfi30xe7DZn3MAmTO/OJ9GfAcc5XVwk4Q7GFpfwk3wPsFwmDHuI/wfbPUMPspRnfwxQsW/AxxO86Rt3JlmOOIuK7C3w93eaT0b49HWzBvQq4jT+G5jnY5lm77SgHR6NLgPNe0zaK644opW6tNSh/O5pGn8LkLw9w+oAxN7+LxyxnshBPt9AIKyTkCJLoEmwfHgfupmu+EvfrMPbTud5fHttE/iSsDyqAOMwKIBTQygmvQ/wR+xSPwVdsHdIXeYzr1vLr4NDVDYL0e3pCPZBBon37CrLlHM7FuhYS5aZu+N5Bi4ihaFf5pLH7O4hk36l7MofM81niKYPZG2sbEma+EhauWSNf1kfK9khr2/9R1z3Pu1bvOb0WPUXuwiNFIKHfRQcnvDfG7nu1HgvlvaWvuxX2xi4/X/pby/oRtEEBZiGkwNBZyh2+m07Whu75ux5haZARmGSgCN0Kn6wjrZP+eO12qofO+c+wQaqngZYNGc0nKu1QDoKwCm/ymrvvixjPUNz7OAYw6migssdy/DwWAJE37L2bCDWj79gI2/9nvIjc/O3JSUX2Opl9Cwr6MRW0KQ6Aki4LDJjC7r+9bkrXnK59rTyM+9ImufvPc6vofNMDt4K9k0/J42jqDe79EmD9kYuh7jd2+MBOnGkWrAl8VqfCtX4w7Np8Y2IjLA3UvZbMcb2WvQ6FN/AOWvKeZEuiN96u8bCL5PL8BtzR9u1eTbzK8ei5ywnDdgKfSZTzmdNF4L153sS5bS6dkRoifbqbfwKrqf42hVqm3kMnjN30b3dJU1TarrnQUD1TIbN3MQ47fgNCcBnGMcaBqBY3yfx/Pegrx8tV0QrLXLvL0lrh4iLLFUZs7PCb5hUJ3TMAVS9fMzeaC9kmkk+LKA6nwqfDNgeRz70rGxsT0TfINSNw3yHh7pfFD/GuwXkX8ZVyv04q92KIR6kZ1/64yENMp7eiOdTM1fDmAAjd8WCr+8P6Ecg53mbUz82CY67jadhTdbpueIgiWaf4mi7Sbe/smwu4DGjqDQW9itBUcR8EfWsgaN7l6YkMtMQzCoLUY/g0KP7knf/XYKvipyTrWfCdihvSh5l6R7DBp9FJ3c5wOWD2Bn1SXxJbfVe7R9VtWWkw9y93fIOW30jPHFzLGh8JrXccR0/DPk6rI29pa+HKH3ZIATjpJ2sP2NTFJ+305tnf2Ne+vvH2Mn22rA8Us4Dksp4iYQeHDXkPU8NMYBXdW+GvdSVF7gwAJO3CcRdTxJrcJZJNV7ranct69FK98egUZrfCcmJs6gWzqfaz7XdwHN6jPPPHPPZ2u//JIxCPQdeMrgNFCiW3e44ajKgI98JbguCGZnBLH7lvHYALwEUPwe3KTDjZY8uExdkecjy6R+akHq/hkLo7urX0KxZR8EHNfCcXrr70y9+yBToKUXtXfbRx5U9733pjK8AMCc5BR6bqhNlSGn2cqnEdfa6o/M6FtYewQadC+/A4f5c+5ek103I8t8jiWbe78bspyD03hXcOnolF2wQwCsufZ6a1172N631B7muOBSBNDUqbwvrI9JcCs0wQ5XYhtE+6G1pQH3M2S+fMaYeW0/pFu6lmsYAPHY1KU2cV0UdtVexYHUf7RPd1AtvhzQSGEZg4Wy2TAXwOmrrXfxwKppn83Tgoaj5Y8EMNpvrRHT3Vz/weq7zftU45d+WxuM/5O8DzxJ/gwN9wpU679tH/rVjOZHnqR8XvLlCIgG61d3uIuR8u0X7JF+yC77g6ldYmczYNsDA7SFhvP/TZ15B5gdScncUe0Cu+jOF+5VtW/7d7hM7e2M0pQ/BE0AKmtVXobqLdbRtfcv+0438JSg0TeuAYkmIV9Hvn6mDD7LuTG371TG3nlbXrqOB7qYTDvqdDT14qZfvOVoMc9lRZxmY5/y/vauYlKvvDVpSWZ5fT1PAJvZ2TDcNQjZlt0y07dx55J38aubmte2BmL+G0LCLcRPj2jqXVWgebBP2EV3Ldkl/+4CJMsUS+9BZnqD647qk5W1IdryOsu3/ATNNn3VzMyTEoWRkr7cdhbFn82ldSTfRF/0sz0WfJ/svnrUNVV+AlGucSCpg0UZeNU45AjrdJR9Z9nHHtodN3iykp8+/KjBDqYM3kUdu5breehFvNVWTd8xqyOmp7orHdE6OXUPz3spXdRPsAvcW0MO13/+PnLeR+2iW58aOCt7kpbf8ka4yZ8CmIUNXKaM+wYr175pt31wz2XQhrvY2blb0ACYNAlfA0j0QdFuhN6vcX1v1j6RM+9Hm61UgdsE97pOPH6z1F7h1cHw/F0cFXa2ffzuGU2u7fDABZ+XANaNNi+uKLTRswc15oeqV9mxf/DsKBfjG7v8jILNP4W67ZNclwMadR+0glQuzrUMgZnZ95Z/tT+7c6VJKdlopNR76+eOspbWv0Hw/Ree4xiAQwlOOOqnvP9A4P8ne1VpvSutMe8+uqM7m84NSDwWVL0CYfeTXL9LzI3Ynz766KPXz+qSzQ+hIU6Ov49+/dO8/bu+RRwwCIE3AZ6PWnXwBrvkDTNb0f/e7x/CyOF6Sj2ZFm14bqHUbjev8k/WMvmTZ43LTDd56FLXkj601RbYK63iv5F2+S2AcxLPH4LE8wF2sInrGk4w/5mNPz5skxNo1UuvACTSJAOWGnKgG3kiL9nPWE/z/6yS+oXNP3psNrql+JYbGi8Muvrqq4/B9VnA8xbsn8FhPnP//fffufu1MXEx+2h/4r4u+uB3kPszEHORYBKayCHLQ6VetY+wMPvHprdyX8253/s6Wd/vXuKw3LCkIHiEsI9ZJXnTbDbsvt5mPd/5t84zf+p0Dpx+JUA5HtnmSPQsyxlRsbOAD3SX8nyyuYImneUVQXWCUddDPMd6wu5AEXy7/eRT+J8ZUwcNIPG/973vHYGw+wGquojrcUZMn2DJ5m1veMMM3/KnuveP3NFsXvIsVNt/AWc5CSaw49RGSGA0mN7lVit8ybqXj1jP4XCdPRg2inW/7fJOa2mSJvrz3Abdrti2jNb7Bg/TU33VxgevsJs/PDNOFhb6zPyKC6WGOmy82MX9L4GrMAXCbLXnw4+10L06yJqu7XbaSPbZmPB1oIm6pPl0Q1oUrp0EnAjpfxXAXApgJp6Zlmgotae3xUa2vQau8nc0AtsumIPZnfGC/7IqK+iK5TtQyo3YpS/TScsRW9opg5YYlO5fYKX0ByjzgwBEanUSOTEui2MDjf0vlrLr7VvvmRUBcac7mLNeBxqNlADJmTzlPwMYzXlcgv8yttBufdaeXBynhsIt8OEK3qupVyOcpnr9Dhruh1EOKnjztT2Ds1ja+q0yPm5fOp2uCwD1MKzesLnTyv6plHUuwDiH8FAu0CIoC6SFvZH837ar3ill4+5BV6/4ecfOLeBAw/HyryLiMwDmFdg3Min5aTS+Tz9zvXNps+H/s18fwQ7FcwDOayDosXAHWLIH54l0Nlrn4oRkLR1g9BX4t8I81iAbPW5VvgE5NbyMyf8zzKsySnL5NXMspd0w9v3cIvM+CMSr39s3G7d7MJbhwWUWIrt8hYeXAu9ndFGfZ2j9C8Lizv/Zb5ce5qEm7j2cibbT6cN/i+7qOMAxDzejA38hdiu6CKYDYBLVWolRQh9bMzZYOcdHtQqHErYEQHEmqgMWk3TeFgDzU5jKf9v3znv02X+guVVjEsFXH+A6kcdaD1Aub29v//VzChi1b49X4vdRhLr11vsHN1pz7Qj8bDKrLULpdyJzKocw1OwCKBm2zYKPCh1PiQ87sujILdnw1gKQrQiMDNmTj5nP0P2F714fHlStCp43M2kBT2t9EXjfBlBydEu37Pfn+J7/zXkIt50IxO3oK1rgKgEaU5YYAJhaUOCLawjufOW8i0Pnlm1/bo/7mAll9uO8/x9teQya14m6TgAAAABJRU5ErkJggg=="
        }
      ) })
    ]
  }
);

// node_modules/@copilotkit/react-ui/dist/chunk-JY2CSDKN.mjs
function getPublishedCopilotKitVersion(current, forceCheck = false) {
  return __async(this, null, function* () {
    const LOCAL_STORAGE_KEY = "__copilotkit_version_check__";
    const serializedVersion = localStorage.getItem(LOCAL_STORAGE_KEY);
    if (serializedVersion && !forceCheck) {
      try {
        const parsedVersion = JSON.parse(serializedVersion);
        const oneHour = 60 * 60 * 1e3;
        const now = (/* @__PURE__ */ new Date()).getTime();
        if (parsedVersion.current === current && now - new Date(parsedVersion.lastChecked).getTime() < oneHour) {
          return parsedVersion;
        }
      } catch (error2) {
        console.error("Failed to parse CopilotKitVersion from localStorage", error2);
      }
    }
    try {
      const response = yield fetch("https://api.cloud.copilotkit.ai/check-for-updates", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          packages: [
            {
              packageName: "@copilotkit/shared",
              packageVersion: current
            }
          ]
        })
      });
      const data = yield response.json();
      const version2 = {
        current,
        lastChecked: (/* @__PURE__ */ new Date()).getTime(),
        latest: data.packages[0].latestVersion,
        severity: data.packages[0].severity,
        advisory: data.packages[0].advisory || null
      };
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(version2));
      return version2;
    } catch (error2) {
      console.error("Failed to check for updates", error2);
      throw error2;
    }
  });
}
function logReadables(context) {
  console.log("%cCurrent Readables:", "font-size: 16px; font-weight: bold;");
  const readables = context.getContextString([], defaultCopilotContextCategories).trim();
  if (readables.length === 0) {
    console.log("No readables found");
    return;
  }
  console.log(readables);
}
function logActions(context) {
  console.log("%cCurrent Actions:", "font-size: 16px; font-weight: bold;");
  if (Object.values(context.actions).length === 0) {
    console.log("No actions found");
    return;
  }
  for (const action of Object.values(context.actions)) {
    console.group(action.name);
    console.log("name", action.name);
    console.log("description", action.description);
    console.log("parameters", action.parameters);
    console.groupEnd();
  }
}
function logMessages(context) {
  console.log("%cCurrent Messages:", "font-size: 16px; font-weight: bold;");
  if (context.messages.length === 0) {
    console.log("No messages found");
    return;
  }
  const tableData = context.messages.map((message) => {
    if (message.isTextMessage()) {
      return {
        id: message.id,
        type: "TextMessage",
        role: message.role,
        name: void 0,
        scope: void 0,
        content: message.content
      };
    } else if (message.isActionExecutionMessage()) {
      return {
        id: message.id,
        type: "ActionExecutionMessage",
        role: void 0,
        name: message.name,
        scope: message.parentMessageId,
        content: message.arguments
      };
    } else if (message.isResultMessage()) {
      return {
        id: message.id,
        type: "ResultMessage",
        role: void 0,
        name: message.actionName,
        scope: message.actionExecutionId,
        content: message.result
      };
    } else if (message.isAgentStateMessage()) {
      return {
        id: message.id,
        type: `AgentStateMessage (running: ${message.running})`,
        role: message.role,
        name: void 0,
        scope: message.threadId,
        content: message.state
      };
    }
  });
  console.table(tableData);
}

// node_modules/@copilotkit/react-ui/dist/chunk-BH6PCAAL.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var CloseIcon2 = () => (0, import_jsx_runtime5.jsx)(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: "1.5",
    stroke: "currentColor",
    width: "20",
    height: "20",
    children: (0, import_jsx_runtime5.jsx)("path", { strokeLinecap: "round", strokeLinejoin: "round", d: "M6 18L18 6M6 6l12 12" })
  }
);

// node_modules/@copilotkit/react-ui/dist/chunk-NRA3CFEE.mjs
var import_react3 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
function CopilotKitHelpModal() {
  const [showHelpModal, setShowHelpModal] = (0, import_react3.useState)(false);
  const buttonRef = (0, import_react3.useRef)(null);
  const popoverRef = (0, import_react3.useRef)(null);
  (0, import_react3.useEffect)(() => {
    const handleClickOutside = (event) => {
      if (popoverRef.current && !popoverRef.current.contains(event.target) && buttonRef.current && !buttonRef.current.contains(event.target)) {
        setShowHelpModal(false);
      }
    };
    if (showHelpModal) {
      document.addEventListener("mousedown", handleClickOutside);
    }
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [showHelpModal]);
  const HelpButton = () => (0, import_jsx_runtime6.jsx)(
    "button",
    {
      ref: buttonRef,
      onClick: () => setShowHelpModal(!showHelpModal),
      className: "copilotKitDebugMenuTriggerButton relative",
      "aria-label": "Open Help",
      children: "Help"
    }
  );
  return (0, import_jsx_runtime6.jsxs)("div", { className: "relative", children: [
    (0, import_jsx_runtime6.jsx)(HelpButton, {}),
    showHelpModal && (0, import_jsx_runtime6.jsx)(
      "div",
      {
        ref: popoverRef,
        className: "absolute mt-2 z-50",
        style: {
          top: "100%",
          right: "-120px",
          width: "380px"
        },
        children: (0, import_jsx_runtime6.jsxs)("div", { className: "copilotKitHelpModal rounded-lg shadow-xl w-full p-4 flex-col relative", children: [
          (0, import_jsx_runtime6.jsx)(
            "button",
            {
              className: "copilotKitHelpModalCloseButton absolute text-gray-400 hover:text-gray-600 focus:outline-none",
              style: { top: "10px", right: "10px" },
              onClick: () => setShowHelpModal(false),
              "aria-label": "Close",
              children: (0, import_jsx_runtime6.jsx)(CloseIcon2, {})
            }
          ),
          (0, import_jsx_runtime6.jsx)("div", { className: "w-full flex mb-6 justify-center", children: (0, import_jsx_runtime6.jsx)("h2", { className: "text-2xl font-bold", children: "Help Options" }) }),
          (0, import_jsx_runtime6.jsxs)("div", { className: "space-y-4 mb-4", children: [
            (0, import_jsx_runtime6.jsx)("div", { className: "copilotKitHelpItemButton", children: (0, import_jsx_runtime6.jsx)(
              "a",
              {
                href: "https://docs.copilotkit.ai/coagents/troubleshooting/common-issues",
                target: "_blank",
                rel: "noopener noreferrer",
                children: "Visit the Troubleshooting and FAQ section in the docs"
              }
            ) }),
            (0, import_jsx_runtime6.jsx)("div", { className: "copilotKitHelpItemButton", children: (0, import_jsx_runtime6.jsx)(
              "a",
              {
                href: "https://go.copilotkit.ai/dev-console-support-discord",
                target: "_blank",
                rel: "noopener noreferrer",
                children: "Go to Discord Support Channel (Community Support)"
              }
            ) }),
            (0, import_jsx_runtime6.jsx)("div", { className: "copilotKitHelpItemButton", children: (0, import_jsx_runtime6.jsx)(
              "a",
              {
                href: "https://go.copilotkit.ai/dev-console-support-slack",
                target: "_blank",
                rel: "noopener noreferrer",
                children: "Apply for Priority Direct Slack Support"
              }
            ) })
          ] })
        ] })
      }
    )
  ] });
}

// node_modules/@copilotkit/react-ui/dist/chunk-FFJHOZX6.mjs
var import_react139 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/useLayoutEffect.mjs
var import_react4 = __toESM(require_react(), 1);
var $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document !== "undefined" ? (0, import_react4.default).useLayoutEffect : () => {
};

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/useEffectEvent.mjs
var import_react5 = __toESM(require_react(), 1);
var $8ae05eaa5c114e9c$var$_React_useInsertionEffect;
var $8ae05eaa5c114e9c$var$useEarlyEffect = ($8ae05eaa5c114e9c$var$_React_useInsertionEffect = (0, import_react5.default)["useInsertionEffect"]) !== null && $8ae05eaa5c114e9c$var$_React_useInsertionEffect !== void 0 ? $8ae05eaa5c114e9c$var$_React_useInsertionEffect : (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/useValueEffect.mjs
var import_react6 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/useId.mjs
var import_react8 = __toESM(require_react(), 1);

// node_modules/@react-aria/ssr/dist/SSRProvider.mjs
var import_react7 = __toESM(require_react(), 1);
var $b5e257d569688ac6$var$defaultContext = {
  prefix: String(Math.round(Math.random() * 1e10)),
  current: 0
};
var $b5e257d569688ac6$var$SSRContext = (0, import_react7.default).createContext($b5e257d569688ac6$var$defaultContext);
var $b5e257d569688ac6$var$IsSSRContext = (0, import_react7.default).createContext(false);
var $b5e257d569688ac6$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
var $b5e257d569688ac6$var$componentIds = /* @__PURE__ */ new WeakMap();
function $b5e257d569688ac6$var$useCounter(isDisabled2 = false) {
  let ctx = (0, import_react7.useContext)($b5e257d569688ac6$var$SSRContext);
  let ref = (0, import_react7.useRef)(null);
  if (ref.current === null && !isDisabled2) {
    var _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner, _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    let currentOwner = (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = (0, import_react7.default).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === void 0 ? void 0 : (_React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner = _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner) === null || _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner === void 0 ? void 0 : _React___SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_ReactCurrentOwner.current;
    if (currentOwner) {
      let prevComponentValue = $b5e257d569688ac6$var$componentIds.get(currentOwner);
      if (prevComponentValue == null)
        $b5e257d569688ac6$var$componentIds.set(currentOwner, {
          id: ctx.current,
          state: currentOwner.memoizedState
        });
      else if (currentOwner.memoizedState !== prevComponentValue.state) {
        ctx.current = prevComponentValue.id;
        $b5e257d569688ac6$var$componentIds.delete(currentOwner);
      }
    }
    ref.current = ++ctx.current;
  }
  return ref.current;
}
function $b5e257d569688ac6$var$useLegacySSRSafeId(defaultId) {
  let ctx = (0, import_react7.useContext)($b5e257d569688ac6$var$SSRContext);
  if (ctx === $b5e257d569688ac6$var$defaultContext && !$b5e257d569688ac6$var$canUseDOM && true) console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
  let counter = $b5e257d569688ac6$var$useCounter(!!defaultId);
  let prefix = ctx === $b5e257d569688ac6$var$defaultContext && false ? "react-aria" : `react-aria${ctx.prefix}`;
  return defaultId || `${prefix}-${counter}`;
}
function $b5e257d569688ac6$var$useModernSSRSafeId(defaultId) {
  let id = (0, import_react7.default).useId();
  let [didSSR] = (0, import_react7.useState)($b5e257d569688ac6$export$535bd6ca7f90a273());
  let prefix = didSSR || false ? "react-aria" : `react-aria${$b5e257d569688ac6$var$defaultContext.prefix}`;
  return defaultId || `${prefix}-${id}`;
}
var $b5e257d569688ac6$export$619500959fc48b26 = typeof (0, import_react7.default)["useId"] === "function" ? $b5e257d569688ac6$var$useModernSSRSafeId : $b5e257d569688ac6$var$useLegacySSRSafeId;
function $b5e257d569688ac6$var$getSnapshot() {
  return false;
}
function $b5e257d569688ac6$var$getServerSnapshot() {
  return true;
}
function $b5e257d569688ac6$var$subscribe(onStoreChange) {
  return () => {
  };
}
function $b5e257d569688ac6$export$535bd6ca7f90a273() {
  if (typeof (0, import_react7.default)["useSyncExternalStore"] === "function") return (0, import_react7.default)["useSyncExternalStore"]($b5e257d569688ac6$var$subscribe, $b5e257d569688ac6$var$getSnapshot, $b5e257d569688ac6$var$getServerSnapshot);
  return (0, import_react7.useContext)($b5e257d569688ac6$var$IsSSRContext);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/useId.mjs
var $bdb11010cef70236$var$canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
var $bdb11010cef70236$export$d41a04c74483c6ef = /* @__PURE__ */ new Map();
var $bdb11010cef70236$var$registry;
if (typeof FinalizationRegistry !== "undefined") $bdb11010cef70236$var$registry = new FinalizationRegistry((heldValue) => {
  $bdb11010cef70236$export$d41a04c74483c6ef.delete(heldValue);
});

// node_modules/@react-stately/flags/dist/import.mjs
var $f4e2df6bd15f8569$var$_shadowDOM = false;
function $f4e2df6bd15f8569$export$98658e8c59125e6a() {
  return $f4e2df6bd15f8569$var$_shadowDOM;
}

// node_modules/clsx/dist/clsx.mjs
function r(e9) {
  var t14, f21, n17 = "";
  if ("string" == typeof e9 || "number" == typeof e9) n17 += e9;
  else if ("object" == typeof e9) if (Array.isArray(e9)) {
    var o20 = e9.length;
    for (t14 = 0; t14 < o20; t14++) e9[t14] && (f21 = r(e9[t14])) && (n17 && (n17 += " "), n17 += f21);
  } else for (f21 in e9) e9[f21] && (n17 && (n17 += " "), n17 += f21);
  return n17;
}
function clsx() {
  for (var e9, t14, f21 = 0, n17 = "", o20 = arguments.length; f21 < o20; f21++) (e9 = arguments[f21]) && (t14 = r(e9)) && (n17 && (n17 += " "), n17 += t14);
  return n17;
}
var clsx_default = clsx;

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/focusWithoutScrolling.mjs
function $7215afc6de606d6b$export$de79e2c695e052f3(element5) {
  if ($7215afc6de606d6b$var$supportsPreventScroll()) element5.focus({
    preventScroll: true
  });
  else {
    let scrollableElements = $7215afc6de606d6b$var$getScrollableElements(element5);
    element5.focus();
    $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements);
  }
}
var $7215afc6de606d6b$var$supportsPreventScrollCached = null;
function $7215afc6de606d6b$var$supportsPreventScroll() {
  if ($7215afc6de606d6b$var$supportsPreventScrollCached == null) {
    $7215afc6de606d6b$var$supportsPreventScrollCached = false;
    try {
      let focusElem = document.createElement("div");
      focusElem.focus({
        get preventScroll() {
          $7215afc6de606d6b$var$supportsPreventScrollCached = true;
          return true;
        }
      });
    } catch {
    }
  }
  return $7215afc6de606d6b$var$supportsPreventScrollCached;
}
function $7215afc6de606d6b$var$getScrollableElements(element5) {
  let parent = element5.parentNode;
  let scrollableElements = [];
  let rootScrollingElement = document.scrollingElement || document.documentElement;
  while (parent instanceof HTMLElement && parent !== rootScrollingElement) {
    if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({
      element: parent,
      scrollTop: parent.scrollTop,
      scrollLeft: parent.scrollLeft
    });
    parent = parent.parentNode;
  }
  if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({
    element: rootScrollingElement,
    scrollTop: rootScrollingElement.scrollTop,
    scrollLeft: rootScrollingElement.scrollLeft
  });
  return scrollableElements;
}
function $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements) {
  for (let { element: element5, scrollTop, scrollLeft } of scrollableElements) {
    element5.scrollTop = scrollTop;
    element5.scrollLeft = scrollLeft;
  }
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/platform.mjs
function $c87311424ea30a05$var$testUserAgent(re5) {
  var _window_navigator_userAgentData;
  if (typeof window === "undefined" || window.navigator == null) return false;
  let brands = (_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands;
  return Array.isArray(brands) && brands.some((brand) => re5.test(brand.brand)) || re5.test(window.navigator.userAgent);
}
function $c87311424ea30a05$var$testPlatform(re5) {
  var _window_navigator_userAgentData;
  return typeof window !== "undefined" && window.navigator != null ? re5.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $c87311424ea30a05$var$cached(fn) {
  if (false) return fn;
  let res = null;
  return () => {
    if (res == null) res = fn();
    return res;
  };
}
var $c87311424ea30a05$export$9ac100e40613ea10 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^Mac/i);
});
var $c87311424ea30a05$export$186c6964ca17d99 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^iPhone/i);
});
var $c87311424ea30a05$export$7bef049ce92e4224 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  $c87311424ea30a05$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
});
var $c87311424ea30a05$export$fedb369cb70207f1 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$export$186c6964ca17d99() || $c87311424ea30a05$export$7bef049ce92e4224();
});
var $c87311424ea30a05$export$e1865c3bedcd822b = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$export$9ac100e40613ea10() || $c87311424ea30a05$export$fedb369cb70207f1();
});
var $c87311424ea30a05$export$78551043582a6a98 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/AppleWebKit/i) && !$c87311424ea30a05$export$6446a186d09e379e();
});
var $c87311424ea30a05$export$6446a186d09e379e = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Chrome/i);
});
var $c87311424ea30a05$export$a11b0059900ceec8 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Android/i);
});
var $c87311424ea30a05$export$b7d78993b74f766d = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Firefox/i);
});

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/openLink.mjs
var import_react9 = __toESM(require_react(), 1);
var $ea8dcbcb9ea1b556$var$RouterContext = (0, import_react9.createContext)({
  isNative: true,
  open: $ea8dcbcb9ea1b556$var$openSyntheticLink,
  useHref: (href) => href
});
function $ea8dcbcb9ea1b556$export$95185d699e05d4d7(target, modifiers, setOpening = true) {
  var _window_event_type, _window_event;
  let { metaKey, ctrlKey, altKey, shiftKey } = modifiers;
  if ((0, $c87311424ea30a05$export$b7d78993b74f766d)() && ((_window_event = window.event) === null || _window_event === void 0 ? void 0 : (_window_event_type = _window_event.type) === null || _window_event_type === void 0 ? void 0 : _window_event_type.startsWith("key")) && target.target === "_blank") {
    if ((0, $c87311424ea30a05$export$9ac100e40613ea10)()) metaKey = true;
    else ctrlKey = true;
  }
  let event = (0, $c87311424ea30a05$export$78551043582a6a98)() && (0, $c87311424ea30a05$export$9ac100e40613ea10)() && !(0, $c87311424ea30a05$export$7bef049ce92e4224)() && true ? new KeyboardEvent("keydown", {
    keyIdentifier: "Enter",
    metaKey,
    ctrlKey,
    altKey,
    shiftKey
  }) : new MouseEvent("click", {
    metaKey,
    ctrlKey,
    altKey,
    shiftKey,
    bubbles: true,
    cancelable: true
  });
  $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = setOpening;
  (0, $7215afc6de606d6b$export$de79e2c695e052f3)(target);
  target.dispatchEvent(event);
  $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;
}
$ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;
function $ea8dcbcb9ea1b556$var$getSyntheticLink(target, open2) {
  if (target instanceof HTMLAnchorElement) open2(target);
  else if (target.hasAttribute("data-href")) {
    let link3 = document.createElement("a");
    link3.href = target.getAttribute("data-href");
    if (target.hasAttribute("data-target")) link3.target = target.getAttribute("data-target");
    if (target.hasAttribute("data-rel")) link3.rel = target.getAttribute("data-rel");
    if (target.hasAttribute("data-download")) link3.download = target.getAttribute("data-download");
    if (target.hasAttribute("data-ping")) link3.ping = target.getAttribute("data-ping");
    if (target.hasAttribute("data-referrer-policy")) link3.referrerPolicy = target.getAttribute("data-referrer-policy");
    target.appendChild(link3);
    open2(link3);
    target.removeChild(link3);
  }
}
function $ea8dcbcb9ea1b556$var$openSyntheticLink(target, modifiers) {
  $ea8dcbcb9ea1b556$var$getSyntheticLink(target, (link3) => $ea8dcbcb9ea1b556$export$95185d699e05d4d7(link3, modifiers));
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/runAfterTransition.mjs
var $bbed8b41f857bcc0$var$transitionsByElement = /* @__PURE__ */ new Map();
var $bbed8b41f857bcc0$var$transitionCallbacks = /* @__PURE__ */ new Set();
function $bbed8b41f857bcc0$var$setupGlobalEvents() {
  if (typeof window === "undefined") return;
  function isTransitionEvent(event) {
    return "propertyName" in event;
  }
  let onTransitionStart = (e9) => {
    if (!isTransitionEvent(e9) || !e9.target) return;
    let transitions = $bbed8b41f857bcc0$var$transitionsByElement.get(e9.target);
    if (!transitions) {
      transitions = /* @__PURE__ */ new Set();
      $bbed8b41f857bcc0$var$transitionsByElement.set(e9.target, transitions);
      e9.target.addEventListener("transitioncancel", onTransitionEnd, {
        once: true
      });
    }
    transitions.add(e9.propertyName);
  };
  let onTransitionEnd = (e9) => {
    if (!isTransitionEvent(e9) || !e9.target) return;
    let properties = $bbed8b41f857bcc0$var$transitionsByElement.get(e9.target);
    if (!properties) return;
    properties.delete(e9.propertyName);
    if (properties.size === 0) {
      e9.target.removeEventListener("transitioncancel", onTransitionEnd);
      $bbed8b41f857bcc0$var$transitionsByElement.delete(e9.target);
    }
    if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) {
      for (let cb of $bbed8b41f857bcc0$var$transitionCallbacks) cb();
      $bbed8b41f857bcc0$var$transitionCallbacks.clear();
    }
  };
  document.body.addEventListener("transitionrun", onTransitionStart);
  document.body.addEventListener("transitionend", onTransitionEnd);
}
if (typeof document !== "undefined") {
  if (document.readyState !== "loading") $bbed8b41f857bcc0$var$setupGlobalEvents();
  else document.addEventListener("DOMContentLoaded", $bbed8b41f857bcc0$var$setupGlobalEvents);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/useDrag1D.mjs
var import_react10 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/useGlobalListeners.mjs
var import_react11 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/useObjectRef.mjs
var import_react12 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/useUpdateEffect.mjs
var import_react13 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/useUpdateLayoutEffect.mjs
var import_react14 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/useResizeObserver.mjs
var import_react15 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/useViewportSize.mjs
var import_react16 = __toESM(require_react(), 1);
var $5df64b3807dc15ee$var$visualViewport = typeof document !== "undefined" && window.visualViewport;

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/useDescription.mjs
var import_react17 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/useEvent.mjs
var import_react18 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/useDeepMemo.mjs
var import_react19 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/useFormReset.mjs
var import_react20 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/useLoadMore.mjs
var import_react21 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/useLoadMoreSentinel.mjs
var import_react22 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/inertValue.mjs
var import_react23 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/animation.mjs
var import_react_dom = __toESM(require_react_dom(), 1);
var import_react24 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/isElementVisible.mjs
var $7d2416ea0959daaa$var$supportsCheckVisibility = typeof Element !== "undefined" && "checkVisibility" in Element.prototype;

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/node_modules/@react-aria/utils/dist/isFocusable.mjs
var $b4b717babfbb907b$var$focusableElements = [
  "input:not([disabled]):not([type=hidden])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  '[contenteditable]:not([contenteditable^="false"])',
  "permission"
];
var $b4b717babfbb907b$var$FOCUSABLE_ELEMENT_SELECTOR = $b4b717babfbb907b$var$focusableElements.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
$b4b717babfbb907b$var$focusableElements.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
var $b4b717babfbb907b$var$TABBABLE_ELEMENT_SELECTOR = $b4b717babfbb907b$var$focusableElements.join(':not([hidden]):not([tabindex="-1"]),');

// node_modules/@react-stately/utils/dist/useControlledState.mjs
var import_react25 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/useLayoutEffect.mjs
var import_react26 = __toESM(require_react(), 1);
var $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c2 = typeof document !== "undefined" ? (0, import_react26.default).useLayoutEffect : () => {
};

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/useEffectEvent.mjs
var import_react27 = __toESM(require_react(), 1);
var $8ae05eaa5c114e9c$var$_React_useInsertionEffect2;
var $8ae05eaa5c114e9c$var$useEarlyEffect2 = ($8ae05eaa5c114e9c$var$_React_useInsertionEffect2 = (0, import_react27.default)["useInsertionEffect"]) !== null && $8ae05eaa5c114e9c$var$_React_useInsertionEffect2 !== void 0 ? $8ae05eaa5c114e9c$var$_React_useInsertionEffect2 : (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c2);
function $8ae05eaa5c114e9c$export$7f54fc3180508a522(fn) {
  const ref = (0, import_react27.useRef)(null);
  $8ae05eaa5c114e9c$var$useEarlyEffect2(() => {
    ref.current = fn;
  }, [
    fn
  ]);
  return (0, import_react27.useCallback)((...args) => {
    const f21 = ref.current;
    return f21 === null || f21 === void 0 ? void 0 : f21(...args);
  }, []);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/useValueEffect.mjs
var import_react28 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/useId.mjs
var import_react29 = __toESM(require_react(), 1);
var $bdb11010cef70236$var$canUseDOM2 = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
var $bdb11010cef70236$export$d41a04c74483c6ef2 = /* @__PURE__ */ new Map();
var $bdb11010cef70236$var$registry2;
if (typeof FinalizationRegistry !== "undefined") $bdb11010cef70236$var$registry2 = new FinalizationRegistry((heldValue) => {
  $bdb11010cef70236$export$d41a04c74483c6ef2.delete(heldValue);
});
function $bdb11010cef70236$export$cd8c9cb68f8426292(idA, idB) {
  if (idA === idB) return idA;
  let setIdsA = $bdb11010cef70236$export$d41a04c74483c6ef2.get(idA);
  if (setIdsA) {
    setIdsA.forEach((ref) => ref.current = idB);
    return idB;
  }
  let setIdsB = $bdb11010cef70236$export$d41a04c74483c6ef2.get(idB);
  if (setIdsB) {
    setIdsB.forEach((ref) => ref.current = idA);
    return idA;
  }
  return idB;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/chain.mjs
function $ff5963eb1fccf552$export$e08e3b67e392101e2(...callbacks) {
  return (...args) => {
    for (let callback of callbacks) if (typeof callback === "function") callback(...args);
  };
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/domHelpers.mjs
var $431fbd86ca7dc216$export$b204af158042fbac2 = (el) => {
  var _el_ownerDocument;
  return (_el_ownerDocument = el === null || el === void 0 ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;
};
var $431fbd86ca7dc216$export$f21a1ffae260145a2 = (el) => {
  if (el && "window" in el && el.window === el) return el;
  const doc = $431fbd86ca7dc216$export$b204af158042fbac2(el);
  return doc.defaultView || window;
};
function $431fbd86ca7dc216$var$isNode(value) {
  return value !== null && typeof value === "object" && "nodeType" in value && typeof value.nodeType === "number";
}
function $431fbd86ca7dc216$export$af51f0f06c0f328a2(node2) {
  return $431fbd86ca7dc216$var$isNode(node2) && node2.nodeType === Node.DOCUMENT_FRAGMENT_NODE && "host" in node2;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/DOMFunctions.mjs
function $d4ee10de306f2510$export$4282f70798064fe02(node2, otherNode) {
  if (!(0, $f4e2df6bd15f8569$export$98658e8c59125e6a)()) return otherNode && node2 ? node2.contains(otherNode) : false;
  if (!node2 || !otherNode) return false;
  let currentNode = otherNode;
  while (currentNode !== null) {
    if (currentNode === node2) return true;
    if (currentNode.tagName === "SLOT" && currentNode.assignedSlot)
      currentNode = currentNode.assignedSlot.parentNode;
    else if ((0, $431fbd86ca7dc216$export$af51f0f06c0f328a2)(currentNode))
      currentNode = currentNode.host;
    else currentNode = currentNode.parentNode;
  }
  return false;
}
var $d4ee10de306f2510$export$cd4e5573fbe2b5762 = (doc = document) => {
  var _activeElement_shadowRoot;
  if (!(0, $f4e2df6bd15f8569$export$98658e8c59125e6a)()) return doc.activeElement;
  let activeElement2 = doc.activeElement;
  while (activeElement2 && "shadowRoot" in activeElement2 && ((_activeElement_shadowRoot = activeElement2.shadowRoot) === null || _activeElement_shadowRoot === void 0 ? void 0 : _activeElement_shadowRoot.activeElement)) activeElement2 = activeElement2.shadowRoot.activeElement;
  return activeElement2;
};
function $d4ee10de306f2510$export$e58f029f0fbfdb292(event) {
  if ((0, $f4e2df6bd15f8569$export$98658e8c59125e6a)() && event.target.shadowRoot) {
    if (event.composedPath) return event.composedPath()[0];
  }
  return event.target;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/mergeProps.mjs
function $3ef42575df84b30b$export$9d1611c77c2fe9282(...args) {
  let result = {
    ...args[0]
  };
  for (let i16 = 1; i16 < args.length; i16++) {
    let props = args[i16];
    for (let key in props) {
      let a28 = result[key];
      let b14 = props[key];
      if (typeof a28 === "function" && typeof b14 === "function" && // This is a lot faster than a regex.
      key[0] === "o" && key[1] === "n" && key.charCodeAt(2) >= /* 'A' */
      65 && key.charCodeAt(2) <= /* 'Z' */
      90) result[key] = (0, $ff5963eb1fccf552$export$e08e3b67e392101e2)(a28, b14);
      else if ((key === "className" || key === "UNSAFE_className") && typeof a28 === "string" && typeof b14 === "string") result[key] = (0, clsx_default)(a28, b14);
      else if (key === "id" && a28 && b14) result.id = (0, $bdb11010cef70236$export$cd8c9cb68f8426292)(a28, b14);
      else result[key] = b14 !== void 0 ? b14 : a28;
    }
  }
  return result;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/mergeRefs.mjs
function $5dc95899b306f630$export$c9058316764c140e2(...refs) {
  if (refs.length === 1 && refs[0]) return refs[0];
  return (value) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup2 = $5dc95899b306f630$var$setRef(ref, value);
      hasCleanup || (hasCleanup = typeof cleanup2 == "function");
      return cleanup2;
    });
    if (hasCleanup) return () => {
      cleanups.forEach((cleanup2, i16) => {
        if (typeof cleanup2 === "function") cleanup2();
        else $5dc95899b306f630$var$setRef(refs[i16], null);
      });
    };
  };
}
function $5dc95899b306f630$var$setRef(ref, value) {
  if (typeof ref === "function") return ref(value);
  else if (ref != null) ref.current = value;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/focusWithoutScrolling.mjs
function $7215afc6de606d6b$export$de79e2c695e052f32(element5) {
  if ($7215afc6de606d6b$var$supportsPreventScroll2()) element5.focus({
    preventScroll: true
  });
  else {
    let scrollableElements = $7215afc6de606d6b$var$getScrollableElements2(element5);
    element5.focus();
    $7215afc6de606d6b$var$restoreScrollPosition2(scrollableElements);
  }
}
var $7215afc6de606d6b$var$supportsPreventScrollCached2 = null;
function $7215afc6de606d6b$var$supportsPreventScroll2() {
  if ($7215afc6de606d6b$var$supportsPreventScrollCached2 == null) {
    $7215afc6de606d6b$var$supportsPreventScrollCached2 = false;
    try {
      let focusElem = document.createElement("div");
      focusElem.focus({
        get preventScroll() {
          $7215afc6de606d6b$var$supportsPreventScrollCached2 = true;
          return true;
        }
      });
    } catch {
    }
  }
  return $7215afc6de606d6b$var$supportsPreventScrollCached2;
}
function $7215afc6de606d6b$var$getScrollableElements2(element5) {
  let parent = element5.parentNode;
  let scrollableElements = [];
  let rootScrollingElement = document.scrollingElement || document.documentElement;
  while (parent instanceof HTMLElement && parent !== rootScrollingElement) {
    if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({
      element: parent,
      scrollTop: parent.scrollTop,
      scrollLeft: parent.scrollLeft
    });
    parent = parent.parentNode;
  }
  if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({
    element: rootScrollingElement,
    scrollTop: rootScrollingElement.scrollTop,
    scrollLeft: rootScrollingElement.scrollLeft
  });
  return scrollableElements;
}
function $7215afc6de606d6b$var$restoreScrollPosition2(scrollableElements) {
  for (let { element: element5, scrollTop, scrollLeft } of scrollableElements) {
    element5.scrollTop = scrollTop;
    element5.scrollLeft = scrollLeft;
  }
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/platform.mjs
function $c87311424ea30a05$var$testUserAgent2(re5) {
  var _window_navigator_userAgentData;
  if (typeof window === "undefined" || window.navigator == null) return false;
  let brands = (_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands;
  return Array.isArray(brands) && brands.some((brand) => re5.test(brand.brand)) || re5.test(window.navigator.userAgent);
}
function $c87311424ea30a05$var$testPlatform2(re5) {
  var _window_navigator_userAgentData;
  return typeof window !== "undefined" && window.navigator != null ? re5.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $c87311424ea30a05$var$cached2(fn) {
  if (false) return fn;
  let res = null;
  return () => {
    if (res == null) res = fn();
    return res;
  };
}
var $c87311424ea30a05$export$9ac100e40613ea102 = $c87311424ea30a05$var$cached2(function() {
  return $c87311424ea30a05$var$testPlatform2(/^Mac/i);
});
var $c87311424ea30a05$export$186c6964ca17d992 = $c87311424ea30a05$var$cached2(function() {
  return $c87311424ea30a05$var$testPlatform2(/^iPhone/i);
});
var $c87311424ea30a05$export$7bef049ce92e42242 = $c87311424ea30a05$var$cached2(function() {
  return $c87311424ea30a05$var$testPlatform2(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  $c87311424ea30a05$export$9ac100e40613ea102() && navigator.maxTouchPoints > 1;
});
var $c87311424ea30a05$export$fedb369cb70207f12 = $c87311424ea30a05$var$cached2(function() {
  return $c87311424ea30a05$export$186c6964ca17d992() || $c87311424ea30a05$export$7bef049ce92e42242();
});
var $c87311424ea30a05$export$e1865c3bedcd822b2 = $c87311424ea30a05$var$cached2(function() {
  return $c87311424ea30a05$export$9ac100e40613ea102() || $c87311424ea30a05$export$fedb369cb70207f12();
});
var $c87311424ea30a05$export$78551043582a6a982 = $c87311424ea30a05$var$cached2(function() {
  return $c87311424ea30a05$var$testUserAgent2(/AppleWebKit/i) && !$c87311424ea30a05$export$6446a186d09e379e2();
});
var $c87311424ea30a05$export$6446a186d09e379e2 = $c87311424ea30a05$var$cached2(function() {
  return $c87311424ea30a05$var$testUserAgent2(/Chrome/i);
});
var $c87311424ea30a05$export$a11b0059900ceec82 = $c87311424ea30a05$var$cached2(function() {
  return $c87311424ea30a05$var$testUserAgent2(/Android/i);
});
var $c87311424ea30a05$export$b7d78993b74f766d2 = $c87311424ea30a05$var$cached2(function() {
  return $c87311424ea30a05$var$testUserAgent2(/Firefox/i);
});

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/openLink.mjs
var import_react30 = __toESM(require_react(), 1);
var $ea8dcbcb9ea1b556$var$RouterContext2 = (0, import_react30.createContext)({
  isNative: true,
  open: $ea8dcbcb9ea1b556$var$openSyntheticLink2,
  useHref: (href) => href
});
function $ea8dcbcb9ea1b556$export$95185d699e05d4d72(target, modifiers, setOpening = true) {
  var _window_event_type, _window_event;
  let { metaKey, ctrlKey, altKey, shiftKey } = modifiers;
  if ((0, $c87311424ea30a05$export$b7d78993b74f766d2)() && ((_window_event = window.event) === null || _window_event === void 0 ? void 0 : (_window_event_type = _window_event.type) === null || _window_event_type === void 0 ? void 0 : _window_event_type.startsWith("key")) && target.target === "_blank") {
    if ((0, $c87311424ea30a05$export$9ac100e40613ea102)()) metaKey = true;
    else ctrlKey = true;
  }
  let event = (0, $c87311424ea30a05$export$78551043582a6a982)() && (0, $c87311424ea30a05$export$9ac100e40613ea102)() && !(0, $c87311424ea30a05$export$7bef049ce92e42242)() && true ? new KeyboardEvent("keydown", {
    keyIdentifier: "Enter",
    metaKey,
    ctrlKey,
    altKey,
    shiftKey
  }) : new MouseEvent("click", {
    metaKey,
    ctrlKey,
    altKey,
    shiftKey,
    bubbles: true,
    cancelable: true
  });
  $ea8dcbcb9ea1b556$export$95185d699e05d4d72.isOpening = setOpening;
  (0, $7215afc6de606d6b$export$de79e2c695e052f32)(target);
  target.dispatchEvent(event);
  $ea8dcbcb9ea1b556$export$95185d699e05d4d72.isOpening = false;
}
$ea8dcbcb9ea1b556$export$95185d699e05d4d72.isOpening = false;
function $ea8dcbcb9ea1b556$var$getSyntheticLink2(target, open2) {
  if (target instanceof HTMLAnchorElement) open2(target);
  else if (target.hasAttribute("data-href")) {
    let link3 = document.createElement("a");
    link3.href = target.getAttribute("data-href");
    if (target.hasAttribute("data-target")) link3.target = target.getAttribute("data-target");
    if (target.hasAttribute("data-rel")) link3.rel = target.getAttribute("data-rel");
    if (target.hasAttribute("data-download")) link3.download = target.getAttribute("data-download");
    if (target.hasAttribute("data-ping")) link3.ping = target.getAttribute("data-ping");
    if (target.hasAttribute("data-referrer-policy")) link3.referrerPolicy = target.getAttribute("data-referrer-policy");
    target.appendChild(link3);
    open2(link3);
    target.removeChild(link3);
  }
}
function $ea8dcbcb9ea1b556$var$openSyntheticLink2(target, modifiers) {
  $ea8dcbcb9ea1b556$var$getSyntheticLink2(target, (link3) => $ea8dcbcb9ea1b556$export$95185d699e05d4d72(link3, modifiers));
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/runAfterTransition.mjs
var $bbed8b41f857bcc0$var$transitionsByElement2 = /* @__PURE__ */ new Map();
var $bbed8b41f857bcc0$var$transitionCallbacks2 = /* @__PURE__ */ new Set();
function $bbed8b41f857bcc0$var$setupGlobalEvents2() {
  if (typeof window === "undefined") return;
  function isTransitionEvent(event) {
    return "propertyName" in event;
  }
  let onTransitionStart = (e9) => {
    if (!isTransitionEvent(e9) || !e9.target) return;
    let transitions = $bbed8b41f857bcc0$var$transitionsByElement2.get(e9.target);
    if (!transitions) {
      transitions = /* @__PURE__ */ new Set();
      $bbed8b41f857bcc0$var$transitionsByElement2.set(e9.target, transitions);
      e9.target.addEventListener("transitioncancel", onTransitionEnd, {
        once: true
      });
    }
    transitions.add(e9.propertyName);
  };
  let onTransitionEnd = (e9) => {
    if (!isTransitionEvent(e9) || !e9.target) return;
    let properties = $bbed8b41f857bcc0$var$transitionsByElement2.get(e9.target);
    if (!properties) return;
    properties.delete(e9.propertyName);
    if (properties.size === 0) {
      e9.target.removeEventListener("transitioncancel", onTransitionEnd);
      $bbed8b41f857bcc0$var$transitionsByElement2.delete(e9.target);
    }
    if ($bbed8b41f857bcc0$var$transitionsByElement2.size === 0) {
      for (let cb of $bbed8b41f857bcc0$var$transitionCallbacks2) cb();
      $bbed8b41f857bcc0$var$transitionCallbacks2.clear();
    }
  };
  document.body.addEventListener("transitionrun", onTransitionStart);
  document.body.addEventListener("transitionend", onTransitionEnd);
}
if (typeof document !== "undefined") {
  if (document.readyState !== "loading") $bbed8b41f857bcc0$var$setupGlobalEvents2();
  else document.addEventListener("DOMContentLoaded", $bbed8b41f857bcc0$var$setupGlobalEvents2);
}
function $bbed8b41f857bcc0$var$cleanupDetachedElements() {
  for (const [eventTarget] of $bbed8b41f857bcc0$var$transitionsByElement2)
    if ("isConnected" in eventTarget && !eventTarget.isConnected) $bbed8b41f857bcc0$var$transitionsByElement2.delete(eventTarget);
}
function $bbed8b41f857bcc0$export$24490316f764c4302(fn) {
  requestAnimationFrame(() => {
    $bbed8b41f857bcc0$var$cleanupDetachedElements();
    if ($bbed8b41f857bcc0$var$transitionsByElement2.size === 0) fn();
    else $bbed8b41f857bcc0$var$transitionCallbacks2.add(fn);
  });
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/useDrag1D.mjs
var import_react31 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/useGlobalListeners.mjs
var import_react32 = __toESM(require_react(), 1);
function $03deb23ff14920c4$export$4eaf04e54aa8eed62() {
  let globalListeners = (0, import_react32.useRef)(/* @__PURE__ */ new Map());
  let addGlobalListener = (0, import_react32.useCallback)((eventTarget, type, listener, options) => {
    let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args) => {
      globalListeners.current.delete(listener);
      listener(...args);
    } : listener;
    globalListeners.current.set(listener, {
      type,
      eventTarget,
      fn,
      options
    });
    eventTarget.addEventListener(type, fn, options);
  }, []);
  let removeGlobalListener = (0, import_react32.useCallback)((eventTarget, type, listener, options) => {
    var _globalListeners_current_get;
    let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
    eventTarget.removeEventListener(type, fn, options);
    globalListeners.current.delete(listener);
  }, []);
  let removeAllGlobalListeners = (0, import_react32.useCallback)(() => {
    globalListeners.current.forEach((value, key) => {
      removeGlobalListener(value.eventTarget, value.type, key, value.options);
    });
  }, [
    removeGlobalListener
  ]);
  (0, import_react32.useEffect)(() => {
    return removeAllGlobalListeners;
  }, [
    removeAllGlobalListeners
  ]);
  return {
    addGlobalListener,
    removeGlobalListener,
    removeAllGlobalListeners
  };
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/useObjectRef.mjs
var import_react33 = __toESM(require_react(), 1);
function $df56164dff5785e2$export$4338b53315abf6662(ref) {
  const objRef = (0, import_react33.useRef)(null);
  const cleanupRef = (0, import_react33.useRef)(void 0);
  const refEffect = (0, import_react33.useCallback)((instance) => {
    if (typeof ref === "function") {
      const refCallback = ref;
      const refCleanup = refCallback(instance);
      return () => {
        if (typeof refCleanup === "function") refCleanup();
        else refCallback(null);
      };
    } else if (ref) {
      ref.current = instance;
      return () => {
        ref.current = null;
      };
    }
  }, [
    ref
  ]);
  return (0, import_react33.useMemo)(() => ({
    get current() {
      return objRef.current;
    },
    set current(value) {
      objRef.current = value;
      if (cleanupRef.current) {
        cleanupRef.current();
        cleanupRef.current = void 0;
      }
      if (value != null) cleanupRef.current = refEffect(value);
    }
  }), [
    refEffect
  ]);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/useUpdateEffect.mjs
var import_react34 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/useUpdateLayoutEffect.mjs
var import_react35 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/useResizeObserver.mjs
var import_react36 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/useSyncRef.mjs
function $e7801be82b4b2a53$export$4debdb1a3f0fa79e2(context, ref) {
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c2)(() => {
    if (context && context.ref && ref) {
      context.ref.current = ref.current;
      return () => {
        if (context.ref) context.ref.current = null;
      };
    }
  });
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/useViewportSize.mjs
var import_react37 = __toESM(require_react(), 1);
var $5df64b3807dc15ee$var$visualViewport2 = typeof document !== "undefined" && window.visualViewport;

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/useDescription.mjs
var import_react38 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/useEvent.mjs
var import_react39 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/isVirtualEvent.mjs
function $6a7db85432448f7f$export$60278871457622de2(event) {
  if (event.pointerType === "" && event.isTrusted) return true;
  if ((0, $c87311424ea30a05$export$a11b0059900ceec82)() && event.pointerType) return event.type === "click" && event.buttons === 1;
  return event.detail === 0 && !event.pointerType;
}
function $6a7db85432448f7f$export$29bf1b5f2c56cf632(event) {
  return !(0, $c87311424ea30a05$export$a11b0059900ceec82)() && event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse";
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/useDeepMemo.mjs
var import_react40 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/useFormReset.mjs
var import_react41 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/useLoadMore.mjs
var import_react42 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/useLoadMoreSentinel.mjs
var import_react43 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/inertValue.mjs
var import_react44 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/animation.mjs
var import_react_dom2 = __toESM(require_react_dom(), 1);
var import_react45 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/isElementVisible.mjs
var $7d2416ea0959daaa$var$supportsCheckVisibility2 = typeof Element !== "undefined" && "checkVisibility" in Element.prototype;
function $7d2416ea0959daaa$var$isStyleVisible(element5) {
  const windowObject = (0, $431fbd86ca7dc216$export$f21a1ffae260145a2)(element5);
  if (!(element5 instanceof windowObject.HTMLElement) && !(element5 instanceof windowObject.SVGElement)) return false;
  let { display, visibility } = element5.style;
  let isVisible = display !== "none" && visibility !== "hidden" && visibility !== "collapse";
  if (isVisible) {
    const { getComputedStyle: getComputedStyle3 } = element5.ownerDocument.defaultView;
    let { display: computedDisplay, visibility: computedVisibility } = getComputedStyle3(element5);
    isVisible = computedDisplay !== "none" && computedVisibility !== "hidden" && computedVisibility !== "collapse";
  }
  return isVisible;
}
function $7d2416ea0959daaa$var$isAttributeVisible(element5, childElement) {
  return !element5.hasAttribute("hidden") && // Ignore HiddenSelect when tree walking.
  !element5.hasAttribute("data-react-aria-prevent-focus") && (element5.nodeName === "DETAILS" && childElement && childElement.nodeName !== "SUMMARY" ? element5.hasAttribute("open") : true);
}
function $7d2416ea0959daaa$export$e989c0fffaa6b27a2(element5, childElement) {
  if ($7d2416ea0959daaa$var$supportsCheckVisibility2) return element5.checkVisibility({
    visibilityProperty: true
  }) && !element5.closest("[data-react-aria-prevent-focus]");
  return element5.nodeName !== "#comment" && $7d2416ea0959daaa$var$isStyleVisible(element5) && $7d2416ea0959daaa$var$isAttributeVisible(element5, childElement) && (!element5.parentElement || $7d2416ea0959daaa$export$e989c0fffaa6b27a2(element5.parentElement, element5));
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/node_modules/@react-aria/utils/dist/isFocusable.mjs
var $b4b717babfbb907b$var$focusableElements2 = [
  "input:not([disabled]):not([type=hidden])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  '[contenteditable]:not([contenteditable^="false"])',
  "permission"
];
var $b4b717babfbb907b$var$FOCUSABLE_ELEMENT_SELECTOR2 = $b4b717babfbb907b$var$focusableElements2.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
$b4b717babfbb907b$var$focusableElements2.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
var $b4b717babfbb907b$var$TABBABLE_ELEMENT_SELECTOR2 = $b4b717babfbb907b$var$focusableElements2.join(':not([hidden]):not([tabindex="-1"]),');
function $b4b717babfbb907b$export$4c063cf1350e6fed2(element5) {
  return element5.matches($b4b717babfbb907b$var$FOCUSABLE_ELEMENT_SELECTOR2) && (0, $7d2416ea0959daaa$export$e989c0fffaa6b27a2)(element5) && !$b4b717babfbb907b$var$isInert(element5);
}
function $b4b717babfbb907b$var$isInert(element5) {
  let node2 = element5;
  while (node2 != null) {
    if (node2 instanceof node2.ownerDocument.defaultView.HTMLElement && node2.inert) return true;
    node2 = node2.parentElement;
  }
  return false;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/dist/utils.mjs
var import_react46 = __toESM(require_react(), 1);
function $8a9cb279dc87e130$export$525bc4921d56d4a(nativeEvent) {
  let event = nativeEvent;
  event.nativeEvent = nativeEvent;
  event.isDefaultPrevented = () => event.defaultPrevented;
  event.isPropagationStopped = () => event.cancelBubble;
  event.persist = () => {
  };
  return event;
}
function $8a9cb279dc87e130$export$c2b7abe5d61ec696(event, target) {
  Object.defineProperty(event, "target", {
    value: target
  });
  Object.defineProperty(event, "currentTarget", {
    value: target
  });
}
function $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {
  let stateRef = (0, import_react46.useRef)({
    isFocused: false,
    observer: null
  });
  (0, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c2)(() => {
    const state = stateRef.current;
    return () => {
      if (state.observer) {
        state.observer.disconnect();
        state.observer = null;
      }
    };
  }, []);
  let dispatchBlur = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a522)((e9) => {
    onBlur === null || onBlur === void 0 ? void 0 : onBlur(e9);
  });
  return (0, import_react46.useCallback)((e9) => {
    if (e9.target instanceof HTMLButtonElement || e9.target instanceof HTMLInputElement || e9.target instanceof HTMLTextAreaElement || e9.target instanceof HTMLSelectElement) {
      stateRef.current.isFocused = true;
      let target = e9.target;
      let onBlurHandler = (e10) => {
        stateRef.current.isFocused = false;
        if (target.disabled) {
          let event = $8a9cb279dc87e130$export$525bc4921d56d4a(e10);
          dispatchBlur(event);
        }
        if (stateRef.current.observer) {
          stateRef.current.observer.disconnect();
          stateRef.current.observer = null;
        }
      };
      target.addEventListener("focusout", onBlurHandler, {
        once: true
      });
      stateRef.current.observer = new MutationObserver(() => {
        if (stateRef.current.isFocused && target.disabled) {
          var _stateRef_current_observer;
          (_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 ? void 0 : _stateRef_current_observer.disconnect();
          let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
          target.dispatchEvent(new FocusEvent("blur", {
            relatedTarget: relatedTargetEl
          }));
          target.dispatchEvent(new FocusEvent("focusout", {
            bubbles: true,
            relatedTarget: relatedTargetEl
          }));
        }
      });
      stateRef.current.observer.observe(target, {
        attributes: true,
        attributeFilter: [
          "disabled"
        ]
      });
    }
  }, [
    dispatchBlur
  ]);
}
var $8a9cb279dc87e130$export$fda7da73ab5d4c48 = false;
function $8a9cb279dc87e130$export$cabe61c495ee3649(target) {
  while (target && !(0, $b4b717babfbb907b$export$4c063cf1350e6fed2)(target)) target = target.parentElement;
  let window2 = (0, $431fbd86ca7dc216$export$f21a1ffae260145a2)(target);
  let activeElement2 = window2.document.activeElement;
  if (!activeElement2 || activeElement2 === target) return;
  $8a9cb279dc87e130$export$fda7da73ab5d4c48 = true;
  let isRefocusing = false;
  let onBlur = (e9) => {
    if (e9.target === activeElement2 || isRefocusing) e9.stopImmediatePropagation();
  };
  let onFocusOut = (e9) => {
    if (e9.target === activeElement2 || isRefocusing) {
      e9.stopImmediatePropagation();
      if (!target && !isRefocusing) {
        isRefocusing = true;
        (0, $7215afc6de606d6b$export$de79e2c695e052f32)(activeElement2);
        cleanup2();
      }
    }
  };
  let onFocus = (e9) => {
    if (e9.target === target || isRefocusing) e9.stopImmediatePropagation();
  };
  let onFocusIn = (e9) => {
    if (e9.target === target || isRefocusing) {
      e9.stopImmediatePropagation();
      if (!isRefocusing) {
        isRefocusing = true;
        (0, $7215afc6de606d6b$export$de79e2c695e052f32)(activeElement2);
        cleanup2();
      }
    }
  };
  window2.addEventListener("blur", onBlur, true);
  window2.addEventListener("focusout", onFocusOut, true);
  window2.addEventListener("focusin", onFocusIn, true);
  window2.addEventListener("focus", onFocus, true);
  let cleanup2 = () => {
    cancelAnimationFrame(raf);
    window2.removeEventListener("blur", onBlur, true);
    window2.removeEventListener("focusout", onFocusOut, true);
    window2.removeEventListener("focusin", onFocusIn, true);
    window2.removeEventListener("focus", onFocus, true);
    $8a9cb279dc87e130$export$fda7da73ab5d4c48 = false;
    isRefocusing = false;
  };
  let raf = requestAnimationFrame(cleanup2);
  return cleanup2;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/dist/textSelection.mjs
var $14c0b72509d70225$var$state = "default";
var $14c0b72509d70225$var$savedUserSelect = "";
var $14c0b72509d70225$var$modifiedElementMap = /* @__PURE__ */ new WeakMap();
function $14c0b72509d70225$export$16a4697467175487(target) {
  if ((0, $c87311424ea30a05$export$fedb369cb70207f12)()) {
    if ($14c0b72509d70225$var$state === "default") {
      const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac2)(target);
      $14c0b72509d70225$var$savedUserSelect = documentObject.documentElement.style.webkitUserSelect;
      documentObject.documentElement.style.webkitUserSelect = "none";
    }
    $14c0b72509d70225$var$state = "disabled";
  } else if (target instanceof HTMLElement || target instanceof SVGElement) {
    let property = "userSelect" in target.style ? "userSelect" : "webkitUserSelect";
    $14c0b72509d70225$var$modifiedElementMap.set(target, target.style[property]);
    target.style[property] = "none";
  }
}
function $14c0b72509d70225$export$b0d6fa1ab32e3295(target) {
  if ((0, $c87311424ea30a05$export$fedb369cb70207f12)()) {
    if ($14c0b72509d70225$var$state !== "disabled") return;
    $14c0b72509d70225$var$state = "restoring";
    setTimeout(() => {
      (0, $bbed8b41f857bcc0$export$24490316f764c4302)(() => {
        if ($14c0b72509d70225$var$state === "restoring") {
          const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac2)(target);
          if (documentObject.documentElement.style.webkitUserSelect === "none") documentObject.documentElement.style.webkitUserSelect = $14c0b72509d70225$var$savedUserSelect || "";
          $14c0b72509d70225$var$savedUserSelect = "";
          $14c0b72509d70225$var$state = "default";
        }
      });
    }, 300);
  } else if (target instanceof HTMLElement || target instanceof SVGElement) {
    if (target && $14c0b72509d70225$var$modifiedElementMap.has(target)) {
      let targetOldUserSelect = $14c0b72509d70225$var$modifiedElementMap.get(target);
      let property = "userSelect" in target.style ? "userSelect" : "webkitUserSelect";
      if (target.style[property] === "none") target.style[property] = targetOldUserSelect;
      if (target.getAttribute("style") === "") target.removeAttribute("style");
      $14c0b72509d70225$var$modifiedElementMap.delete(target);
    }
  }
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/dist/context.mjs
var import_react47 = __toESM(require_react(), 1);
var $ae1eeba8b9eafd08$export$5165eccb35aaadb5 = (0, import_react47.default).createContext({
  register: () => {
  }
});
$ae1eeba8b9eafd08$export$5165eccb35aaadb5.displayName = "PressResponderContext";

// node_modules/@swc/helpers/esm/_class_apply_descriptor_get.js
function _class_apply_descriptor_get(receiver, descriptor) {
  if (descriptor.get) return descriptor.get.call(receiver);
  return descriptor.value;
}

// node_modules/@swc/helpers/esm/_class_extract_field_descriptor.js
function _class_extract_field_descriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) throw new TypeError("attempted to " + action + " private field on non-instance");
  return privateMap.get(receiver);
}

// node_modules/@swc/helpers/esm/_class_private_field_get.js
function _class_private_field_get(receiver, privateMap) {
  var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
  return _class_apply_descriptor_get(receiver, descriptor);
}

// node_modules/@swc/helpers/esm/_check_private_redeclaration.js
function _check_private_redeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

// node_modules/@swc/helpers/esm/_class_private_field_init.js
function _class_private_field_init(obj, privateMap, value) {
  _check_private_redeclaration(obj, privateMap);
  privateMap.set(obj, value);
}

// node_modules/@swc/helpers/esm/_class_apply_descriptor_set.js
function _class_apply_descriptor_set(receiver, descriptor, value) {
  if (descriptor.set) descriptor.set.call(receiver, value);
  else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}

// node_modules/@swc/helpers/esm/_class_private_field_set.js
function _class_private_field_set(receiver, privateMap, value) {
  var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
  _class_apply_descriptor_set(receiver, descriptor, value);
  return value;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/dist/usePress.mjs
var import_react_dom3 = __toESM(require_react_dom(), 1);
var import_react48 = __toESM(require_react(), 1);
function $f6c31cce2adf654f$var$usePressResponderContext(props) {
  let context = (0, import_react48.useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));
  if (context) {
    let { register, ...contextProps } = context;
    props = (0, $3ef42575df84b30b$export$9d1611c77c2fe9282)(contextProps, props);
    register();
  }
  (0, $e7801be82b4b2a53$export$4debdb1a3f0fa79e2)(context, props.ref);
  return props;
}
var $f6c31cce2adf654f$var$_shouldStopPropagation = /* @__PURE__ */ new WeakMap();
var $f6c31cce2adf654f$var$PressEvent = class {
  continuePropagation() {
    (0, _class_private_field_set)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, false);
  }
  get shouldStopPropagation() {
    return (0, _class_private_field_get)(this, $f6c31cce2adf654f$var$_shouldStopPropagation);
  }
  constructor(type, pointerType, originalEvent, state) {
    (0, _class_private_field_init)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, {
      writable: true,
      value: void 0
    });
    (0, _class_private_field_set)(this, $f6c31cce2adf654f$var$_shouldStopPropagation, true);
    var _state_target;
    let currentTarget = (_state_target = state === null || state === void 0 ? void 0 : state.target) !== null && _state_target !== void 0 ? _state_target : originalEvent.currentTarget;
    const rect = currentTarget === null || currentTarget === void 0 ? void 0 : currentTarget.getBoundingClientRect();
    let x10, y10 = 0;
    let clientX, clientY = null;
    if (originalEvent.clientX != null && originalEvent.clientY != null) {
      clientX = originalEvent.clientX;
      clientY = originalEvent.clientY;
    }
    if (rect) {
      if (clientX != null && clientY != null) {
        x10 = clientX - rect.left;
        y10 = clientY - rect.top;
      } else {
        x10 = rect.width / 2;
        y10 = rect.height / 2;
      }
    }
    this.type = type;
    this.pointerType = pointerType;
    this.target = originalEvent.currentTarget;
    this.shiftKey = originalEvent.shiftKey;
    this.metaKey = originalEvent.metaKey;
    this.ctrlKey = originalEvent.ctrlKey;
    this.altKey = originalEvent.altKey;
    this.x = x10;
    this.y = y10;
  }
};
var $f6c31cce2adf654f$var$LINK_CLICKED = Symbol("linkClicked");
var $f6c31cce2adf654f$var$STYLE_ID = "react-aria-pressable-style";
var $f6c31cce2adf654f$var$PRESSABLE_ATTRIBUTE = "data-react-aria-pressable";
function $f6c31cce2adf654f$export$45712eceda6fad21(props) {
  let { onPress, onPressChange, onPressStart, onPressEnd, onPressUp, onClick, isDisabled: isDisabled2, isPressed: isPressedProp, preventFocusOnPress, shouldCancelOnPointerExit, allowTextSelectionOnPress, ref: domRef, ...domProps } = $f6c31cce2adf654f$var$usePressResponderContext(props);
  let [isPressed, setPressed] = (0, import_react48.useState)(false);
  let ref = (0, import_react48.useRef)({
    isPressed: false,
    ignoreEmulatedMouseEvents: false,
    didFirePressStart: false,
    isTriggeringEvent: false,
    activePointerId: null,
    target: null,
    isOverTarget: false,
    pointerType: null,
    disposables: []
  });
  let { addGlobalListener, removeAllGlobalListeners } = (0, $03deb23ff14920c4$export$4eaf04e54aa8eed62)();
  let triggerPressStart = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a522)((originalEvent, pointerType) => {
    let state = ref.current;
    if (isDisabled2 || state.didFirePressStart) return false;
    let shouldStopPropagation = true;
    state.isTriggeringEvent = true;
    if (onPressStart) {
      let event = new $f6c31cce2adf654f$var$PressEvent("pressstart", pointerType, originalEvent);
      onPressStart(event);
      shouldStopPropagation = event.shouldStopPropagation;
    }
    if (onPressChange) onPressChange(true);
    state.isTriggeringEvent = false;
    state.didFirePressStart = true;
    setPressed(true);
    return shouldStopPropagation;
  });
  let triggerPressEnd = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a522)((originalEvent, pointerType, wasPressed = true) => {
    let state = ref.current;
    if (!state.didFirePressStart) return false;
    state.didFirePressStart = false;
    state.isTriggeringEvent = true;
    let shouldStopPropagation = true;
    if (onPressEnd) {
      let event = new $f6c31cce2adf654f$var$PressEvent("pressend", pointerType, originalEvent);
      onPressEnd(event);
      shouldStopPropagation = event.shouldStopPropagation;
    }
    if (onPressChange) onPressChange(false);
    setPressed(false);
    if (onPress && wasPressed && !isDisabled2) {
      let event = new $f6c31cce2adf654f$var$PressEvent("press", pointerType, originalEvent);
      onPress(event);
      shouldStopPropagation && (shouldStopPropagation = event.shouldStopPropagation);
    }
    state.isTriggeringEvent = false;
    return shouldStopPropagation;
  });
  let triggerPressUp = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a522)((originalEvent, pointerType) => {
    let state = ref.current;
    if (isDisabled2) return false;
    if (onPressUp) {
      state.isTriggeringEvent = true;
      let event = new $f6c31cce2adf654f$var$PressEvent("pressup", pointerType, originalEvent);
      onPressUp(event);
      state.isTriggeringEvent = false;
      return event.shouldStopPropagation;
    }
    return true;
  });
  let cancel = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a522)((e9) => {
    let state = ref.current;
    if (state.isPressed && state.target) {
      if (state.didFirePressStart && state.pointerType != null) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e9), state.pointerType, false);
      state.isPressed = false;
      state.isOverTarget = false;
      state.activePointerId = null;
      state.pointerType = null;
      removeAllGlobalListeners();
      if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);
      for (let dispose of state.disposables) dispose();
      state.disposables = [];
    }
  });
  let cancelOnPointerExit = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a522)((e9) => {
    if (shouldCancelOnPointerExit) cancel(e9);
  });
  let triggerClick = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a522)((e9) => {
    if (isDisabled2) return;
    onClick === null || onClick === void 0 ? void 0 : onClick(e9);
  });
  let triggerSyntheticClick = (0, $8ae05eaa5c114e9c$export$7f54fc3180508a522)((e9, target) => {
    if (isDisabled2) return;
    if (onClick) {
      let event = new MouseEvent("click", e9);
      (0, $8a9cb279dc87e130$export$c2b7abe5d61ec696)(event, target);
      onClick((0, $8a9cb279dc87e130$export$525bc4921d56d4a)(event));
    }
  });
  let pressProps = (0, import_react48.useMemo)(() => {
    let state = ref.current;
    let pressProps2 = {
      onKeyDown(e9) {
        if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e9.nativeEvent, e9.currentTarget) && (0, $d4ee10de306f2510$export$4282f70798064fe02)(e9.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9.nativeEvent))) {
          var _state_metaKeyEvents;
          if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard((0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9.nativeEvent), e9.key)) e9.preventDefault();
          let shouldStopPropagation = true;
          if (!state.isPressed && !e9.repeat) {
            state.target = e9.currentTarget;
            state.isPressed = true;
            state.pointerType = "keyboard";
            shouldStopPropagation = triggerPressStart(e9, "keyboard");
            let originalTarget = e9.currentTarget;
            let pressUp = (e10) => {
              if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e10, originalTarget) && !e10.repeat && (0, $d4ee10de306f2510$export$4282f70798064fe02)(originalTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e10)) && state.target) triggerPressUp($f6c31cce2adf654f$var$createEvent(state.target, e10), "keyboard");
            };
            addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac2)(e9.currentTarget), "keyup", (0, $ff5963eb1fccf552$export$e08e3b67e392101e2)(pressUp, onKeyUp), true);
          }
          if (shouldStopPropagation) e9.stopPropagation();
          if (e9.metaKey && (0, $c87311424ea30a05$export$9ac100e40613ea102)()) (_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.set(e9.key, e9.nativeEvent);
        } else if (e9.key === "Meta") state.metaKeyEvents = /* @__PURE__ */ new Map();
      },
      onClick(e9) {
        if (e9 && !(0, $d4ee10de306f2510$export$4282f70798064fe02)(e9.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9.nativeEvent))) return;
        if (e9 && e9.button === 0 && !state.isTriggeringEvent && !(0, $ea8dcbcb9ea1b556$export$95185d699e05d4d72).isOpening) {
          let shouldStopPropagation = true;
          if (isDisabled2) e9.preventDefault();
          if (!state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === "virtual" || (0, $6a7db85432448f7f$export$60278871457622de2)(e9.nativeEvent))) {
            let stopPressStart = triggerPressStart(e9, "virtual");
            let stopPressUp = triggerPressUp(e9, "virtual");
            let stopPressEnd = triggerPressEnd(e9, "virtual");
            triggerClick(e9);
            shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;
          } else if (state.isPressed && state.pointerType !== "keyboard") {
            let pointerType = state.pointerType || e9.nativeEvent.pointerType || "virtual";
            let stopPressUp = triggerPressUp($f6c31cce2adf654f$var$createEvent(e9.currentTarget, e9), pointerType);
            let stopPressEnd = triggerPressEnd($f6c31cce2adf654f$var$createEvent(e9.currentTarget, e9), pointerType, true);
            shouldStopPropagation = stopPressUp && stopPressEnd;
            state.isOverTarget = false;
            triggerClick(e9);
            cancel(e9);
          }
          state.ignoreEmulatedMouseEvents = false;
          if (shouldStopPropagation) e9.stopPropagation();
        }
      }
    };
    let onKeyUp = (e9) => {
      var _state_metaKeyEvents;
      if (state.isPressed && state.target && $f6c31cce2adf654f$var$isValidKeyboardEvent(e9, state.target)) {
        var _state_metaKeyEvents1;
        if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard((0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9), e9.key)) e9.preventDefault();
        let target = (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9);
        let wasPressed = (0, $d4ee10de306f2510$export$4282f70798064fe02)(state.target, (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9));
        triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e9), "keyboard", wasPressed);
        if (wasPressed) triggerSyntheticClick(e9, state.target);
        removeAllGlobalListeners();
        if (e9.key !== "Enter" && $f6c31cce2adf654f$var$isHTMLAnchorLink(state.target) && (0, $d4ee10de306f2510$export$4282f70798064fe02)(state.target, target) && !e9[$f6c31cce2adf654f$var$LINK_CLICKED]) {
          e9[$f6c31cce2adf654f$var$LINK_CLICKED] = true;
          (0, $ea8dcbcb9ea1b556$export$95185d699e05d4d72)(state.target, e9, false);
        }
        state.isPressed = false;
        (_state_metaKeyEvents1 = state.metaKeyEvents) === null || _state_metaKeyEvents1 === void 0 ? void 0 : _state_metaKeyEvents1.delete(e9.key);
      } else if (e9.key === "Meta" && ((_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.size)) {
        var _state_target;
        let events = state.metaKeyEvents;
        state.metaKeyEvents = void 0;
        for (let event of events.values()) (_state_target = state.target) === null || _state_target === void 0 ? void 0 : _state_target.dispatchEvent(new KeyboardEvent("keyup", event));
      }
    };
    if (typeof PointerEvent !== "undefined") {
      pressProps2.onPointerDown = (e9) => {
        if (e9.button !== 0 || !(0, $d4ee10de306f2510$export$4282f70798064fe02)(e9.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9.nativeEvent))) return;
        if ((0, $6a7db85432448f7f$export$29bf1b5f2c56cf632)(e9.nativeEvent)) {
          state.pointerType = "virtual";
          return;
        }
        state.pointerType = e9.pointerType;
        let shouldStopPropagation = true;
        if (!state.isPressed) {
          state.isPressed = true;
          state.isOverTarget = true;
          state.activePointerId = e9.pointerId;
          state.target = e9.currentTarget;
          if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$16a4697467175487)(state.target);
          shouldStopPropagation = triggerPressStart(e9, state.pointerType);
          let target = (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9.nativeEvent);
          if ("releasePointerCapture" in target) target.releasePointerCapture(e9.pointerId);
          addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac2)(e9.currentTarget), "pointerup", onPointerUp, false);
          addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac2)(e9.currentTarget), "pointercancel", onPointerCancel, false);
        }
        if (shouldStopPropagation) e9.stopPropagation();
      };
      pressProps2.onMouseDown = (e9) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe02)(e9.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9.nativeEvent))) return;
        if (e9.button === 0) {
          if (preventFocusOnPress) {
            let dispose = (0, $8a9cb279dc87e130$export$cabe61c495ee3649)(e9.target);
            if (dispose) state.disposables.push(dispose);
          }
          e9.stopPropagation();
        }
      };
      pressProps2.onPointerUp = (e9) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe02)(e9.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9.nativeEvent)) || state.pointerType === "virtual") return;
        if (e9.button === 0 && !state.isPressed) triggerPressUp(e9, state.pointerType || e9.pointerType);
      };
      pressProps2.onPointerEnter = (e9) => {
        if (e9.pointerId === state.activePointerId && state.target && !state.isOverTarget && state.pointerType != null) {
          state.isOverTarget = true;
          triggerPressStart($f6c31cce2adf654f$var$createEvent(state.target, e9), state.pointerType);
        }
      };
      pressProps2.onPointerLeave = (e9) => {
        if (e9.pointerId === state.activePointerId && state.target && state.isOverTarget && state.pointerType != null) {
          state.isOverTarget = false;
          triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e9), state.pointerType, false);
          cancelOnPointerExit(e9);
        }
      };
      let onPointerUp = (e9) => {
        if (e9.pointerId === state.activePointerId && state.isPressed && e9.button === 0 && state.target) {
          if ((0, $d4ee10de306f2510$export$4282f70798064fe02)(state.target, (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9)) && state.pointerType != null) {
            let clicked = false;
            let timeout = setTimeout(() => {
              if (state.isPressed && state.target instanceof HTMLElement) {
                if (clicked) cancel(e9);
                else {
                  (0, $7215afc6de606d6b$export$de79e2c695e052f32)(state.target);
                  state.target.click();
                }
              }
            }, 80);
            addGlobalListener(e9.currentTarget, "click", () => clicked = true, true);
            state.disposables.push(() => clearTimeout(timeout));
          } else cancel(e9);
          state.isOverTarget = false;
        }
      };
      let onPointerCancel = (e9) => {
        cancel(e9);
      };
      pressProps2.onDragStart = (e9) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe02)(e9.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9.nativeEvent))) return;
        cancel(e9);
      };
    } else if (false) {
      pressProps2.onMouseDown = (e9) => {
        if (e9.button !== 0 || !(0, $d4ee10de306f2510$export$4282f70798064fe02)(e9.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9.nativeEvent))) return;
        if (state.ignoreEmulatedMouseEvents) {
          e9.stopPropagation();
          return;
        }
        state.isPressed = true;
        state.isOverTarget = true;
        state.target = e9.currentTarget;
        state.pointerType = (0, $6a7db85432448f7f$export$60278871457622de2)(e9.nativeEvent) ? "virtual" : "mouse";
        let shouldStopPropagation = (0, import_react_dom3.flushSync)(() => triggerPressStart(e9, state.pointerType));
        if (shouldStopPropagation) e9.stopPropagation();
        if (preventFocusOnPress) {
          let dispose = (0, $8a9cb279dc87e130$export$cabe61c495ee3649)(e9.target);
          if (dispose) state.disposables.push(dispose);
        }
        addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac2)(e9.currentTarget), "mouseup", onMouseUp, false);
      };
      pressProps2.onMouseEnter = (e9) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe02)(e9.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9.nativeEvent))) return;
        let shouldStopPropagation = true;
        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {
          state.isOverTarget = true;
          shouldStopPropagation = triggerPressStart(e9, state.pointerType);
        }
        if (shouldStopPropagation) e9.stopPropagation();
      };
      pressProps2.onMouseLeave = (e9) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe02)(e9.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9.nativeEvent))) return;
        let shouldStopPropagation = true;
        if (state.isPressed && !state.ignoreEmulatedMouseEvents && state.pointerType != null) {
          state.isOverTarget = false;
          shouldStopPropagation = triggerPressEnd(e9, state.pointerType, false);
          cancelOnPointerExit(e9);
        }
        if (shouldStopPropagation) e9.stopPropagation();
      };
      pressProps2.onMouseUp = (e9) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe02)(e9.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9.nativeEvent))) return;
        if (!state.ignoreEmulatedMouseEvents && e9.button === 0 && !state.isPressed) triggerPressUp(e9, state.pointerType || "mouse");
      };
      let onMouseUp = (e9) => {
        if (e9.button !== 0) return;
        if (state.ignoreEmulatedMouseEvents) {
          state.ignoreEmulatedMouseEvents = false;
          return;
        }
        if (state.target && state.target.contains(e9.target) && state.pointerType != null) ;
        else cancel(e9);
        state.isOverTarget = false;
      };
      pressProps2.onTouchStart = (e9) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe02)(e9.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9.nativeEvent))) return;
        let touch = $f6c31cce2adf654f$var$getTouchFromEvent(e9.nativeEvent);
        if (!touch) return;
        state.activePointerId = touch.identifier;
        state.ignoreEmulatedMouseEvents = true;
        state.isOverTarget = true;
        state.isPressed = true;
        state.target = e9.currentTarget;
        state.pointerType = "touch";
        if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$16a4697467175487)(state.target);
        let shouldStopPropagation = triggerPressStart($f6c31cce2adf654f$var$createTouchEvent(state.target, e9), state.pointerType);
        if (shouldStopPropagation) e9.stopPropagation();
        addGlobalListener((0, $431fbd86ca7dc216$export$f21a1ffae260145a2)(e9.currentTarget), "scroll", onScroll, true);
      };
      pressProps2.onTouchMove = (e9) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe02)(e9.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9.nativeEvent))) return;
        if (!state.isPressed) {
          e9.stopPropagation();
          return;
        }
        let touch = $f6c31cce2adf654f$var$getTouchById(e9.nativeEvent, state.activePointerId);
        let shouldStopPropagation = true;
        if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e9.currentTarget)) {
          if (!state.isOverTarget && state.pointerType != null) {
            state.isOverTarget = true;
            shouldStopPropagation = triggerPressStart($f6c31cce2adf654f$var$createTouchEvent(state.target, e9), state.pointerType);
          }
        } else if (state.isOverTarget && state.pointerType != null) {
          state.isOverTarget = false;
          shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createTouchEvent(state.target, e9), state.pointerType, false);
          cancelOnPointerExit($f6c31cce2adf654f$var$createTouchEvent(state.target, e9));
        }
        if (shouldStopPropagation) e9.stopPropagation();
      };
      pressProps2.onTouchEnd = (e9) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe02)(e9.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9.nativeEvent))) return;
        if (!state.isPressed) {
          e9.stopPropagation();
          return;
        }
        let touch = $f6c31cce2adf654f$var$getTouchById(e9.nativeEvent, state.activePointerId);
        let shouldStopPropagation = true;
        if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e9.currentTarget) && state.pointerType != null) {
          triggerPressUp($f6c31cce2adf654f$var$createTouchEvent(state.target, e9), state.pointerType);
          shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createTouchEvent(state.target, e9), state.pointerType);
          triggerSyntheticClick(e9.nativeEvent, state.target);
        } else if (state.isOverTarget && state.pointerType != null) shouldStopPropagation = triggerPressEnd($f6c31cce2adf654f$var$createTouchEvent(state.target, e9), state.pointerType, false);
        if (shouldStopPropagation) e9.stopPropagation();
        state.isPressed = false;
        state.activePointerId = null;
        state.isOverTarget = false;
        state.ignoreEmulatedMouseEvents = true;
        if (state.target && !allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)(state.target);
        removeAllGlobalListeners();
      };
      pressProps2.onTouchCancel = (e9) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe02)(e9.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9.nativeEvent))) return;
        e9.stopPropagation();
        if (state.isPressed) cancel($f6c31cce2adf654f$var$createTouchEvent(state.target, e9));
      };
      let onScroll = (e9) => {
        if (state.isPressed && (0, $d4ee10de306f2510$export$4282f70798064fe02)((0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9), state.target)) cancel({
          currentTarget: state.target,
          shiftKey: false,
          ctrlKey: false,
          metaKey: false,
          altKey: false
        });
      };
      pressProps2.onDragStart = (e9) => {
        if (!(0, $d4ee10de306f2510$export$4282f70798064fe02)(e9.currentTarget, (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9.nativeEvent))) return;
        cancel(e9);
      };
    }
    return pressProps2;
  }, [
    addGlobalListener,
    isDisabled2,
    preventFocusOnPress,
    removeAllGlobalListeners,
    allowTextSelectionOnPress,
    cancel,
    cancelOnPointerExit,
    triggerPressEnd,
    triggerPressStart,
    triggerPressUp,
    triggerClick,
    triggerSyntheticClick
  ]);
  (0, import_react48.useEffect)(() => {
    if (!domRef || false) return;
    const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac2)(domRef.current);
    if (!ownerDocument || !ownerDocument.head || ownerDocument.getElementById($f6c31cce2adf654f$var$STYLE_ID)) return;
    const style2 = ownerDocument.createElement("style");
    style2.id = $f6c31cce2adf654f$var$STYLE_ID;
    style2.textContent = `
@layer {
  [${$f6c31cce2adf654f$var$PRESSABLE_ATTRIBUTE}] {
    touch-action: pan-x pan-y pinch-zoom;
  }
}
    `.trim();
    ownerDocument.head.prepend(style2);
  }, [
    domRef
  ]);
  (0, import_react48.useEffect)(() => {
    let state = ref.current;
    return () => {
      var _state_target;
      if (!allowTextSelectionOnPress) (0, $14c0b72509d70225$export$b0d6fa1ab32e3295)((_state_target = state.target) !== null && _state_target !== void 0 ? _state_target : void 0);
      for (let dispose of state.disposables) dispose();
      state.disposables = [];
    };
  }, [
    allowTextSelectionOnPress
  ]);
  return {
    isPressed: isPressedProp || isPressed,
    pressProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe9282)(domProps, pressProps, {
      [$f6c31cce2adf654f$var$PRESSABLE_ATTRIBUTE]: true
    })
  };
}
function $f6c31cce2adf654f$var$isHTMLAnchorLink(target) {
  return target.tagName === "A" && target.hasAttribute("href");
}
function $f6c31cce2adf654f$var$isValidKeyboardEvent(event, currentTarget) {
  const { key, code: code4 } = event;
  const element5 = currentTarget;
  const role = element5.getAttribute("role");
  return (key === "Enter" || key === " " || key === "Spacebar" || code4 === "Space") && !(element5 instanceof (0, $431fbd86ca7dc216$export$f21a1ffae260145a2)(element5).HTMLInputElement && !$f6c31cce2adf654f$var$isValidInputKey(element5, key) || element5 instanceof (0, $431fbd86ca7dc216$export$f21a1ffae260145a2)(element5).HTMLTextAreaElement || element5.isContentEditable) && // Links should only trigger with Enter key
  !((role === "link" || !role && $f6c31cce2adf654f$var$isHTMLAnchorLink(element5)) && key !== "Enter");
}
function $f6c31cce2adf654f$var$createEvent(target, e9) {
  let clientX = e9.clientX;
  let clientY = e9.clientY;
  return {
    currentTarget: target,
    shiftKey: e9.shiftKey,
    ctrlKey: e9.ctrlKey,
    metaKey: e9.metaKey,
    altKey: e9.altKey,
    clientX,
    clientY
  };
}
function $f6c31cce2adf654f$var$shouldPreventDefaultUp(target) {
  if (target instanceof HTMLInputElement) return false;
  if (target instanceof HTMLButtonElement) return target.type !== "submit" && target.type !== "reset";
  if ($f6c31cce2adf654f$var$isHTMLAnchorLink(target)) return false;
  return true;
}
function $f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(target, key) {
  if (target instanceof HTMLInputElement) return !$f6c31cce2adf654f$var$isValidInputKey(target, key);
  return $f6c31cce2adf654f$var$shouldPreventDefaultUp(target);
}
var $f6c31cce2adf654f$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $f6c31cce2adf654f$var$isValidInputKey(target, key) {
  return target.type === "checkbox" || target.type === "radio" ? key === " " : $f6c31cce2adf654f$var$nonTextInputTypes.has(target.type);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/dist/useFocusVisible.mjs
var import_react49 = __toESM(require_react(), 1);
var $507fabe10e71c6fb$var$currentModality = null;
var $507fabe10e71c6fb$var$changeHandlers = /* @__PURE__ */ new Set();
var $507fabe10e71c6fb$export$d90243b58daecda7 = /* @__PURE__ */ new Map();
var $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
var $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
var $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};
function $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e9) {
  for (let handler of $507fabe10e71c6fb$var$changeHandlers) handler(modality, e9);
}
function $507fabe10e71c6fb$var$isValidKey(e9) {
  return !(e9.metaKey || !(0, $c87311424ea30a05$export$9ac100e40613ea102)() && e9.altKey || e9.ctrlKey || e9.key === "Control" || e9.key === "Shift" || e9.key === "Meta");
}
function $507fabe10e71c6fb$var$handleKeyboardEvent(e9) {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
  if ($507fabe10e71c6fb$var$isValidKey(e9)) {
    $507fabe10e71c6fb$var$currentModality = "keyboard";
    $507fabe10e71c6fb$var$triggerChangeHandlers("keyboard", e9);
  }
}
function $507fabe10e71c6fb$var$handlePointerEvent(e9) {
  $507fabe10e71c6fb$var$currentModality = "pointer";
  if (e9.type === "mousedown" || e9.type === "pointerdown") {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    $507fabe10e71c6fb$var$triggerChangeHandlers("pointer", e9);
  }
}
function $507fabe10e71c6fb$var$handleClickEvent(e9) {
  if ((0, $6a7db85432448f7f$export$60278871457622de2)(e9)) {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    $507fabe10e71c6fb$var$currentModality = "virtual";
  }
}
function $507fabe10e71c6fb$var$handleFocusEvent(e9) {
  if (e9.target === window || e9.target === document || (0, $8a9cb279dc87e130$export$fda7da73ab5d4c48) || !e9.isTrusted) return;
  if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {
    $507fabe10e71c6fb$var$currentModality = "virtual";
    $507fabe10e71c6fb$var$triggerChangeHandlers("virtual", e9);
  }
  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
  $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
}
function $507fabe10e71c6fb$var$handleWindowBlur() {
  if (0, $8a9cb279dc87e130$export$fda7da73ab5d4c48) return;
  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
  $507fabe10e71c6fb$var$hasBlurredWindowRecently = true;
}
function $507fabe10e71c6fb$var$setupGlobalFocusEvents(element5) {
  if (typeof window === "undefined" || typeof document === "undefined" || $507fabe10e71c6fb$export$d90243b58daecda7.get((0, $431fbd86ca7dc216$export$f21a1ffae260145a2)(element5))) return;
  const windowObject = (0, $431fbd86ca7dc216$export$f21a1ffae260145a2)(element5);
  const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac2)(element5);
  let focus = windowObject.HTMLElement.prototype.focus;
  windowObject.HTMLElement.prototype.focus = function() {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    focus.apply(this, arguments);
  };
  documentObject.addEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.addEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.addEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, true);
  windowObject.addEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, true);
  windowObject.addEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, false);
  if (typeof PointerEvent !== "undefined") {
    documentObject.addEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  } else if (false) {
    documentObject.addEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  }
  windowObject.addEventListener("beforeunload", () => {
    $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element5);
  }, {
    once: true
  });
  $507fabe10e71c6fb$export$d90243b58daecda7.set(windowObject, {
    focus
  });
}
var $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (element5, loadListener) => {
  const windowObject = (0, $431fbd86ca7dc216$export$f21a1ffae260145a2)(element5);
  const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac2)(element5);
  if (loadListener) documentObject.removeEventListener("DOMContentLoaded", loadListener);
  if (!$507fabe10e71c6fb$export$d90243b58daecda7.has(windowObject)) return;
  windowObject.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(windowObject).focus;
  documentObject.removeEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.removeEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.removeEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, true);
  windowObject.removeEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, true);
  windowObject.removeEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, false);
  if (typeof PointerEvent !== "undefined") {
    documentObject.removeEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  } else if (false) {
    documentObject.removeEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  }
  $507fabe10e71c6fb$export$d90243b58daecda7.delete(windowObject);
};
function $507fabe10e71c6fb$export$2f1888112f558a7d(element5) {
  const documentObject = (0, $431fbd86ca7dc216$export$b204af158042fbac2)(element5);
  let loadListener;
  if (documentObject.readyState !== "loading") $507fabe10e71c6fb$var$setupGlobalFocusEvents(element5);
  else {
    loadListener = () => {
      $507fabe10e71c6fb$var$setupGlobalFocusEvents(element5);
    };
    documentObject.addEventListener("DOMContentLoaded", loadListener);
  }
  return () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element5, loadListener);
}
if (typeof document !== "undefined") $507fabe10e71c6fb$export$2f1888112f558a7d();
function $507fabe10e71c6fb$export$b9b3dfddab17db27() {
  return $507fabe10e71c6fb$var$currentModality !== "pointer";
}
function $507fabe10e71c6fb$export$630ff653c5ada6a9() {
  return $507fabe10e71c6fb$var$currentModality;
}
var $507fabe10e71c6fb$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e9) {
  let document1 = (0, $431fbd86ca7dc216$export$b204af158042fbac2)(e9 === null || e9 === void 0 ? void 0 : e9.target);
  const IHTMLInputElement = typeof window !== "undefined" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a2)(e9 === null || e9 === void 0 ? void 0 : e9.target).HTMLInputElement : HTMLInputElement;
  const IHTMLTextAreaElement = typeof window !== "undefined" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a2)(e9 === null || e9 === void 0 ? void 0 : e9.target).HTMLTextAreaElement : HTMLTextAreaElement;
  const IHTMLElement = typeof window !== "undefined" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a2)(e9 === null || e9 === void 0 ? void 0 : e9.target).HTMLElement : HTMLElement;
  const IKeyboardEvent = typeof window !== "undefined" ? (0, $431fbd86ca7dc216$export$f21a1ffae260145a2)(e9 === null || e9 === void 0 ? void 0 : e9.target).KeyboardEvent : KeyboardEvent;
  isTextInput = isTextInput || document1.activeElement instanceof IHTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(document1.activeElement.type) || document1.activeElement instanceof IHTMLTextAreaElement || document1.activeElement instanceof IHTMLElement && document1.activeElement.isContentEditable;
  return !(isTextInput && modality === "keyboard" && e9 instanceof IKeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e9.key]);
}
function $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn, deps, opts) {
  $507fabe10e71c6fb$var$setupGlobalFocusEvents();
  (0, import_react49.useEffect)(() => {
    let handler = (modality, e9) => {
      if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e9)) return;
      fn($507fabe10e71c6fb$export$b9b3dfddab17db27());
    };
    $507fabe10e71c6fb$var$changeHandlers.add(handler);
    return () => {
      $507fabe10e71c6fb$var$changeHandlers.delete(handler);
    };
  }, deps);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/dist/focusSafely.mjs
function $3ad3f6e1647bc98d$export$80f3e147d781571c(element5) {
  const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac2)(element5);
  const activeElement2 = (0, $d4ee10de306f2510$export$cd4e5573fbe2b5762)(ownerDocument);
  if ((0, $507fabe10e71c6fb$export$630ff653c5ada6a9)() === "virtual") {
    let lastFocusedElement = activeElement2;
    (0, $bbed8b41f857bcc0$export$24490316f764c4302)(() => {
      if ((0, $d4ee10de306f2510$export$cd4e5573fbe2b5762)(ownerDocument) === lastFocusedElement && element5.isConnected) (0, $7215afc6de606d6b$export$de79e2c695e052f32)(element5);
    });
  } else (0, $7215afc6de606d6b$export$de79e2c695e052f32)(element5);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/dist/useFocus.mjs
var import_react50 = __toESM(require_react(), 1);
function $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {
  let { isDisabled: isDisabled2, onFocus: onFocusProp, onBlur: onBlurProp, onFocusChange } = props;
  const onBlur = (0, import_react50.useCallback)((e9) => {
    if (e9.target === e9.currentTarget) {
      if (onBlurProp) onBlurProp(e9);
      if (onFocusChange) onFocusChange(false);
      return true;
    }
  }, [
    onBlurProp,
    onFocusChange
  ]);
  const onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);
  const onFocus = (0, import_react50.useCallback)((e9) => {
    const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac2)(e9.target);
    const activeElement2 = ownerDocument ? (0, $d4ee10de306f2510$export$cd4e5573fbe2b5762)(ownerDocument) : (0, $d4ee10de306f2510$export$cd4e5573fbe2b5762)();
    if (e9.target === e9.currentTarget && activeElement2 === (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9.nativeEvent)) {
      if (onFocusProp) onFocusProp(e9);
      if (onFocusChange) onFocusChange(true);
      onSyntheticFocus(e9);
    }
  }, [
    onFocusChange,
    onFocusProp,
    onSyntheticFocus
  ]);
  return {
    focusProps: {
      onFocus: !isDisabled2 && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : void 0,
      onBlur: !isDisabled2 && (onBlurProp || onFocusChange) ? onBlur : void 0
    }
  };
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/dist/createEventHandler.mjs
function $93925083ecbb358c$export$48d1ea6320830260(handler) {
  if (!handler) return void 0;
  let shouldStopPropagation = true;
  return (e9) => {
    let event = {
      ...e9,
      preventDefault() {
        e9.preventDefault();
      },
      isDefaultPrevented() {
        return e9.isDefaultPrevented();
      },
      stopPropagation() {
        if (shouldStopPropagation && true) console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.");
        else shouldStopPropagation = true;
      },
      continuePropagation() {
        shouldStopPropagation = false;
      },
      isPropagationStopped() {
        return shouldStopPropagation;
      }
    };
    handler(event);
    if (shouldStopPropagation) e9.stopPropagation();
  };
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/dist/useKeyboard.mjs
function $46d819fcbaf35654$export$8f71654801c2f7cd(props) {
  return {
    keyboardProps: props.isDisabled ? {} : {
      onKeyDown: (0, $93925083ecbb358c$export$48d1ea6320830260)(props.onKeyDown),
      onKeyUp: (0, $93925083ecbb358c$export$48d1ea6320830260)(props.onKeyUp)
    }
  };
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/dist/useFocusable.mjs
var import_react51 = __toESM(require_react(), 1);
var $f645667febf57a63$export$f9762fab77588ecb = (0, import_react51.default).createContext(null);
function $f645667febf57a63$var$useFocusableContext(ref) {
  let context = (0, import_react51.useContext)($f645667febf57a63$export$f9762fab77588ecb) || {};
  (0, $e7801be82b4b2a53$export$4debdb1a3f0fa79e2)(context, ref);
  let { ref: _10, ...otherProps } = context;
  return otherProps;
}
var $f645667febf57a63$export$13f3202a3e5ddd5 = (0, import_react51.default).forwardRef(function FocusableProvider(props, ref) {
  let { children, ...otherProps } = props;
  let objRef = (0, $df56164dff5785e2$export$4338b53315abf6662)(ref);
  let context = {
    ...otherProps,
    ref: objRef
  };
  return (0, import_react51.default).createElement($f645667febf57a63$export$f9762fab77588ecb.Provider, {
    value: context
  }, children);
});
function $f645667febf57a63$export$4c014de7c8940b4c(props, domRef) {
  let { focusProps } = (0, $a1ea59d68270f0dd$export$f8168d8dd8fd66e6)(props);
  let { keyboardProps } = (0, $46d819fcbaf35654$export$8f71654801c2f7cd)(props);
  let interactions = (0, $3ef42575df84b30b$export$9d1611c77c2fe9282)(focusProps, keyboardProps);
  let domProps = $f645667febf57a63$var$useFocusableContext(domRef);
  let interactionProps = props.isDisabled ? {} : domProps;
  let autoFocusRef = (0, import_react51.useRef)(props.autoFocus);
  (0, import_react51.useEffect)(() => {
    if (autoFocusRef.current && domRef.current) (0, $3ad3f6e1647bc98d$export$80f3e147d781571c)(domRef.current);
    autoFocusRef.current = false;
  }, [
    domRef
  ]);
  let tabIndex = props.excludeFromTabOrder ? -1 : 0;
  if (props.isDisabled) tabIndex = void 0;
  return {
    focusableProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe9282)({
      ...interactions,
      tabIndex
    }, interactionProps)
  };
}
var $f645667febf57a63$export$35a3bebf7ef2d934 = (0, import_react51.forwardRef)(({ children, ...props }, ref) => {
  ref = (0, $df56164dff5785e2$export$4338b53315abf6662)(ref);
  let { focusableProps } = $f645667febf57a63$export$4c014de7c8940b4c(props, ref);
  let child = (0, import_react51.default).Children.only(children);
  (0, import_react51.useEffect)(() => {
    if (false) return;
    let el = ref.current;
    if (!el || !(el instanceof (0, $431fbd86ca7dc216$export$f21a1ffae260145a2)(el).Element)) {
      console.error("<Focusable> child must forward its ref to a DOM element.");
      return;
    }
    if (!props.isDisabled && !(0, $b4b717babfbb907b$export$4c063cf1350e6fed2)(el)) {
      console.warn("<Focusable> child must be focusable. Please ensure the tabIndex prop is passed through.");
      return;
    }
    if (el.localName !== "button" && el.localName !== "input" && el.localName !== "select" && el.localName !== "textarea" && el.localName !== "a" && el.localName !== "area" && el.localName !== "summary" && el.localName !== "img" && el.localName !== "svg") {
      let role = el.getAttribute("role");
      if (!role) console.warn("<Focusable> child must have an interactive ARIA role.");
      else if (
        // https://w3c.github.io/aria/#widget_roles
        role !== "application" && role !== "button" && role !== "checkbox" && role !== "combobox" && role !== "gridcell" && role !== "link" && role !== "menuitem" && role !== "menuitemcheckbox" && role !== "menuitemradio" && role !== "option" && role !== "radio" && role !== "searchbox" && role !== "separator" && role !== "slider" && role !== "spinbutton" && role !== "switch" && role !== "tab" && role !== "tabpanel" && role !== "textbox" && role !== "treeitem" && // aria-describedby is also announced on these roles
        role !== "img" && role !== "meter" && role !== "progressbar"
      ) console.warn(`<Focusable> child must have an interactive ARIA role. Got "${role}".`);
    }
  }, [
    ref,
    props.isDisabled
  ]);
  let childRef = parseInt((0, import_react51.default).version, 10) < 19 ? child.ref : child.props.ref;
  return (0, import_react51.default).cloneElement(child, {
    ...(0, $3ef42575df84b30b$export$9d1611c77c2fe9282)(focusableProps, child.props),
    // @ts-ignore
    ref: (0, $5dc95899b306f630$export$c9058316764c140e2)(childRef, ref)
  });
});

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/dist/Pressable.mjs
var import_react52 = __toESM(require_react(), 1);
var $3b117e43dc0ca95d$export$27c701ed9e449e99 = (0, import_react52.default).forwardRef(({ children, ...props }, ref) => {
  ref = (0, $df56164dff5785e2$export$4338b53315abf6662)(ref);
  let { pressProps } = (0, $f6c31cce2adf654f$export$45712eceda6fad21)({
    ...props,
    ref
  });
  let { focusableProps } = (0, $f645667febf57a63$export$4c014de7c8940b4c)(props, ref);
  let child = (0, import_react52.default).Children.only(children);
  (0, import_react52.useEffect)(() => {
    if (false) return;
    let el = ref.current;
    if (!el || !(el instanceof (0, $431fbd86ca7dc216$export$f21a1ffae260145a2)(el).Element)) {
      console.error("<Pressable> child must forward its ref to a DOM element.");
      return;
    }
    if (!props.isDisabled && !(0, $b4b717babfbb907b$export$4c063cf1350e6fed2)(el)) {
      console.warn("<Pressable> child must be focusable. Please ensure the tabIndex prop is passed through.");
      return;
    }
    if (el.localName !== "button" && el.localName !== "input" && el.localName !== "select" && el.localName !== "textarea" && el.localName !== "a" && el.localName !== "area" && el.localName !== "summary") {
      let role = el.getAttribute("role");
      if (!role) console.warn("<Pressable> child must have an interactive ARIA role.");
      else if (
        // https://w3c.github.io/aria/#widget_roles
        role !== "application" && role !== "button" && role !== "checkbox" && role !== "combobox" && role !== "gridcell" && role !== "link" && role !== "menuitem" && role !== "menuitemcheckbox" && role !== "menuitemradio" && role !== "option" && role !== "radio" && role !== "searchbox" && role !== "separator" && role !== "slider" && role !== "spinbutton" && role !== "switch" && role !== "tab" && role !== "textbox" && role !== "treeitem"
      ) console.warn(`<Pressable> child must have an interactive ARIA role. Got "${role}".`);
    }
  }, [
    ref,
    props.isDisabled
  ]);
  let childRef = parseInt((0, import_react52.default).version, 10) < 19 ? child.ref : child.props.ref;
  return (0, import_react52.default).cloneElement(child, {
    ...(0, $3ef42575df84b30b$export$9d1611c77c2fe9282)(pressProps, focusableProps, child.props),
    // @ts-ignore
    ref: (0, $5dc95899b306f630$export$c9058316764c140e2)(childRef, ref)
  });
});

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/dist/PressResponder.mjs
var import_react53 = __toESM(require_react(), 1);
var $f1ab8c75478c6f73$export$3351871ee4b288b8 = (0, import_react53.default).forwardRef(({ children, ...props }, ref) => {
  let isRegistered = (0, import_react53.useRef)(false);
  let prevContext = (0, import_react53.useContext)((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5));
  ref = (0, $df56164dff5785e2$export$4338b53315abf6662)(ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref));
  let context = (0, $3ef42575df84b30b$export$9d1611c77c2fe9282)(prevContext || {}, {
    ...props,
    ref,
    register() {
      isRegistered.current = true;
      if (prevContext) prevContext.register();
    }
  });
  (0, $e7801be82b4b2a53$export$4debdb1a3f0fa79e2)(prevContext, ref);
  (0, import_react53.useEffect)(() => {
    if (!isRegistered.current) {
      if (true) console.warn("A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.");
      isRegistered.current = true;
    }
  }, []);
  return (0, import_react53.default).createElement((0, $ae1eeba8b9eafd08$export$5165eccb35aaadb5).Provider, {
    value: context
  }, children);
});

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/dist/useFocusWithin.mjs
var import_react54 = __toESM(require_react(), 1);
function $9ab94262bd0047c7$export$420e68273165f4ec(props) {
  let { isDisabled: isDisabled2, onBlurWithin, onFocusWithin, onFocusWithinChange } = props;
  let state = (0, import_react54.useRef)({
    isFocusWithin: false
  });
  let { addGlobalListener, removeAllGlobalListeners } = (0, $03deb23ff14920c4$export$4eaf04e54aa8eed62)();
  let onBlur = (0, import_react54.useCallback)((e9) => {
    if (!e9.currentTarget.contains(e9.target)) return;
    if (state.current.isFocusWithin && !e9.currentTarget.contains(e9.relatedTarget)) {
      state.current.isFocusWithin = false;
      removeAllGlobalListeners();
      if (onBlurWithin) onBlurWithin(e9);
      if (onFocusWithinChange) onFocusWithinChange(false);
    }
  }, [
    onBlurWithin,
    onFocusWithinChange,
    state,
    removeAllGlobalListeners
  ]);
  let onSyntheticFocus = (0, $8a9cb279dc87e130$export$715c682d09d639cc)(onBlur);
  let onFocus = (0, import_react54.useCallback)((e9) => {
    if (!e9.currentTarget.contains(e9.target)) return;
    const ownerDocument = (0, $431fbd86ca7dc216$export$b204af158042fbac2)(e9.target);
    const activeElement2 = (0, $d4ee10de306f2510$export$cd4e5573fbe2b5762)(ownerDocument);
    if (!state.current.isFocusWithin && activeElement2 === (0, $d4ee10de306f2510$export$e58f029f0fbfdb292)(e9.nativeEvent)) {
      if (onFocusWithin) onFocusWithin(e9);
      if (onFocusWithinChange) onFocusWithinChange(true);
      state.current.isFocusWithin = true;
      onSyntheticFocus(e9);
      let currentTarget = e9.currentTarget;
      addGlobalListener(ownerDocument, "focus", (e10) => {
        if (state.current.isFocusWithin && !(0, $d4ee10de306f2510$export$4282f70798064fe02)(currentTarget, e10.target)) {
          let nativeEvent = new ownerDocument.defaultView.FocusEvent("blur", {
            relatedTarget: e10.target
          });
          (0, $8a9cb279dc87e130$export$c2b7abe5d61ec696)(nativeEvent, currentTarget);
          let event = (0, $8a9cb279dc87e130$export$525bc4921d56d4a)(nativeEvent);
          onBlur(event);
        }
      }, {
        capture: true
      });
    }
  }, [
    onFocusWithin,
    onFocusWithinChange,
    onSyntheticFocus,
    addGlobalListener,
    onBlur
  ]);
  if (isDisabled2) return {
    focusWithinProps: {
      // These cannot be null, that would conflict in mergeProps
      onFocus: void 0,
      onBlur: void 0
    }
  };
  return {
    focusWithinProps: {
      onFocus,
      onBlur
    }
  };
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/dist/useHover.mjs
var import_react55 = __toESM(require_react(), 1);
var $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
var $6179b936705e76d3$var$hoverCount = 0;
function $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {
  $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = true;
  setTimeout(() => {
    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
  }, 50);
}
function $6179b936705e76d3$var$handleGlobalPointerEvent(e9) {
  if (e9.pointerType === "touch") $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $6179b936705e76d3$var$setupGlobalTouchEvents() {
  if (typeof document === "undefined") return;
  if ($6179b936705e76d3$var$hoverCount === 0) {
    if (typeof PointerEvent !== "undefined") document.addEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
    else if (false) document.addEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);
  }
  $6179b936705e76d3$var$hoverCount++;
  return () => {
    $6179b936705e76d3$var$hoverCount--;
    if ($6179b936705e76d3$var$hoverCount > 0) return;
    if (typeof PointerEvent !== "undefined") document.removeEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
    else if (false) document.removeEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);
  };
}
function $6179b936705e76d3$export$ae780daf29e6d456(props) {
  let { onHoverStart, onHoverChange, onHoverEnd, isDisabled: isDisabled2 } = props;
  let [isHovered, setHovered] = (0, import_react55.useState)(false);
  let state = (0, import_react55.useRef)({
    isHovered: false,
    ignoreEmulatedMouseEvents: false,
    pointerType: "",
    target: null
  }).current;
  (0, import_react55.useEffect)($6179b936705e76d3$var$setupGlobalTouchEvents, []);
  let { addGlobalListener, removeAllGlobalListeners } = (0, $03deb23ff14920c4$export$4eaf04e54aa8eed62)();
  let { hoverProps, triggerHoverEnd } = (0, import_react55.useMemo)(() => {
    let triggerHoverStart = (event, pointerType) => {
      state.pointerType = pointerType;
      if (isDisabled2 || pointerType === "touch" || state.isHovered || !event.currentTarget.contains(event.target)) return;
      state.isHovered = true;
      let target = event.currentTarget;
      state.target = target;
      addGlobalListener((0, $431fbd86ca7dc216$export$b204af158042fbac2)(event.target), "pointerover", (e9) => {
        if (state.isHovered && state.target && !(0, $d4ee10de306f2510$export$4282f70798064fe02)(state.target, e9.target)) triggerHoverEnd2(e9, e9.pointerType);
      }, {
        capture: true
      });
      if (onHoverStart) onHoverStart({
        type: "hoverstart",
        target,
        pointerType
      });
      if (onHoverChange) onHoverChange(true);
      setHovered(true);
    };
    let triggerHoverEnd2 = (event, pointerType) => {
      let target = state.target;
      state.pointerType = "";
      state.target = null;
      if (pointerType === "touch" || !state.isHovered || !target) return;
      state.isHovered = false;
      removeAllGlobalListeners();
      if (onHoverEnd) onHoverEnd({
        type: "hoverend",
        target,
        pointerType
      });
      if (onHoverChange) onHoverChange(false);
      setHovered(false);
    };
    let hoverProps2 = {};
    if (typeof PointerEvent !== "undefined") {
      hoverProps2.onPointerEnter = (e9) => {
        if ($6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e9.pointerType === "mouse") return;
        triggerHoverStart(e9, e9.pointerType);
      };
      hoverProps2.onPointerLeave = (e9) => {
        if (!isDisabled2 && e9.currentTarget.contains(e9.target)) triggerHoverEnd2(e9, e9.pointerType);
      };
    } else if (false) {
      hoverProps2.onTouchStart = () => {
        state.ignoreEmulatedMouseEvents = true;
      };
      hoverProps2.onMouseEnter = (e9) => {
        if (!state.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e9, "mouse");
        state.ignoreEmulatedMouseEvents = false;
      };
      hoverProps2.onMouseLeave = (e9) => {
        if (!isDisabled2 && e9.currentTarget.contains(e9.target)) triggerHoverEnd2(e9, "mouse");
      };
    }
    return {
      hoverProps: hoverProps2,
      triggerHoverEnd: triggerHoverEnd2
    };
  }, [
    onHoverStart,
    onHoverChange,
    onHoverEnd,
    isDisabled2,
    state,
    addGlobalListener,
    removeAllGlobalListeners
  ]);
  (0, import_react55.useEffect)(() => {
    if (isDisabled2) triggerHoverEnd({
      currentTarget: state.target
    }, state.pointerType);
  }, [
    isDisabled2
  ]);
  return {
    hoverProps,
    isHovered
  };
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/dist/useInteractOutside.mjs
var import_react56 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/dist/useMove.mjs
var import_react57 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/dist/useScrollWheel.mjs
var import_react58 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/interactions/dist/useLongPress.mjs
var import_react59 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/dist/FocusScope.mjs
var import_react60 = __toESM(require_react(), 1);
var $9bf71ea28793e738$var$FocusContext = (0, import_react60.default).createContext(null);
function $9bf71ea28793e738$var$isElementInScope(element5, scope) {
  if (!element5) return false;
  if (!scope) return false;
  return scope.some((node2) => node2.contains(element5));
}
var $9bf71ea28793e738$var$Tree = class _$9bf71ea28793e738$var$Tree {
  get size() {
    return this.fastMap.size;
  }
  getTreeNode(data) {
    return this.fastMap.get(data);
  }
  addTreeNode(scopeRef, parent, nodeToRestore) {
    let parentNode = this.fastMap.get(parent !== null && parent !== void 0 ? parent : null);
    if (!parentNode) return;
    let node2 = new $9bf71ea28793e738$var$TreeNode({
      scopeRef
    });
    parentNode.addChild(node2);
    node2.parent = parentNode;
    this.fastMap.set(scopeRef, node2);
    if (nodeToRestore) node2.nodeToRestore = nodeToRestore;
  }
  addNode(node2) {
    this.fastMap.set(node2.scopeRef, node2);
  }
  removeTreeNode(scopeRef) {
    if (scopeRef === null) return;
    let node2 = this.fastMap.get(scopeRef);
    if (!node2) return;
    let parentNode = node2.parent;
    for (let current of this.traverse()) if (current !== node2 && node2.nodeToRestore && current.nodeToRestore && node2.scopeRef && node2.scopeRef.current && $9bf71ea28793e738$var$isElementInScope(current.nodeToRestore, node2.scopeRef.current)) current.nodeToRestore = node2.nodeToRestore;
    let children = node2.children;
    if (parentNode) {
      parentNode.removeChild(node2);
      if (children.size > 0) children.forEach((child) => parentNode && parentNode.addChild(child));
    }
    this.fastMap.delete(node2.scopeRef);
  }
  // Pre Order Depth First
  *traverse(node2 = this.root) {
    if (node2.scopeRef != null) yield node2;
    if (node2.children.size > 0) for (let child of node2.children) yield* this.traverse(child);
  }
  clone() {
    var _node_parent;
    let newTree = new _$9bf71ea28793e738$var$Tree();
    var _node_parent_scopeRef;
    for (let node2 of this.traverse()) newTree.addTreeNode(node2.scopeRef, (_node_parent_scopeRef = (_node_parent = node2.parent) === null || _node_parent === void 0 ? void 0 : _node_parent.scopeRef) !== null && _node_parent_scopeRef !== void 0 ? _node_parent_scopeRef : null, node2.nodeToRestore);
    return newTree;
  }
  constructor() {
    this.fastMap = /* @__PURE__ */ new Map();
    this.root = new $9bf71ea28793e738$var$TreeNode({
      scopeRef: null
    });
    this.fastMap.set(null, this.root);
  }
};
var $9bf71ea28793e738$var$TreeNode = class {
  addChild(node2) {
    this.children.add(node2);
    node2.parent = this;
  }
  removeChild(node2) {
    this.children.delete(node2);
    node2.parent = void 0;
  }
  constructor(props) {
    this.children = /* @__PURE__ */ new Set();
    this.contain = false;
    this.scopeRef = props.scopeRef;
  }
};
var $9bf71ea28793e738$export$d06fae2ee68b101e = new $9bf71ea28793e738$var$Tree();

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/dist/useFocusRing.mjs
var import_react61 = __toESM(require_react(), 1);
function $f7dceffc5ad7768b$export$4e328f61c538687f(props = {}) {
  let { autoFocus = false, isTextInput, within } = props;
  let state = (0, import_react61.useRef)({
    isFocused: false,
    isFocusVisible: autoFocus || (0, $507fabe10e71c6fb$export$b9b3dfddab17db27)()
  });
  let [isFocused, setFocused] = (0, import_react61.useState)(false);
  let [isFocusVisibleState, setFocusVisible] = (0, import_react61.useState)(() => state.current.isFocused && state.current.isFocusVisible);
  let updateState = (0, import_react61.useCallback)(() => setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);
  let onFocusChange = (0, import_react61.useCallback)((isFocused2) => {
    state.current.isFocused = isFocused2;
    setFocused(isFocused2);
    updateState();
  }, [
    updateState
  ]);
  (0, $507fabe10e71c6fb$export$ec71b4b83ac08ec3)((isFocusVisible) => {
    state.current.isFocusVisible = isFocusVisible;
    updateState();
  }, [], {
    isTextInput
  });
  let { focusProps } = (0, $a1ea59d68270f0dd$export$f8168d8dd8fd66e6)({
    isDisabled: within,
    onFocusChange
  });
  let { focusWithinProps } = (0, $9ab94262bd0047c7$export$420e68273165f4ec)({
    isDisabled: !within,
    onFocusWithinChange: onFocusChange
  });
  return {
    isFocused,
    isFocusVisible: isFocusVisibleState,
    focusProps: within ? focusWithinProps : focusProps
  };
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/dist/FocusRing.mjs
var import_react62 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@react-aria/focus/dist/useHasTabbableChild.mjs
var import_react63 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-active-press.js
var import_react68 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/env.js
var i = Object.defineProperty;
var d = (t14, e9, n17) => e9 in t14 ? i(t14, e9, { enumerable: true, configurable: true, writable: true, value: n17 }) : t14[e9] = n17;
var r2 = (t14, e9, n17) => (d(t14, typeof e9 != "symbol" ? e9 + "" : e9, n17), n17);
var o = class {
  constructor() {
    r2(this, "current", this.detect());
    r2(this, "handoffState", "pending");
    r2(this, "currentId", 0);
  }
  set(e9) {
    this.current !== e9 && (this.handoffState = "pending", this.currentId = 0, this.current = e9);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window == "undefined" || typeof document == "undefined" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
};
var s = new o();

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/owner.js
function l(n17) {
  var u25;
  return s.isServer ? null : n17 == null ? document : (u25 = n17 == null ? void 0 : n17.ownerDocument) != null ? u25 : document;
}
function r3(n17) {
  var u25, o20;
  return s.isServer ? null : n17 == null ? document : (o20 = (u25 = n17 == null ? void 0 : n17.getRootNode) == null ? void 0 : u25.call(n17)) != null ? o20 : document;
}
function e(n17) {
  var u25, o20;
  return (o20 = (u25 = r3(n17)) == null ? void 0 : u25.activeElement) != null ? o20 : null;
}
function d2(n17) {
  return e(n17) === n17;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-disposables.js
var import_react64 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/micro-task.js
function t(e9) {
  typeof queueMicrotask == "function" ? queueMicrotask(e9) : Promise.resolve().then(e9).catch((o20) => setTimeout(() => {
    throw o20;
  }));
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/disposables.js
function o2() {
  let s21 = [], r22 = { addEventListener(e9, t14, n17, i16) {
    return e9.addEventListener(t14, n17, i16), r22.add(() => e9.removeEventListener(t14, n17, i16));
  }, requestAnimationFrame(...e9) {
    let t14 = requestAnimationFrame(...e9);
    return r22.add(() => cancelAnimationFrame(t14));
  }, nextFrame(...e9) {
    return r22.requestAnimationFrame(() => r22.requestAnimationFrame(...e9));
  }, setTimeout(...e9) {
    let t14 = setTimeout(...e9);
    return r22.add(() => clearTimeout(t14));
  }, microTask(...e9) {
    let t14 = { current: true };
    return t(() => {
      t14.current && e9[0]();
    }), r22.add(() => {
      t14.current = false;
    });
  }, style(e9, t14, n17) {
    let i16 = e9.style.getPropertyValue(t14);
    return Object.assign(e9.style, { [t14]: n17 }), this.add(() => {
      Object.assign(e9.style, { [t14]: i16 });
    });
  }, group(e9) {
    let t14 = o2();
    return e9(t14), this.add(() => t14.dispose());
  }, add(e9) {
    return s21.includes(e9) || s21.push(e9), () => {
      let t14 = s21.indexOf(e9);
      if (t14 >= 0) for (let n17 of s21.splice(t14, 1)) n17();
    };
  }, dispose() {
    for (let e9 of s21.splice(0)) e9();
  } };
  return r22;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-disposables.js
function p() {
  let [e9] = (0, import_react64.useState)(o2);
  return (0, import_react64.useEffect)(() => () => e9.dispose(), [e9]), e9;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-event.js
var import_react67 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-latest-value.js
var import_react66 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js
var import_react65 = __toESM(require_react(), 1);
var n = (e9, t14) => {
  s.isServer ? (0, import_react65.useEffect)(e9, t14) : (0, import_react65.useLayoutEffect)(e9, t14);
};

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-latest-value.js
function s3(e9) {
  let r22 = (0, import_react66.useRef)(e9);
  return n(() => {
    r22.current = e9;
  }, [e9]), r22;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-event.js
var o4 = function(t14) {
  let e9 = s3(t14);
  return import_react67.default.useCallback((...r22) => e9.current(...r22), [e9]);
};

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-active-press.js
function E(e9) {
  let t14 = e9.width / 2, n17 = e9.height / 2;
  return { top: e9.clientY - n17, right: e9.clientX + t14, bottom: e9.clientY + n17, left: e9.clientX - t14 };
}
function P(e9, t14) {
  return !(!e9 || !t14 || e9.right < t14.left || e9.left > t14.right || e9.bottom < t14.top || e9.top > t14.bottom);
}
function w({ disabled: e9 = false } = {}) {
  let t14 = (0, import_react68.useRef)(null), [n17, l19] = (0, import_react68.useState)(false), r22 = p(), o20 = o4(() => {
    t14.current = null, l19(false), r22.dispose();
  }), f21 = o4((s21) => {
    if (r22.dispose(), t14.current === null) {
      t14.current = s21.currentTarget, l19(true);
      {
        let i16 = l(s21.currentTarget);
        r22.addEventListener(i16, "pointerup", o20, false), r22.addEventListener(i16, "pointermove", (c21) => {
          if (t14.current) {
            let p13 = E(c21);
            l19(P(p13, t14.current.getBoundingClientRect()));
          }
        }, false), r22.addEventListener(i16, "pointercancel", o20, false);
      }
    }
  });
  return { pressed: n17, pressProps: e9 ? {} : { onPointerDown: f21, onPointerUp: o20, onClick: o20 } };
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-slot.js
var import_react69 = __toESM(require_react(), 1);
function n2(e9) {
  return (0, import_react69.useMemo)(() => e9, Object.values(e9));
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/internal/disabled.js
var import_react70 = __toESM(require_react(), 1);
var e2 = (0, import_react70.createContext)(void 0);
function a3() {
  return (0, import_react70.useContext)(e2);
}
function l2({ value: t14, children: o20 }) {
  return import_react70.default.createElement(e2.Provider, { value: t14 }, o20);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/render.js
var import_react71 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/class-names.js
function t4(...r22) {
  return Array.from(new Set(r22.flatMap((n17) => typeof n17 == "string" ? n17.split(" ") : []))).filter(Boolean).join(" ");
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/match.js
function u(r22, n17, ...a28) {
  if (r22 in n17) {
    let e9 = n17[r22];
    return typeof e9 == "function" ? e9(...a28) : e9;
  }
  let t14 = new Error(`Tried to handle "${r22}" but there is no handler defined. Only defined handlers are: ${Object.keys(n17).map((e9) => `"${e9}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(t14, u), t14;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/render.js
var A = ((a28) => (a28[a28.None = 0] = "None", a28[a28.RenderStrategy = 1] = "RenderStrategy", a28[a28.Static = 2] = "Static", a28))(A || {});
var C = ((e9) => (e9[e9.Unmount = 0] = "Unmount", e9[e9.Hidden = 1] = "Hidden", e9))(C || {});
function K() {
  let n17 = $();
  return (0, import_react71.useCallback)((r22) => U({ mergeRefs: n17, ...r22 }), [n17]);
}
function U({ ourProps: n17, theirProps: r22, slot: e9, defaultTag: a28, features: s21, visible: t14 = true, name: l19, mergeRefs: i16 }) {
  i16 = i16 != null ? i16 : I;
  let o20 = P2(r22, n17);
  if (t14) return F(o20, e9, a28, l19, i16);
  let y10 = s21 != null ? s21 : 0;
  if (y10 & 2) {
    let { static: f21 = false, ...u25 } = o20;
    if (f21) return F(u25, e9, a28, l19, i16);
  }
  if (y10 & 1) {
    let { unmount: f21 = true, ...u25 } = o20;
    return u(f21 ? 0 : 1, { [0]() {
      return null;
    }, [1]() {
      return F({ ...u25, hidden: true, style: { display: "none" } }, e9, a28, l19, i16);
    } });
  }
  return F(o20, e9, a28, l19, i16);
}
function F(n17, r22 = {}, e9, a28, s21) {
  let { as: t14 = e9, children: l19, refName: i16 = "ref", ...o20 } = h(n17, ["unmount", "static"]), y10 = n17.ref !== void 0 ? { [i16]: n17.ref } : {}, f21 = typeof l19 == "function" ? l19(r22) : l19;
  "className" in o20 && o20.className && typeof o20.className == "function" && (o20.className = o20.className(r22)), o20["aria-labelledby"] && o20["aria-labelledby"] === o20.id && (o20["aria-labelledby"] = void 0);
  let u25 = {};
  if (r22) {
    let d14 = false, p13 = [];
    for (let [c21, T11] of Object.entries(r22)) typeof T11 == "boolean" && (d14 = true), T11 === true && p13.push(c21.replace(/([A-Z])/g, (g6) => `-${g6.toLowerCase()}`));
    if (d14) {
      u25["data-headlessui-state"] = p13.join(" ");
      for (let c21 of p13) u25[`data-${c21}`] = "";
    }
  }
  if (b(t14) && (Object.keys(m2(o20)).length > 0 || Object.keys(m2(u25)).length > 0)) if (!(0, import_react71.isValidElement)(f21) || Array.isArray(f21) && f21.length > 1 || D(f21)) {
    if (Object.keys(m2(o20)).length > 0) throw new Error(['Passing props on "Fragment"!', "", `The current component <${a28} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(m2(o20)).concat(Object.keys(m2(u25))).map((d14) => `  - ${d14}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((d14) => `  - ${d14}`).join(`
`)].join(`
`));
  } else {
    let d14 = f21.props, p13 = d14 == null ? void 0 : d14.className, c21 = typeof p13 == "function" ? (...R7) => t4(p13(...R7), o20.className) : t4(p13, o20.className), T11 = c21 ? { className: c21 } : {}, g6 = P2(f21.props, m2(h(o20, ["ref"])));
    for (let R7 in u25) R7 in g6 && delete u25[R7];
    return (0, import_react71.cloneElement)(f21, Object.assign({}, g6, u25, y10, { ref: s21(H(f21), y10.ref) }, T11));
  }
  return (0, import_react71.createElement)(t14, Object.assign({}, h(o20, ["ref"]), !b(t14) && y10, !b(t14) && u25), f21);
}
function $() {
  let n17 = (0, import_react71.useRef)([]), r22 = (0, import_react71.useCallback)((e9) => {
    for (let a28 of n17.current) a28 != null && (typeof a28 == "function" ? a28(e9) : a28.current = e9);
  }, []);
  return (...e9) => {
    if (!e9.every((a28) => a28 == null)) return n17.current = e9, r22;
  };
}
function I(...n17) {
  return n17.every((r22) => r22 == null) ? void 0 : (r22) => {
    for (let e9 of n17) e9 != null && (typeof e9 == "function" ? e9(r22) : e9.current = r22);
  };
}
function P2(...n17) {
  var a28;
  if (n17.length === 0) return {};
  if (n17.length === 1) return n17[0];
  let r22 = {}, e9 = {};
  for (let s21 of n17) for (let t14 in s21) t14.startsWith("on") && typeof s21[t14] == "function" ? ((a28 = e9[t14]) != null || (e9[t14] = []), e9[t14].push(s21[t14])) : r22[t14] = s21[t14];
  if (r22.disabled || r22["aria-disabled"]) for (let s21 in e9) /^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(s21) && (e9[s21] = [(t14) => {
    var l19;
    return (l19 = t14 == null ? void 0 : t14.preventDefault) == null ? void 0 : l19.call(t14);
  }]);
  for (let s21 in e9) Object.assign(r22, { [s21](t14, ...l19) {
    let i16 = e9[s21];
    for (let o20 of i16) {
      if ((t14 instanceof Event || (t14 == null ? void 0 : t14.nativeEvent) instanceof Event) && t14.defaultPrevented) return;
      o20(t14, ...l19);
    }
  } });
  return r22;
}
function V(...n17) {
  var a28;
  if (n17.length === 0) return {};
  if (n17.length === 1) return n17[0];
  let r22 = {}, e9 = {};
  for (let s21 of n17) for (let t14 in s21) t14.startsWith("on") && typeof s21[t14] == "function" ? ((a28 = e9[t14]) != null || (e9[t14] = []), e9[t14].push(s21[t14])) : r22[t14] = s21[t14];
  for (let s21 in e9) Object.assign(r22, { [s21](...t14) {
    let l19 = e9[s21];
    for (let i16 of l19) i16 == null || i16(...t14);
  } });
  return r22;
}
function Y(n17) {
  var r22;
  return Object.assign((0, import_react71.forwardRef)(n17), { displayName: (r22 = n17.displayName) != null ? r22 : n17.name });
}
function m2(n17) {
  let r22 = Object.assign({}, n17);
  for (let e9 in r22) r22[e9] === void 0 && delete r22[e9];
  return r22;
}
function h(n17, r22 = []) {
  let e9 = Object.assign({}, n17);
  for (let a28 of r22) a28 in e9 && delete e9[a28];
  return e9;
}
function H(n17) {
  return import_react71.default.version.split(".")[0] >= "19" ? n17.props.ref : n17.ref;
}
function b(n17) {
  return n17 === import_react71.Fragment || n17 === Symbol.for("react.fragment");
}
function D(n17) {
  return b(n17.type);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/button/button.js
var R = "button";
function v2(s21, n17) {
  var r22;
  let p13 = a3(), { disabled: e9 = p13 || false, autoFocus: t14 = false, ...o20 } = s21, { isFocusVisible: a28, focusProps: l19 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: t14 }), { isHovered: u25, hoverProps: i16 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e9 }), { pressed: T11, pressProps: d14 } = w({ disabled: e9 }), f21 = V({ ref: n17, type: (r22 = o20.type) != null ? r22 : "button", disabled: e9 || void 0, autoFocus: t14 }, l19, i16, d14), m10 = n2({ disabled: e9, hover: u25, focus: a28, active: T11, autofocus: t14 });
  return K()({ ourProps: f21, theirProps: o20, slot: m10, defaultTag: R, name: "Button" });
}
var L = Y(v2);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/checkbox/checkbox.js
var import_react81 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-controllable.js
var import_react72 = __toESM(require_react(), 1);
var import_react_dom4 = __toESM(require_react_dom(), 1);
function b2(l19, r22, c21) {
  let [i16, s21] = (0, import_react72.useState)(c21), e9 = l19 !== void 0, t14 = (0, import_react72.useRef)(e9), u25 = (0, import_react72.useRef)(false), d14 = (0, import_react72.useRef)(false);
  return e9 && !t14.current && !u25.current ? (u25.current = true, t14.current = e9, console.error("A component is changing from uncontrolled to controlled. This may be caused by the value changing from undefined to a defined value, which should not happen.")) : !e9 && t14.current && !d14.current && (d14.current = true, t14.current = e9, console.error("A component is changing from controlled to uncontrolled. This may be caused by the value changing from a defined value to undefined, which should not happen.")), [e9 ? l19 : i16, o4((n17) => (e9 || (0, import_react_dom4.flushSync)(() => s21(n17)), r22 == null ? void 0 : r22(n17)))];
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-default-value.js
var import_react73 = __toESM(require_react(), 1);
function l3(e9) {
  let [t14] = (0, import_react73.useState)(e9);
  return t14;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-id.js
var import_react74 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/internal/form-fields.js
var import_react76 = __toESM(require_react(), 1);
var import_react_dom5 = __toESM(require_react_dom(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/form.js
var import_react75 = __toESM(require_react(), 1);
function p2(t14 = {}, i16 = null, n17 = []) {
  for (let [e9, o20] of Object.entries(t14)) s4(n17, r6(i16, e9), o20);
  return n17;
}
function r6(t14, i16) {
  return t14 ? t14 + "[" + i16 + "]" : i16;
}
function s4(t14, i16, n17) {
  if (Array.isArray(n17)) for (let [e9, o20] of n17.entries()) s4(t14, r6(i16, e9.toString()), o20);
  else n17 instanceof Date ? t14.push([i16, n17.toISOString()]) : typeof n17 == "boolean" ? t14.push([i16, n17 ? "1" : "0"]) : typeof n17 == "string" ? t14.push([i16, n17]) : typeof n17 == "number" ? t14.push([i16, `${n17}`]) : n17 == null ? t14.push([i16, ""]) : c2(n17) && !(0, import_react75.isValidElement)(n17) && p2(n17, i16, t14);
}
function g(t14) {
  var n17, e9;
  let i16 = (n17 = t14 == null ? void 0 : t14.form) != null ? n17 : t14.closest("form");
  if (i16) {
    for (let o20 of i16.elements) if (o20 !== t14 && (o20.tagName === "INPUT" && o20.type === "submit" || o20.tagName === "BUTTON" && o20.type === "submit" || o20.nodeName === "INPUT" && o20.type === "image")) {
      o20.click();
      return;
    }
    (e9 = i16.requestSubmit) == null || e9.call(i16);
  }
}
function c2(t14) {
  if (Object.prototype.toString.call(t14) !== "[object Object]") return false;
  let i16 = Object.getPrototypeOf(t14);
  return i16 === null || Object.getPrototypeOf(i16) === null;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/internal/hidden.js
var a5 = "span";
var s5 = ((e9) => (e9[e9.None = 1] = "None", e9[e9.Focusable = 2] = "Focusable", e9[e9.Hidden = 4] = "Hidden", e9))(s5 || {});
function l4(t14, r22) {
  var n17;
  let { features: d14 = 1, ...e9 } = t14, o20 = { ref: r22, "aria-hidden": (d14 & 2) === 2 ? true : (n17 = e9["aria-hidden"]) != null ? n17 : void 0, hidden: (d14 & 4) === 4 ? true : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(d14 & 4) === 4 && (d14 & 2) !== 2 && { display: "none" } } };
  return K()({ ourProps: o20, theirProps: e9, slot: {}, defaultTag: a5, name: "Hidden" });
}
var f4 = Y(l4);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/internal/form-fields.js
var f5 = (0, import_react76.createContext)(null);
function W(t14) {
  let [e9, r22] = (0, import_react76.useState)(null);
  return import_react76.default.createElement(f5.Provider, { value: { target: e9 } }, t14.children, import_react76.default.createElement(f4, { features: s5.Hidden, ref: r22 }));
}
function c3({ children: t14 }) {
  let e9 = (0, import_react76.useContext)(f5);
  if (!e9) return import_react76.default.createElement(import_react76.default.Fragment, null, t14);
  let { target: r22 } = e9;
  return r22 ? (0, import_react_dom5.createPortal)(import_react76.default.createElement(import_react76.default.Fragment, null, t14), r22) : null;
}
function j2({ data: t14, form: e9, disabled: r22, onReset: n17, overrides: F7 }) {
  let [i16, a28] = (0, import_react76.useState)(null), p13 = p();
  return (0, import_react76.useEffect)(() => {
    if (n17 && i16) return p13.addEventListener(i16, "reset", n17);
  }, [i16, e9, n17]), import_react76.default.createElement(c3, null, import_react76.default.createElement(C2, { setForm: a28, formId: e9 }), p2(t14).map(([s21, v11]) => import_react76.default.createElement(f4, { features: s5.Hidden, ...m2({ key: s21, as: "input", type: "hidden", hidden: true, readOnly: true, form: e9, disabled: r22, name: s21, value: v11, ...F7 }) })));
}
function C2({ setForm: t14, formId: e9 }) {
  return (0, import_react76.useEffect)(() => {
    if (e9) {
      let r22 = document.getElementById(e9);
      r22 && t14(r22);
    }
  }, [t14, e9]), e9 ? null : import_react76.default.createElement(f4, { features: s5.Hidden, as: "input", type: "hidden", hidden: true, readOnly: true, ref: (r22) => {
    if (!r22) return;
    let n17 = r22.closest("form");
    n17 && t14(n17);
  } });
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/internal/id.js
var import_react77 = __toESM(require_react(), 1);
var e3 = (0, import_react77.createContext)(void 0);
function u4() {
  return (0, import_react77.useContext)(e3);
}
function f6({ id: t14, children: r22 }) {
  return import_react77.default.createElement(e3.Provider, { value: t14 }, r22);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/dom.js
function o7(e9) {
  return typeof e9 != "object" || e9 === null ? false : "nodeType" in e9;
}
function t5(e9) {
  return o7(e9) && "tagName" in e9;
}
function n5(e9) {
  return t5(e9) && "accessKey" in e9;
}
function i4(e9) {
  return t5(e9) && "tabIndex" in e9;
}
function r7(e9) {
  return t5(e9) && "style" in e9;
}
function u5(e9) {
  return n5(e9) && e9.nodeName === "IFRAME";
}
function l5(e9) {
  return n5(e9) && e9.nodeName === "INPUT";
}
function m4(e9) {
  return n5(e9) && e9.nodeName === "LABEL";
}
function a6(e9) {
  return n5(e9) && e9.nodeName === "FIELDSET";
}
function E4(e9) {
  return n5(e9) && e9.nodeName === "LEGEND";
}
function L2(e9) {
  return t5(e9) ? e9.matches('a[href],audio[controls],button,details,embed,iframe,img[usemap],input:not([type="hidden"]),label,select,textarea,video[controls]') : false;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/bugs.js
function s6(l19) {
  let e9 = l19.parentElement, t14 = null;
  for (; e9 && !a6(e9); ) E4(e9) && (t14 = e9), e9 = e9.parentElement;
  let i16 = (e9 == null ? void 0 : e9.getAttribute("disabled")) === "";
  return i16 && r8(t14) ? false : i16;
}
function r8(l19) {
  if (!l19) return false;
  let e9 = l19.previousElementSibling;
  for (; e9 !== null; ) {
    if (E4(e9)) return false;
    e9 = e9.previousElementSibling;
  }
  return true;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/description/description.js
var import_react79 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-sync-refs.js
var import_react78 = __toESM(require_react(), 1);
var u6 = Symbol();
function T(t14, n17 = true) {
  return Object.assign(t14, { [u6]: n17 });
}
function y(...t14) {
  let n17 = (0, import_react78.useRef)(t14);
  (0, import_react78.useEffect)(() => {
    n17.current = t14;
  }, [t14]);
  let c21 = o4((e9) => {
    for (let o20 of n17.current) o20 != null && (typeof o20 == "function" ? o20(e9) : o20.current = e9);
  });
  return t14.every((e9) => e9 == null || (e9 == null ? void 0 : e9[u6])) ? void 0 : c21;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/description/description.js
var a7 = (0, import_react79.createContext)(null);
a7.displayName = "DescriptionContext";
function f7() {
  let r22 = (0, import_react79.useContext)(a7);
  if (r22 === null) {
    let e9 = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(e9, f7), e9;
  }
  return r22;
}
function w3() {
  var r22, e9;
  return (e9 = (r22 = (0, import_react79.useContext)(a7)) == null ? void 0 : r22.value) != null ? e9 : void 0;
}
function H3() {
  let [r22, e9] = (0, import_react79.useState)([]);
  return [r22.length > 0 ? r22.join(" ") : void 0, (0, import_react79.useMemo)(() => function(t14) {
    let i16 = o4((n17) => (e9((o20) => [...o20, n17]), () => e9((o20) => {
      let s21 = o20.slice(), p13 = s21.indexOf(n17);
      return p13 !== -1 && s21.splice(p13, 1), s21;
    }))), l19 = (0, import_react79.useMemo)(() => ({ register: i16, slot: t14.slot, name: t14.name, props: t14.props, value: t14.value }), [i16, t14.slot, t14.name, t14.props, t14.value]);
    return import_react79.default.createElement(a7.Provider, { value: l19 }, t14.children);
  }, [e9])];
}
var I2 = "p";
function C3(r22, e9) {
  let c21 = (0, import_react74.useId)(), t14 = a3(), { id: i16 = `headlessui-description-${c21}`, ...l19 } = r22, n17 = f7(), o20 = y(e9);
  n(() => n17.register(i16), [i16, n17.register]);
  let s21 = n2({ ...n17.slot, disabled: t14 || false }), p13 = { ref: o20, ...n17.props, id: i16 };
  return K()({ ourProps: p13, theirProps: l19, slot: s21, defaultTag: I2, name: n17.name || "Description" });
}
var _ = Y(C3);
var M2 = Object.assign(_, {});

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/keyboard.js
var o8 = ((r22) => (r22.Space = " ", r22.Enter = "Enter", r22.Escape = "Escape", r22.Backspace = "Backspace", r22.Delete = "Delete", r22.ArrowLeft = "ArrowLeft", r22.ArrowUp = "ArrowUp", r22.ArrowRight = "ArrowRight", r22.ArrowDown = "ArrowDown", r22.Home = "Home", r22.End = "End", r22.PageUp = "PageUp", r22.PageDown = "PageDown", r22.Tab = "Tab", r22))(o8 || {});

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/label/label.js
var import_react80 = __toESM(require_react(), 1);
var L3 = (0, import_react80.createContext)(null);
L3.displayName = "LabelContext";
function C4() {
  let n17 = (0, import_react80.useContext)(L3);
  if (n17 === null) {
    let l19 = new Error("You used a <Label /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(l19, C4), l19;
  }
  return n17;
}
function N(n17) {
  var a28, e9, o20;
  let l19 = (e9 = (a28 = (0, import_react80.useContext)(L3)) == null ? void 0 : a28.value) != null ? e9 : void 0;
  return ((o20 = n17 == null ? void 0 : n17.length) != null ? o20 : 0) > 0 ? [l19, ...n17].filter(Boolean).join(" ") : l19;
}
function V2({ inherit: n17 = false } = {}) {
  let l19 = N(), [a28, e9] = (0, import_react80.useState)([]), o20 = n17 ? [l19, ...a28].filter(Boolean) : a28;
  return [o20.length > 0 ? o20.join(" ") : void 0, (0, import_react80.useMemo)(() => function(t14) {
    let p13 = o4((i16) => (e9((u25) => [...u25, i16]), () => e9((u25) => {
      let d14 = u25.slice(), f21 = d14.indexOf(i16);
      return f21 !== -1 && d14.splice(f21, 1), d14;
    }))), b14 = (0, import_react80.useMemo)(() => ({ register: p13, slot: t14.slot, name: t14.name, props: t14.props, value: t14.value }), [p13, t14.slot, t14.name, t14.props, t14.value]);
    return import_react80.default.createElement(L3.Provider, { value: b14 }, t14.children);
  }, [e9])];
}
var G = "label";
function U2(n17, l19) {
  var y10;
  let a28 = (0, import_react74.useId)(), e9 = C4(), o20 = u4(), T11 = a3(), { id: t14 = `headlessui-label-${a28}`, htmlFor: p13 = o20 != null ? o20 : (y10 = e9.props) == null ? void 0 : y10.htmlFor, passive: b14 = false, ...i16 } = n17, u25 = y(l19);
  n(() => e9.register(t14), [t14, e9.register]);
  let d14 = o4((s21) => {
    let g6 = s21.currentTarget;
    if (!(s21.target !== s21.currentTarget && L2(s21.target)) && (m4(g6) && s21.preventDefault(), e9.props && "onClick" in e9.props && typeof e9.props.onClick == "function" && e9.props.onClick(s21), m4(g6))) {
      let r22 = document.getElementById(g6.htmlFor);
      if (r22) {
        let E13 = r22.getAttribute("disabled");
        if (E13 === "true" || E13 === "") return;
        let x10 = r22.getAttribute("aria-disabled");
        if (x10 === "true" || x10 === "") return;
        (l5(r22) && (r22.type === "file" || r22.type === "radio" || r22.type === "checkbox") || r22.role === "radio" || r22.role === "checkbox" || r22.role === "switch") && r22.click(), r22.focus({ preventScroll: true });
      }
    }
  }), f21 = n2({ ...e9.slot, disabled: T11 || false }), c21 = { ref: u25, ...e9.props, id: t14, htmlFor: p13, onClick: d14 };
  return b14 && ("onClick" in c21 && (delete c21.htmlFor, delete c21.onClick), "onClick" in i16 && delete i16.onClick), K()({ ourProps: c21, theirProps: i16, slot: f21, defaultTag: p13 ? G : "div", name: e9.name || "Label" });
}
var j3 = Y(U2);
var Z = Object.assign(j3, {});

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/checkbox/checkbox.js
var de = "span";
function pe(u25, b14) {
  let f21 = (0, import_react74.useId)(), y10 = u4(), T11 = a3(), { id: h16 = y10 || `headlessui-checkbox-${f21}`, disabled: o20 = T11 || false, autoFocus: i16 = false, checked: C11, defaultChecked: k13, onChange: x10, name: d14, value: g6, form: E13, indeterminate: l19 = false, tabIndex: v11 = 0, ...P8 } = u25, r22 = l3(k13), [a28, t14] = b2(C11, x10, r22 != null ? r22 : false), D13 = N(), R7 = w3(), A5 = p(), [F7, p13] = (0, import_react81.useState)(false), c21 = o4(() => {
    p13(true), t14 == null || t14(!a28), A5.nextFrame(() => {
      p13(false);
    });
  }), K4 = o4((e9) => {
    if (s6(e9.currentTarget)) return e9.preventDefault();
    e9.preventDefault(), c21();
  }), _10 = o4((e9) => {
    e9.key === o8.Space ? (e9.preventDefault(), c21()) : e9.key === o8.Enter && g(e9.currentTarget);
  }), H9 = o4((e9) => e9.preventDefault()), { isFocusVisible: B2, focusProps: I10 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: i16 }), { isHovered: L7, hoverProps: M12 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: o20 }), { pressed: U3, pressProps: O5 } = w({ disabled: o20 }), S11 = V({ ref: b14, id: h16, role: "checkbox", "aria-checked": l19 ? "mixed" : a28 ? "true" : "false", "aria-labelledby": D13, "aria-describedby": R7, "aria-disabled": o20 ? true : void 0, indeterminate: l19 ? "true" : void 0, tabIndex: o20 ? void 0 : v11, onKeyUp: o20 ? void 0 : _10, onKeyPress: o20 ? void 0 : H9, onClick: o20 ? void 0 : K4 }, I10, M12, O5), X5 = n2({ checked: a28, disabled: o20, hover: L7, focus: B2, active: U3, indeterminate: l19, changing: F7, autofocus: i16 }), G6 = (0, import_react81.useCallback)(() => {
    if (r22 !== void 0) return t14 == null ? void 0 : t14(r22);
  }, [t14, r22]), W5 = K();
  return import_react81.default.createElement(import_react81.default.Fragment, null, d14 != null && import_react81.default.createElement(j2, { disabled: o20, data: { [d14]: g6 || "on" }, overrides: { type: "checkbox", checked: a28 }, form: E13, onReset: G6 }), W5({ ourProps: S11, theirProps: P8, slot: X5, defaultTag: de, name: "Checkbox" }));
}
var Ke = Y(pe);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/close-button/close-button.js
var import_react83 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/internal/close-provider.js
var import_react82 = __toESM(require_react(), 1);
var e4 = (0, import_react82.createContext)(() => {
});
function u8() {
  return (0, import_react82.useContext)(e4);
}
function C5({ value: t14, children: o20 }) {
  return import_react82.default.createElement(e4.Provider, { value: t14 }, o20);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/close-button/close-button.js
function l7(t14, e9) {
  let o20 = u8();
  return import_react83.default.createElement(L, { ref: e9, ...V({ onClick: o20 }, t14) });
}
var y2 = Y(l7);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@tanstack/react-virtual/dist/esm/index.js
var React3 = __toESM(require_react());
var import_react_dom6 = __toESM(require_react_dom());

// node_modules/@tanstack/virtual-core/dist/esm/utils.js
function memo(getDeps, fn, opts) {
  let deps = opts.initialDeps ?? [];
  let result;
  function memoizedFunction() {
    var _a2, _b, _c, _d;
    let depTime;
    if (opts.key && ((_a2 = opts.debug) == null ? void 0 : _a2.call(opts))) depTime = Date.now();
    const newDeps = getDeps();
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index4) => deps[index4] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();
    result = fn(...newDeps);
    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {
      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
      const resultFpsPercentage = resultEndTime / 16;
      const pad2 = (str, num) => {
        str = String(str);
        while (str.length < num) {
          str = " " + str;
        }
        return str;
      };
      console.info(
        `%c ${pad2(resultEndTime, 5)} /${pad2(depEndTime, 5)} ms`,
        `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(
          0,
          Math.min(120 - 120 * resultFpsPercentage, 120)
        )}deg 100% 31%);`,
        opts == null ? void 0 : opts.key
      );
    }
    (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);
    return result;
  }
  memoizedFunction.updateDeps = (newDeps) => {
    deps = newDeps;
  };
  return memoizedFunction;
}
function notUndefined(value, msg) {
  if (value === void 0) {
    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : ""}`);
  } else {
    return value;
  }
}
var approxEqual = (a28, b14) => Math.abs(a28 - b14) < 1.01;
var debounce = (targetWindow, fn, ms) => {
  let timeoutId2;
  return function(...args) {
    targetWindow.clearTimeout(timeoutId2);
    timeoutId2 = targetWindow.setTimeout(() => fn.apply(this, args), ms);
  };
};

// node_modules/@tanstack/virtual-core/dist/esm/index.js
var getRect = (element5) => {
  const { offsetWidth, offsetHeight } = element5;
  return { width: offsetWidth, height: offsetHeight };
};
var defaultKeyExtractor = (index4) => index4;
var defaultRangeExtractor = (range) => {
  const start2 = Math.max(range.startIndex - range.overscan, 0);
  const end = Math.min(range.endIndex + range.overscan, range.count - 1);
  const arr = [];
  for (let i16 = start2; i16 <= end; i16++) {
    arr.push(i16);
  }
  return arr;
};
var observeElementRect = (instance, cb) => {
  const element5 = instance.scrollElement;
  if (!element5) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  const handler = (rect) => {
    const { width, height } = rect;
    cb({ width: Math.round(width), height: Math.round(height) });
  };
  handler(getRect(element5));
  if (!targetWindow.ResizeObserver) {
    return () => {
    };
  }
  const observer = new targetWindow.ResizeObserver((entries) => {
    const run = () => {
      const entry = entries[0];
      if (entry == null ? void 0 : entry.borderBoxSize) {
        const box = entry.borderBoxSize[0];
        if (box) {
          handler({ width: box.inlineSize, height: box.blockSize });
          return;
        }
      }
      handler(getRect(element5));
    };
    instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
  });
  observer.observe(element5, { box: "border-box" });
  return () => {
    observer.unobserve(element5);
  };
};
var addEventListenerOptions = {
  passive: true
};
var supportsScrollend = typeof window == "undefined" ? true : "onscrollend" in window;
var observeElementOffset = (instance, cb) => {
  const element5 = instance.scrollElement;
  if (!element5) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  let offset4 = 0;
  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(
    targetWindow,
    () => {
      cb(offset4, false);
    },
    instance.options.isScrollingResetDelay
  );
  const createHandler = (isScrolling) => () => {
    const { horizontal, isRtl } = instance.options;
    offset4 = horizontal ? element5["scrollLeft"] * (isRtl && -1 || 1) : element5["scrollTop"];
    fallback();
    cb(offset4, isScrolling);
  };
  const handler = createHandler(true);
  const endHandler = createHandler(false);
  endHandler();
  element5.addEventListener("scroll", handler, addEventListenerOptions);
  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;
  if (registerScrollendEvent) {
    element5.addEventListener("scrollend", endHandler, addEventListenerOptions);
  }
  return () => {
    element5.removeEventListener("scroll", handler);
    if (registerScrollendEvent) {
      element5.removeEventListener("scrollend", endHandler);
    }
  };
};
var measureElement = (element5, entry, instance) => {
  if (entry == null ? void 0 : entry.borderBoxSize) {
    const box = entry.borderBoxSize[0];
    if (box) {
      const size4 = Math.round(
        box[instance.options.horizontal ? "inlineSize" : "blockSize"]
      );
      return size4;
    }
  }
  return element5[instance.options.horizontal ? "offsetWidth" : "offsetHeight"];
};
var elementScroll = (offset4, {
  adjustments = 0,
  behavior
}, instance) => {
  var _a2, _b;
  const toOffset = offset4 + adjustments;
  (_b = (_a2 = instance.scrollElement) == null ? void 0 : _a2.scrollTo) == null ? void 0 : _b.call(_a2, {
    [instance.options.horizontal ? "left" : "top"]: toOffset,
    behavior
  });
};
var Virtualizer = class {
  constructor(opts) {
    this.unsubs = [];
    this.scrollElement = null;
    this.targetWindow = null;
    this.isScrolling = false;
    this.measurementsCache = [];
    this.itemSizeCache = /* @__PURE__ */ new Map();
    this.pendingMeasuredCacheIndexes = [];
    this.scrollRect = null;
    this.scrollOffset = null;
    this.scrollDirection = null;
    this.scrollAdjustments = 0;
    this.elementsCache = /* @__PURE__ */ new Map();
    this.observer = /* @__PURE__ */ (() => {
      let _ro = null;
      const get = () => {
        if (_ro) {
          return _ro;
        }
        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {
          return null;
        }
        return _ro = new this.targetWindow.ResizeObserver((entries) => {
          entries.forEach((entry) => {
            const run = () => {
              this._measureElement(entry.target, entry);
            };
            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
          });
        });
      };
      return {
        disconnect: () => {
          var _a2;
          (_a2 = get()) == null ? void 0 : _a2.disconnect();
          _ro = null;
        },
        observe: (target) => {
          var _a2;
          return (_a2 = get()) == null ? void 0 : _a2.observe(target, { box: "border-box" });
        },
        unobserve: (target) => {
          var _a2;
          return (_a2 = get()) == null ? void 0 : _a2.unobserve(target);
        }
      };
    })();
    this.range = null;
    this.setOptions = (opts2) => {
      Object.entries(opts2).forEach(([key, value]) => {
        if (typeof value === "undefined") delete opts2[key];
      });
      this.options = {
        debug: false,
        initialOffset: 0,
        overscan: 1,
        paddingStart: 0,
        paddingEnd: 0,
        scrollPaddingStart: 0,
        scrollPaddingEnd: 0,
        horizontal: false,
        getItemKey: defaultKeyExtractor,
        rangeExtractor: defaultRangeExtractor,
        onChange: () => {
        },
        measureElement,
        initialRect: { width: 0, height: 0 },
        scrollMargin: 0,
        gap: 0,
        indexAttribute: "data-index",
        initialMeasurementsCache: [],
        lanes: 1,
        isScrollingResetDelay: 150,
        enabled: true,
        isRtl: false,
        useScrollendEvent: false,
        useAnimationFrameWithResizeObserver: false,
        ...opts2
      };
    };
    this.notify = (sync) => {
      var _a2, _b;
      (_b = (_a2 = this.options).onChange) == null ? void 0 : _b.call(_a2, this, sync);
    };
    this.maybeNotify = memo(
      () => {
        this.calculateRange();
        return [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ];
      },
      (isScrolling) => {
        this.notify(isScrolling);
      },
      {
        key: "maybeNotify",
        debug: () => this.options.debug,
        initialDeps: [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ]
      }
    );
    this.cleanup = () => {
      this.unsubs.filter(Boolean).forEach((d14) => d14());
      this.unsubs = [];
      this.observer.disconnect();
      this.scrollElement = null;
      this.targetWindow = null;
    };
    this._didMount = () => {
      return () => {
        this.cleanup();
      };
    };
    this._willUpdate = () => {
      var _a2;
      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;
      if (this.scrollElement !== scrollElement) {
        this.cleanup();
        if (!scrollElement) {
          this.maybeNotify();
          return;
        }
        this.scrollElement = scrollElement;
        if (this.scrollElement && "ownerDocument" in this.scrollElement) {
          this.targetWindow = this.scrollElement.ownerDocument.defaultView;
        } else {
          this.targetWindow = ((_a2 = this.scrollElement) == null ? void 0 : _a2.window) ?? null;
        }
        this.elementsCache.forEach((cached) => {
          this.observer.observe(cached);
        });
        this._scrollToOffset(this.getScrollOffset(), {
          adjustments: void 0,
          behavior: void 0
        });
        this.unsubs.push(
          this.options.observeElementRect(this, (rect) => {
            this.scrollRect = rect;
            this.maybeNotify();
          })
        );
        this.unsubs.push(
          this.options.observeElementOffset(this, (offset4, isScrolling) => {
            this.scrollAdjustments = 0;
            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset4 ? "forward" : "backward" : null;
            this.scrollOffset = offset4;
            this.isScrolling = isScrolling;
            this.maybeNotify();
          })
        );
      }
    };
    this.getSize = () => {
      if (!this.options.enabled) {
        this.scrollRect = null;
        return 0;
      }
      this.scrollRect = this.scrollRect ?? this.options.initialRect;
      return this.scrollRect[this.options.horizontal ? "width" : "height"];
    };
    this.getScrollOffset = () => {
      if (!this.options.enabled) {
        this.scrollOffset = null;
        return 0;
      }
      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === "function" ? this.options.initialOffset() : this.options.initialOffset);
      return this.scrollOffset;
    };
    this.getFurthestMeasurement = (measurements, index4) => {
      const furthestMeasurementsFound = /* @__PURE__ */ new Map();
      const furthestMeasurements = /* @__PURE__ */ new Map();
      for (let m10 = index4 - 1; m10 >= 0; m10--) {
        const measurement = measurements[m10];
        if (furthestMeasurementsFound.has(measurement.lane)) {
          continue;
        }
        const previousFurthestMeasurement = furthestMeasurements.get(
          measurement.lane
        );
        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {
          furthestMeasurements.set(measurement.lane, measurement);
        } else if (measurement.end < previousFurthestMeasurement.end) {
          furthestMeasurementsFound.set(measurement.lane, true);
        }
        if (furthestMeasurementsFound.size === this.options.lanes) {
          break;
        }
      }
      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a28, b14) => {
        if (a28.end === b14.end) {
          return a28.index - b14.index;
        }
        return a28.end - b14.end;
      })[0] : void 0;
    };
    this.getMeasurementOptions = memo(
      () => [
        this.options.count,
        this.options.paddingStart,
        this.options.scrollMargin,
        this.options.getItemKey,
        this.options.enabled
      ],
      (count2, paddingStart, scrollMargin, getItemKey, enabled) => {
        this.pendingMeasuredCacheIndexes = [];
        return {
          count: count2,
          paddingStart,
          scrollMargin,
          getItemKey,
          enabled
        };
      },
      {
        key: false
      }
    );
    this.getMeasurements = memo(
      () => [this.getMeasurementOptions(), this.itemSizeCache],
      ({ count: count2, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache) => {
        if (!enabled) {
          this.measurementsCache = [];
          this.itemSizeCache.clear();
          return [];
        }
        if (this.measurementsCache.length === 0) {
          this.measurementsCache = this.options.initialMeasurementsCache;
          this.measurementsCache.forEach((item) => {
            this.itemSizeCache.set(item.key, item.size);
          });
        }
        const min2 = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
        this.pendingMeasuredCacheIndexes = [];
        const measurements = this.measurementsCache.slice(0, min2);
        for (let i16 = min2; i16 < count2; i16++) {
          const key = getItemKey(i16);
          const furthestMeasurement = this.options.lanes === 1 ? measurements[i16 - 1] : this.getFurthestMeasurement(measurements, i16);
          const start2 = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;
          const measuredSize = itemSizeCache.get(key);
          const size4 = typeof measuredSize === "number" ? measuredSize : this.options.estimateSize(i16);
          const end = start2 + size4;
          const lane = furthestMeasurement ? furthestMeasurement.lane : i16 % this.options.lanes;
          measurements[i16] = {
            index: i16,
            start: start2,
            size: size4,
            end,
            key,
            lane
          };
        }
        this.measurementsCache = measurements;
        return measurements;
      },
      {
        key: "getMeasurements",
        debug: () => this.options.debug
      }
    );
    this.calculateRange = memo(
      () => [
        this.getMeasurements(),
        this.getSize(),
        this.getScrollOffset(),
        this.options.lanes
      ],
      (measurements, outerSize, scrollOffset, lanes) => {
        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({
          measurements,
          outerSize,
          scrollOffset,
          lanes
        }) : null;
      },
      {
        key: "calculateRange",
        debug: () => this.options.debug
      }
    );
    this.getVirtualIndexes = memo(
      () => {
        let startIndex = null;
        let endIndex = null;
        const range = this.calculateRange();
        if (range) {
          startIndex = range.startIndex;
          endIndex = range.endIndex;
        }
        this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);
        return [
          this.options.rangeExtractor,
          this.options.overscan,
          this.options.count,
          startIndex,
          endIndex
        ];
      },
      (rangeExtractor, overscan, count2, startIndex, endIndex) => {
        return startIndex === null || endIndex === null ? [] : rangeExtractor({
          startIndex,
          endIndex,
          overscan,
          count: count2
        });
      },
      {
        key: "getVirtualIndexes",
        debug: () => this.options.debug
      }
    );
    this.indexFromElement = (node2) => {
      const attributeName = this.options.indexAttribute;
      const indexStr = node2.getAttribute(attributeName);
      if (!indexStr) {
        console.warn(
          `Missing attribute name '${attributeName}={index}' on measured element.`
        );
        return -1;
      }
      return parseInt(indexStr, 10);
    };
    this._measureElement = (node2, entry) => {
      const index4 = this.indexFromElement(node2);
      const item = this.measurementsCache[index4];
      if (!item) {
        return;
      }
      const key = item.key;
      const prevNode = this.elementsCache.get(key);
      if (prevNode !== node2) {
        if (prevNode) {
          this.observer.unobserve(prevNode);
        }
        this.observer.observe(node2);
        this.elementsCache.set(key, node2);
      }
      if (node2.isConnected) {
        this.resizeItem(index4, this.options.measureElement(node2, entry, this));
      }
    };
    this.resizeItem = (index4, size4) => {
      const item = this.measurementsCache[index4];
      if (!item) {
        return;
      }
      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;
      const delta = size4 - itemSize;
      if (delta !== 0) {
        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {
          if (this.options.debug) {
            console.info("correction", delta);
          }
          this._scrollToOffset(this.getScrollOffset(), {
            adjustments: this.scrollAdjustments += delta,
            behavior: void 0
          });
        }
        this.pendingMeasuredCacheIndexes.push(item.index);
        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size4));
        this.notify(false);
      }
    };
    this.measureElement = (node2) => {
      if (!node2) {
        this.elementsCache.forEach((cached, key) => {
          if (!cached.isConnected) {
            this.observer.unobserve(cached);
            this.elementsCache.delete(key);
          }
        });
        return;
      }
      this._measureElement(node2, void 0);
    };
    this.getVirtualItems = memo(
      () => [this.getVirtualIndexes(), this.getMeasurements()],
      (indexes, measurements) => {
        const virtualItems = [];
        for (let k13 = 0, len = indexes.length; k13 < len; k13++) {
          const i16 = indexes[k13];
          const measurement = measurements[i16];
          virtualItems.push(measurement);
        }
        return virtualItems;
      },
      {
        key: "getVirtualItems",
        debug: () => this.options.debug
      }
    );
    this.getVirtualItemForOffset = (offset4) => {
      const measurements = this.getMeasurements();
      if (measurements.length === 0) {
        return void 0;
      }
      return notUndefined(
        measurements[findNearestBinarySearch(
          0,
          measurements.length - 1,
          (index4) => notUndefined(measurements[index4]).start,
          offset4
        )]
      );
    };
    this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {
      const size4 = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        align = toOffset >= scrollOffset + size4 ? "end" : "start";
      }
      if (align === "center") {
        toOffset += (itemSize - size4) / 2;
      } else if (align === "end") {
        toOffset -= size4;
      }
      const maxOffset = this.getTotalSize() + this.options.scrollMargin - size4;
      return Math.max(Math.min(maxOffset, toOffset), 0);
    };
    this.getOffsetForIndex = (index4, align = "auto") => {
      index4 = Math.max(0, Math.min(index4, this.options.count - 1));
      const item = this.measurementsCache[index4];
      if (!item) {
        return void 0;
      }
      const size4 = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        if (item.end >= scrollOffset + size4 - this.options.scrollPaddingEnd) {
          align = "end";
        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {
          align = "start";
        } else {
          return [scrollOffset, align];
        }
      }
      const toOffset = align === "end" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;
      return [
        this.getOffsetForAlignment(toOffset, align, item.size),
        align
      ];
    };
    this.isDynamicMode = () => this.elementsCache.size > 0;
    this.scrollToOffset = (toOffset, { align = "start", behavior } = {}) => {
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {
        adjustments: void 0,
        behavior
      });
    };
    this.scrollToIndex = (index4, { align: initialAlign = "auto", behavior } = {}) => {
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      index4 = Math.max(0, Math.min(index4, this.options.count - 1));
      let attempts = 0;
      const maxAttempts = 10;
      const tryScroll = (currentAlign) => {
        if (!this.targetWindow) return;
        const offsetInfo = this.getOffsetForIndex(index4, currentAlign);
        if (!offsetInfo) {
          console.warn("Failed to get offset for index:", index4);
          return;
        }
        const [offset4, align] = offsetInfo;
        this._scrollToOffset(offset4, { adjustments: void 0, behavior });
        this.targetWindow.requestAnimationFrame(() => {
          const currentOffset = this.getScrollOffset();
          const afterInfo = this.getOffsetForIndex(index4, align);
          if (!afterInfo) {
            console.warn("Failed to get offset for index:", index4);
            return;
          }
          if (!approxEqual(afterInfo[0], currentOffset)) {
            scheduleRetry(align);
          }
        });
      };
      const scheduleRetry = (align) => {
        if (!this.targetWindow) return;
        attempts++;
        if (attempts < maxAttempts) {
          if (this.options.debug) {
            console.info("Schedule retry", attempts, maxAttempts);
          }
          this.targetWindow.requestAnimationFrame(() => tryScroll(align));
        } else {
          console.warn(
            `Failed to scroll to index ${index4} after ${maxAttempts} attempts.`
          );
        }
      };
      tryScroll(initialAlign);
    };
    this.scrollBy = (delta, { behavior } = {}) => {
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getScrollOffset() + delta, {
        adjustments: void 0,
        behavior
      });
    };
    this.getTotalSize = () => {
      var _a2;
      const measurements = this.getMeasurements();
      let end;
      if (measurements.length === 0) {
        end = this.options.paddingStart;
      } else if (this.options.lanes === 1) {
        end = ((_a2 = measurements[measurements.length - 1]) == null ? void 0 : _a2.end) ?? 0;
      } else {
        const endByLane = Array(this.options.lanes).fill(null);
        let endIndex = measurements.length - 1;
        while (endIndex >= 0 && endByLane.some((val) => val === null)) {
          const item = measurements[endIndex];
          if (endByLane[item.lane] === null) {
            endByLane[item.lane] = item.end;
          }
          endIndex--;
        }
        end = Math.max(...endByLane.filter((val) => val !== null));
      }
      return Math.max(
        end - this.options.scrollMargin + this.options.paddingEnd,
        0
      );
    };
    this._scrollToOffset = (offset4, {
      adjustments,
      behavior
    }) => {
      this.options.scrollToFn(offset4, { behavior, adjustments }, this);
    };
    this.measure = () => {
      this.itemSizeCache = /* @__PURE__ */ new Map();
      this.notify(false);
    };
    this.setOptions(opts);
  }
};
var findNearestBinarySearch = (low, high, getCurrentValue, value) => {
  while (low <= high) {
    const middle = (low + high) / 2 | 0;
    const currentValue = getCurrentValue(middle);
    if (currentValue < value) {
      low = middle + 1;
    } else if (currentValue > value) {
      high = middle - 1;
    } else {
      return middle;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
function calculateRange({
  measurements,
  outerSize,
  scrollOffset,
  lanes
}) {
  const lastIndex = measurements.length - 1;
  const getOffset = (index4) => measurements[index4].start;
  if (measurements.length <= lanes) {
    return {
      startIndex: 0,
      endIndex: lastIndex
    };
  }
  let startIndex = findNearestBinarySearch(
    0,
    lastIndex,
    getOffset,
    scrollOffset
  );
  let endIndex = startIndex;
  if (lanes === 1) {
    while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) {
      endIndex++;
    }
  } else if (lanes > 1) {
    const endPerLane = Array(lanes).fill(0);
    while (endIndex < lastIndex && endPerLane.some((pos) => pos < scrollOffset + outerSize)) {
      const item = measurements[endIndex];
      endPerLane[item.lane] = item.end;
      endIndex++;
    }
    const startPerLane = Array(lanes).fill(scrollOffset + outerSize);
    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {
      const item = measurements[startIndex];
      startPerLane[item.lane] = item.start;
      startIndex--;
    }
    startIndex = Math.max(0, startIndex - startIndex % lanes);
    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));
  }
  return { startIndex, endIndex };
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@tanstack/react-virtual/dist/esm/index.js
var useIsomorphicLayoutEffect = typeof document !== "undefined" ? React3.useLayoutEffect : React3.useEffect;
function useVirtualizerBase(options) {
  const rerender = React3.useReducer(() => ({}), {})[1];
  const resolvedOptions = {
    ...options,
    onChange: (instance2, sync) => {
      var _a2;
      if (sync) {
        (0, import_react_dom6.flushSync)(rerender);
      } else {
        rerender();
      }
      (_a2 = options.onChange) == null ? void 0 : _a2.call(options, instance2, sync);
    }
  };
  const [instance] = React3.useState(
    () => new Virtualizer(resolvedOptions)
  );
  instance.setOptions(resolvedOptions);
  useIsomorphicLayoutEffect(() => {
    return instance._didMount();
  }, []);
  useIsomorphicLayoutEffect(() => {
    return instance._willUpdate();
  });
  return instance;
}
function useVirtualizer(options) {
  return useVirtualizerBase({
    observeElementRect,
    observeElementOffset,
    scrollToFn: elementScroll,
    ...options
  });
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/combobox/combobox.js
var import_react113 = __toESM(require_react(), 1);
var import_react_dom10 = __toESM(require_react_dom(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-by-comparator.js
var import_react84 = __toESM(require_react(), 1);
function l8(e9, r22) {
  return e9 !== null && r22 !== null && typeof e9 == "object" && typeof r22 == "object" && "id" in e9 && "id" in r22 ? e9.id === r22.id : e9 === r22;
}
function u9(e9 = l8) {
  return (0, import_react84.useCallback)((r22, t14) => {
    if (typeof e9 == "string") {
      let o20 = e9;
      return (r22 == null ? void 0 : r22[o20]) === (t14 == null ? void 0 : t14[o20]);
    }
    return e9(r22, t14);
  }, [e9]);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-element-size.js
var import_react85 = __toESM(require_react(), 1);
function h3(i16) {
  if (i16 === null) return { width: 0, height: 0 };
  let { width: t14, height: e9 } = i16.getBoundingClientRect();
  return { width: t14, height: e9 };
}
function w5(i16, t14, e9 = false) {
  let [r22, f21] = (0, import_react85.useState)(() => h3(t14));
  return n(() => {
    if (!t14 || !i16) return;
    let n17 = o2();
    return n17.requestAnimationFrame(function s21() {
      n17.requestAnimationFrame(s21), f21((u25) => {
        let o20 = h3(t14);
        return o20.width === u25.width && o20.height === u25.height ? u25 : o20;
      });
    }), () => {
      n17.dispose();
    };
  }, [t14, i16]), e9 ? { width: `${r22.width}px`, height: `${r22.height}px` } : r22;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-handle-toggle.js
var import_react86 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/mouse.js
var g3 = ((f21) => (f21[f21.Left = 0] = "Left", f21[f21.Right = 2] = "Right", f21))(g3 || {});

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-handle-toggle.js
function s8(t14) {
  let r22 = (0, import_react86.useRef)(null), u25 = o4((e9) => {
    r22.current = e9.pointerType, !s6(e9.currentTarget) && e9.pointerType === "mouse" && e9.button === g3.Left && (e9.preventDefault(), t14(e9));
  }), i16 = o4((e9) => {
    r22.current !== "mouse" && (s6(e9.currentTarget) || t14(e9));
  });
  return { onPointerDown: u25, onClick: i16 };
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-is-top-layer.js
var import_react87 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/default-map.js
var a8 = class extends Map {
  constructor(t14) {
    super();
    this.factory = t14;
  }
  get(t14) {
    let e9 = super.get(t14);
    return e9 === void 0 && (e9 = this.factory(t14), this.set(t14, e9)), e9;
  }
};

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/machine.js
var h4 = Object.defineProperty;
var v4 = (t14, e9, r22) => e9 in t14 ? h4(t14, e9, { enumerable: true, configurable: true, writable: true, value: r22 }) : t14[e9] = r22;
var S2 = (t14, e9, r22) => (v4(t14, typeof e9 != "symbol" ? e9 + "" : e9, r22), r22);
var b3 = (t14, e9, r22) => {
  if (!e9.has(t14)) throw TypeError("Cannot " + r22);
};
var i7 = (t14, e9, r22) => (b3(t14, e9, "read from private field"), r22 ? r22.call(t14) : e9.get(t14));
var c4 = (t14, e9, r22) => {
  if (e9.has(t14)) throw TypeError("Cannot add the same private member more than once");
  e9 instanceof WeakSet ? e9.add(t14) : e9.set(t14, r22);
};
var u10 = (t14, e9, r22, s21) => (b3(t14, e9, "write to private field"), s21 ? s21.call(t14, r22) : e9.set(t14, r22), r22);
var n9;
var a9;
var o9;
var T3 = class {
  constructor(e9) {
    c4(this, n9, {});
    c4(this, a9, new a8(() => /* @__PURE__ */ new Set()));
    c4(this, o9, /* @__PURE__ */ new Set());
    S2(this, "disposables", o2());
    u10(this, n9, e9), s.isServer && this.disposables.microTask(() => {
      this.dispose();
    });
  }
  dispose() {
    this.disposables.dispose();
  }
  get state() {
    return i7(this, n9);
  }
  subscribe(e9, r22) {
    if (s.isServer) return () => {
    };
    let s21 = { selector: e9, callback: r22, current: e9(i7(this, n9)) };
    return i7(this, o9).add(s21), this.disposables.add(() => {
      i7(this, o9).delete(s21);
    });
  }
  on(e9, r22) {
    return s.isServer ? () => {
    } : (i7(this, a9).get(e9).add(r22), this.disposables.add(() => {
      i7(this, a9).get(e9).delete(r22);
    }));
  }
  send(e9) {
    let r22 = this.reduce(i7(this, n9), e9);
    if (r22 !== i7(this, n9)) {
      u10(this, n9, r22);
      for (let s21 of i7(this, o9)) {
        let l19 = s21.selector(i7(this, n9));
        j4(s21.current, l19) || (s21.current = l19, s21.callback(l19));
      }
      for (let s21 of i7(this, a9).get(e9.type)) s21(i7(this, n9), e9);
    }
  }
};
n9 = /* @__PURE__ */ new WeakMap(), a9 = /* @__PURE__ */ new WeakMap(), o9 = /* @__PURE__ */ new WeakMap();
function j4(t14, e9) {
  return Object.is(t14, e9) ? true : typeof t14 != "object" || t14 === null || typeof e9 != "object" || e9 === null ? false : Array.isArray(t14) && Array.isArray(e9) ? t14.length !== e9.length ? false : f8(t14[Symbol.iterator](), e9[Symbol.iterator]()) : t14 instanceof Map && e9 instanceof Map || t14 instanceof Set && e9 instanceof Set ? t14.size !== e9.size ? false : f8(t14.entries(), e9.entries()) : p3(t14) && p3(e9) ? f8(Object.entries(t14)[Symbol.iterator](), Object.entries(e9)[Symbol.iterator]()) : false;
}
function f8(t14, e9) {
  do {
    let r22 = t14.next(), s21 = e9.next();
    if (r22.done && s21.done) return true;
    if (r22.done || s21.done || !Object.is(r22.value, s21.value)) return false;
  } while (true);
}
function p3(t14) {
  if (Object.prototype.toString.call(t14) !== "[object Object]") return false;
  let e9 = Object.getPrototypeOf(t14);
  return e9 === null || Object.getPrototypeOf(e9) === null;
}
function k3(t14) {
  let [e9, r22] = t14(), s21 = o2();
  return (...l19) => {
    e9(...l19), s21.dispose(), s21.microTask(r22);
  };
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/machines/stack-machine.js
var a10 = Object.defineProperty;
var r10 = (e9, c21, t14) => c21 in e9 ? a10(e9, c21, { enumerable: true, configurable: true, writable: true, value: t14 }) : e9[c21] = t14;
var p4 = (e9, c21, t14) => (r10(e9, typeof c21 != "symbol" ? c21 + "" : c21, t14), t14);
var k4 = ((t14) => (t14[t14.Push = 0] = "Push", t14[t14.Pop = 1] = "Pop", t14))(k4 || {});
var y3 = { [0](e9, c21) {
  let t14 = c21.id, s21 = e9.stack, i16 = e9.stack.indexOf(t14);
  if (i16 !== -1) {
    let n17 = e9.stack.slice();
    return n17.splice(i16, 1), n17.push(t14), s21 = n17, { ...e9, stack: s21 };
  }
  return { ...e9, stack: [...e9.stack, t14] };
}, [1](e9, c21) {
  let t14 = c21.id, s21 = e9.stack.indexOf(t14);
  if (s21 === -1) return e9;
  let i16 = e9.stack.slice();
  return i16.splice(s21, 1), { ...e9, stack: i16 };
} };
var o10 = class _o2 extends T3 {
  constructor() {
    super(...arguments);
    p4(this, "actions", { push: (t14) => this.send({ type: 0, id: t14 }), pop: (t14) => this.send({ type: 1, id: t14 }) });
    p4(this, "selectors", { isTop: (t14, s21) => t14.stack[t14.stack.length - 1] === s21, inStack: (t14, s21) => t14.stack.includes(s21) });
  }
  static new() {
    return new _o2({ stack: [] });
  }
  reduce(t14, s21) {
    return u(s21.type, y3, t14, s21);
  }
};
var x2 = new a8(() => o10.new());

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/react-glue.js
var import_with_selector = __toESM(require_with_selector(), 1);
function S3(e9, n17, r22 = j4) {
  return (0, import_with_selector.useSyncExternalStoreWithSelector)(o4((i16) => e9.subscribe(s9, i16)), o4(() => e9.state), o4(() => e9.state), o4(n17), r22);
}
function s9(e9) {
  return e9;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-is-top-layer.js
function I3(o20, s21) {
  let t14 = (0, import_react87.useId)(), r22 = x2.get(s21), [i16, c21] = S3(r22, (0, import_react87.useCallback)((e9) => [r22.selectors.isTop(e9, t14), r22.selectors.inStack(e9, t14)], [r22, t14]));
  return n(() => {
    if (o20) return r22.actions.push(t14), () => r22.actions.pop(t14);
  }, [r22, o20, t14]), o20 ? c21 ? i16 : true : false;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-inert-others.js
var f9 = /* @__PURE__ */ new Map();
var u12 = /* @__PURE__ */ new Map();
function h5(t14) {
  var e9;
  let r22 = (e9 = u12.get(t14)) != null ? e9 : 0;
  return u12.set(t14, r22 + 1), r22 !== 0 ? () => m6(t14) : (f9.set(t14, { "aria-hidden": t14.getAttribute("aria-hidden"), inert: t14.inert }), t14.setAttribute("aria-hidden", "true"), t14.inert = true, () => m6(t14));
}
function m6(t14) {
  var i16;
  let r22 = (i16 = u12.get(t14)) != null ? i16 : 1;
  if (r22 === 1 ? u12.delete(t14) : u12.set(t14, r22 - 1), r22 !== 1) return;
  let e9 = f9.get(t14);
  e9 && (e9["aria-hidden"] === null ? t14.removeAttribute("aria-hidden") : t14.setAttribute("aria-hidden", e9["aria-hidden"]), t14.inert = e9.inert, f9.delete(t14));
}
function y4(t14, { allowed: r22, disallowed: e9 } = {}) {
  let i16 = I3(t14, "inert-others");
  n(() => {
    var d14, c21;
    if (!i16) return;
    let a28 = o2();
    for (let n17 of (d14 = e9 == null ? void 0 : e9()) != null ? d14 : []) n17 && a28.add(h5(n17));
    let s21 = (c21 = r22 == null ? void 0 : r22()) != null ? c21 : [];
    for (let n17 of s21) {
      if (!n17) continue;
      let l19 = l(n17);
      if (!l19) continue;
      let o20 = n17.parentElement;
      for (; o20 && o20 !== l19.body; ) {
        for (let p13 of o20.children) s21.some((E13) => p13.contains(E13)) || a28.add(h5(p13));
        o20 = o20.parentElement;
      }
    }
    return a28.dispose;
  }, [i16, r22, e9]);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-on-disappear.js
var import_react88 = __toESM(require_react(), 1);
function p5(s21, n17, o20) {
  let i16 = s3((t14) => {
    let e9 = t14.getBoundingClientRect();
    e9.x === 0 && e9.y === 0 && e9.width === 0 && e9.height === 0 && o20();
  });
  (0, import_react88.useEffect)(() => {
    if (!s21) return;
    let t14 = n17 === null ? null : n5(n17) ? n17 : n17.current;
    if (!t14) return;
    let e9 = o2();
    if (typeof ResizeObserver != "undefined") {
      let r22 = new ResizeObserver(() => i16.current(t14));
      r22.observe(t14), e9.add(() => r22.disconnect());
    }
    if (typeof IntersectionObserver != "undefined") {
      let r22 = new IntersectionObserver(() => i16.current(t14));
      r22.observe(t14), e9.add(() => r22.disconnect());
    }
    return () => e9.dispose();
  }, [n17, i16, s21]);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-outside-click.js
var import_react91 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/focus-management.js
var E5 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "details>summary", "textarea:not([disabled])"].map((e9) => `${e9}:not([tabindex='-1'])`).join(",");
var S4 = ["[data-autofocus]"].map((e9) => `${e9}:not([tabindex='-1'])`).join(",");
var T4 = ((o20) => (o20[o20.First = 1] = "First", o20[o20.Previous = 2] = "Previous", o20[o20.Next = 4] = "Next", o20[o20.Last = 8] = "Last", o20[o20.WrapAround = 16] = "WrapAround", o20[o20.NoScroll = 32] = "NoScroll", o20[o20.AutoFocus = 64] = "AutoFocus", o20))(T4 || {});
var A2 = ((n17) => (n17[n17.Error = 0] = "Error", n17[n17.Overflow = 1] = "Overflow", n17[n17.Success = 2] = "Success", n17[n17.Underflow = 3] = "Underflow", n17))(A2 || {});
var O = ((t14) => (t14[t14.Previous = -1] = "Previous", t14[t14.Next = 1] = "Next", t14))(O || {});
function x3(e9 = document.body) {
  return e9 == null ? [] : Array.from(e9.querySelectorAll(E5)).sort((r22, t14) => Math.sign((r22.tabIndex || Number.MAX_SAFE_INTEGER) - (t14.tabIndex || Number.MAX_SAFE_INTEGER)));
}
function h6(e9 = document.body) {
  return e9 == null ? [] : Array.from(e9.querySelectorAll(S4)).sort((r22, t14) => Math.sign((r22.tabIndex || Number.MAX_SAFE_INTEGER) - (t14.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var I4 = ((t14) => (t14[t14.Strict = 0] = "Strict", t14[t14.Loose = 1] = "Loose", t14))(I4 || {});
function H4(e9, r22 = 0) {
  var t14;
  return e9 === ((t14 = l(e9)) == null ? void 0 : t14.body) ? false : u(r22, { [0]() {
    return e9.matches(E5);
  }, [1]() {
    let l19 = e9;
    for (; l19 !== null; ) {
      if (l19.matches(E5)) return true;
      l19 = l19.parentElement;
    }
    return false;
  } });
}
function K2(e9) {
  o2().nextFrame(() => {
    let r22 = e(e9);
    r22 && i4(r22) && !H4(r22, 0) && w6(e9);
  });
}
var g4 = ((t14) => (t14[t14.Keyboard = 0] = "Keyboard", t14[t14.Mouse = 1] = "Mouse", t14))(g4 || {});
typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("keydown", (e9) => {
  e9.metaKey || e9.altKey || e9.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true), document.addEventListener("click", (e9) => {
  e9.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e9.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true));
function w6(e9) {
  e9 == null || e9.focus({ preventScroll: true });
}
var _2 = ["textarea", "input"].join(",");
function P3(e9) {
  var r22, t14;
  return (t14 = (r22 = e9 == null ? void 0 : e9.matches) == null ? void 0 : r22.call(e9, _2)) != null ? t14 : false;
}
function G2(e9, r22 = (t14) => t14) {
  return e9.slice().sort((t14, l19) => {
    let n17 = r22(t14), a28 = r22(l19);
    if (n17 === null || a28 === null) return 0;
    let u25 = n17.compareDocumentPosition(a28);
    return u25 & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : u25 & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function R3(e9, r22, t14 = e9 === null ? document.body : r3(e9)) {
  return v5(x3(t14), r22, { relativeTo: e9 });
}
function v5(e9, r22, { sorted: t14 = true, relativeTo: l19 = null, skipElements: n17 = [] } = {}) {
  let a28 = Array.isArray(e9) ? e9.length > 0 ? r3(e9[0]) : document : r3(e9), u25 = Array.isArray(e9) ? t14 ? G2(e9) : e9 : r22 & 64 ? h6(e9) : x3(e9);
  n17.length > 0 && u25.length > 1 && (u25 = u25.filter((i16) => !n17.some((d14) => d14 != null && "current" in d14 ? (d14 == null ? void 0 : d14.current) === i16 : d14 === i16))), l19 = l19 != null ? l19 : a28 == null ? void 0 : a28.activeElement;
  let o20 = (() => {
    if (r22 & 5) return 1;
    if (r22 & 10) return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), M12 = (() => {
    if (r22 & 1) return 0;
    if (r22 & 2) return Math.max(0, u25.indexOf(l19)) - 1;
    if (r22 & 4) return Math.max(0, u25.indexOf(l19)) + 1;
    if (r22 & 8) return u25.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), N4 = r22 & 32 ? { preventScroll: true } : {}, m10 = 0, c21 = u25.length, s21;
  do {
    if (m10 >= c21 || m10 + c21 <= 0) return 0;
    let i16 = M12 + m10;
    if (r22 & 16) i16 = (i16 + c21) % c21;
    else {
      if (i16 < 0) return 3;
      if (i16 >= c21) return 1;
    }
    s21 = u25[i16], s21 == null || s21.focus(N4), m10 += o20;
  } while (s21 !== e(s21));
  return r22 & 6 && P3(s21) && s21.select(), 2;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/platform.js
function t6() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i8() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n11() {
  return t6() || i8();
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-document-event.js
var import_react89 = __toESM(require_react(), 1);
function i9(t14, e9, o20, n17) {
  let u25 = s3(o20);
  (0, import_react89.useEffect)(() => {
    if (!t14) return;
    function r22(m10) {
      u25.current(m10);
    }
    return document.addEventListener(e9, r22, n17), () => document.removeEventListener(e9, r22, n17);
  }, [t14, e9, n17]);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-window-event.js
var import_react90 = __toESM(require_react(), 1);
function s10(t14, e9, o20, n17) {
  let i16 = s3(o20);
  (0, import_react90.useEffect)(() => {
    if (!t14) return;
    function r22(d14) {
      i16.current(d14);
    }
    return window.addEventListener(e9, r22, n17), () => window.removeEventListener(e9, r22, n17);
  }, [t14, e9, n17]);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-outside-click.js
var C6 = 30;
function k5(o20, f21, h16) {
  let m10 = s3(h16), s21 = (0, import_react91.useCallback)(function(e9, c21) {
    if (e9.defaultPrevented) return;
    let r22 = c21(e9);
    if (r22 === null || !r22.getRootNode().contains(r22) || !r22.isConnected) return;
    let M12 = function u25(n17) {
      return typeof n17 == "function" ? u25(n17()) : Array.isArray(n17) || n17 instanceof Set ? n17 : [n17];
    }(f21);
    for (let u25 of M12) if (u25 !== null && (u25.contains(r22) || e9.composed && e9.composedPath().includes(u25))) return;
    return !H4(r22, I4.Loose) && r22.tabIndex !== -1 && e9.preventDefault(), m10.current(e9, r22);
  }, [m10, f21]), i16 = (0, import_react91.useRef)(null);
  i9(o20, "pointerdown", (t14) => {
    var e9, c21;
    n11() || (i16.current = ((c21 = (e9 = t14.composedPath) == null ? void 0 : e9.call(t14)) == null ? void 0 : c21[0]) || t14.target);
  }, true), i9(o20, "pointerup", (t14) => {
    if (n11() || !i16.current) return;
    let e9 = i16.current;
    return i16.current = null, s21(t14, () => e9);
  }, true);
  let l19 = (0, import_react91.useRef)({ x: 0, y: 0 });
  i9(o20, "touchstart", (t14) => {
    l19.current.x = t14.touches[0].clientX, l19.current.y = t14.touches[0].clientY;
  }, true), i9(o20, "touchend", (t14) => {
    let e9 = { x: t14.changedTouches[0].clientX, y: t14.changedTouches[0].clientY };
    if (!(Math.abs(e9.x - l19.current.x) >= C6 || Math.abs(e9.y - l19.current.y) >= C6)) return s21(t14, () => i4(t14.target) ? t14.target : null);
  }, true), s10(o20, "blur", (t14) => s21(t14, () => u5(window.document.activeElement) ? window.document.activeElement : null), true);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-owner.js
var import_react92 = __toESM(require_react(), 1);
function u13(...e9) {
  return (0, import_react92.useMemo)(() => l(...e9), [...e9]);
}
function c6(...e9) {
  return (0, import_react92.useMemo)(() => r3(...e9), [...e9]);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-quick-release.js
var import_react93 = __toESM(require_react(), 1);
var H5 = ((e9) => (e9[e9.Ignore = 0] = "Ignore", e9[e9.Select = 1] = "Select", e9[e9.Close = 2] = "Close", e9))(H5 || {});
var S5 = { Ignore: { kind: 0 }, Select: (r22) => ({ kind: 1, target: r22 }), Close: { kind: 2 } };
var M3 = 200;
var f10 = 5;
function L4(r22, { trigger: n17, action: T11, close: e9, select: p13 }) {
  let l19 = (0, import_react93.useRef)(null), i16 = (0, import_react93.useRef)(null), u25 = (0, import_react93.useRef)(null);
  i9(r22 && n17 !== null, "pointerdown", (t14) => {
    o7(t14 == null ? void 0 : t14.target) && n17 != null && n17.contains(t14.target) && (i16.current = t14.x, u25.current = t14.y, l19.current = t14.timeStamp);
  }), i9(r22 && n17 !== null, "pointerup", (t14) => {
    var s21, m10;
    let c21 = l19.current;
    if (c21 === null || (l19.current = null, !i4(t14.target)) || Math.abs(t14.x - ((s21 = i16.current) != null ? s21 : t14.x)) < f10 && Math.abs(t14.y - ((m10 = u25.current) != null ? m10 : t14.y)) < f10) return;
    let a28 = T11(t14);
    switch (a28.kind) {
      case 0:
        return;
      case 1: {
        t14.timeStamp - c21 > M3 && (p13(a28.target), e9());
        break;
      }
      case 2: {
        e9();
        break;
      }
    }
  }, { capture: true });
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-refocusable-input.js
var import_react95 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-event-listener.js
var import_react94 = __toESM(require_react(), 1);
function E7(n17, e9, a28, t14) {
  let i16 = s3(a28);
  (0, import_react94.useEffect)(() => {
    n17 = n17 != null ? n17 : window;
    function r22(o20) {
      i16.current(o20);
    }
    return n17.addEventListener(e9, r22, t14), () => n17.removeEventListener(e9, r22, t14);
  }, [n17, e9, t14]);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-refocusable-input.js
function v6(e9) {
  let l19 = (0, import_react95.useRef)({ value: "", selectionStart: null, selectionEnd: null });
  return E7(e9, "blur", (n17) => {
    let t14 = n17.target;
    l5(t14) && (l19.current = { value: t14.value, selectionStart: t14.selectionStart, selectionEnd: t14.selectionEnd });
  }), o4(() => {
    if (!d2(e9) && l5(e9) && e9.isConnected) {
      if (e9.focus({ preventScroll: true }), e9.value !== l19.current.value) e9.setSelectionRange(e9.value.length, e9.value.length);
      else {
        let { selectionStart: n17, selectionEnd: t14 } = l19.current;
        n17 !== null && t14 !== null && e9.setSelectionRange(n17, t14);
      }
      l19.current = { value: "", selectionStart: null, selectionEnd: null };
    }
  });
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js
var import_react96 = __toESM(require_react(), 1);
function e5(t14, u25) {
  return (0, import_react96.useMemo)(() => {
    var n17;
    if (t14.type) return t14.type;
    let r22 = (n17 = t14.as) != null ? n17 : "button";
    if (typeof r22 == "string" && r22.toLowerCase() === "button" || (u25 == null ? void 0 : u25.tagName) === "BUTTON" && !u25.hasAttribute("type")) return "button";
  }, [t14.type, t14.as, u25]);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-store.js
var import_react97 = __toESM(require_react(), 1);
function o13(t14) {
  return (0, import_react97.useSyncExternalStore)(t14.subscribe, t14.getSnapshot, t14.getSnapshot);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/store.js
function a14(o20, r22) {
  let t14 = o20(), n17 = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return t14;
  }, subscribe(e9) {
    return n17.add(e9), () => n17.delete(e9);
  }, dispatch(e9, ...s21) {
    let i16 = r22[e9].call(t14, ...s21);
    i16 && (t14 = i16, n17.forEach((c21) => c21()));
  } };
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/document-overflow/adjust-scrollbar-padding.js
function d6() {
  let r22;
  return { before({ doc: e9 }) {
    var l19;
    let o20 = e9.documentElement, t14 = (l19 = e9.defaultView) != null ? l19 : window;
    r22 = Math.max(0, t14.innerWidth - o20.clientWidth);
  }, after({ doc: e9, d: o20 }) {
    let t14 = e9.documentElement, l19 = Math.max(0, t14.clientWidth - t14.offsetWidth), n17 = Math.max(0, r22 - l19);
    o20.style(t14, "paddingRight", `${n17}px`);
  } };
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/document-overflow/handle-ios-locking.js
function w7() {
  return t6() ? { before({ doc: o20, d: r22, meta: m10 }) {
    function a28(s21) {
      for (let l19 of m10().containers) for (let c21 of l19()) if (c21.contains(s21)) return true;
      return false;
    }
    r22.microTask(() => {
      var c21;
      if (window.getComputedStyle(o20.documentElement).scrollBehavior !== "auto") {
        let t14 = o2();
        t14.style(o20.documentElement, "scrollBehavior", "auto"), r22.add(() => r22.microTask(() => t14.dispose()));
      }
      let s21 = (c21 = window.scrollY) != null ? c21 : window.pageYOffset, l19 = null;
      r22.addEventListener(o20, "click", (t14) => {
        if (i4(t14.target)) try {
          let e9 = t14.target.closest("a");
          if (!e9) return;
          let { hash: n17 } = new URL(e9.href), f21 = o20.querySelector(n17);
          i4(f21) && !a28(f21) && (l19 = f21);
        } catch {
        }
      }, true), r22.group((t14) => {
        r22.addEventListener(o20, "touchstart", (e9) => {
          if (t14.dispose(), i4(e9.target) && r7(e9.target)) if (a28(e9.target)) {
            let n17 = e9.target;
            for (; n17.parentElement && a28(n17.parentElement); ) n17 = n17.parentElement;
            t14.style(n17, "overscrollBehavior", "contain");
          } else t14.style(e9.target, "touchAction", "none");
        });
      }), r22.addEventListener(o20, "touchmove", (t14) => {
        if (i4(t14.target)) {
          if (l5(t14.target)) return;
          if (a28(t14.target)) {
            let e9 = t14.target;
            for (; e9.parentElement && e9.dataset.headlessuiPortal !== "" && !(e9.scrollHeight > e9.clientHeight || e9.scrollWidth > e9.clientWidth); ) e9 = e9.parentElement;
            e9.dataset.headlessuiPortal === "" && t14.preventDefault();
          } else t14.preventDefault();
        }
      }, { passive: false }), r22.add(() => {
        var e9;
        let t14 = (e9 = window.scrollY) != null ? e9 : window.pageYOffset;
        s21 !== t14 && window.scrollTo(0, s21), l19 && l19.isConnected && (l19.scrollIntoView({ block: "nearest" }), l19 = null);
      });
    });
  } } : {};
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/document-overflow/prevent-scroll.js
function r11() {
  return { before({ doc: e9, d: o20 }) {
    o20.style(e9.documentElement, "overflow", "hidden");
  } };
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/document-overflow/overflow-store.js
function r12(e9) {
  let o20 = {};
  for (let t14 of e9) Object.assign(o20, t14(o20));
  return o20;
}
var c7 = a14(() => /* @__PURE__ */ new Map(), { PUSH(e9, o20) {
  var n17;
  let t14 = (n17 = this.get(e9)) != null ? n17 : { doc: e9, count: 0, d: o2(), meta: /* @__PURE__ */ new Set(), computedMeta: {} };
  return t14.count++, t14.meta.add(o20), t14.computedMeta = r12(t14.meta), this.set(e9, t14), this;
}, POP(e9, o20) {
  let t14 = this.get(e9);
  return t14 && (t14.count--, t14.meta.delete(o20), t14.computedMeta = r12(t14.meta)), this;
}, SCROLL_PREVENT(e9) {
  let o20 = { doc: e9.doc, d: e9.d, meta() {
    return e9.computedMeta;
  } }, t14 = [w7(), d6(), r11()];
  t14.forEach(({ before: n17 }) => n17 == null ? void 0 : n17(o20)), t14.forEach(({ after: n17 }) => n17 == null ? void 0 : n17(o20));
}, SCROLL_ALLOW({ d: e9 }) {
  e9.dispose();
}, TEARDOWN({ doc: e9 }) {
  this.delete(e9);
} });
c7.subscribe(() => {
  let e9 = c7.getSnapshot(), o20 = /* @__PURE__ */ new Map();
  for (let [t14] of e9) o20.set(t14, t14.documentElement.style.overflow);
  for (let t14 of e9.values()) {
    let n17 = o20.get(t14.doc) === "hidden", a28 = t14.count !== 0;
    (a28 && !n17 || !a28 && n17) && c7.dispatch(t14.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", t14), t14.count === 0 && c7.dispatch("TEARDOWN", t14);
  }
});

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/document-overflow/use-document-overflow.js
function a15(r22, e9, n17 = () => ({ containers: [] })) {
  let f21 = o13(c7), o20 = e9 ? f21.get(e9) : void 0, i16 = o20 ? o20.count > 0 : false;
  return n(() => {
    if (!(!e9 || !r22)) return c7.dispatch("PUSH", e9, n17), () => c7.dispatch("POP", e9, n17);
  }, [r22, e9]), i16;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-scroll-lock.js
function f11(e9, c21, n17 = () => [document.body]) {
  let r22 = I3(e9, "scroll-lock");
  a15(r22, c21, (t14) => {
    var o20;
    return { containers: [...(o20 = t14.containers) != null ? o20 : [], n17] };
  });
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-tracked-pointer.js
var import_react98 = __toESM(require_react(), 1);
function t7(e9) {
  return [e9.screenX, e9.screenY];
}
function u15() {
  let e9 = (0, import_react98.useRef)([-1, -1]);
  return { wasMoved(r22) {
    let n17 = t7(r22);
    return e9.current[0] === n17[0] && e9.current[1] === n17[1] ? false : (e9.current = n17, true);
  }, update(r22) {
    e9.current = t7(r22);
  } };
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-transition.js
var import_react100 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-flags.js
var import_react99 = __toESM(require_react(), 1);
function c8(u25 = 0) {
  let [r22, a28] = (0, import_react99.useState)(u25), g6 = (0, import_react99.useCallback)((e9) => a28(e9), []), s21 = (0, import_react99.useCallback)((e9) => a28((l19) => l19 | e9), []), m10 = (0, import_react99.useCallback)((e9) => (r22 & e9) === e9, [r22]), n17 = (0, import_react99.useCallback)((e9) => a28((l19) => l19 & ~e9), []), F7 = (0, import_react99.useCallback)((e9) => a28((l19) => l19 ^ e9), []);
  return { flags: r22, setFlag: g6, addFlag: s21, hasFlag: m10, removeFlag: n17, toggleFlag: F7 };
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-transition.js
var T6;
var S6;
typeof process != "undefined" && typeof globalThis != "undefined" && typeof Element != "undefined" && ((T6 = process == null ? void 0 : process.env) == null ? void 0 : T6["NODE_ENV"]) === "test" && typeof ((S6 = Element == null ? void 0 : Element.prototype) == null ? void 0 : S6.getAnimations) == "undefined" && (Element.prototype.getAnimations = function() {
  return console.warn(["Headless UI has polyfilled `Element.prototype.getAnimations` for your tests.", "Please install a proper polyfill e.g. `jsdom-testing-mocks`, to silence these warnings.", "", "Example usage:", "```js", "import { mockAnimationsApi } from 'jsdom-testing-mocks'", "mockAnimationsApi()", "```"].join(`
`)), [];
});
var A3 = ((i16) => (i16[i16.None = 0] = "None", i16[i16.Closed = 1] = "Closed", i16[i16.Enter = 2] = "Enter", i16[i16.Leave = 4] = "Leave", i16))(A3 || {});
function x4(e9) {
  let r22 = {};
  for (let t14 in e9) e9[t14] === true && (r22[`data-${t14}`] = "");
  return r22;
}
function N2(e9, r22, t14, n17) {
  let [i16, a28] = (0, import_react100.useState)(t14), { hasFlag: s21, addFlag: o20, removeFlag: l19 } = c8(e9 && i16 ? 3 : 0), u25 = (0, import_react100.useRef)(false), f21 = (0, import_react100.useRef)(false), E13 = p();
  return n(() => {
    var d14;
    if (e9) {
      if (t14 && a28(true), !r22) {
        t14 && o20(3);
        return;
      }
      return (d14 = n17 == null ? void 0 : n17.start) == null || d14.call(n17, t14), C7(r22, { inFlight: u25, prepare() {
        f21.current ? f21.current = false : f21.current = u25.current, u25.current = true, !f21.current && (t14 ? (o20(3), l19(4)) : (o20(4), l19(2)));
      }, run() {
        f21.current ? t14 ? (l19(3), o20(4)) : (l19(4), o20(3)) : t14 ? l19(1) : o20(1);
      }, done() {
        var p13;
        f21.current && D4(r22) || (u25.current = false, l19(7), t14 || a28(false), (p13 = n17 == null ? void 0 : n17.end) == null || p13.call(n17, t14));
      } });
    }
  }, [e9, t14, r22, E13]), e9 ? [i16, { closed: s21(1), enter: s21(2), leave: s21(4), transition: s21(2) || s21(4) }] : [t14, { closed: void 0, enter: void 0, leave: void 0, transition: void 0 }];
}
function C7(e9, { prepare: r22, run: t14, done: n17, inFlight: i16 }) {
  let a28 = o2();
  return j5(e9, { prepare: r22, inFlight: i16 }), a28.nextFrame(() => {
    t14(), a28.requestAnimationFrame(() => {
      a28.add(M4(e9, n17));
    });
  }), a28.dispose;
}
function M4(e9, r22) {
  var a28, s21;
  let t14 = o2();
  if (!e9) return t14.dispose;
  let n17 = false;
  t14.add(() => {
    n17 = true;
  });
  let i16 = (s21 = (a28 = e9.getAnimations) == null ? void 0 : a28.call(e9).filter((o20) => o20 instanceof CSSTransition)) != null ? s21 : [];
  return i16.length === 0 ? (r22(), t14.dispose) : (Promise.allSettled(i16.map((o20) => o20.finished)).then(() => {
    n17 || r22();
  }), t14.dispose);
}
function j5(e9, { inFlight: r22, prepare: t14 }) {
  if (r22 != null && r22.current) {
    t14();
    return;
  }
  let n17 = e9.style.transition;
  e9.style.transition = "none", t14(), e9.offsetHeight, e9.style.transition = n17;
}
function D4(e9) {
  var t14, n17;
  return ((n17 = (t14 = e9.getAnimations) == null ? void 0 : t14.call(e9)) != null ? n17 : []).some((i16) => i16 instanceof CSSTransition && i16.playState !== "finished");
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-tree-walker.js
var import_react101 = __toESM(require_react(), 1);
function F2(c21, { container: e9, accept: t14, walk: r22 }) {
  let o20 = (0, import_react101.useRef)(t14), l19 = (0, import_react101.useRef)(r22);
  (0, import_react101.useEffect)(() => {
    o20.current = t14, l19.current = r22;
  }, [t14, r22]), n(() => {
    if (!e9 || !c21) return;
    let n17 = l(e9);
    if (!n17) return;
    let f21 = o20.current, p13 = l19.current, i16 = Object.assign((m10) => f21(m10), { acceptNode: f21 }), u25 = n17.createTreeWalker(e9, NodeFilter.SHOW_ELEMENT, i16, false);
    for (; u25.nextNode(); ) p13(u25.currentNode);
  }, [e9, c21, o20, l19]);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-watch.js
var import_react102 = __toESM(require_react(), 1);
function m7(u25, t14) {
  let e9 = (0, import_react102.useRef)([]), r22 = o4(u25);
  (0, import_react102.useEffect)(() => {
    let o20 = [...e9.current];
    for (let [a28, l19] of t14.entries()) if (e9.current[a28] !== l19) {
      let n17 = r22(t14, o20);
      return e9.current = t14, n17;
    }
  }, [r22, ...t14]);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var React5 = __toESM(require_react(), 1);
var import_react104 = __toESM(require_react(), 1);

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node2) {
  if (isNode(node2)) {
    return (node2.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node2) {
  var _ref;
  return (_ref = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element5) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element5);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element5) {
  return tableElements.has(getNodeName(element5));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element5) {
  return topLayerSelectors.some((selector) => {
    try {
      return element5.matches(selector);
    } catch (_e4) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element5) {
  let currentNode = getParentNode(element5);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node2) {
  return lastTraversableNodeNames.has(getNodeName(node2));
}
function getComputedStyle2(element5) {
  return getWindow(element5).getComputedStyle(element5);
}
function getNodeScroll(element5) {
  if (isElement(element5)) {
    return {
      scrollLeft: element5.scrollLeft,
      scrollTop: element5.scrollTop
    };
  }
  return {
    scrollLeft: element5.scrollX,
    scrollTop: element5.scrollY
  };
}
function getParentNode(node2) {
  if (getNodeName(node2) === "html") {
    return node2;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode(node2);
  if (isLastTraversableNode(parentNode)) {
    return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node2, list4, traverseIframes) {
  var _node$ownerDocument2;
  if (list4 === void 0) {
    list4 = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node2);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list4.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list4.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs
function getPlatform() {
  const uaData = navigator.userAgentData;
  if (uaData != null && uaData.platform) {
    return uaData.platform;
  }
  return navigator.platform;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    return uaData.brands.map((_ref) => {
      let {
        brand,
        version: version2
      } = _ref;
      return brand + "/" + version2;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v11) => ({
  x: v11,
  y: v11
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start2, value, end) {
  return max(start2, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list4 = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list4 = list4.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list4 = list4.concat(list4.map(getOppositeAlignmentPlacement));
    }
  }
  return list4;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x10,
    y: y10,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y10,
    left: x10,
    right: x10 + width,
    bottom: y10 + height,
    x: x10,
    y: y10
  };
}

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element5) {
  var _element$getRootNode;
  return element5 === null || element5 === void 0 ? void 0 : (_element$getRootNode = element5.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element5);
} : function(element5) {
  return element5 === null || element5 === void 0 ? void 0 : element5.ownerDocument;
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var ReactDOM2 = __toESM(require_react_dom(), 1);

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x10,
    y: y10
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i16 = 0; i16 < validMiddleware.length; i16++) {
    const {
      name: name2,
      fn
    } = validMiddleware[i16];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x10,
      y: y10,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x10 = nextX != null ? nextX : x10;
    y10 = nextY != null ? nextY : y10;
    middlewareData = {
      ...middlewareData,
      [name2]: {
        ...middlewareData[name2],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x10,
          y: y10
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i16 = -1;
    }
  }
  return {
    x: x10,
    y: y10,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x10,
    y: y10,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element5 = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element5))) != null ? _await$platform$isEle : true) ? element5 : element5.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x10,
    y: y10,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d14) => getSideAxis(d14.placement) === initialSideAxis ? d14.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d14) => d14.overflows[0] <= 0).sort((a28, b14) => a28.overflows[1] - b14.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d14) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d14.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d14) => [d14.placement, d14.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a28, b14) => a28[1] - b14[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x10,
        y: y10,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x10 + diffCoords.x,
        y: y10 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x10,
        y: y10,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x11,
              y: y11
            } = _ref;
            return {
              x: x11,
              y: y11
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x10,
        y: y10
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x10,
          y: limitedCoords.y - y10,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element5) {
  const css = getComputedStyle2(element5);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element5);
  const offsetWidth = hasOffset ? element5.offsetWidth : width;
  const offsetHeight = hasOffset ? element5.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element5) {
  return !isElement(element5) ? element5.contextElement : element5;
}
function getScale(element5) {
  const domElement = unwrapElement(element5);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $7
  } = getCssDimensions(domElement);
  let x10 = ($7 ? round(rect.width) : rect.width) / width;
  let y10 = ($7 ? round(rect.height) : rect.height) / height;
  if (!x10 || !Number.isFinite(x10)) {
    x10 = 1;
  }
  if (!y10 || !Number.isFinite(y10)) {
    y10 = 1;
  }
  return {
    x: x10,
    y: y10
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element5) {
  const win = getWindow(element5);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element5, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element5)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element5, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element5.getBoundingClientRect();
  const domElement = unwrapElement(element5);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element5);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x10 = (clientRect.left + visualOffsets.x) / scale.x;
  let y10 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x10 *= iframeScale.x;
      y10 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x10 += left;
      y10 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x10,
    y: y10
  });
}
function getWindowScrollBarX(element5, rect) {
  const leftScroll = getNodeScroll(element5).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element5)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x10 = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y10 = htmlRect.top + scroll.scrollTop;
  return {
    x: x10,
    y: y10
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element5) {
  return Array.from(element5.getClientRects());
}
function getDocumentRect(element5) {
  const html8 = getDocumentElement(element5);
  const scroll = getNodeScroll(element5);
  const body = element5.ownerDocument.body;
  const width = max(html8.scrollWidth, html8.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html8.scrollHeight, html8.clientHeight, body.scrollHeight, body.clientHeight);
  let x10 = -scroll.scrollLeft + getWindowScrollBarX(element5);
  const y10 = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x10 += max(html8.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x10,
    y: y10
  };
}
var SCROLLBAR_MAX = 25;
function getViewportRect(element5, strategy) {
  const win = getWindow(element5);
  const html8 = getDocumentElement(element5);
  const visualViewport = win.visualViewport;
  let width = html8.clientWidth;
  let height = html8.clientHeight;
  let x10 = 0;
  let y10 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x10 = visualViewport.offsetLeft;
      y10 = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html8);
  if (windowScrollbarX <= 0) {
    const doc = html8.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html8.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x: x10,
    y: y10
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element5, strategy) {
  const clientRect = getBoundingClientRect(element5, true, strategy === "fixed");
  const top = clientRect.top + element5.clientTop;
  const left = clientRect.left + element5.clientLeft;
  const scale = isHTMLElement(element5) ? getScale(element5) : createCoords(1);
  const width = element5.clientWidth * scale.x;
  const height = element5.clientHeight * scale.y;
  const x10 = left * scale.x;
  const y10 = top * scale.y;
  return {
    width,
    height,
    x: x10,
    y: y10
  };
}
function getClientRectFromClippingAncestor(element5, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element5, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element5));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element5);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element5, stopNode) {
  const parentNode = getParentNode(element5);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element5, cache) {
  const cachedResult = cache.get(element5);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element5, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element5).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element5) : element5;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element5, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element5, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element: element5,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element5) ? [] : getClippingElementAncestors(element5, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element5, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element5, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element5) {
  const {
    width,
    height
  } = getCssDimensions(element5);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element5, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element5, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x10 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y10 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x10,
    y: y10,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element5) {
  return getComputedStyle2(element5).position === "static";
}
function getTrueOffsetParent(element5, polyfill) {
  if (!isHTMLElement(element5) || getComputedStyle2(element5).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element5);
  }
  let rawOffsetParent = element5.offsetParent;
  if (getDocumentElement(element5) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element5, polyfill) {
  const win = getWindow(element5);
  if (isTopLayer(element5)) {
    return win;
  }
  if (!isHTMLElement(element5)) {
    let svgOffsetParent = getParentNode(element5);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element5, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element5) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element5) {
  return getComputedStyle2(element5).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a28, b14) {
  return a28.x === b14.x && a28.y === b14.y && a28.width === b14.width && a28.height === b14.height;
}
function observeMove(element5, onMove) {
  let io = null;
  let timeoutId2;
  const root6 = getDocumentElement(element5);
  function cleanup2() {
    var _io;
    clearTimeout(timeoutId2);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup2();
    const elementRectForRootMargin = element5.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root6.clientWidth - (left + width));
    const insetBottom = floor(root6.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId2 = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element5.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root6.ownerDocument
      });
    } catch (_e4) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element5);
  }
  refresh(true);
  return cleanup2;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var detectOverflow2 = detectOverflow;
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@floating-ui/react/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React4 = __toESM(require_react(), 1);
var import_react103 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var isClient = typeof document !== "undefined";
var noop = function noop2() {
};
var index = isClient ? import_react103.useLayoutEffect : noop;
function deepEqual(a28, b14) {
  if (a28 === b14) {
    return true;
  }
  if (typeof a28 !== typeof b14) {
    return false;
  }
  if (typeof a28 === "function" && a28.toString() === b14.toString()) {
    return true;
  }
  let length;
  let i16;
  let keys2;
  if (a28 && b14 && typeof a28 === "object") {
    if (Array.isArray(a28)) {
      length = a28.length;
      if (length !== b14.length) return false;
      for (i16 = length; i16-- !== 0; ) {
        if (!deepEqual(a28[i16], b14[i16])) {
          return false;
        }
      }
      return true;
    }
    keys2 = Object.keys(a28);
    length = keys2.length;
    if (length !== Object.keys(b14).length) {
      return false;
    }
    for (i16 = length; i16-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b14, keys2[i16])) {
        return false;
      }
    }
    for (i16 = length; i16-- !== 0; ) {
      const key = keys2[i16];
      if (key === "_owner" && a28.$$typeof) {
        continue;
      }
      if (!deepEqual(a28[key], b14[key])) {
        return false;
      }
    }
    return true;
  }
  return a28 !== a28 && b14 !== b14;
}
function getDPR(element5) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element5.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element5, value) {
  const dpr = getDPR(element5);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React4.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open: open2
  } = options;
  const [data, setData] = React4.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React4.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React4.useState(null);
  const [_floating, _setFloating] = React4.useState(null);
  const setReference = React4.useCallback((node2) => {
    if (node2 !== referenceRef.current) {
      referenceRef.current = node2;
      _setReference(node2);
    }
  }, []);
  const setFloating = React4.useCallback((node2) => {
    if (node2 !== floatingRef.current) {
      floatingRef.current = node2;
      _setFloating(node2);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React4.useRef(null);
  const floatingRef = React4.useRef(null);
  const dataRef = React4.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open2);
  const update = React4.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open2 === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open2]);
  const isMountedRef = React4.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React4.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React4.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React4.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x10 = roundByDPR(elements.floating, data.x);
    const y10 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x10 + "px, " + y10 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x10,
      top: y10
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React4.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var shift3 = (options, deps) => ({
  ...shift2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var size3 = (options, deps) => ({
  ...size2(options),
  options: [options, deps]
});

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/node_modules/@floating-ui/react/dist/floating-ui.react.mjs
function useMergeRefs(refs) {
  return React5.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value) => {
      refs.forEach((ref) => {
        if (typeof ref === "function") {
          ref(value);
        } else if (ref != null) {
          ref.current = value;
        }
      });
    };
  }, refs);
}
var SafeReact = {
  ...React5
};
var useInsertionEffect = SafeReact.useInsertionEffect;
var useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
  const ref = React5.useRef(() => {
    if (true) {
      throw new Error("Cannot call an event handler while rendering.");
    }
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return React5.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
var ARROW_UP = "ArrowUp";
var ARROW_DOWN = "ArrowDown";
var ARROW_LEFT = "ArrowLeft";
var ARROW_RIGHT = "ArrowRight";
function isDifferentRow(index4, cols, prevRow) {
  return Math.floor(index4 / cols) !== prevRow;
}
function isIndexOutOfBounds(listRef, index4) {
  return index4 < 0 || index4 >= listRef.current.length;
}
function getMinIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    disabledIndices
  });
}
function getMaxIndex(listRef, disabledIndices) {
  return findNonDisabledIndex(listRef, {
    decrement: true,
    startingIndex: listRef.current.length,
    disabledIndices
  });
}
function findNonDisabledIndex(listRef, _temp) {
  let {
    startingIndex = -1,
    decrement = false,
    disabledIndices,
    amount = 1
  } = _temp === void 0 ? {} : _temp;
  const list4 = listRef.current;
  let index4 = startingIndex;
  do {
    index4 += decrement ? -amount : amount;
  } while (index4 >= 0 && index4 <= list4.length - 1 && isDisabled(list4, index4, disabledIndices));
  return index4;
}
function getGridNavigatedIndex(elementsRef, _ref) {
  let {
    event,
    orientation,
    loop,
    rtl,
    cols,
    disabledIndices,
    minIndex,
    maxIndex,
    prevIndex,
    stopEvent: stop = false
  } = _ref;
  let nextIndex = prevIndex;
  if (event.key === ARROW_UP) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = maxIndex;
    } else {
      nextIndex = findNonDisabledIndex(elementsRef, {
        startingIndex: nextIndex,
        amount: cols,
        decrement: true,
        disabledIndices
      });
      if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {
        const col = prevIndex % cols;
        const maxCol = maxIndex % cols;
        const offset4 = maxIndex - (maxCol - col);
        if (maxCol === col) {
          nextIndex = maxIndex;
        } else {
          nextIndex = maxCol > col ? offset4 : offset4 - cols;
        }
      }
    }
    if (isIndexOutOfBounds(elementsRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (event.key === ARROW_DOWN) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = minIndex;
    } else {
      nextIndex = findNonDisabledIndex(elementsRef, {
        startingIndex: prevIndex,
        amount: cols,
        disabledIndices
      });
      if (loop && prevIndex + cols > maxIndex) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex % cols - cols,
          amount: cols,
          disabledIndices
        });
      }
    }
    if (isIndexOutOfBounds(elementsRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (orientation === "both") {
    const prevRow = floor(prevIndex / cols);
    if (event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT)) {
      stop && stopEvent(event);
      if (prevIndex % cols !== cols - 1) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex,
          disabledIndices
        });
        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledIndex(elementsRef, {
            startingIndex: prevIndex - prevIndex % cols - 1,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      }
      if (isDifferentRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    if (event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT)) {
      stop && stopEvent(event);
      if (prevIndex % cols !== 0) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex,
          decrement: true,
          disabledIndices
        });
        if (loop && isDifferentRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledIndex(elementsRef, {
            startingIndex: prevIndex + (cols - prevIndex % cols),
            decrement: true,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex + (cols - prevIndex % cols),
          decrement: true,
          disabledIndices
        });
      }
      if (isDifferentRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    const lastRow = floor(maxIndex / cols) === prevRow;
    if (isIndexOutOfBounds(elementsRef, nextIndex)) {
      if (loop && lastRow) {
        nextIndex = event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT) ? maxIndex : findNonDisabledIndex(elementsRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      } else {
        nextIndex = prevIndex;
      }
    }
  }
  return nextIndex;
}
function buildCellMap(sizes, cols, dense) {
  const cellMap = [];
  let startIndex = 0;
  sizes.forEach((_ref2, index4) => {
    let {
      width,
      height
    } = _ref2;
    if (width > cols) {
      if (true) {
        throw new Error("[Floating UI]: Invalid grid - item width at index " + index4 + " is greater than grid columns");
      }
    }
    let itemPlaced = false;
    if (dense) {
      startIndex = 0;
    }
    while (!itemPlaced) {
      const targetCells = [];
      for (let i16 = 0; i16 < width; i16++) {
        for (let j11 = 0; j11 < height; j11++) {
          targetCells.push(startIndex + i16 + j11 * cols);
        }
      }
      if (startIndex % cols + width <= cols && targetCells.every((cell) => cellMap[cell] == null)) {
        targetCells.forEach((cell) => {
          cellMap[cell] = index4;
        });
        itemPlaced = true;
      } else {
        startIndex++;
      }
    }
  });
  return [...cellMap];
}
function getCellIndexOfCorner(index4, sizes, cellMap, cols, corner) {
  if (index4 === -1) return -1;
  const firstCellIndex = cellMap.indexOf(index4);
  const sizeItem = sizes[index4];
  switch (corner) {
    case "tl":
      return firstCellIndex;
    case "tr":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + sizeItem.width - 1;
    case "bl":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + (sizeItem.height - 1) * cols;
    case "br":
      return cellMap.lastIndexOf(index4);
  }
}
function getCellIndices(indices, cellMap) {
  return cellMap.flatMap((index4, cellIndex) => indices.includes(index4) ? [cellIndex] : []);
}
function isDisabled(list4, index4, disabledIndices) {
  if (disabledIndices) {
    return disabledIndices.includes(index4);
  }
  const element5 = list4[index4];
  return element5 == null || element5.hasAttribute("disabled") || element5.getAttribute("aria-disabled") === "true";
}
var index2 = typeof document !== "undefined" ? import_react104.useLayoutEffect : import_react104.useEffect;
function sortByDocumentPosition(a28, b14) {
  const position4 = a28.compareDocumentPosition(b14);
  if (position4 & Node.DOCUMENT_POSITION_FOLLOWING || position4 & Node.DOCUMENT_POSITION_CONTAINED_BY) {
    return -1;
  }
  if (position4 & Node.DOCUMENT_POSITION_PRECEDING || position4 & Node.DOCUMENT_POSITION_CONTAINS) {
    return 1;
  }
  return 0;
}
function areMapsEqual(map1, map22) {
  if (map1.size !== map22.size) {
    return false;
  }
  for (const [key, value] of map1.entries()) {
    if (value !== map22.get(key)) {
      return false;
    }
  }
  return true;
}
var FloatingListContext = React5.createContext({
  register: () => {
  },
  unregister: () => {
  },
  map: /* @__PURE__ */ new Map(),
  elementsRef: {
    current: []
  }
});
function FloatingList(props) {
  const {
    children,
    elementsRef,
    labelsRef
  } = props;
  const [map3, setMap] = React5.useState(() => /* @__PURE__ */ new Map());
  const register = React5.useCallback((node2) => {
    setMap((prevMap) => new Map(prevMap).set(node2, null));
  }, []);
  const unregister = React5.useCallback((node2) => {
    setMap((prevMap) => {
      const map4 = new Map(prevMap);
      map4.delete(node2);
      return map4;
    });
  }, []);
  index2(() => {
    const newMap = new Map(map3);
    const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);
    nodes.forEach((node2, index4) => {
      newMap.set(node2, index4);
    });
    if (!areMapsEqual(map3, newMap)) {
      setMap(newMap);
    }
  }, [map3]);
  return React5.createElement(FloatingListContext.Provider, {
    value: React5.useMemo(() => ({
      register,
      unregister,
      map: map3,
      elementsRef,
      labelsRef
    }), [register, unregister, map3, elementsRef, labelsRef])
  }, children);
}
function useListItem(props) {
  if (props === void 0) {
    props = {};
  }
  const {
    label
  } = props;
  const {
    register,
    unregister,
    map: map3,
    elementsRef,
    labelsRef
  } = React5.useContext(FloatingListContext);
  const [index$1, setIndex] = React5.useState(null);
  const componentRef = React5.useRef(null);
  const ref = React5.useCallback((node2) => {
    componentRef.current = node2;
    if (index$1 !== null) {
      elementsRef.current[index$1] = node2;
      if (labelsRef) {
        var _node$textContent;
        const isLabelDefined = label !== void 0;
        labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node2 == null ? void 0 : node2.textContent) != null ? _node$textContent : null;
      }
    }
  }, [index$1, elementsRef, labelsRef, label]);
  index2(() => {
    const node2 = componentRef.current;
    if (node2) {
      register(node2);
      return () => {
        unregister(node2);
      };
    }
  }, [register, unregister]);
  index2(() => {
    const index4 = componentRef.current ? map3.get(componentRef.current) : null;
    if (index4 != null) {
      setIndex(index4);
    }
  }, [map3]);
  return React5.useMemo(() => ({
    ref,
    index: index$1 == null ? -1 : index$1
  }), [index$1, ref]);
}
function renderJsx(render3, computedProps) {
  if (typeof render3 === "function") {
    return render3(computedProps);
  }
  if (render3) {
    return React5.cloneElement(render3, computedProps);
  }
  return React5.createElement("div", computedProps);
}
var CompositeContext = React5.createContext({
  activeIndex: 0,
  onNavigate: () => {
  }
});
var horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];
var verticalKeys = [ARROW_UP, ARROW_DOWN];
var allKeys = [...horizontalKeys, ...verticalKeys];
var Composite = React5.forwardRef(function Composite2(props, forwardedRef) {
  const {
    render: render3,
    orientation = "both",
    loop = true,
    rtl = false,
    cols = 1,
    disabledIndices,
    activeIndex: externalActiveIndex,
    onNavigate: externalSetActiveIndex,
    itemSizes,
    dense = false,
    ...domProps
  } = props;
  const [internalActiveIndex, internalSetActiveIndex] = React5.useState(0);
  const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;
  const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);
  const elementsRef = React5.useRef([]);
  const renderElementProps = render3 && typeof render3 !== "function" ? render3.props : {};
  const contextValue = React5.useMemo(() => ({
    activeIndex,
    onNavigate
  }), [activeIndex, onNavigate]);
  const isGrid = cols > 1;
  function handleKeyDown(event) {
    if (!allKeys.includes(event.key)) return;
    let nextIndex = activeIndex;
    const minIndex = getMinIndex(elementsRef, disabledIndices);
    const maxIndex = getMaxIndex(elementsRef, disabledIndices);
    const horizontalEndKey = rtl ? ARROW_LEFT : ARROW_RIGHT;
    const horizontalStartKey = rtl ? ARROW_RIGHT : ARROW_LEFT;
    if (isGrid) {
      const sizes = itemSizes || Array.from({
        length: elementsRef.current.length
      }, () => ({
        width: 1,
        height: 1
      }));
      const cellMap = buildCellMap(sizes, cols, dense);
      const minGridIndex = cellMap.findIndex((index4) => index4 != null && !isDisabled(elementsRef.current, index4, disabledIndices));
      const maxGridIndex = cellMap.reduce((foundIndex, index4, cellIndex) => index4 != null && !isDisabled(elementsRef.current, index4, disabledIndices) ? cellIndex : foundIndex, -1);
      const maybeNextIndex = cellMap[getGridNavigatedIndex({
        current: cellMap.map((itemIndex) => itemIndex ? elementsRef.current[itemIndex] : null)
      }, {
        event,
        orientation,
        loop,
        rtl,
        cols,
        // treat undefined (empty grid spaces) as disabled indices so we
        // don't end up in them
        disabledIndices: getCellIndices([...disabledIndices || elementsRef.current.map((_10, index4) => isDisabled(elementsRef.current, index4) ? index4 : void 0), void 0], cellMap),
        minIndex: minGridIndex,
        maxIndex: maxGridIndex,
        prevIndex: getCellIndexOfCorner(
          activeIndex > maxIndex ? minIndex : activeIndex,
          sizes,
          cellMap,
          cols,
          // use a corner matching the edge closest to the direction we're
          // moving in so we don't end up in the same item. Prefer
          // top/left over bottom/right.
          event.key === ARROW_DOWN ? "bl" : event.key === horizontalEndKey ? "tr" : "tl"
        )
      })];
      if (maybeNextIndex != null) {
        nextIndex = maybeNextIndex;
      }
    }
    const toEndKeys = {
      horizontal: [horizontalEndKey],
      vertical: [ARROW_DOWN],
      both: [horizontalEndKey, ARROW_DOWN]
    }[orientation];
    const toStartKeys = {
      horizontal: [horizontalStartKey],
      vertical: [ARROW_UP],
      both: [horizontalStartKey, ARROW_UP]
    }[orientation];
    const preventedKeys = isGrid ? allKeys : {
      horizontal: horizontalKeys,
      vertical: verticalKeys,
      both: allKeys
    }[orientation];
    if (nextIndex === activeIndex && [...toEndKeys, ...toStartKeys].includes(event.key)) {
      if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {
        nextIndex = minIndex;
      } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {
        nextIndex = maxIndex;
      } else {
        nextIndex = findNonDisabledIndex(elementsRef, {
          startingIndex: nextIndex,
          decrement: toStartKeys.includes(event.key),
          disabledIndices
        });
      }
    }
    if (nextIndex !== activeIndex && !isIndexOutOfBounds(elementsRef, nextIndex)) {
      var _elementsRef$current$;
      event.stopPropagation();
      if (preventedKeys.includes(event.key)) {
        event.preventDefault();
      }
      onNavigate(nextIndex);
      (_elementsRef$current$ = elementsRef.current[nextIndex]) == null || _elementsRef$current$.focus();
    }
  }
  const computedProps = {
    ...domProps,
    ...renderElementProps,
    ref: forwardedRef,
    "aria-orientation": orientation === "both" ? void 0 : orientation,
    onKeyDown(e9) {
      domProps.onKeyDown == null || domProps.onKeyDown(e9);
      renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e9);
      handleKeyDown(e9);
    }
  };
  return React5.createElement(CompositeContext.Provider, {
    value: contextValue
  }, React5.createElement(FloatingList, {
    elementsRef
  }, renderJsx(render3, computedProps)));
});
var CompositeItem = React5.forwardRef(function CompositeItem2(props, forwardedRef) {
  const {
    render: render3,
    ...domProps
  } = props;
  const renderElementProps = render3 && typeof render3 !== "function" ? render3.props : {};
  const {
    activeIndex,
    onNavigate
  } = React5.useContext(CompositeContext);
  const {
    ref,
    index: index4
  } = useListItem();
  const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);
  const isActive = activeIndex === index4;
  const computedProps = {
    ...domProps,
    ...renderElementProps,
    ref: mergedRef,
    tabIndex: isActive ? 0 : -1,
    "data-active": isActive ? "" : void 0,
    onFocus(e9) {
      domProps.onFocus == null || domProps.onFocus(e9);
      renderElementProps.onFocus == null || renderElementProps.onFocus(e9);
      onNavigate(index4);
    }
  };
  return renderJsx(render3, computedProps);
});
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i16 = 1; i16 < arguments.length; i16++) {
      var source = arguments[i16];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var serverHandoffComplete = false;
var count = 0;
var genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [id, setId] = React5.useState(() => serverHandoffComplete ? genId() : void 0);
  index2(() => {
    if (id == null) {
      setId(genId());
    }
  }, []);
  React5.useEffect(() => {
    serverHandoffComplete = true;
  }, []);
  return id;
}
var useReactId = SafeReact.useId;
var useId = useReactId || useFloatingId;
var devMessageSet;
if (true) {
  devMessageSet = /* @__PURE__ */ new Set();
}
function warn() {
  var _devMessageSet;
  for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {
    messages[_key] = arguments[_key];
  }
  const message = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {
    var _devMessageSet2;
    (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);
    console.warn(message);
  }
}
function error() {
  var _devMessageSet3;
  for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    messages[_key2] = arguments[_key2];
  }
  const message = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {
    var _devMessageSet4;
    (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);
    console.error(message);
  }
}
var FloatingArrow = React5.forwardRef(function FloatingArrow2(props, ref) {
  const {
    context: {
      placement,
      elements: {
        floating
      },
      middlewareData: {
        arrow: arrow4,
        shift: shift4
      }
    },
    width = 14,
    height = 7,
    tipRadius = 0,
    strokeWidth = 0,
    staticOffset,
    stroke,
    d: d14,
    style: {
      transform,
      ...restStyle
    } = {},
    ...rest
  } = props;
  if (true) {
    if (!ref) {
      warn("The `ref` prop is required for `FloatingArrow`.");
    }
  }
  const clipPathId = useId();
  const [isRTL2, setIsRTL] = React5.useState(false);
  index2(() => {
    if (!floating) return;
    const isRTL3 = getComputedStyle2(floating).direction === "rtl";
    if (isRTL3) {
      setIsRTL(true);
    }
  }, [floating]);
  if (!floating) {
    return null;
  }
  const [side, alignment] = placement.split("-");
  const isVerticalSide = side === "top" || side === "bottom";
  let computedStaticOffset = staticOffset;
  if (isVerticalSide && shift4 != null && shift4.x || !isVerticalSide && shift4 != null && shift4.y) {
    computedStaticOffset = null;
  }
  const computedStrokeWidth = strokeWidth * 2;
  const halfStrokeWidth = computedStrokeWidth / 2;
  const svgX = width / 2 * (tipRadius / -8 + 1);
  const svgY = height / 2 * tipRadius / 4;
  const isCustomShape = !!d14;
  const yOffsetProp = computedStaticOffset && alignment === "end" ? "bottom" : "top";
  let xOffsetProp = computedStaticOffset && alignment === "end" ? "right" : "left";
  if (computedStaticOffset && isRTL2) {
    xOffsetProp = alignment === "end" ? "left" : "right";
  }
  const arrowX = (arrow4 == null ? void 0 : arrow4.x) != null ? computedStaticOffset || arrow4.x : "";
  const arrowY = (arrow4 == null ? void 0 : arrow4.y) != null ? computedStaticOffset || arrow4.y : "";
  const dValue = d14 || "M0,0" + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + " Z";
  const rotation = {
    top: isCustomShape ? "rotate(180deg)" : "",
    left: isCustomShape ? "rotate(90deg)" : "rotate(-90deg)",
    bottom: isCustomShape ? "" : "rotate(180deg)",
    right: isCustomShape ? "rotate(-90deg)" : "rotate(90deg)"
  }[side];
  return React5.createElement("svg", _extends({}, rest, {
    "aria-hidden": true,
    ref,
    width: isCustomShape ? width : width + computedStrokeWidth,
    height: width,
    viewBox: "0 0 " + width + " " + (height > width ? height : width),
    style: {
      position: "absolute",
      pointerEvents: "none",
      [xOffsetProp]: arrowX,
      [yOffsetProp]: arrowY,
      [side]: isVerticalSide || isCustomShape ? "100%" : "calc(100% - " + computedStrokeWidth / 2 + "px)",
      transform: [rotation, transform].filter((t14) => !!t14).join(" "),
      ...restStyle
    }
  }), computedStrokeWidth > 0 && React5.createElement("path", {
    clipPath: "url(#" + clipPathId + ")",
    fill: "none",
    stroke,
    strokeWidth: computedStrokeWidth + (d14 ? 0 : 1),
    d: dValue
  }), React5.createElement("path", {
    stroke: computedStrokeWidth && !d14 ? rest.fill : "none",
    d: dValue
  }), React5.createElement("clipPath", {
    id: clipPathId
  }, React5.createElement("rect", {
    x: -halfStrokeWidth,
    y: halfStrokeWidth * (isCustomShape ? -1 : 1),
    width: width + computedStrokeWidth,
    height: width
  })));
});
function createPubSub() {
  const map3 = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map3.get(event)) == null || _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map3.set(event, [...map3.get(event) || [], listener]);
    },
    off(event, listener) {
      var _map$get2;
      map3.set(event, ((_map$get2 = map3.get(event)) == null ? void 0 : _map$get2.filter((l19) => l19 !== listener)) || []);
    }
  };
}
var FloatingNodeContext = React5.createContext(null);
var FloatingTreeContext = React5.createContext(null);
var useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = React5.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
var useFloatingTree = () => React5.useContext(FloatingTreeContext);
function createAttribute(name2) {
  return "data-floating-ui-" + name2;
}
var safePolygonIdentifier = createAttribute("safe-polygon");
var NOOP = () => {
};
var FloatingDelayGroupContext = React5.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: NOOP,
  setState: NOOP,
  isInstantPhase: false
});
var HIDDEN_STYLES = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
var timeoutId;
function setActiveElementOnTab(event) {
  if (event.key === "Tab") {
    event.target;
    clearTimeout(timeoutId);
  }
}
var FocusGuard = React5.forwardRef(function FocusGuard2(props, ref) {
  const [role, setRole] = React5.useState();
  index2(() => {
    if (isSafari()) {
      setRole("button");
    }
    document.addEventListener("keydown", setActiveElementOnTab);
    return () => {
      document.removeEventListener("keydown", setActiveElementOnTab);
    };
  }, []);
  const restProps = {
    ref,
    tabIndex: 0,
    // Role is only for VoiceOver
    role,
    "aria-hidden": role ? void 0 : true,
    [createAttribute("focus-guard")]: "",
    style: HIDDEN_STYLES
  };
  return React5.createElement("span", _extends({}, props, restProps));
});
var PortalContext = React5.createContext(null);
var attr = createAttribute("portal");
var FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
var VisuallyHiddenDismiss = React5.forwardRef(function VisuallyHiddenDismiss2(props, ref) {
  return React5.createElement("button", _extends({}, props, {
    type: "button",
    ref,
    tabIndex: -1,
    style: HIDDEN_STYLES
  }));
});
var lockCount = 0;
function enableScrollLock() {
  const isIOS = /iP(hone|ad|od)|iOS/.test(getPlatform());
  const bodyStyle = document.body.style;
  const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;
  const paddingProp = scrollbarX ? "paddingLeft" : "paddingRight";
  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
  const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.scrollX;
  const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.scrollY;
  bodyStyle.overflow = "hidden";
  if (scrollbarWidth) {
    bodyStyle[paddingProp] = scrollbarWidth + "px";
  }
  if (isIOS) {
    var _window$visualViewpor, _window$visualViewpor2;
    const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;
    const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;
    Object.assign(bodyStyle, {
      position: "fixed",
      top: -(scrollY - Math.floor(offsetTop)) + "px",
      left: -(scrollX - Math.floor(offsetLeft)) + "px",
      right: "0"
    });
  }
  return () => {
    Object.assign(bodyStyle, {
      overflow: "",
      [paddingProp]: ""
    });
    if (isIOS) {
      Object.assign(bodyStyle, {
        position: "",
        top: "",
        left: "",
        right: ""
      });
      window.scrollTo(scrollX, scrollY);
    }
  };
}
var cleanup = () => {
};
var FloatingOverlay = React5.forwardRef(function FloatingOverlay2(props, ref) {
  const {
    lockScroll = false,
    ...rest
  } = props;
  index2(() => {
    if (!lockScroll) return;
    lockCount++;
    if (lockCount === 1) {
      cleanup = enableScrollLock();
    }
    return () => {
      lockCount--;
      if (lockCount === 0) {
        cleanup();
      }
    };
  }, [lockScroll]);
  return React5.createElement("div", _extends({
    ref
  }, rest, {
    style: {
      position: "fixed",
      overflow: "auto",
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...rest.style
    }
  }));
});
function useFloatingRootContext(options) {
  const {
    open: open2 = false,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options;
  const floatingId = useId();
  const dataRef = React5.useRef({});
  const [events] = React5.useState(() => createPubSub());
  const nested = useFloatingParentNodeId() != null;
  if (true) {
    const optionDomReference = elementsProp.reference;
    if (optionDomReference && !isElement(optionDomReference)) {
      error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
    }
  }
  const [positionReference, setPositionReference] = React5.useState(elementsProp.reference);
  const onOpenChange = useEffectEvent((open3, event, reason) => {
    dataRef.current.openEvent = open3 ? event : void 0;
    events.emit("openchange", {
      open: open3,
      event,
      reason,
      nested
    });
    onOpenChangeProp == null || onOpenChangeProp(open3, event, reason);
  });
  const refs = React5.useMemo(() => ({
    setPositionReference
  }), []);
  const elements = React5.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return React5.useMemo(() => ({
    dataRef,
    open: open2,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open2, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating2(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    nodeId
  } = options;
  const internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  });
  const rootContext = options.rootContext || internalRootContext;
  const computedElements = rootContext.elements;
  const [_domReference, setDomReference] = React5.useState(null);
  const [positionReference, _setPositionReference] = React5.useState(null);
  const optionDomReference = computedElements == null ? void 0 : computedElements.domReference;
  const domReference = optionDomReference || _domReference;
  const domReferenceRef = React5.useRef(null);
  const tree = useFloatingTree();
  index2(() => {
    if (domReference) {
      domReferenceRef.current = domReference;
    }
  }, [domReference]);
  const position4 = useFloating({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  });
  const setPositionReference = React5.useCallback((node2) => {
    const computedPositionReference = isElement(node2) ? {
      getBoundingClientRect: () => node2.getBoundingClientRect(),
      contextElement: node2
    } : node2;
    _setPositionReference(computedPositionReference);
    position4.refs.setReference(computedPositionReference);
  }, [position4.refs]);
  const setReference = React5.useCallback((node2) => {
    if (isElement(node2) || node2 === null) {
      domReferenceRef.current = node2;
      setDomReference(node2);
    }
    if (isElement(position4.refs.reference.current) || position4.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node2 !== null && !isElement(node2)) {
      position4.refs.setReference(node2);
    }
  }, [position4.refs]);
  const refs = React5.useMemo(() => ({
    ...position4.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position4.refs, setReference, setPositionReference]);
  const elements = React5.useMemo(() => ({
    ...position4.elements,
    domReference
  }), [position4.elements, domReference]);
  const context = React5.useMemo(() => ({
    ...position4,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position4, refs, elements, nodeId, rootContext]);
  index2(() => {
    rootContext.dataRef.current.floatingContext = context;
    const node2 = tree == null ? void 0 : tree.nodesRef.current.find((node3) => node3.id === nodeId);
    if (node2) {
      node2.context = context;
    }
  });
  return React5.useMemo(() => ({
    ...position4,
    context,
    refs,
    elements
  }), [position4, refs, elements, context]);
}
var ACTIVE_KEY = "active";
var SELECTED_KEY = "selected";
function mergeProps(userProps, propsList, elementKey) {
  const map3 = /* @__PURE__ */ new Map();
  const isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _10,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      if (typeof propsOrGetProps === "function") {
        return userProps ? propsOrGetProps(userProps) : null;
      }
      return propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref) => {
        let [key, value] = _ref;
        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {
          return;
        }
        if (key.indexOf("on") === 0) {
          if (!map3.has(key)) {
            map3.set(key, []);
          }
          if (typeof value === "function") {
            var _map$get;
            (_map$get = map3.get(key)) == null || _map$get.push(value);
            acc[key] = function() {
              var _map$get2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return (_map$get2 = map3.get(key)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}
function useInteractions(propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  const referenceDeps = propsList.map((key) => key == null ? void 0 : key.reference);
  const floatingDeps = propsList.map((key) => key == null ? void 0 : key.floating);
  const itemDeps = propsList.map((key) => key == null ? void 0 : key.item);
  const getReferenceProps = React5.useCallback(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  );
  const getFloatingProps = React5.useCallback(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  );
  const getItemProps = React5.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return React5.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
function getArgsWithCustomFloatingHeight(state, height) {
  return {
    ...state,
    rects: {
      ...state.rects,
      floating: {
        ...state.rects.floating,
        height
      }
    }
  };
}
var inner = (props) => ({
  name: "inner",
  options: props,
  async fn(state) {
    const {
      listRef,
      overflowRef,
      onFallbackChange,
      offset: innerOffset = 0,
      index: index4 = 0,
      minItemsVisible = 4,
      referenceOverflowThreshold = 0,
      scrollRef,
      ...detectOverflowOptions
    } = evaluate(props, state);
    const {
      rects,
      elements: {
        floating
      }
    } = state;
    const item = listRef.current[index4];
    const scrollEl = (scrollRef == null ? void 0 : scrollRef.current) || floating;
    const clientTop = floating.clientTop || scrollEl.clientTop;
    const floatingIsBordered = floating.clientTop !== 0;
    const scrollElIsBordered = scrollEl.clientTop !== 0;
    const floatingIsScrollEl = floating === scrollEl;
    if (true) {
      if (!state.placement.startsWith("bottom")) {
        warn('`placement` side must be "bottom" when using the `inner`', "middleware.");
      }
    }
    if (!item) {
      return {};
    }
    const nextArgs = {
      ...state,
      ...await offset3(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state)
    };
    const overflow = await detectOverflow2(getArgsWithCustomFloatingHeight(nextArgs, scrollEl.scrollHeight + clientTop + floating.clientTop), detectOverflowOptions);
    const refOverflow = await detectOverflow2(nextArgs, {
      ...detectOverflowOptions,
      elementContext: "reference"
    });
    const diffY = max(0, overflow.top);
    const nextY = nextArgs.y + diffY;
    const isScrollable = scrollEl.scrollHeight > scrollEl.clientHeight;
    const rounder = isScrollable ? (v11) => v11 : round;
    const maxHeight = rounder(max(0, scrollEl.scrollHeight + (floatingIsBordered && floatingIsScrollEl || scrollElIsBordered ? clientTop * 2 : 0) - diffY - max(0, overflow.bottom)));
    scrollEl.style.maxHeight = maxHeight + "px";
    scrollEl.scrollTop = diffY;
    if (onFallbackChange) {
      const shouldFallback = scrollEl.offsetHeight < item.offsetHeight * min(minItemsVisible, listRef.current.length) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold;
      ReactDOM2.flushSync(() => onFallbackChange(shouldFallback));
    }
    if (overflowRef) {
      overflowRef.current = await detectOverflow2(getArgsWithCustomFloatingHeight({
        ...nextArgs,
        y: nextY
      }, scrollEl.offsetHeight + clientTop + floating.clientTop), detectOverflowOptions);
    }
    return {
      y: nextY
    };
  }
});
function useInnerOffset(context, props) {
  const {
    open: open2,
    elements
  } = context;
  const {
    enabled = true,
    overflowRef,
    scrollRef,
    onChange: unstable_onChange
  } = props;
  const onChange = useEffectEvent(unstable_onChange);
  const controlledScrollingRef = React5.useRef(false);
  const prevScrollTopRef = React5.useRef(null);
  const initialOverflowRef = React5.useRef(null);
  React5.useEffect(() => {
    if (!enabled) return;
    function onWheel(e9) {
      if (e9.ctrlKey || !el || overflowRef.current == null) {
        return;
      }
      const dY = e9.deltaY;
      const isAtTop = overflowRef.current.top >= -0.5;
      const isAtBottom = overflowRef.current.bottom >= -0.5;
      const remainingScroll = el.scrollHeight - el.clientHeight;
      const sign = dY < 0 ? -1 : 1;
      const method = dY < 0 ? "max" : "min";
      if (el.scrollHeight <= el.clientHeight) {
        return;
      }
      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {
        e9.preventDefault();
        ReactDOM2.flushSync(() => {
          onChange((d14) => d14 + Math[method](dY, remainingScroll * sign));
        });
      } else if (/firefox/i.test(getUserAgent())) {
        el.scrollTop += dY;
      }
    }
    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
    if (open2 && el) {
      el.addEventListener("wheel", onWheel);
      requestAnimationFrame(() => {
        prevScrollTopRef.current = el.scrollTop;
        if (overflowRef.current != null) {
          initialOverflowRef.current = {
            ...overflowRef.current
          };
        }
      });
      return () => {
        prevScrollTopRef.current = null;
        initialOverflowRef.current = null;
        el.removeEventListener("wheel", onWheel);
      };
    }
  }, [enabled, open2, elements.floating, overflowRef, scrollRef, onChange]);
  const floating = React5.useMemo(() => ({
    onKeyDown() {
      controlledScrollingRef.current = true;
    },
    onWheel() {
      controlledScrollingRef.current = false;
    },
    onPointerMove() {
      controlledScrollingRef.current = false;
    },
    onScroll() {
      const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
      if (!overflowRef.current || !el || !controlledScrollingRef.current) {
        return;
      }
      if (prevScrollTopRef.current !== null) {
        const scrollDiff = el.scrollTop - prevScrollTopRef.current;
        if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {
          ReactDOM2.flushSync(() => onChange((d14) => d14 + scrollDiff));
        }
      }
      requestAnimationFrame(() => {
        prevScrollTopRef.current = el.scrollTop;
      });
    }
  }), [elements.floating, onChange, overflowRef, scrollRef]);
  return React5.useMemo(() => enabled ? {
    floating
  } : {}, [enabled, floating]);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/internal/floating.js
var j6 = __toESM(require_react(), 1);
var import_react106 = __toESM(require_react(), 1);
var y5 = (0, import_react106.createContext)({ styles: void 0, setReference: () => {
}, setFloating: () => {
}, getReferenceProps: () => ({}), getFloatingProps: () => ({}), slot: {} });
y5.displayName = "FloatingContext";
var $2 = (0, import_react106.createContext)(null);
$2.displayName = "PlacementContext";
function ye(e9) {
  return (0, import_react106.useMemo)(() => e9 ? typeof e9 == "string" ? { to: e9 } : e9 : null, [e9]);
}
function Fe() {
  return (0, import_react106.useContext)(y5).setReference;
}
function be() {
  return (0, import_react106.useContext)(y5).getReferenceProps;
}
function Te() {
  let { getFloatingProps: e9, slot: t14 } = (0, import_react106.useContext)(y5);
  return (0, import_react106.useCallback)((...n17) => Object.assign({}, e9(...n17), { "data-anchor": t14.anchor }), [e9, t14]);
}
function Re(e9 = null) {
  e9 === false && (e9 = null), typeof e9 == "string" && (e9 = { to: e9 });
  let t14 = (0, import_react106.useContext)($2), n17 = (0, import_react106.useMemo)(() => e9, [JSON.stringify(e9, (l19, o20) => {
    var u25;
    return (u25 = o20 == null ? void 0 : o20.outerHTML) != null ? u25 : o20;
  })]);
  n(() => {
    t14 == null || t14(n17 != null ? n17 : null);
  }, [t14, n17]);
  let r22 = (0, import_react106.useContext)(y5);
  return (0, import_react106.useMemo)(() => [r22.setFloating, e9 ? r22.styles : {}], [r22.setFloating, e9, r22.styles]);
}
var D5 = 4;
function Ae({ children: e9, enabled: t14 = true }) {
  let [n17, r22] = (0, import_react106.useState)(null), [l19, o20] = (0, import_react106.useState)(0), u25 = (0, import_react106.useRef)(null), [f21, s21] = (0, import_react106.useState)(null);
  ce(f21);
  let i16 = t14 && n17 !== null && f21 !== null, { to: F7 = "bottom", gap: E13 = 0, offset: A5 = 0, padding: c21 = 0, inner: h16 } = ge(n17, f21), [a28, p13 = "center"] = F7.split(" ");
  n(() => {
    i16 && o20(0);
  }, [i16]);
  let { refs: b14, floatingStyles: S11, context: g6 } = useFloating2({ open: i16, placement: a28 === "selection" ? p13 === "center" ? "bottom" : `bottom-${p13}` : p13 === "center" ? `${a28}` : `${a28}-${p13}`, strategy: "absolute", transform: false, middleware: [offset3({ mainAxis: a28 === "selection" ? 0 : E13, crossAxis: A5 }), shift3({ padding: c21 }), a28 !== "selection" && flip3({ padding: c21 }), a28 === "selection" && h16 ? inner({ ...h16, padding: c21, overflowRef: u25, offset: l19, minItemsVisible: D5, referenceOverflowThreshold: c21, onFallbackChange(P8) {
    var L7, N4;
    if (!P8) return;
    let d14 = g6.elements.floating;
    if (!d14) return;
    let M12 = parseFloat(getComputedStyle(d14).scrollPaddingBottom) || 0, I10 = Math.min(D5, d14.childElementCount), W5 = 0, B2 = 0;
    for (let m10 of (N4 = (L7 = g6.elements.floating) == null ? void 0 : L7.childNodes) != null ? N4 : []) if (n5(m10)) {
      let x10 = m10.offsetTop, k13 = x10 + m10.clientHeight + M12, H9 = d14.scrollTop, U3 = H9 + d14.clientHeight;
      if (x10 >= H9 && k13 <= U3) I10--;
      else {
        B2 = Math.max(0, Math.min(k13, U3) - Math.max(x10, H9)), W5 = m10.clientHeight;
        break;
      }
    }
    I10 >= 1 && o20((m10) => {
      let x10 = W5 * I10 - B2 + M12;
      return m10 >= x10 ? m10 : x10;
    });
  } }) : null, size3({ padding: c21, apply({ availableWidth: P8, availableHeight: d14, elements: M12 }) {
    Object.assign(M12.floating.style, { overflow: "auto", maxWidth: `${P8}px`, maxHeight: `min(var(--anchor-max-height, 100vh), ${d14}px)` });
  } })].filter(Boolean), whileElementsMounted: autoUpdate }), [w12 = a28, V6 = p13] = g6.placement.split("-");
  a28 === "selection" && (w12 = "selection");
  let G6 = (0, import_react106.useMemo)(() => ({ anchor: [w12, V6].filter(Boolean).join(" ") }), [w12, V6]), K4 = useInnerOffset(g6, { overflowRef: u25, onChange: o20 }), { getReferenceProps: Q7, getFloatingProps: X5 } = useInteractions([K4]), Y4 = o4((P8) => {
    s21(P8), b14.setFloating(P8);
  });
  return j6.createElement($2.Provider, { value: r22 }, j6.createElement(y5.Provider, { value: { setFloating: Y4, setReference: b14.setReference, styles: S11, getReferenceProps: Q7, getFloatingProps: X5, slot: G6 } }, e9));
}
function ce(e9) {
  n(() => {
    if (!e9) return;
    let t14 = new MutationObserver(() => {
      let n17 = window.getComputedStyle(e9).maxHeight, r22 = parseFloat(n17);
      if (isNaN(r22)) return;
      let l19 = parseInt(n17);
      isNaN(l19) || r22 !== l19 && (e9.style.maxHeight = `${Math.ceil(r22)}px`);
    });
    return t14.observe(e9, { attributes: true, attributeFilter: ["style"] }), () => {
      t14.disconnect();
    };
  }, [e9]);
}
function ge(e9, t14) {
  var o20, u25, f21;
  let n17 = O2((o20 = e9 == null ? void 0 : e9.gap) != null ? o20 : "var(--anchor-gap, 0)", t14), r22 = O2((u25 = e9 == null ? void 0 : e9.offset) != null ? u25 : "var(--anchor-offset, 0)", t14), l19 = O2((f21 = e9 == null ? void 0 : e9.padding) != null ? f21 : "var(--anchor-padding, 0)", t14);
  return { ...e9, gap: n17, offset: r22, padding: l19 };
}
function O2(e9, t14, n17 = void 0) {
  let r22 = p(), l19 = o4((s21, i16) => {
    if (s21 == null) return [n17, null];
    if (typeof s21 == "number") return [s21, null];
    if (typeof s21 == "string") {
      if (!i16) return [n17, null];
      let F7 = J2(s21, i16);
      return [F7, (E13) => {
        let A5 = q(s21);
        {
          let c21 = A5.map((h16) => window.getComputedStyle(i16).getPropertyValue(h16));
          r22.requestAnimationFrame(function h16() {
            r22.nextFrame(h16);
            let a28 = false;
            for (let [b14, S11] of A5.entries()) {
              let g6 = window.getComputedStyle(i16).getPropertyValue(S11);
              if (c21[b14] !== g6) {
                c21[b14] = g6, a28 = true;
                break;
              }
            }
            if (!a28) return;
            let p13 = J2(s21, i16);
            F7 !== p13 && (E13(p13), F7 = p13);
          });
        }
        return r22.dispose;
      }];
    }
    return [n17, null];
  }), o20 = (0, import_react106.useMemo)(() => l19(e9, t14)[0], [e9, t14]), [u25 = o20, f21] = (0, import_react106.useState)();
  return n(() => {
    let [s21, i16] = l19(e9, t14);
    if (f21(s21), !!i16) return i16(f21);
  }, [e9, t14]), u25;
}
function q(e9) {
  let t14 = /var\((.*)\)/.exec(e9);
  if (t14) {
    let n17 = t14[1].indexOf(",");
    if (n17 === -1) return [t14[1]];
    let r22 = t14[1].slice(0, n17).trim(), l19 = t14[1].slice(n17 + 1).trim();
    return l19 ? [r22, ...q(l19)] : [r22];
  }
  return [];
}
function J2(e9, t14) {
  let n17 = document.createElement("div");
  t14.appendChild(n17), n17.style.setProperty("margin-top", "0px", "important"), n17.style.setProperty("margin-top", e9, "important");
  let r22 = parseFloat(window.getComputedStyle(n17).marginTop) || 0;
  return t14.removeChild(n17), r22;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/internal/frozen.js
var import_react107 = __toESM(require_react(), 1);
function f13({ children: t14, freeze: e9 }, o20) {
  let n17 = u16(e9, t14);
  return (0, import_react107.isValidElement)(n17) ? (0, import_react107.cloneElement)(n17, { ref: o20 }) : import_react107.default.createElement(import_react107.default.Fragment, null, n17);
}
var s12 = import_react107.default.forwardRef(f13);
function u16(t14, e9) {
  let [o20, n17] = (0, import_react107.useState)(e9);
  return !t14 && o20 !== e9 && n17(e9), t14 ? o20 : e9;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/internal/open-closed.js
var import_react108 = __toESM(require_react(), 1);
var n12 = (0, import_react108.createContext)(null);
n12.displayName = "OpenClosedContext";
var i10 = ((e9) => (e9[e9.Open = 1] = "Open", e9[e9.Closed = 2] = "Closed", e9[e9.Closing = 4] = "Closing", e9[e9.Opening = 8] = "Opening", e9))(i10 || {});
function u17() {
  return (0, import_react108.useContext)(n12);
}
function c11({ value: o20, children: t14 }) {
  return import_react108.default.createElement(n12.Provider, { value: o20 }, t14);
}
function s13({ children: o20 }) {
  return import_react108.default.createElement(n12.Provider, { value: null }, o20);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/document-ready.js
function t9(n17) {
  function e9() {
    document.readyState !== "loading" && (n17(), document.removeEventListener("DOMContentLoaded", e9));
  }
  typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("DOMContentLoaded", e9), e9());
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/active-element-history.js
var n13 = [];
t9(() => {
  function e9(t14) {
    if (!i4(t14.target) || t14.target === document.body || n13[0] === t14.target) return;
    let r22 = t14.target;
    r22 = r22.closest(E5), n13.unshift(r22 != null ? r22 : t14.target), n13 = n13.filter((o20) => o20 != null && o20.isConnected), n13.splice(10);
  }
  window.addEventListener("click", e9, { capture: true }), window.addEventListener("mousedown", e9, { capture: true }), window.addEventListener("focus", e9, { capture: true }), document.body.addEventListener("click", e9, { capture: true }), document.body.addEventListener("mousedown", e9, { capture: true }), document.body.addEventListener("focus", e9, { capture: true });
});

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/calculate-active-index.js
function u18(l19) {
  throw new Error("Unexpected object: " + l19);
}
var c12 = ((i16) => (i16[i16.First = 0] = "First", i16[i16.Previous = 1] = "Previous", i16[i16.Next = 2] = "Next", i16[i16.Last = 3] = "Last", i16[i16.Specific = 4] = "Specific", i16[i16.Nothing = 5] = "Nothing", i16))(c12 || {});
function f14(l19, n17) {
  let t14 = n17.resolveItems();
  if (t14.length <= 0) return null;
  let r22 = n17.resolveActiveIndex(), s21 = r22 != null ? r22 : -1;
  switch (l19.focus) {
    case 0: {
      for (let e9 = 0; e9 < t14.length; ++e9) if (!n17.resolveDisabled(t14[e9], e9, t14)) return e9;
      return r22;
    }
    case 1: {
      s21 === -1 && (s21 = t14.length);
      for (let e9 = s21 - 1; e9 >= 0; --e9) if (!n17.resolveDisabled(t14[e9], e9, t14)) return e9;
      return r22;
    }
    case 2: {
      for (let e9 = s21 + 1; e9 < t14.length; ++e9) if (!n17.resolveDisabled(t14[e9], e9, t14)) return e9;
      return r22;
    }
    case 3: {
      for (let e9 = t14.length - 1; e9 >= 0; --e9) if (!n17.resolveDisabled(t14[e9], e9, t14)) return e9;
      return r22;
    }
    case 4: {
      for (let e9 = 0; e9 < t14.length; ++e9) if (n17.resolveId(t14[e9], e9, t14) === l19.id) return e9;
      return r22;
    }
    case 5:
      return null;
    default:
      u18(l19);
  }
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/portal/portal.js
var import_react111 = __toESM(require_react(), 1);
var import_react_dom9 = __toESM(require_react_dom(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-on-unmount.js
var import_react109 = __toESM(require_react(), 1);
function c13(t14) {
  let r22 = o4(t14), e9 = (0, import_react109.useRef)(false);
  (0, import_react109.useEffect)(() => (e9.current = false, () => {
    e9.current = true, t(() => {
      e9.current && r22();
    });
  }), [r22]);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/internal/portal-force-root.js
var import_react110 = __toESM(require_react(), 1);
var e7 = (0, import_react110.createContext)(false);
function a17() {
  return (0, import_react110.useContext)(e7);
}
function l14(o20) {
  return import_react110.default.createElement(e7.Provider, { value: o20.force }, o20.children);
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/portal/portal.js
function W2(e9) {
  let o20 = a17(), l19 = (0, import_react111.useContext)(c15), [r22, p13] = (0, import_react111.useState)(() => {
    var s21;
    if (!o20 && l19 !== null) return (s21 = l19.current) != null ? s21 : null;
    if (s.isServer) return null;
    let t14 = e9 == null ? void 0 : e9.getElementById("headlessui-portal-root");
    if (t14) return t14;
    if (e9 === null) return null;
    let n17 = e9.createElement("div");
    return n17.setAttribute("id", "headlessui-portal-root"), e9.body.appendChild(n17);
  });
  return (0, import_react111.useEffect)(() => {
    r22 !== null && (e9 != null && e9.body.contains(r22) || e9 == null || e9.body.appendChild(r22));
  }, [r22, e9]), (0, import_react111.useEffect)(() => {
    o20 || l19 !== null && p13(l19.current);
  }, [l19, p13, o20]), r22;
}
var _4 = import_react111.Fragment;
var j7 = Y(function(o20, l19) {
  let { ownerDocument: r22 = null, ...p13 } = o20, t14 = (0, import_react111.useRef)(null), n17 = y(T((a28) => {
    t14.current = a28;
  }), l19), s21 = u13(t14.current), C11 = r22 != null ? r22 : s21, u25 = W2(C11), y10 = (0, import_react111.useContext)(m8), g6 = p(), v11 = K();
  return c13(() => {
    var a28;
    u25 && u25.childNodes.length <= 0 && ((a28 = u25.parentElement) == null || a28.removeChild(u25));
  }), u25 ? (0, import_react_dom9.createPortal)(import_react111.default.createElement("div", { "data-headlessui-portal": "", ref: (a28) => {
    g6.dispose(), y10 && a28 && g6.add(y10.register(a28));
  } }, v11({ ourProps: { ref: n17 }, theirProps: p13, slot: {}, defaultTag: _4, name: "Portal" })), u25) : null;
});
function S7(e9, o20) {
  let l19 = y(o20), { enabled: r22 = true, ownerDocument: p13, ...t14 } = e9, n17 = K();
  return r22 ? import_react111.default.createElement(j7, { ...t14, ownerDocument: p13, ref: l19 }) : n17({ ourProps: { ref: l19 }, theirProps: t14, slot: {}, defaultTag: _4, name: "Portal" });
}
var I5 = import_react111.Fragment;
var c15 = (0, import_react111.createContext)(null);
function D6(e9, o20) {
  let { target: l19, ...r22 } = e9, t14 = { ref: y(o20) }, n17 = K();
  return import_react111.default.createElement(c15.Provider, { value: l19 }, n17({ ourProps: t14, theirProps: r22, defaultTag: I5, name: "Popover.Group" }));
}
var m8 = (0, import_react111.createContext)(null);
function ee() {
  let e9 = (0, import_react111.useContext)(m8), o20 = (0, import_react111.useRef)([]), l19 = o4((t14) => (o20.current.push(t14), e9 && e9.register(t14), () => r22(t14))), r22 = o4((t14) => {
    let n17 = o20.current.indexOf(t14);
    n17 !== -1 && o20.current.splice(n17, 1), e9 && e9.unregister(t14);
  }), p13 = (0, import_react111.useMemo)(() => ({ register: l19, unregister: r22, portals: o20 }), [l19, r22, o20]);
  return [o20, (0, import_react111.useMemo)(() => function({ children: n17 }) {
    return import_react111.default.createElement(m8.Provider, { value: p13 }, n17);
  }, [p13])];
}
var J3 = Y(S7);
var X = Y(D6);
var te = Object.assign(J3, { Group: X });

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/element-movement.js
var c16 = { Idle: { kind: "Idle" }, Tracked: (e9) => ({ kind: "Tracked", position: e9 }), Moved: { kind: "Moved" } };
function a18(e9) {
  let t14 = e9.getBoundingClientRect();
  return `${t14.x},${t14.y}`;
}
function p6(e9, t14, i16) {
  let n17 = o2();
  if (t14.kind === "Tracked") {
    let o20 = function() {
      d14 !== a18(e9) && (n17.dispose(), i16());
    };
    var f21 = o20;
    let { position: d14 } = t14, s21 = new ResizeObserver(o20);
    s21.observe(e9), n17.add(() => s21.disconnect()), n17.addEventListener(window, "scroll", o20, { passive: true }), n17.addEventListener(window, "resize", o20);
  }
  return () => n17.dispose();
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/combobox/combobox-machine.js
var I6 = Object.defineProperty;
var h7 = (t14, i16, e9) => i16 in t14 ? I6(t14, i16, { enumerable: true, configurable: true, writable: true, value: e9 }) : t14[i16] = e9;
var f15 = (t14, i16, e9) => (h7(t14, typeof i16 != "symbol" ? i16 + "" : i16, e9), e9);
var P5 = ((e9) => (e9[e9.Open = 0] = "Open", e9[e9.Closed = 1] = "Closed", e9))(P5 || {});
var k6 = ((e9) => (e9[e9.Single = 0] = "Single", e9[e9.Multi = 1] = "Multi", e9))(k6 || {});
var _5 = ((n17) => (n17[n17.Pointer = 0] = "Pointer", n17[n17.Focus = 1] = "Focus", n17[n17.Other = 2] = "Other", n17))(_5 || {});
var D7 = ((l19) => (l19[l19.OpenCombobox = 0] = "OpenCombobox", l19[l19.CloseCombobox = 1] = "CloseCombobox", l19[l19.GoToOption = 2] = "GoToOption", l19[l19.SetTyping = 3] = "SetTyping", l19[l19.RegisterOption = 4] = "RegisterOption", l19[l19.UnregisterOption = 5] = "UnregisterOption", l19[l19.DefaultToFirstOption = 6] = "DefaultToFirstOption", l19[l19.SetActivationTrigger = 7] = "SetActivationTrigger", l19[l19.UpdateVirtualConfiguration = 8] = "UpdateVirtualConfiguration", l19[l19.SetInputElement = 9] = "SetInputElement", l19[l19.SetButtonElement = 10] = "SetButtonElement", l19[l19.SetOptionsElement = 11] = "SetOptionsElement", l19[l19.MarkInputAsMoved = 12] = "MarkInputAsMoved", l19))(D7 || {});
function v8(t14, i16 = (e9) => e9) {
  let e9 = t14.activeOptionIndex !== null ? t14.options[t14.activeOptionIndex] : null, n17 = i16(t14.options.slice()), o20 = n17.length > 0 && n17[0].dataRef.current.order !== null ? n17.sort((u25, a28) => u25.dataRef.current.order - a28.dataRef.current.order) : G2(n17, (u25) => u25.dataRef.current.domRef.current), r22 = e9 ? o20.indexOf(e9) : null;
  return r22 === -1 && (r22 = null), { options: o20, activeOptionIndex: r22 };
}
var j8 = { [1](t14) {
  var e9;
  if ((e9 = t14.dataRef.current) != null && e9.disabled || t14.comboboxState === 1) return t14;
  let i16 = t14.inputElement ? c16.Tracked(a18(t14.inputElement)) : t14.inputPositionState;
  return { ...t14, activeOptionIndex: null, comboboxState: 1, isTyping: false, activationTrigger: 2, inputPositionState: i16, __demoMode: false };
}, [0](t14) {
  var i16, e9;
  if ((i16 = t14.dataRef.current) != null && i16.disabled || t14.comboboxState === 0) return t14;
  if ((e9 = t14.dataRef.current) != null && e9.value) {
    let n17 = t14.dataRef.current.calculateIndex(t14.dataRef.current.value);
    if (n17 !== -1) return { ...t14, activeOptionIndex: n17, comboboxState: 0, __demoMode: false, inputPositionState: c16.Idle };
  }
  return { ...t14, comboboxState: 0, inputPositionState: c16.Idle, __demoMode: false };
}, [3](t14, i16) {
  return t14.isTyping === i16.isTyping ? t14 : { ...t14, isTyping: i16.isTyping };
}, [2](t14, i16) {
  var r22, u25, a28, s21;
  if ((r22 = t14.dataRef.current) != null && r22.disabled || t14.optionsElement && !((u25 = t14.dataRef.current) != null && u25.optionsPropsRef.current.static) && t14.comboboxState === 1) return t14;
  if (t14.virtual) {
    let { options: p13, disabled: c21 } = t14.virtual, m10 = i16.focus === c12.Specific ? i16.idx : f14(i16, { resolveItems: () => p13, resolveActiveIndex: () => {
      var l19, x10;
      return (x10 = (l19 = t14.activeOptionIndex) != null ? l19 : p13.findIndex((S11) => !c21(S11))) != null ? x10 : null;
    }, resolveDisabled: c21, resolveId() {
      throw new Error("Function not implemented.");
    } }), b14 = (a28 = i16.trigger) != null ? a28 : 2;
    return t14.activeOptionIndex === m10 && t14.activationTrigger === b14 ? t14 : { ...t14, activeOptionIndex: m10, activationTrigger: b14, isTyping: false, __demoMode: false };
  }
  let e9 = v8(t14);
  if (e9.activeOptionIndex === null) {
    let p13 = e9.options.findIndex((c21) => !c21.dataRef.current.disabled);
    p13 !== -1 && (e9.activeOptionIndex = p13);
  }
  let n17 = i16.focus === c12.Specific ? i16.idx : f14(i16, { resolveItems: () => e9.options, resolveActiveIndex: () => e9.activeOptionIndex, resolveId: (p13) => p13.id, resolveDisabled: (p13) => p13.dataRef.current.disabled }), o20 = (s21 = i16.trigger) != null ? s21 : 2;
  return t14.activeOptionIndex === n17 && t14.activationTrigger === o20 ? t14 : { ...t14, ...e9, isTyping: false, activeOptionIndex: n17, activationTrigger: o20, __demoMode: false };
}, [4]: (t14, i16) => {
  var r22, u25, a28, s21;
  if ((r22 = t14.dataRef.current) != null && r22.virtual) return { ...t14, options: [...t14.options, i16.payload] };
  let e9 = i16.payload, n17 = v8(t14, (p13) => (p13.push(e9), p13));
  t14.activeOptionIndex === null && (a28 = (u25 = t14.dataRef.current).isSelected) != null && a28.call(u25, i16.payload.dataRef.current.value) && (n17.activeOptionIndex = n17.options.indexOf(e9));
  let o20 = { ...t14, ...n17, activationTrigger: 2 };
  return (s21 = t14.dataRef.current) != null && s21.__demoMode && t14.dataRef.current.value === void 0 && (o20.activeOptionIndex = 0), o20;
}, [5]: (t14, i16) => {
  var n17;
  if ((n17 = t14.dataRef.current) != null && n17.virtual) return { ...t14, options: t14.options.filter((o20) => o20.id !== i16.id) };
  let e9 = v8(t14, (o20) => {
    let r22 = o20.findIndex((u25) => u25.id === i16.id);
    return r22 !== -1 && o20.splice(r22, 1), o20;
  });
  return { ...t14, ...e9, activationTrigger: 2 };
}, [6]: (t14, i16) => t14.defaultToFirstOption === i16.value ? t14 : { ...t14, defaultToFirstOption: i16.value }, [7]: (t14, i16) => t14.activationTrigger === i16.trigger ? t14 : { ...t14, activationTrigger: i16.trigger }, [8]: (t14, i16) => {
  var n17, o20;
  if (t14.virtual === null) return { ...t14, virtual: { options: i16.options, disabled: (n17 = i16.disabled) != null ? n17 : () => false } };
  if (t14.virtual.options === i16.options && t14.virtual.disabled === i16.disabled) return t14;
  let e9 = t14.activeOptionIndex;
  if (t14.activeOptionIndex !== null) {
    let r22 = i16.options.indexOf(t14.virtual.options[t14.activeOptionIndex]);
    r22 !== -1 ? e9 = r22 : e9 = null;
  }
  return { ...t14, activeOptionIndex: e9, virtual: { options: i16.options, disabled: (o20 = i16.disabled) != null ? o20 : () => false } };
}, [9]: (t14, i16) => t14.inputElement === i16.element ? t14 : { ...t14, inputElement: i16.element }, [10]: (t14, i16) => t14.buttonElement === i16.element ? t14 : { ...t14, buttonElement: i16.element }, [11]: (t14, i16) => t14.optionsElement === i16.element ? t14 : { ...t14, optionsElement: i16.element }, [12](t14) {
  return t14.inputPositionState.kind !== "Tracked" ? t14 : { ...t14, inputPositionState: c16.Moved };
} };
var y6 = class _y extends T3 {
  constructor(e9) {
    super(e9);
    f15(this, "actions", { onChange: (e10) => {
      let { onChange: n17, compare: o20, mode: r22, value: u25 } = this.state.dataRef.current;
      return u(r22, { [0]: () => n17 == null ? void 0 : n17(e10), [1]: () => {
        let a28 = u25.slice(), s21 = a28.findIndex((p13) => o20(p13, e10));
        return s21 === -1 ? a28.push(e10) : a28.splice(s21, 1), n17 == null ? void 0 : n17(a28);
      } });
    }, registerOption: (e10, n17) => (this.send({ type: 4, payload: { id: e10, dataRef: n17 } }), () => {
      this.state.activeOptionIndex === this.state.dataRef.current.calculateIndex(n17.current.value) && this.send({ type: 6, value: true }), this.send({ type: 5, id: e10 });
    }), goToOption: (e10, n17) => (this.send({ type: 6, value: false }), this.send({ type: 2, ...e10, trigger: n17 })), setIsTyping: (e10) => {
      this.send({ type: 3, isTyping: e10 });
    }, closeCombobox: () => {
      var e10, n17;
      this.send({ type: 1 }), this.send({ type: 6, value: false }), (n17 = (e10 = this.state.dataRef.current).onClose) == null || n17.call(e10);
    }, openCombobox: () => {
      this.send({ type: 0 }), this.send({ type: 6, value: true });
    }, setActivationTrigger: (e10) => {
      this.send({ type: 7, trigger: e10 });
    }, selectActiveOption: () => {
      let e10 = this.selectors.activeOptionIndex(this.state);
      if (e10 !== null) {
        if (this.actions.setIsTyping(false), this.state.virtual) this.actions.onChange(this.state.virtual.options[e10]);
        else {
          let { dataRef: n17 } = this.state.options[e10];
          this.actions.onChange(n17.current.value);
        }
        this.actions.goToOption({ focus: c12.Specific, idx: e10 });
      }
    }, setInputElement: (e10) => {
      this.send({ type: 9, element: e10 });
    }, setButtonElement: (e10) => {
      this.send({ type: 10, element: e10 });
    }, setOptionsElement: (e10) => {
      this.send({ type: 11, element: e10 });
    } });
    f15(this, "selectors", { activeDescendantId: (e10) => {
      var o20, r22;
      let n17 = this.selectors.activeOptionIndex(e10);
      if (n17 !== null) return e10.virtual ? (r22 = e10.options.find((u25) => !u25.dataRef.current.disabled && e10.dataRef.current.compare(u25.dataRef.current.value, e10.virtual.options[n17]))) == null ? void 0 : r22.id : (o20 = e10.options[n17]) == null ? void 0 : o20.id;
    }, activeOptionIndex: (e10) => {
      if (e10.defaultToFirstOption && e10.activeOptionIndex === null && (e10.virtual ? e10.virtual.options.length > 0 : e10.options.length > 0)) {
        if (e10.virtual) {
          let { options: o20, disabled: r22 } = e10.virtual, u25 = o20.findIndex((a28) => {
            var s21;
            return !((s21 = r22 == null ? void 0 : r22(a28)) != null && s21);
          });
          if (u25 !== -1) return u25;
        }
        let n17 = e10.options.findIndex((o20) => !o20.dataRef.current.disabled);
        if (n17 !== -1) return n17;
      }
      return e10.activeOptionIndex;
    }, activeOption: (e10) => {
      var o20, r22;
      let n17 = this.selectors.activeOptionIndex(e10);
      return n17 === null ? null : e10.virtual ? e10.virtual.options[n17 != null ? n17 : 0] : (r22 = (o20 = e10.options[n17]) == null ? void 0 : o20.dataRef.current.value) != null ? r22 : null;
    }, isActive: (e10, n17, o20) => {
      var u25;
      let r22 = this.selectors.activeOptionIndex(e10);
      return r22 === null ? false : e10.virtual ? r22 === e10.dataRef.current.calculateIndex(n17) : ((u25 = e10.options[r22]) == null ? void 0 : u25.id) === o20;
    }, shouldScrollIntoView: (e10, n17, o20) => !(e10.virtual || e10.__demoMode || e10.comboboxState !== 0 || e10.activationTrigger === 0 || !this.selectors.isActive(e10, n17, o20)), didInputMove(e10) {
      return e10.inputPositionState.kind === "Moved";
    } });
    {
      let n17 = this.state.id, o20 = x2.get(null);
      this.disposables.add(o20.on(k4.Push, (r22) => {
        !o20.selectors.isTop(r22, n17) && this.state.comboboxState === 0 && this.actions.closeCombobox();
      })), this.on(0, () => o20.actions.push(n17)), this.on(1, () => o20.actions.pop(n17));
    }
    this.disposables.group((n17) => {
      this.on(1, (o20) => {
        o20.inputElement && (n17.dispose(), n17.add(p6(o20.inputElement, o20.inputPositionState, () => {
          this.send({ type: 12 });
        })));
      });
    });
  }
  static new({ id: e9, virtual: n17 = null, __demoMode: o20 = false }) {
    var r22;
    return new _y({ id: e9, dataRef: { current: {} }, comboboxState: o20 ? 0 : 1, isTyping: false, options: [], virtual: n17 ? { options: n17.options, disabled: (r22 = n17.disabled) != null ? r22 : () => false } : null, activeOptionIndex: null, activationTrigger: 2, inputElement: null, buttonElement: null, optionsElement: null, __demoMode: o20, inputPositionState: c16.Idle });
  }
  reduce(e9, n17) {
    return u(n17.type, j8, e9, n17);
  }
};

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/combobox/combobox-machine-glue.js
var import_react112 = __toESM(require_react(), 1);
var u20 = (0, import_react112.createContext)(null);
function p7(n17) {
  let o20 = (0, import_react112.useContext)(u20);
  if (o20 === null) {
    let e9 = new Error(`<${n17} /> is missing a parent <Combobox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(e9, b7), e9;
  }
  return o20;
}
function b7({ id: n17, virtual: o20 = null, __demoMode: e9 = false }) {
  let t14 = (0, import_react112.useMemo)(() => y6.new({ id: n17, virtual: o20, __demoMode: e9 }), []);
  return c13(() => t14.dispose()), t14;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/combobox/combobox.js
var de2 = (0, import_react113.createContext)(null);
de2.displayName = "ComboboxDataContext";
function te2(T11) {
  let O5 = (0, import_react113.useContext)(de2);
  if (O5 === null) {
    let e9 = new Error(`<${T11} /> is missing a parent <Combobox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(e9, te2), e9;
  }
  return O5;
}
var Le = (0, import_react113.createContext)(null);
function Eo(T11) {
  let O5 = p7("VirtualProvider"), e9 = te2("VirtualProvider"), { options: o20 } = e9.virtual, E13 = S3(O5, (a28) => a28.optionsElement), [R7, y10] = (0, import_react113.useMemo)(() => {
    let a28 = E13;
    if (!a28) return [0, 0];
    let u25 = window.getComputedStyle(a28);
    return [parseFloat(u25.paddingBlockStart || u25.paddingTop), parseFloat(u25.paddingBlockEnd || u25.paddingBottom)];
  }, [E13]), b14 = useVirtualizer({ enabled: o20.length !== 0, scrollPaddingStart: R7, scrollPaddingEnd: y10, count: o20.length, estimateSize() {
    return 40;
  }, getScrollElement() {
    return O5.state.optionsElement;
  }, overscan: 12 }), [h16, p13] = (0, import_react113.useState)(0);
  n(() => {
    p13((a28) => a28 + 1);
  }, [o20]);
  let f21 = b14.getVirtualItems(), n17 = S3(O5, (a28) => a28.activationTrigger === _5.Pointer), m10 = S3(O5, O5.selectors.activeOptionIndex);
  return f21.length === 0 ? null : import_react113.default.createElement(Le.Provider, { value: b14 }, import_react113.default.createElement("div", { style: { position: "relative", width: "100%", height: `${b14.getTotalSize()}px` }, ref: (a28) => {
    a28 && (n17 || m10 !== null && o20.length > m10 && b14.scrollToIndex(m10));
  } }, f21.map((a28) => {
    var u25;
    return import_react113.default.createElement(import_react113.Fragment, { key: a28.key }, import_react113.default.cloneElement((u25 = T11.children) == null ? void 0 : u25.call(T11, { ...T11.slot, option: o20[a28.index] }), { key: `${h16}-${a28.key}`, "data-index": a28.index, "aria-setsize": o20.length, "aria-posinset": a28.index + 1, style: { position: "absolute", top: 0, left: 0, transform: `translateY(${a28.start}px)`, overflowAnchor: "none" } }));
  })));
}
var ho = import_react113.Fragment;
function Ao(T11, O5) {
  let e9 = (0, import_react74.useId)(), o20 = a3(), { value: E13, defaultValue: R7, onChange: y10, form: b14, name: h16, by: p13, invalid: f21 = false, disabled: n17 = o20 || false, onClose: m10, __demoMode: a28 = false, multiple: u25 = false, immediate: A5 = false, virtual: d14 = null, nullable: X5, ...G6 } = T11, C11 = l3(R7), [x10 = u25 ? [] : void 0, v11] = b2(E13, y10, C11), c21 = b7({ id: e9, virtual: d14, __demoMode: a28 }), z4 = (0, import_react113.useRef)({ static: false, hold: false }), D13 = u9(p13), K4 = o4((i16) => d14 ? p13 === null ? d14.options.indexOf(i16) : d14.options.findIndex((M12) => D13(M12, i16)) : c21.state.options.findIndex((M12) => D13(M12.dataRef.current.value, i16))), W5 = (0, import_react113.useCallback)((i16) => u(l19.mode, { [k6.Multi]: () => x10.some((M12) => D13(M12, i16)), [k6.Single]: () => D13(x10, i16) }), [x10]), S11 = S3(c21, (i16) => i16.virtual), j11 = o4(() => m10 == null ? void 0 : m10()), l19 = (0, import_react113.useMemo)(() => ({ __demoMode: a28, immediate: A5, optionsPropsRef: z4, value: x10, defaultValue: C11, disabled: n17, invalid: f21, mode: u25 ? k6.Multi : k6.Single, virtual: d14 ? S11 : null, onChange: v11, isSelected: W5, calculateIndex: K4, compare: D13, onClose: j11 }), [a28, A5, z4, x10, C11, n17, f21, u25, d14, S11, v11, W5, K4, D13, j11]);
  n(() => {
    var i16;
    d14 && c21.send({ type: D7.UpdateVirtualConfiguration, options: d14.options, disabled: (i16 = d14.disabled) != null ? i16 : null });
  }, [d14, d14 == null ? void 0 : d14.options, d14 == null ? void 0 : d14.disabled]), n(() => {
    c21.state.dataRef.current = l19;
  }, [l19]);
  let [k13, Y4, s21, U3] = S3(c21, (i16) => [i16.comboboxState, i16.buttonElement, i16.inputElement, i16.optionsElement]), $7 = x2.get(null), ne4 = S3($7, (0, import_react113.useCallback)((i16) => $7.selectors.isTop(i16, e9), [$7, e9]));
  k5(ne4, [Y4, s21, U3], () => c21.actions.closeCombobox());
  let be3 = S3(c21, c21.selectors.activeOptionIndex), ee7 = S3(c21, c21.selectors.activeOption), q5 = n2({ open: k13 === P5.Open, disabled: n17, invalid: f21, activeIndex: be3, activeOption: ee7, value: x10 }), [t14, V6] = V2(), P8 = O5 === null ? {} : { ref: O5 }, N4 = (0, import_react113.useCallback)(() => {
    if (C11 !== void 0) return v11 == null ? void 0 : v11(C11);
  }, [v11, C11]), g6 = K();
  return import_react113.default.createElement(V6, { value: t14, props: { htmlFor: s21 == null ? void 0 : s21.id }, slot: { open: k13 === P5.Open, disabled: n17 } }, import_react113.default.createElement(Ae, null, import_react113.default.createElement(de2.Provider, { value: l19 }, import_react113.default.createElement(u20.Provider, { value: c21 }, import_react113.default.createElement(c11, { value: u(k13, { [P5.Open]: i10.Open, [P5.Closed]: i10.Closed }) }, h16 != null && import_react113.default.createElement(j2, { disabled: n17, data: x10 != null ? { [h16]: x10 } : {}, form: b14, onReset: N4 }), g6({ ourProps: P8, theirProps: G6, slot: q5, defaultTag: ho, name: "Combobox" }))))));
}
var Io = "input";
function Ro(T11, O5) {
  var ee7, q5;
  let e9 = p7("Combobox.Input"), o20 = te2("Combobox.Input"), E13 = (0, import_react74.useId)(), R7 = u4(), { id: y10 = R7 || `headlessui-combobox-input-${E13}`, onChange: b14, displayValue: h16, disabled: p13 = o20.disabled || false, autoFocus: f21 = false, type: n17 = "text", ...m10 } = T11, a28 = (0, import_react113.useRef)(null), u25 = y(a28, O5, Fe(), e9.actions.setInputElement), [A5, d14] = S3(e9, (t14) => [t14.comboboxState, t14.isTyping]), X5 = p(), G6 = o4(() => {
    e9.actions.onChange(null), e9.state.optionsElement && (e9.state.optionsElement.scrollTop = 0), e9.actions.goToOption({ focus: c12.Nothing });
  }), C11 = (0, import_react113.useMemo)(() => {
    var t14;
    return typeof h16 == "function" && o20.value !== void 0 ? (t14 = h16(o20.value)) != null ? t14 : "" : typeof o20.value == "string" ? o20.value : "";
  }, [o20.value, h16]);
  m7(([t14, V6], [P8, N4]) => {
    if (e9.state.isTyping) return;
    let g6 = a28.current;
    g6 && ((N4 === P5.Open && V6 === P5.Closed || t14 !== P8) && (g6.value = t14), requestAnimationFrame(() => {
      if (e9.state.isTyping || !g6 || d2(g6)) return;
      let { selectionStart: i16, selectionEnd: M12 } = g6;
      Math.abs((M12 != null ? M12 : 0) - (i16 != null ? i16 : 0)) === 0 && i16 === 0 && g6.setSelectionRange(g6.value.length, g6.value.length);
    }));
  }, [C11, A5, d14]), m7(([t14], [V6]) => {
    if (t14 === P5.Open && V6 === P5.Closed) {
      if (e9.state.isTyping) return;
      let P8 = a28.current;
      if (!P8) return;
      let N4 = P8.value, { selectionStart: g6, selectionEnd: i16, selectionDirection: M12 } = P8;
      P8.value = "", P8.value = N4, M12 !== null ? P8.setSelectionRange(g6, i16, M12) : P8.setSelectionRange(g6, i16);
    }
  }, [A5]);
  let x10 = (0, import_react113.useRef)(false), v11 = o4(() => {
    x10.current = true;
  }), c21 = o4(() => {
    X5.nextFrame(() => {
      x10.current = false;
    });
  }), z4 = o4((t14) => {
    switch (e9.actions.setIsTyping(true), t14.key) {
      case o8.Enter:
        if (e9.state.comboboxState !== P5.Open || x10.current) return;
        if (t14.preventDefault(), t14.stopPropagation(), e9.selectors.activeOptionIndex(e9.state) === null) {
          e9.actions.closeCombobox();
          return;
        }
        e9.actions.selectActiveOption(), o20.mode === k6.Single && e9.actions.closeCombobox();
        break;
      case o8.ArrowDown:
        return t14.preventDefault(), t14.stopPropagation(), u(e9.state.comboboxState, { [P5.Open]: () => e9.actions.goToOption({ focus: c12.Next }), [P5.Closed]: () => e9.actions.openCombobox() });
      case o8.ArrowUp:
        return t14.preventDefault(), t14.stopPropagation(), u(e9.state.comboboxState, { [P5.Open]: () => e9.actions.goToOption({ focus: c12.Previous }), [P5.Closed]: () => {
          (0, import_react_dom10.flushSync)(() => e9.actions.openCombobox()), o20.value || e9.actions.goToOption({ focus: c12.Last });
        } });
      case o8.Home:
        if (e9.state.comboboxState === P5.Closed || t14.shiftKey) break;
        return t14.preventDefault(), t14.stopPropagation(), e9.actions.goToOption({ focus: c12.First });
      case o8.PageUp:
        return t14.preventDefault(), t14.stopPropagation(), e9.actions.goToOption({ focus: c12.First });
      case o8.End:
        if (e9.state.comboboxState === P5.Closed || t14.shiftKey) break;
        return t14.preventDefault(), t14.stopPropagation(), e9.actions.goToOption({ focus: c12.Last });
      case o8.PageDown:
        return t14.preventDefault(), t14.stopPropagation(), e9.actions.goToOption({ focus: c12.Last });
      case o8.Escape:
        return e9.state.comboboxState !== P5.Open ? void 0 : (t14.preventDefault(), e9.state.optionsElement && !o20.optionsPropsRef.current.static && t14.stopPropagation(), o20.mode === k6.Single && o20.value === null && G6(), e9.actions.closeCombobox());
      case o8.Tab:
        if (e9.actions.setIsTyping(false), e9.state.comboboxState !== P5.Open) return;
        o20.mode === k6.Single && e9.state.activationTrigger !== _5.Focus && e9.actions.selectActiveOption(), e9.actions.closeCombobox();
        break;
    }
  }), D13 = o4((t14) => {
    b14 == null || b14(t14), o20.mode === k6.Single && t14.target.value === "" && G6(), e9.actions.openCombobox();
  }), K4 = o4((t14) => {
    var P8, N4, g6;
    let V6 = (P8 = t14.relatedTarget) != null ? P8 : n13.find((i16) => i16 !== t14.currentTarget);
    if (!((N4 = e9.state.optionsElement) != null && N4.contains(V6)) && !((g6 = e9.state.buttonElement) != null && g6.contains(V6)) && e9.state.comboboxState === P5.Open) return t14.preventDefault(), o20.mode === k6.Single && o20.value === null && G6(), e9.actions.closeCombobox();
  }), W5 = o4((t14) => {
    var P8, N4, g6;
    let V6 = (P8 = t14.relatedTarget) != null ? P8 : n13.find((i16) => i16 !== t14.currentTarget);
    (N4 = e9.state.buttonElement) != null && N4.contains(V6) || (g6 = e9.state.optionsElement) != null && g6.contains(V6) || o20.disabled || o20.immediate && e9.state.comboboxState !== P5.Open && X5.microTask(() => {
      (0, import_react_dom10.flushSync)(() => e9.actions.openCombobox()), e9.actions.setActivationTrigger(_5.Focus);
    });
  }), S11 = N(), j11 = w3(), { isFocused: l19, focusProps: k13 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: f21 }), { isHovered: Y4, hoverProps: s21 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: p13 }), U3 = S3(e9, (t14) => t14.optionsElement), $7 = n2({ open: A5 === P5.Open, disabled: p13, invalid: o20.invalid, hover: Y4, focus: l19, autofocus: f21 }), ne4 = V({ ref: u25, id: y10, role: "combobox", type: n17, "aria-controls": U3 == null ? void 0 : U3.id, "aria-expanded": A5 === P5.Open, "aria-activedescendant": S3(e9, e9.selectors.activeDescendantId), "aria-labelledby": S11, "aria-describedby": j11, "aria-autocomplete": "list", defaultValue: (q5 = (ee7 = T11.defaultValue) != null ? ee7 : o20.defaultValue !== void 0 ? h16 == null ? void 0 : h16(o20.defaultValue) : null) != null ? q5 : o20.defaultValue, disabled: p13 || void 0, autoFocus: f21, onCompositionStart: v11, onCompositionEnd: c21, onKeyDown: z4, onChange: D13, onFocus: W5, onBlur: K4 }, k13, s21);
  return K()({ ourProps: ne4, theirProps: m10, slot: $7, defaultTag: Io, name: "Combobox.Input" });
}
var _o = "button";
function Fo(T11, O5) {
  let e9 = p7("Combobox.Button"), o20 = te2("Combobox.Button"), [E13, R7] = (0, import_react113.useState)(null), y10 = y(O5, R7, e9.actions.setButtonElement), b14 = (0, import_react74.useId)(), { id: h16 = `headlessui-combobox-button-${b14}`, disabled: p13 = o20.disabled || false, autoFocus: f21 = false, ...n17 } = T11, [m10, a28, u25] = S3(e9, (l19) => [l19.comboboxState, l19.inputElement, l19.optionsElement]), A5 = v6(a28), d14 = m10 === P5.Open;
  L4(d14, { trigger: E13, action: (0, import_react113.useCallback)((l19) => {
    if (E13 != null && E13.contains(l19.target)) return S5.Ignore;
    if (a28 != null && a28.contains(l19.target)) return S5.Ignore;
    let k13 = l19.target.closest('[role="option"]:not([data-disabled])');
    return n5(k13) ? S5.Select(k13) : u25 != null && u25.contains(l19.target) ? S5.Ignore : S5.Close;
  }, [E13, a28, u25]), close: e9.actions.closeCombobox, select: e9.actions.selectActiveOption });
  let X5 = o4((l19) => {
    switch (l19.key) {
      case o8.Space:
      case o8.Enter:
        l19.preventDefault(), l19.stopPropagation(), e9.state.comboboxState === P5.Closed && (0, import_react_dom10.flushSync)(() => e9.actions.openCombobox()), A5();
        return;
      case o8.ArrowDown:
        l19.preventDefault(), l19.stopPropagation(), e9.state.comboboxState === P5.Closed && ((0, import_react_dom10.flushSync)(() => e9.actions.openCombobox()), e9.state.dataRef.current.value || e9.actions.goToOption({ focus: c12.First })), A5();
        return;
      case o8.ArrowUp:
        l19.preventDefault(), l19.stopPropagation(), e9.state.comboboxState === P5.Closed && ((0, import_react_dom10.flushSync)(() => e9.actions.openCombobox()), e9.state.dataRef.current.value || e9.actions.goToOption({ focus: c12.Last })), A5();
        return;
      case o8.Escape:
        if (e9.state.comboboxState !== P5.Open) return;
        l19.preventDefault(), e9.state.optionsElement && !o20.optionsPropsRef.current.static && l19.stopPropagation(), (0, import_react_dom10.flushSync)(() => e9.actions.closeCombobox()), A5();
        return;
      default:
        return;
    }
  }), G6 = s8(() => {
    e9.state.comboboxState === P5.Open ? e9.actions.closeCombobox() : e9.actions.openCombobox(), A5();
  }), C11 = N([h16]), { isFocusVisible: x10, focusProps: v11 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: f21 }), { isHovered: c21, hoverProps: z4 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: p13 }), { pressed: D13, pressProps: K4 } = w({ disabled: p13 }), W5 = n2({ open: m10 === P5.Open, active: D13 || m10 === P5.Open, disabled: p13, invalid: o20.invalid, value: o20.value, hover: c21, focus: x10 }), S11 = V({ ref: y10, id: h16, type: e5(T11, E13), tabIndex: -1, "aria-haspopup": "listbox", "aria-controls": u25 == null ? void 0 : u25.id, "aria-expanded": m10 === P5.Open, "aria-labelledby": C11, disabled: p13 || void 0, autoFocus: f21, onKeyDown: X5 }, G6, v11, z4, K4);
  return K()({ ourProps: S11, theirProps: n17, slot: W5, defaultTag: _o, name: "Combobox.Button" });
}
var Do = "div";
var So = A.RenderStrategy | A.Static;
function Mo(T11, O5) {
  var M12, Ce5, ve3;
  let e9 = (0, import_react74.useId)(), { id: o20 = `headlessui-combobox-options-${e9}`, hold: E13 = false, anchor: R7, portal: y10 = false, modal: b14 = true, transition: h16 = false, ...p13 } = T11, f21 = p7("Combobox.Options"), n17 = te2("Combobox.Options"), m10 = ye(R7);
  m10 && (y10 = true);
  let [a28, u25] = Re(m10), [A5, d14] = (0, import_react113.useState)(null), X5 = Te(), G6 = y(O5, m10 ? a28 : null, f21.actions.setOptionsElement, d14), [C11, x10, v11, c21, z4] = S3(f21, (_10) => [_10.comboboxState, _10.inputElement, _10.buttonElement, _10.optionsElement, _10.activationTrigger]), D13 = u13(x10 || v11), K4 = u13(c21), W5 = u17(), [S11, j11] = N2(h16, A5, W5 !== null ? (W5 & i10.Open) === i10.Open : C11 === P5.Open);
  p5(S11, x10, f21.actions.closeCombobox);
  let l19 = n17.__demoMode ? false : b14 && C11 === P5.Open;
  f11(l19, K4);
  let k13 = n17.__demoMode ? false : b14 && C11 === P5.Open;
  y4(k13, { allowed: (0, import_react113.useCallback)(() => [x10, v11, c21], [x10, v11, c21]) });
  let s21 = S3(f21, f21.selectors.didInputMove) ? false : S11;
  n(() => {
    var _10;
    n17.optionsPropsRef.current.static = (_10 = T11.static) != null ? _10 : false;
  }, [n17.optionsPropsRef, T11.static]), n(() => {
    n17.optionsPropsRef.current.hold = E13;
  }, [n17.optionsPropsRef, E13]), F2(C11 === P5.Open, { container: c21, accept(_10) {
    return _10.getAttribute("role") === "option" ? NodeFilter.FILTER_REJECT : _10.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(_10) {
    _10.setAttribute("role", "none");
  } });
  let U3 = N([v11 == null ? void 0 : v11.id]), $7 = n2({ open: C11 === P5.Open, option: void 0 }), ne4 = o4(() => {
    f21.actions.setActivationTrigger(_5.Pointer);
  }), be3 = o4((_10) => {
    _10.preventDefault(), f21.actions.setActivationTrigger(_5.Pointer);
  }), ee7 = V(m10 ? X5() : {}, { "aria-labelledby": U3, role: "listbox", "aria-multiselectable": n17.mode === k6.Multi ? true : void 0, id: o20, ref: G6, style: { ...p13.style, ...u25, "--input-width": w5(S11, x10, true).width, "--button-width": w5(S11, v11, true).width }, onWheel: z4 === _5.Pointer ? void 0 : ne4, onMouseDown: be3, ...x4(j11) }), q5 = S11 && C11 === P5.Closed && !T11.static, t14 = u16(q5, (M12 = n17.virtual) == null ? void 0 : M12.options), V6 = u16(q5, n17.value), P8 = (0, import_react113.useCallback)((_10) => n17.compare(V6, _10), [n17.compare, V6]), N4 = (0, import_react113.useMemo)(() => {
    if (!n17.virtual) return n17;
    if (t14 === void 0) throw new Error("Missing `options` in virtual mode");
    return t14 !== n17.virtual.options ? { ...n17, virtual: { ...n17.virtual, options: t14 } } : n17;
  }, [n17, t14, (Ce5 = n17.virtual) == null ? void 0 : Ce5.options]);
  n17.virtual && Object.assign(p13, { children: import_react113.default.createElement(de2.Provider, { value: N4 }, import_react113.default.createElement(Eo, { slot: $7 }, p13.children)) });
  let g6 = K(), i16 = (0, import_react113.useMemo)(() => n17.mode === k6.Multi ? n17 : { ...n17, isSelected: P8 }, [n17, P8]);
  return import_react113.default.createElement(te, { enabled: y10 ? T11.static || S11 : false, ownerDocument: D13 }, import_react113.default.createElement(de2.Provider, { value: i16 }, g6({ ourProps: ee7, theirProps: { ...p13, children: import_react113.default.createElement(s12, { freeze: q5 }, typeof p13.children == "function" ? (ve3 = p13.children) == null ? void 0 : ve3.call(p13, $7) : p13.children) }, slot: $7, defaultTag: Do, features: So, visible: s21, name: "Combobox.Options" })));
}
var Lo = "div";
function Vo(T11, O5) {
  var l19, k13, Y4;
  let e9 = te2("Combobox.Option"), o20 = p7("Combobox.Option"), E13 = (0, import_react74.useId)(), { id: R7 = `headlessui-combobox-option-${E13}`, value: y10, disabled: b14 = (Y4 = (k13 = (l19 = e9.virtual) == null ? void 0 : l19.disabled) == null ? void 0 : k13.call(l19, y10)) != null ? Y4 : false, order: h16 = null, ...p13 } = T11, [f21] = S3(o20, (s21) => [s21.inputElement]), n17 = v6(f21), m10 = S3(o20, (0, import_react113.useCallback)((s21) => o20.selectors.isActive(s21, y10, R7), [y10, R7])), a28 = e9.isSelected(y10), u25 = (0, import_react113.useRef)(null), A5 = s3({ disabled: b14, value: y10, domRef: u25, order: h16 }), d14 = (0, import_react113.useContext)(Le), X5 = y(O5, u25, d14 ? d14.measureElement : null), G6 = o4(() => {
    o20.actions.setIsTyping(false), o20.actions.onChange(y10);
  });
  n(() => o20.actions.registerOption(R7, A5), [A5, R7]);
  let C11 = S3(o20, (0, import_react113.useCallback)((s21) => o20.selectors.shouldScrollIntoView(s21, y10, R7), [y10, R7]));
  n(() => {
    if (C11) return o2().requestAnimationFrame(() => {
      var s21, U3;
      (U3 = (s21 = u25.current) == null ? void 0 : s21.scrollIntoView) == null || U3.call(s21, { block: "nearest" });
    });
  }, [C11, u25]);
  let x10 = o4((s21) => {
    s21.preventDefault(), s21.button === g3.Left && (b14 || (G6(), n11() || requestAnimationFrame(() => n17()), e9.mode === k6.Single && o20.actions.closeCombobox()));
  }), v11 = o4(() => {
    if (b14) return o20.actions.goToOption({ focus: c12.Nothing });
    let s21 = e9.calculateIndex(y10);
    o20.actions.goToOption({ focus: c12.Specific, idx: s21 });
  }), c21 = u15(), z4 = o4((s21) => c21.update(s21)), D13 = o4((s21) => {
    if (!c21.wasMoved(s21) || b14 || m10 && o20.state.activationTrigger === _5.Pointer) return;
    let U3 = e9.calculateIndex(y10);
    o20.actions.goToOption({ focus: c12.Specific, idx: U3 }, _5.Pointer);
  }), K4 = o4((s21) => {
    c21.wasMoved(s21) && (b14 || m10 && (e9.optionsPropsRef.current.hold || o20.state.activationTrigger === _5.Pointer && o20.actions.goToOption({ focus: c12.Nothing })));
  }), W5 = n2({ active: m10, focus: m10, selected: a28, disabled: b14 }), S11 = { id: R7, ref: X5, role: "option", tabIndex: b14 === true ? void 0 : -1, "aria-disabled": b14 === true ? true : void 0, "aria-selected": a28, disabled: void 0, onMouseDown: x10, onFocus: v11, onPointerEnter: z4, onMouseEnter: z4, onPointerMove: D13, onMouseMove: D13, onPointerLeave: K4, onMouseLeave: K4 };
  return K()({ ourProps: S11, theirProps: p13, slot: W5, defaultTag: Lo, name: "Combobox.Option" });
}
var wo = Y(Ao);
var Bo = Y(Fo);
var ko = Y(Ro);
var No = Z;
var Uo = Y(Mo);
var Ho = Y(Vo);
var Ht = Object.assign(wo, { Input: ko, Button: Bo, Label: No, Options: Uo, Option: Ho });

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/data-interactive/data-interactive.js
var import_react114 = __toESM(require_react(), 1);
var E10 = import_react114.Fragment;
function d8(t14, r22) {
  let { ...a28 } = t14, e9 = false, { isFocusVisible: o20, focusProps: n17 } = $f7dceffc5ad7768b$export$4e328f61c538687f(), { isHovered: p13, hoverProps: s21 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e9 }), { pressed: i16, pressProps: T11 } = w({ disabled: e9 }), l19 = V({ ref: r22 }, n17, s21, T11), m10 = n2({ hover: p13, focus: o20, active: i16 });
  return K()({ ourProps: l19, theirProps: a28, slot: m10, defaultTag: E10, name: "DataInteractive" });
}
var b8 = Y(d8);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/dialog/dialog.js
var import_react121 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-escape.js
function a20(o20, r22 = typeof document != "undefined" ? document.defaultView : null, t14) {
  let n17 = I3(o20, "escape");
  E7(r22, "keydown", (e9) => {
    n17 && (e9.defaultPrevented || e9.key === o8.Escape && t14(e9));
  });
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-is-touch-device.js
var import_react115 = __toESM(require_react(), 1);
function f16() {
  var t14;
  let [e9] = (0, import_react115.useState)(() => typeof window != "undefined" && typeof window.matchMedia == "function" ? window.matchMedia("(pointer: coarse)") : null), [o20, c21] = (0, import_react115.useState)((t14 = e9 == null ? void 0 : e9.matches) != null ? t14 : false);
  return n(() => {
    if (!e9) return;
    function n17(r22) {
      c21(r22.matches);
    }
    return e9.addEventListener("change", n17), () => e9.removeEventListener("change", n17);
  }, [e9]), o20;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-root-containers.js
var import_react116 = __toESM(require_react(), 1);
function S8({ defaultContainers: l19 = [], portals: n17, mainTreeNode: o20 } = {}) {
  let c21 = o4(() => {
    var r22, u25;
    let i16 = l(o20), t14 = [];
    for (let e9 of l19) e9 !== null && (t5(e9) ? t14.push(e9) : "current" in e9 && t5(e9.current) && t14.push(e9.current));
    if (n17 != null && n17.current) for (let e9 of n17.current) t14.push(e9);
    for (let e9 of (r22 = i16 == null ? void 0 : i16.querySelectorAll("html > *, body > *")) != null ? r22 : []) e9 !== document.body && e9 !== document.head && t5(e9) && e9.id !== "headlessui-portal-root" && (o20 && (e9.contains(o20) || e9.contains((u25 = o20 == null ? void 0 : o20.getRootNode()) == null ? void 0 : u25.host)) || t14.some((E13) => e9.contains(E13)) || t14.push(e9));
    return t14;
  });
  return { resolveContainers: c21, contains: o4((i16) => c21().some((t14) => t14.contains(i16))) };
}
var d9 = (0, import_react116.createContext)(null);
function j9({ children: l19, node: n17 }) {
  let [o20, c21] = (0, import_react116.useState)(null), i16 = x6(n17 != null ? n17 : o20);
  return import_react116.default.createElement(d9.Provider, { value: i16 }, l19, i16 === null && import_react116.default.createElement(f4, { features: s5.Hidden, ref: (t14) => {
    var r22, u25;
    if (t14) {
      for (let e9 of (u25 = (r22 = l(t14)) == null ? void 0 : r22.querySelectorAll("html > *, body > *")) != null ? u25 : []) if (e9 !== document.body && e9 !== document.head && t5(e9) && e9 != null && e9.contains(t14)) {
        c21(e9);
        break;
      }
    }
  } }));
}
function x6(l19 = null) {
  var n17;
  return (n17 = (0, import_react116.useContext)(d9)) != null ? n17 : l19;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-server-handoff-complete.js
var t11 = __toESM(require_react(), 1);
function s15() {
  let r22 = typeof document == "undefined";
  return "useSyncExternalStore" in t11 ? ((o20) => o20.useSyncExternalStore)(t11)(() => () => {
  }, () => false, () => !r22) : false;
}
function l15() {
  let r22 = s15(), [e9, n17] = t11.useState(s.isHandoffComplete);
  return e9 && s.isHandoffComplete === false && n17(false), t11.useEffect(() => {
    e9 !== true && n17(true);
  }, [e9]), t11.useEffect(() => s.handoff(), []), r22 ? false : e9;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/focus-trap/focus-trap.js
var import_react119 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-is-mounted.js
var import_react117 = __toESM(require_react(), 1);
function f17() {
  let e9 = (0, import_react117.useRef)(false);
  return n(() => (e9.current = true, () => {
    e9.current = false;
  }), []), e9;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-tab-direction.js
var import_react118 = __toESM(require_react(), 1);
var a21 = ((r22) => (r22[r22.Forwards = 0] = "Forwards", r22[r22.Backwards = 1] = "Backwards", r22))(a21 || {});
function u21() {
  let e9 = (0, import_react118.useRef)(0);
  return s10(true, "keydown", (r22) => {
    r22.key === "Tab" && (e9.current = r22.shiftKey ? 1 : 0);
  }, true), e9;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/focus-trap/focus-trap.js
function x7(o20) {
  if (!o20) return /* @__PURE__ */ new Set();
  if (typeof o20 == "function") return new Set(o20());
  let t14 = /* @__PURE__ */ new Set();
  for (let e9 of o20.current) t5(e9.current) && t14.add(e9.current);
  return t14;
}
var $3 = "div";
var G4 = ((n17) => (n17[n17.None = 0] = "None", n17[n17.InitialFocus = 1] = "InitialFocus", n17[n17.TabLock = 2] = "TabLock", n17[n17.FocusLock = 4] = "FocusLock", n17[n17.RestoreFocus = 8] = "RestoreFocus", n17[n17.AutoFocus = 16] = "AutoFocus", n17))(G4 || {});
function w8(o20, t14) {
  let e9 = (0, import_react119.useRef)(null), r22 = y(e9, t14), { initialFocus: u25, initialFocusFallback: a28, containers: n17, features: s21 = 15, ...f21 } = o20;
  l15() || (s21 = 0);
  let l19 = u13(e9.current);
  re(s21, { ownerDocument: l19 });
  let T11 = ne(s21, { ownerDocument: l19, container: e9, initialFocus: u25, initialFocusFallback: a28 });
  oe2(s21, { ownerDocument: l19, container: e9, containers: n17, previousActiveElement: T11 });
  let g6 = u21(), A5 = o4((c21) => {
    if (!n5(e9.current)) return;
    let E13 = e9.current;
    ((V6) => V6())(() => {
      u(g6.current, { [a21.Forwards]: () => {
        v5(E13, T4.First, { skipElements: [c21.relatedTarget, a28] });
      }, [a21.Backwards]: () => {
        v5(E13, T4.Last, { skipElements: [c21.relatedTarget, a28] });
      } });
    });
  }), v11 = I3(!!(s21 & 2), "focus-trap#tab-lock"), N4 = p(), b14 = (0, import_react119.useRef)(false), k13 = { ref: r22, onKeyDown(c21) {
    c21.key == "Tab" && (b14.current = true, N4.requestAnimationFrame(() => {
      b14.current = false;
    }));
  }, onBlur(c21) {
    if (!(s21 & 4)) return;
    let E13 = x7(n17);
    n5(e9.current) && E13.add(e9.current);
    let L7 = c21.relatedTarget;
    i4(L7) && L7.dataset.headlessuiFocusGuard !== "true" && (I7(E13, L7) || (b14.current ? v5(e9.current, u(g6.current, { [a21.Forwards]: () => T4.Next, [a21.Backwards]: () => T4.Previous }) | T4.WrapAround, { relativeTo: c21.target }) : i4(c21.target) && w6(c21.target)));
  } }, B2 = K();
  return import_react119.default.createElement(import_react119.default.Fragment, null, v11 && import_react119.default.createElement(f4, { as: "button", type: "button", "data-headlessui-focus-guard": true, onFocus: A5, features: s5.Focusable }), B2({ ourProps: k13, theirProps: f21, defaultTag: $3, name: "FocusTrap" }), v11 && import_react119.default.createElement(f4, { as: "button", type: "button", "data-headlessui-focus-guard": true, onFocus: A5, features: s5.Focusable }));
}
var ee2 = Y(w8);
var ge2 = Object.assign(ee2, { features: G4 });
function te3(o20 = true) {
  let t14 = (0, import_react119.useRef)(n13.slice());
  return m7(([e9], [r22]) => {
    r22 === true && e9 === false && t(() => {
      t14.current.splice(0);
    }), r22 === false && e9 === true && (t14.current = n13.slice());
  }, [o20, n13, t14]), o4(() => {
    var e9;
    return (e9 = t14.current.find((r22) => r22 != null && r22.isConnected)) != null ? e9 : null;
  });
}
function re(o20, { ownerDocument: t14 }) {
  let e9 = !!(o20 & 8), r22 = te3(e9);
  m7(() => {
    e9 || d2(t14 == null ? void 0 : t14.body) && w6(r22());
  }, [e9]), c13(() => {
    e9 && w6(r22());
  });
}
function ne(o20, { ownerDocument: t14, container: e9, initialFocus: r22, initialFocusFallback: u25 }) {
  let a28 = (0, import_react119.useRef)(null), n17 = I3(!!(o20 & 1), "focus-trap#initial-focus"), s21 = f17();
  return m7(() => {
    if (o20 === 0) return;
    if (!n17) {
      u25 != null && u25.current && w6(u25.current);
      return;
    }
    let f21 = e9.current;
    f21 && t(() => {
      if (!s21.current) return;
      let l19 = t14 == null ? void 0 : t14.activeElement;
      if (r22 != null && r22.current) {
        if ((r22 == null ? void 0 : r22.current) === l19) {
          a28.current = l19;
          return;
        }
      } else if (f21.contains(l19)) {
        a28.current = l19;
        return;
      }
      if (r22 != null && r22.current) w6(r22.current);
      else {
        if (o20 & 16) {
          if (v5(f21, T4.First | T4.AutoFocus) !== A2.Error) return;
        } else if (v5(f21, T4.First) !== A2.Error) return;
        if (u25 != null && u25.current && (w6(u25.current), (t14 == null ? void 0 : t14.activeElement) === u25.current)) return;
        console.warn("There are no focusable elements inside the <FocusTrap />");
      }
      a28.current = t14 == null ? void 0 : t14.activeElement;
    });
  }, [u25, n17, o20]), a28;
}
function oe2(o20, { ownerDocument: t14, container: e9, containers: r22, previousActiveElement: u25 }) {
  let a28 = f17(), n17 = !!(o20 & 4);
  E7(t14 == null ? void 0 : t14.defaultView, "focus", (s21) => {
    if (!n17 || !a28.current) return;
    let f21 = x7(r22);
    n5(e9.current) && f21.add(e9.current);
    let l19 = u25.current;
    if (!l19) return;
    let T11 = s21.target;
    n5(T11) ? I7(f21, T11) ? (u25.current = T11, w6(T11)) : (s21.preventDefault(), s21.stopPropagation(), w6(l19)) : w6(u25.current);
  }, true);
}
function I7(o20, t14) {
  for (let e9 of o20) if (e9.contains(t14)) return true;
  return false;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/transition/transition.js
var import_react120 = __toESM(require_react(), 1);
function ue2(e9) {
  var t14;
  return !!(e9.enter || e9.enterFrom || e9.enterTo || e9.leave || e9.leaveFrom || e9.leaveTo) || !b((t14 = e9.as) != null ? t14 : de3) || import_react120.default.Children.count(e9.children) === 1;
}
var V3 = (0, import_react120.createContext)(null);
V3.displayName = "TransitionContext";
var De = ((n17) => (n17.Visible = "visible", n17.Hidden = "hidden", n17))(De || {});
function He() {
  let e9 = (0, import_react120.useContext)(V3);
  if (e9 === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return e9;
}
function Ae3() {
  let e9 = (0, import_react120.useContext)(w9);
  if (e9 === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return e9;
}
var w9 = (0, import_react120.createContext)(null);
w9.displayName = "NestingContext";
function M7(e9) {
  return "children" in e9 ? M7(e9.children) : e9.current.filter(({ el: t14 }) => t14.current !== null).filter(({ state: t14 }) => t14 === "visible").length > 0;
}
function Te2(e9, t14) {
  let n17 = s3(e9), l19 = (0, import_react120.useRef)([]), S11 = f17(), R7 = p(), d14 = o4((o20, i16 = C.Hidden) => {
    let a28 = l19.current.findIndex(({ el: s21 }) => s21 === o20);
    a28 !== -1 && (u(i16, { [C.Unmount]() {
      l19.current.splice(a28, 1);
    }, [C.Hidden]() {
      l19.current[a28].state = "hidden";
    } }), R7.microTask(() => {
      var s21;
      !M7(l19) && S11.current && ((s21 = n17.current) == null || s21.call(n17));
    }));
  }), y10 = o4((o20) => {
    let i16 = l19.current.find(({ el: a28 }) => a28 === o20);
    return i16 ? i16.state !== "visible" && (i16.state = "visible") : l19.current.push({ el: o20, state: "visible" }), () => d14(o20, C.Unmount);
  }), C11 = (0, import_react120.useRef)([]), p13 = (0, import_react120.useRef)(Promise.resolve()), h16 = (0, import_react120.useRef)({ enter: [], leave: [] }), g6 = o4((o20, i16, a28) => {
    C11.current.splice(0), t14 && (t14.chains.current[i16] = t14.chains.current[i16].filter(([s21]) => s21 !== o20)), t14 == null || t14.chains.current[i16].push([o20, new Promise((s21) => {
      C11.current.push(s21);
    })]), t14 == null || t14.chains.current[i16].push([o20, new Promise((s21) => {
      Promise.all(h16.current[i16].map(([r22, f21]) => f21)).then(() => s21());
    })]), i16 === "enter" ? p13.current = p13.current.then(() => t14 == null ? void 0 : t14.wait.current).then(() => a28(i16)) : a28(i16);
  }), v11 = o4((o20, i16, a28) => {
    Promise.all(h16.current[i16].splice(0).map(([s21, r22]) => r22)).then(() => {
      var s21;
      (s21 = C11.current.shift()) == null || s21();
    }).then(() => a28(i16));
  });
  return (0, import_react120.useMemo)(() => ({ children: l19, register: y10, unregister: d14, onStart: g6, onStop: v11, wait: p13, chains: h16 }), [y10, d14, l19, g6, v11, h16, p13]);
}
var de3 = import_react120.Fragment;
var fe = A.RenderStrategy;
function Fe2(e9, t14) {
  var ee7, te6;
  let { transition: n17 = true, beforeEnter: l19, afterEnter: S11, beforeLeave: R7, afterLeave: d14, enter: y10, enterFrom: C11, enterTo: p13, entered: h16, leave: g6, leaveFrom: v11, leaveTo: o20, ...i16 } = e9, [a28, s21] = (0, import_react120.useState)(null), r22 = (0, import_react120.useRef)(null), f21 = ue2(e9), U3 = y(...f21 ? [r22, t14, s21] : t14 === null ? [] : [t14]), H9 = (ee7 = i16.unmount) == null || ee7 ? C.Unmount : C.Hidden, { show: u25, appear: z4, initial: K4 } = He(), [m10, j11] = (0, import_react120.useState)(u25 ? "visible" : "hidden"), Q7 = Ae3(), { register: A5, unregister: F7 } = Q7;
  n(() => A5(r22), [A5, r22]), n(() => {
    if (H9 === C.Hidden && r22.current) {
      if (u25 && m10 !== "visible") {
        j11("visible");
        return;
      }
      return u(m10, { ["hidden"]: () => F7(r22), ["visible"]: () => A5(r22) });
    }
  }, [m10, r22, A5, F7, u25, H9]);
  let G6 = l15();
  n(() => {
    if (f21 && G6 && m10 === "visible" && r22.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [r22, m10, G6, f21]);
  let ce3 = K4 && !z4, Y4 = z4 && u25 && K4, B2 = (0, import_react120.useRef)(false), I10 = Te2(() => {
    B2.current || (j11("hidden"), F7(r22));
  }, Q7), Z4 = o4((W5) => {
    B2.current = true;
    let L7 = W5 ? "enter" : "leave";
    I10.onStart(r22, L7, (_10) => {
      _10 === "enter" ? l19 == null || l19() : _10 === "leave" && (R7 == null || R7());
    });
  }), $7 = o4((W5) => {
    let L7 = W5 ? "enter" : "leave";
    B2.current = false, I10.onStop(r22, L7, (_10) => {
      _10 === "enter" ? S11 == null || S11() : _10 === "leave" && (d14 == null || d14());
    }), L7 === "leave" && !M7(I10) && (j11("hidden"), F7(r22));
  });
  (0, import_react120.useEffect)(() => {
    f21 && n17 || (Z4(u25), $7(u25));
  }, [u25, f21, n17]);
  let pe4 = /* @__PURE__ */ (() => !(!n17 || !f21 || !G6 || ce3))(), [, T11] = N2(pe4, a28, u25, { start: Z4, end: $7 }), Ce5 = m2({ ref: U3, className: ((te6 = t4(i16.className, Y4 && y10, Y4 && C11, T11.enter && y10, T11.enter && T11.closed && C11, T11.enter && !T11.closed && p13, T11.leave && g6, T11.leave && !T11.closed && v11, T11.leave && T11.closed && o20, !T11.transition && u25 && h16)) == null ? void 0 : te6.trim()) || void 0, ...x4(T11) }), N4 = 0;
  m10 === "visible" && (N4 |= i10.Open), m10 === "hidden" && (N4 |= i10.Closed), u25 && m10 === "hidden" && (N4 |= i10.Opening), !u25 && m10 === "visible" && (N4 |= i10.Closing);
  let he3 = K();
  return import_react120.default.createElement(w9.Provider, { value: I10 }, import_react120.default.createElement(c11, { value: N4 }, he3({ ourProps: Ce5, theirProps: i16, defaultTag: de3, features: fe, visible: m10 === "visible", name: "Transition.Child" })));
}
function Ie(e9, t14) {
  let { show: n17, appear: l19 = false, unmount: S11 = true, ...R7 } = e9, d14 = (0, import_react120.useRef)(null), y10 = ue2(e9), C11 = y(...y10 ? [d14, t14] : t14 === null ? [] : [t14]);
  l15();
  let p13 = u17();
  if (n17 === void 0 && p13 !== null && (n17 = (p13 & i10.Open) === i10.Open), n17 === void 0) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [h16, g6] = (0, import_react120.useState)(n17 ? "visible" : "hidden"), v11 = Te2(() => {
    n17 || g6("hidden");
  }), [o20, i16] = (0, import_react120.useState)(true), a28 = (0, import_react120.useRef)([n17]);
  n(() => {
    o20 !== false && a28.current[a28.current.length - 1] !== n17 && (a28.current.push(n17), i16(false));
  }, [a28, n17]);
  let s21 = (0, import_react120.useMemo)(() => ({ show: n17, appear: l19, initial: o20 }), [n17, l19, o20]);
  n(() => {
    n17 ? g6("visible") : !M7(v11) && d14.current !== null && g6("hidden");
  }, [n17, v11]);
  let r22 = { unmount: S11 }, f21 = o4(() => {
    var u25;
    o20 && i16(false), (u25 = e9.beforeEnter) == null || u25.call(e9);
  }), U3 = o4(() => {
    var u25;
    o20 && i16(false), (u25 = e9.beforeLeave) == null || u25.call(e9);
  }), H9 = K();
  return import_react120.default.createElement(w9.Provider, { value: v11 }, import_react120.default.createElement(V3.Provider, { value: s21 }, H9({ ourProps: { ...r22, as: import_react120.Fragment, children: import_react120.default.createElement(me2, { ref: C11, ...r22, ...R7, beforeEnter: f21, beforeLeave: U3 }) }, theirProps: {}, defaultTag: import_react120.Fragment, features: fe, visible: h16 === "visible", name: "Transition" })));
}
function Le2(e9, t14) {
  let n17 = (0, import_react120.useContext)(V3) !== null, l19 = u17() !== null;
  return import_react120.default.createElement(import_react120.default.Fragment, null, !n17 && l19 ? import_react120.default.createElement(X2, { ref: t14, ...e9 }) : import_react120.default.createElement(me2, { ref: t14, ...e9 }));
}
var X2 = Y(Ie);
var me2 = Y(Fe2);
var Oe = Y(Le2);
var Ke2 = Object.assign(X2, { Child: Oe, Root: X2 });

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/dialog/dialog.js
var we = ((o20) => (o20[o20.Open = 0] = "Open", o20[o20.Closed = 1] = "Closed", o20))(we || {});
var Be = ((t14) => (t14[t14.SetTitleId = 0] = "SetTitleId", t14))(Be || {});
var Ue = { [0](e9, t14) {
  return e9.titleId === t14.id ? e9 : { ...e9, titleId: t14.id };
} };
var w10 = (0, import_react121.createContext)(null);
w10.displayName = "DialogContext";
function O4(e9) {
  let t14 = (0, import_react121.useContext)(w10);
  if (t14 === null) {
    let o20 = new Error(`<${e9} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o20, O4), o20;
  }
  return t14;
}
function He2(e9, t14) {
  return u(t14.type, Ue, e9, t14);
}
var z = Y(function(t14, o20) {
  let a28 = (0, import_react74.useId)(), { id: n17 = `headlessui-dialog-${a28}`, open: i16, onClose: p13, initialFocus: d14, role: s21 = "dialog", autoFocus: f21 = true, __demoMode: u25 = false, unmount: y10 = false, ...S11 } = t14, R7 = (0, import_react121.useRef)(false);
  s21 = function() {
    return s21 === "dialog" || s21 === "alertdialog" ? s21 : (R7.current || (R7.current = true, console.warn(`Invalid role [${s21}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog");
  }();
  let g6 = u17();
  i16 === void 0 && g6 !== null && (i16 = (g6 & i10.Open) === i10.Open);
  let T11 = (0, import_react121.useRef)(null), I10 = y(T11, o20), F7 = u13(T11.current), c21 = i16 ? 0 : 1, [b14, Q7] = (0, import_react121.useReducer)(He2, { titleId: null, descriptionId: null, panelRef: (0, import_react121.createRef)() }), m10 = o4(() => p13(false)), B2 = o4((r22) => Q7({ type: 0, id: r22 })), D13 = l15() ? c21 === 0 : false, [Z4, ee7] = ee(), te6 = { get current() {
    var r22;
    return (r22 = b14.panelRef.current) != null ? r22 : T11.current;
  } }, v11 = x6(), { resolveContainers: M12 } = S8({ mainTreeNode: v11, portals: Z4, defaultContainers: [te6] }), U3 = g6 !== null ? (g6 & i10.Closing) === i10.Closing : false;
  y4(u25 || U3 ? false : D13, { allowed: o4(() => {
    var r22, W5;
    return [(W5 = (r22 = T11.current) == null ? void 0 : r22.closest("[data-headlessui-portal]")) != null ? W5 : null];
  }), disallowed: o4(() => {
    var r22;
    return [(r22 = v11 == null ? void 0 : v11.closest("body > *:not(#headlessui-portal-root)")) != null ? r22 : null];
  }) });
  let P8 = x2.get(null);
  n(() => {
    if (D13) return P8.actions.push(n17), () => P8.actions.pop(n17);
  }, [P8, n17, D13]);
  let H9 = S3(P8, (0, import_react121.useCallback)((r22) => P8.selectors.isTop(r22, n17), [P8, n17]));
  k5(H9, M12, (r22) => {
    r22.preventDefault(), m10();
  }), a20(H9, F7 == null ? void 0 : F7.defaultView, (r22) => {
    r22.preventDefault(), r22.stopPropagation(), document.activeElement && "blur" in document.activeElement && typeof document.activeElement.blur == "function" && document.activeElement.blur(), m10();
  }), f11(u25 || U3 ? false : D13, F7, M12), p5(D13, T11, m10);
  let [oe6, ne4] = H3(), re5 = (0, import_react121.useMemo)(() => [{ dialogState: c21, close: m10, setTitleId: B2, unmount: y10 }, b14], [c21, m10, B2, y10, b14]), N4 = n2({ open: c21 === 0 }), le = { ref: I10, id: n17, role: s21, tabIndex: -1, "aria-modal": u25 ? void 0 : c21 === 0 ? true : void 0, "aria-labelledby": b14.titleId, "aria-describedby": oe6, unmount: y10 }, ae5 = !f16(), E13 = G4.None;
  D13 && !u25 && (E13 |= G4.RestoreFocus, E13 |= G4.TabLock, f21 && (E13 |= G4.AutoFocus), ae5 && (E13 |= G4.InitialFocus));
  let ie4 = K();
  return import_react121.default.createElement(s13, null, import_react121.default.createElement(l14, { force: true }, import_react121.default.createElement(te, null, import_react121.default.createElement(w10.Provider, { value: re5 }, import_react121.default.createElement(X, { target: T11 }, import_react121.default.createElement(l14, { force: false }, import_react121.default.createElement(ne4, { slot: N4 }, import_react121.default.createElement(ee7, null, import_react121.default.createElement(ge2, { initialFocus: d14, initialFocusFallback: T11, containers: M12, features: E13 }, import_react121.default.createElement(C5, { value: m10 }, ie4({ ourProps: le, theirProps: S11, slot: N4, defaultTag: Ne, features: We, visible: c21 === 0, name: "Dialog" })))))))))));
});
var Ne = "div";
var We = A.RenderStrategy | A.Static;
function $e(e9, t14) {
  let { transition: o20 = false, open: a28, ...n17 } = e9, i16 = u17(), p13 = e9.hasOwnProperty("open") || i16 !== null, d14 = e9.hasOwnProperty("onClose");
  if (!p13 && !d14) throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!p13) throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!d14) throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (!i16 && typeof e9.open != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${e9.open}`);
  if (typeof e9.onClose != "function") throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${e9.onClose}`);
  return (a28 !== void 0 || o20) && !n17.static ? import_react121.default.createElement(j9, null, import_react121.default.createElement(Ke2, { show: a28, transition: o20, unmount: n17.unmount }, import_react121.default.createElement(z, { ref: t14, ...n17 }))) : import_react121.default.createElement(j9, null, import_react121.default.createElement(z, { ref: t14, open: a28, ...n17 }));
}
var je = "div";
function Ye(e9, t14) {
  let o20 = (0, import_react74.useId)(), { id: a28 = `headlessui-dialog-panel-${o20}`, transition: n17 = false, ...i16 } = e9, [{ dialogState: p13, unmount: d14 }, s21] = O4("Dialog.Panel"), f21 = y(t14, s21.panelRef), u25 = n2({ open: p13 === 0 }), y10 = o4((I10) => {
    I10.stopPropagation();
  }), S11 = { ref: f21, id: a28, onClick: y10 }, R7 = n17 ? Oe : import_react121.Fragment, g6 = n17 ? { unmount: d14 } : {}, T11 = K();
  return import_react121.default.createElement(R7, { ...g6 }, T11({ ourProps: S11, theirProps: i16, slot: u25, defaultTag: je, name: "Dialog.Panel" }));
}
var Je = "div";
function Ke3(e9, t14) {
  let { transition: o20 = false, ...a28 } = e9, [{ dialogState: n17, unmount: i16 }] = O4("Dialog.Backdrop"), p13 = n2({ open: n17 === 0 }), d14 = { ref: t14, "aria-hidden": true }, s21 = o20 ? Oe : import_react121.Fragment, f21 = o20 ? { unmount: i16 } : {}, u25 = K();
  return import_react121.default.createElement(s21, { ...f21 }, u25({ ourProps: d14, theirProps: a28, slot: p13, defaultTag: Je, name: "Dialog.Backdrop" }));
}
var Xe = "h2";
function Ve(e9, t14) {
  let o20 = (0, import_react74.useId)(), { id: a28 = `headlessui-dialog-title-${o20}`, ...n17 } = e9, [{ dialogState: i16, setTitleId: p13 }] = O4("Dialog.Title"), d14 = y(t14);
  (0, import_react121.useEffect)(() => (p13(a28), () => p13(null)), [a28, p13]);
  let s21 = n2({ open: i16 === 0 }), f21 = { ref: d14, id: a28 };
  return K()({ ourProps: f21, theirProps: n17, slot: s21, defaultTag: Xe, name: "Dialog.Title" });
}
var qe = Y($e);
var ze = Y(Ye);
var Lt = Y(Ke3);
var Qe = Y(Ve);
var ht = Object.assign(qe, { Panel: ze, Title: Qe, Description: M2 });

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/disclosure/disclosure.js
var import_react123 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/start-transition.js
var import_react122 = __toESM(require_react(), 1);
var t12;
var a22 = (t12 = import_react122.default.startTransition) != null ? t12 : function(i16) {
  i16();
};

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/disclosure/disclosure.js
var me3 = ((l19) => (l19[l19.Open = 0] = "Open", l19[l19.Closed = 1] = "Closed", l19))(me3 || {});
var fe3 = ((n17) => (n17[n17.ToggleDisclosure = 0] = "ToggleDisclosure", n17[n17.CloseDisclosure = 1] = "CloseDisclosure", n17[n17.SetButtonId = 2] = "SetButtonId", n17[n17.SetPanelId = 3] = "SetPanelId", n17[n17.SetButtonElement = 4] = "SetButtonElement", n17[n17.SetPanelElement = 5] = "SetPanelElement", n17))(fe3 || {});
var De2 = { [0]: (e9) => ({ ...e9, disclosureState: u(e9.disclosureState, { [0]: 1, [1]: 0 }) }), [1]: (e9) => e9.disclosureState === 1 ? e9 : { ...e9, disclosureState: 1 }, [2](e9, t14) {
  return e9.buttonId === t14.buttonId ? e9 : { ...e9, buttonId: t14.buttonId };
}, [3](e9, t14) {
  return e9.panelId === t14.panelId ? e9 : { ...e9, panelId: t14.panelId };
}, [4](e9, t14) {
  return e9.buttonElement === t14.element ? e9 : { ...e9, buttonElement: t14.element };
}, [5](e9, t14) {
  return e9.panelElement === t14.element ? e9 : { ...e9, panelElement: t14.element };
} };
var _6 = (0, import_react123.createContext)(null);
_6.displayName = "DisclosureContext";
function M8(e9) {
  let t14 = (0, import_react123.useContext)(_6);
  if (t14 === null) {
    let l19 = new Error(`<${e9} /> is missing a parent <Disclosure /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(l19, M8), l19;
  }
  return t14;
}
var F4 = (0, import_react123.createContext)(null);
F4.displayName = "DisclosureAPIContext";
function V4(e9) {
  let t14 = (0, import_react123.useContext)(F4);
  if (t14 === null) {
    let l19 = new Error(`<${e9} /> is missing a parent <Disclosure /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(l19, V4), l19;
  }
  return t14;
}
var H6 = (0, import_react123.createContext)(null);
H6.displayName = "DisclosurePanelContext";
function ye2() {
  return (0, import_react123.useContext)(H6);
}
function Pe(e9, t14) {
  return u(t14.type, De2, e9, t14);
}
var Ee2 = import_react123.Fragment;
function Se(e9, t14) {
  let { defaultOpen: l19 = false, ...p13 } = e9, a28 = (0, import_react123.useRef)(null), c21 = y(t14, T((u25) => {
    a28.current = u25;
  }, e9.as === void 0 || b(e9.as))), n17 = (0, import_react123.useReducer)(Pe, { disclosureState: l19 ? 0 : 1, buttonElement: null, panelElement: null, buttonId: null, panelId: null }), [{ disclosureState: o20, buttonId: r22 }, f21] = n17, s21 = o4((u25) => {
    f21({ type: 1 });
    let m10 = l(a28.current);
    if (!m10 || !r22) return;
    let d14 = (() => u25 ? i4(u25) ? u25 : "current" in u25 && i4(u25.current) ? u25.current : m10.getElementById(r22) : m10.getElementById(r22))();
    d14 == null || d14.focus();
  }), E13 = (0, import_react123.useMemo)(() => ({ close: s21 }), [s21]), T11 = n2({ open: o20 === 0, close: s21 }), D13 = { ref: c21 }, S11 = K();
  return import_react123.default.createElement(_6.Provider, { value: n17 }, import_react123.default.createElement(F4.Provider, { value: E13 }, import_react123.default.createElement(C5, { value: s21 }, import_react123.default.createElement(c11, { value: u(o20, { [0]: i10.Open, [1]: i10.Closed }) }, S11({ ourProps: D13, theirProps: p13, slot: T11, defaultTag: Ee2, name: "Disclosure" })))));
}
var ge5 = "button";
function Ae4(e9, t14) {
  let l19 = (0, import_react74.useId)(), { id: p13 = `headlessui-disclosure-button-${l19}`, disabled: a28 = false, autoFocus: c21 = false, ...n17 } = e9, [o20, r22] = M8("Disclosure.Button"), f21 = ye2(), s21 = f21 === null ? false : f21 === o20.panelId, E13 = (0, import_react123.useRef)(null), T11 = y(E13, t14, o4((i16) => {
    if (!s21) return r22({ type: 4, element: i16 });
  }));
  (0, import_react123.useEffect)(() => {
    if (!s21) return r22({ type: 2, buttonId: p13 }), () => {
      r22({ type: 2, buttonId: null });
    };
  }, [p13, r22, s21]);
  let D13 = o4((i16) => {
    var g6;
    if (s21) {
      if (o20.disclosureState === 1) return;
      switch (i16.key) {
        case o8.Space:
        case o8.Enter:
          i16.preventDefault(), i16.stopPropagation(), r22({ type: 0 }), (g6 = o20.buttonElement) == null || g6.focus();
          break;
      }
    } else switch (i16.key) {
      case o8.Space:
      case o8.Enter:
        i16.preventDefault(), i16.stopPropagation(), r22({ type: 0 });
        break;
    }
  }), S11 = o4((i16) => {
    switch (i16.key) {
      case o8.Space:
        i16.preventDefault();
        break;
    }
  }), u25 = o4((i16) => {
    var g6;
    s6(i16.currentTarget) || a28 || (s21 ? (r22({ type: 0 }), (g6 = o20.buttonElement) == null || g6.focus()) : r22({ type: 0 }));
  }), { isFocusVisible: m10, focusProps: d14 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: c21 }), { isHovered: C11, hoverProps: h16 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: a28 }), { pressed: $7, pressProps: U3 } = w({ disabled: a28 }), J4 = n2({ open: o20.disclosureState === 0, hover: C11, active: $7, disabled: a28, focus: m10, autofocus: c21 }), G6 = e5(e9, o20.buttonElement), X5 = s21 ? V({ ref: T11, type: G6, disabled: a28 || void 0, autoFocus: c21, onKeyDown: D13, onClick: u25 }, d14, h16, U3) : V({ ref: T11, id: p13, type: G6, "aria-expanded": o20.disclosureState === 0, "aria-controls": o20.panelElement ? o20.panelId : void 0, disabled: a28 || void 0, autoFocus: c21, onKeyDown: D13, onKeyUp: S11, onClick: u25 }, d14, h16, U3);
  return K()({ ourProps: X5, theirProps: n17, slot: J4, defaultTag: ge5, name: "Disclosure.Button" });
}
var be2 = "div";
var Ce = A.RenderStrategy | A.Static;
function Re2(e9, t14) {
  let l19 = (0, import_react74.useId)(), { id: p13 = `headlessui-disclosure-panel-${l19}`, transition: a28 = false, ...c21 } = e9, [n17, o20] = M8("Disclosure.Panel"), { close: r22 } = V4("Disclosure.Panel"), [f21, s21] = (0, import_react123.useState)(null), E13 = y(t14, o4((C11) => {
    a22(() => o20({ type: 5, element: C11 }));
  }), s21);
  (0, import_react123.useEffect)(() => (o20({ type: 3, panelId: p13 }), () => {
    o20({ type: 3, panelId: null });
  }), [p13, o20]);
  let T11 = u17(), [D13, S11] = N2(a28, f21, T11 !== null ? (T11 & i10.Open) === i10.Open : n17.disclosureState === 0), u25 = n2({ open: n17.disclosureState === 0, close: r22 }), m10 = { ref: E13, id: p13, ...x4(S11) }, d14 = K();
  return import_react123.default.createElement(s13, null, import_react123.default.createElement(H6.Provider, { value: n17.panelId }, d14({ ourProps: m10, theirProps: c21, slot: u25, defaultTag: be2, features: Ce, visible: D13, name: "Disclosure.Panel" })));
}
var Ie2 = Y(Se);
var xe2 = Y(Ae4);
var Le3 = Y(Re2);
var Xe2 = Object.assign(Ie2, { Button: xe2, Panel: Le3 });

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/field/field.js
var import_react124 = __toESM(require_react(), 1);
var _7 = "div";
function c18(d14, l19) {
  let t14 = `headlessui-control-${(0, import_react74.useId)()}`, [p13, s21] = V2(), [n17, a28] = H3(), m10 = a3(), { disabled: r22 = m10 || false, ...o20 } = d14, i16 = n2({ disabled: r22 }), F7 = { ref: l19, disabled: r22 || void 0, "aria-disabled": r22 || void 0 }, T11 = K();
  return import_react124.default.createElement(l2, { value: r22 }, import_react124.default.createElement(s21, { value: p13 }, import_react124.default.createElement(a28, { value: n17 }, import_react124.default.createElement(f6, { id: t14 }, T11({ ourProps: F7, theirProps: { ...o20, children: import_react124.default.createElement(W, null, typeof o20.children == "function" ? o20.children(i16) : o20.children) }, slot: i16, defaultTag: _7, name: "Field" })))));
}
var W3 = Y(c18);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/fieldset/fieldset.js
var import_react126 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-resolved-tag.js
var import_react125 = __toESM(require_react(), 1);
function d10(t14) {
  let e9 = typeof t14 == "string" ? t14 : void 0, [s21, o20] = (0, import_react125.useState)(e9);
  return [e9 != null ? e9 : s21, (0, import_react125.useCallback)((n17) => {
    e9 || n5(n17) && o20(n17.tagName.toLowerCase());
  }, [e9])];
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/fieldset/fieldset.js
var d11 = "fieldset";
function _8(t14, a28) {
  var s21;
  let i16 = a3(), { disabled: e9 = i16 || false, ...p13 } = t14, [n17, T11] = d10((s21 = t14.as) != null ? s21 : d11), l19 = y(a28, T11), [r22, f21] = V2(), m10 = n2({ disabled: e9 }), y10 = n17 === "fieldset" ? { ref: l19, "aria-labelledby": r22, disabled: e9 || void 0 } : { ref: l19, role: "group", "aria-labelledby": r22, "aria-disabled": e9 || void 0 }, F7 = K();
  return import_react126.default.createElement(l2, { value: e9 }, import_react126.default.createElement(f21, null, F7({ ourProps: y10, theirProps: p13, slot: m10, defaultTag: d11, name: "Fieldset" })));
}
var I9 = Y(_8);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/input/input.js
var x8 = "input";
function h9(r22, p13) {
  let n17 = (0, import_react74.useId)(), s21 = u4(), a28 = a3(), { id: l19 = s21 || `headlessui-input-${n17}`, disabled: e9 = a28 || false, autoFocus: o20 = false, invalid: t14 = false, ...i16 } = r22, d14 = N(), u25 = w3(), { isFocused: f21, focusProps: m10 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: o20 }), { isHovered: T11, hoverProps: b14 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e9 }), y10 = V({ ref: p13, id: l19, "aria-labelledby": d14, "aria-describedby": u25, "aria-invalid": t14 ? "true" : void 0, disabled: e9 || void 0, autoFocus: o20 }, m10, b14), I10 = n2({ disabled: e9, invalid: t14, hover: T11, focus: f21, autofocus: o20 });
  return K()({ ourProps: y10, theirProps: i16, slot: I10, defaultTag: x8, name: "Input" });
}
var X3 = Y(h9);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/legend/legend.js
var import_react127 = __toESM(require_react(), 1);
function o17(t14, n17) {
  return import_react127.default.createElement(Z, { as: "div", ref: n17, ...t14 });
}
var d12 = Y(o17);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/listbox/listbox.js
var import_react130 = __toESM(require_react(), 1);
var import_react_dom11 = __toESM(require_react_dom(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-text-value.js
var import_react128 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/get-text-value.js
var a24 = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o18(e9) {
  var l19, n17;
  let i16 = (l19 = e9.innerText) != null ? l19 : "", t14 = e9.cloneNode(true);
  if (!n5(t14)) return i16;
  let u25 = false;
  for (let f21 of t14.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) f21.remove(), u25 = true;
  let r22 = u25 ? (n17 = t14.innerText) != null ? n17 : "" : i16;
  return a24.test(r22) && (r22 = r22.replace(a24, "")), r22;
}
function F5(e9) {
  let i16 = e9.getAttribute("aria-label");
  if (typeof i16 == "string") return i16.trim();
  let t14 = e9.getAttribute("aria-labelledby");
  if (t14) {
    let u25 = t14.split(" ").map((r22) => {
      let l19 = document.getElementById(r22);
      if (l19) {
        let n17 = l19.getAttribute("aria-label");
        return typeof n17 == "string" ? n17.trim() : o18(l19).trim();
      }
      return null;
    }).filter(Boolean);
    if (u25.length > 0) return u25.join(", ");
  }
  return o18(e9).trim();
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/hooks/use-text-value.js
function s16(c21) {
  let t14 = (0, import_react128.useRef)(""), r22 = (0, import_react128.useRef)("");
  return o4(() => {
    let e9 = c21.current;
    if (!e9) return "";
    let u25 = e9.innerText;
    if (t14.current === u25) return r22.current;
    let n17 = F5(e9).trim().toLowerCase();
    return t14.current = u25, r22.current = n17, n17;
  });
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/listbox/listbox-machine.js
var T9 = Object.defineProperty;
var y8 = (e9, o20, t14) => o20 in e9 ? T9(e9, o20, { enumerable: true, configurable: true, writable: true, value: t14 }) : e9[o20] = t14;
var b11 = (e9, o20, t14) => (y8(e9, typeof o20 != "symbol" ? o20 + "" : o20, t14), t14);
var F6 = ((t14) => (t14[t14.Open = 0] = "Open", t14[t14.Closed = 1] = "Closed", t14))(F6 || {});
var P6 = ((t14) => (t14[t14.Single = 0] = "Single", t14[t14.Multi = 1] = "Multi", t14))(P6 || {});
var C8 = ((t14) => (t14[t14.Pointer = 0] = "Pointer", t14[t14.Other = 1] = "Other", t14))(C8 || {});
var k9 = ((r22) => (r22[r22.OpenListbox = 0] = "OpenListbox", r22[r22.CloseListbox = 1] = "CloseListbox", r22[r22.GoToOption = 2] = "GoToOption", r22[r22.Search = 3] = "Search", r22[r22.ClearSearch = 4] = "ClearSearch", r22[r22.SelectOption = 5] = "SelectOption", r22[r22.RegisterOptions = 6] = "RegisterOptions", r22[r22.UnregisterOptions = 7] = "UnregisterOptions", r22[r22.SetButtonElement = 8] = "SetButtonElement", r22[r22.SetOptionsElement = 9] = "SetOptionsElement", r22[r22.SortOptions = 10] = "SortOptions", r22[r22.MarkButtonAsMoved = 11] = "MarkButtonAsMoved", r22))(k9 || {});
function g5(e9, o20 = (t14) => t14) {
  let t14 = e9.activeOptionIndex !== null ? e9.options[e9.activeOptionIndex] : null, n17 = G2(o20(e9.options.slice()), (s21) => s21.dataRef.current.domRef.current), i16 = t14 ? n17.indexOf(t14) : null;
  return i16 === -1 && (i16 = null), { options: n17, activeOptionIndex: i16 };
}
var D9 = { [1](e9) {
  if (e9.dataRef.current.disabled || e9.listboxState === 1) return e9;
  let o20 = e9.buttonElement ? c16.Tracked(a18(e9.buttonElement)) : e9.buttonPositionState;
  return { ...e9, activeOptionIndex: null, pendingFocus: { focus: c12.Nothing }, listboxState: 1, __demoMode: false, buttonPositionState: o20 };
}, [0](e9, o20) {
  if (e9.dataRef.current.disabled || e9.listboxState === 0) return e9;
  let t14 = e9.activeOptionIndex, { isSelected: n17 } = e9.dataRef.current, i16 = e9.options.findIndex((s21) => n17(s21.dataRef.current.value));
  return i16 !== -1 && (t14 = i16), { ...e9, frozenValue: false, pendingFocus: o20.focus, listboxState: 0, activeOptionIndex: t14, __demoMode: false, buttonPositionState: c16.Idle };
}, [2](e9, o20) {
  var s21, l19, c21, p13, f21;
  if (e9.dataRef.current.disabled || e9.listboxState === 1) return e9;
  let t14 = { ...e9, searchQuery: "", activationTrigger: (s21 = o20.trigger) != null ? s21 : 1, __demoMode: false };
  if (o20.focus === c12.Nothing) return { ...t14, activeOptionIndex: null };
  if (o20.focus === c12.Specific) return { ...t14, activeOptionIndex: e9.options.findIndex((d14) => d14.id === o20.id) };
  if (o20.focus === c12.Previous) {
    let d14 = e9.activeOptionIndex;
    if (d14 !== null) {
      let O5 = e9.options[d14].dataRef.current.domRef, r22 = f14(o20, { resolveItems: () => e9.options, resolveActiveIndex: () => e9.activeOptionIndex, resolveId: (u25) => u25.id, resolveDisabled: (u25) => u25.dataRef.current.disabled });
      if (r22 !== null) {
        let u25 = e9.options[r22].dataRef.current.domRef;
        if (((l19 = O5.current) == null ? void 0 : l19.previousElementSibling) === u25.current || ((c21 = u25.current) == null ? void 0 : c21.previousElementSibling) === null) return { ...t14, activeOptionIndex: r22 };
      }
    }
  } else if (o20.focus === c12.Next) {
    let d14 = e9.activeOptionIndex;
    if (d14 !== null) {
      let O5 = e9.options[d14].dataRef.current.domRef, r22 = f14(o20, { resolveItems: () => e9.options, resolveActiveIndex: () => e9.activeOptionIndex, resolveId: (u25) => u25.id, resolveDisabled: (u25) => u25.dataRef.current.disabled });
      if (r22 !== null) {
        let u25 = e9.options[r22].dataRef.current.domRef;
        if (((p13 = O5.current) == null ? void 0 : p13.nextElementSibling) === u25.current || ((f21 = u25.current) == null ? void 0 : f21.nextElementSibling) === null) return { ...t14, activeOptionIndex: r22 };
      }
    }
  }
  let n17 = g5(e9), i16 = f14(o20, { resolveItems: () => n17.options, resolveActiveIndex: () => n17.activeOptionIndex, resolveId: (d14) => d14.id, resolveDisabled: (d14) => d14.dataRef.current.disabled });
  return { ...t14, ...n17, activeOptionIndex: i16 };
}, [3]: (e9, o20) => {
  if (e9.dataRef.current.disabled || e9.listboxState === 1) return e9;
  let n17 = e9.searchQuery !== "" ? 0 : 1, i16 = e9.searchQuery + o20.value.toLowerCase(), l19 = (e9.activeOptionIndex !== null ? e9.options.slice(e9.activeOptionIndex + n17).concat(e9.options.slice(0, e9.activeOptionIndex + n17)) : e9.options).find((p13) => {
    var f21;
    return !p13.dataRef.current.disabled && ((f21 = p13.dataRef.current.textValue) == null ? void 0 : f21.startsWith(i16));
  }), c21 = l19 ? e9.options.indexOf(l19) : -1;
  return c21 === -1 || c21 === e9.activeOptionIndex ? { ...e9, searchQuery: i16 } : { ...e9, searchQuery: i16, activeOptionIndex: c21, activationTrigger: 1 };
}, [4](e9) {
  return e9.dataRef.current.disabled || e9.listboxState === 1 || e9.searchQuery === "" ? e9 : { ...e9, searchQuery: "" };
}, [5](e9) {
  return e9.dataRef.current.mode === 0 ? { ...e9, frozenValue: true } : { ...e9 };
}, [6]: (e9, o20) => {
  let t14 = e9.options.concat(o20.options), n17 = e9.activeOptionIndex;
  if (e9.pendingFocus.focus !== c12.Nothing && (n17 = f14(e9.pendingFocus, { resolveItems: () => t14, resolveActiveIndex: () => e9.activeOptionIndex, resolveId: (i16) => i16.id, resolveDisabled: (i16) => i16.dataRef.current.disabled })), e9.activeOptionIndex === null) {
    let { isSelected: i16 } = e9.dataRef.current;
    if (i16) {
      let s21 = t14.findIndex((l19) => i16 == null ? void 0 : i16(l19.dataRef.current.value));
      s21 !== -1 && (n17 = s21);
    }
  }
  return { ...e9, options: t14, activeOptionIndex: n17, pendingFocus: { focus: c12.Nothing }, pendingShouldSort: true };
}, [7]: (e9, o20) => {
  let t14 = e9.options, n17 = [], i16 = new Set(o20.options);
  for (let [s21, l19] of t14.entries()) if (i16.has(l19.id) && (n17.push(s21), i16.delete(l19.id), i16.size === 0)) break;
  if (n17.length > 0) {
    t14 = t14.slice();
    for (let s21 of n17.reverse()) t14.splice(s21, 1);
  }
  return { ...e9, options: t14, activationTrigger: 1 };
}, [8]: (e9, o20) => e9.buttonElement === o20.element ? e9 : { ...e9, buttonElement: o20.element }, [9]: (e9, o20) => e9.optionsElement === o20.element ? e9 : { ...e9, optionsElement: o20.element }, [10]: (e9) => e9.pendingShouldSort ? { ...e9, ...g5(e9), pendingShouldSort: false } : e9, [11](e9) {
  return e9.buttonPositionState.kind !== "Tracked" ? e9 : { ...e9, buttonPositionState: c16.Moved };
} };
var h10 = class _h extends T3 {
  constructor(t14) {
    super(t14);
    b11(this, "actions", { onChange: (t15) => {
      let { onChange: n17, compare: i16, mode: s21, value: l19 } = this.state.dataRef.current;
      return u(s21, { [0]: () => n17 == null ? void 0 : n17(t15), [1]: () => {
        let c21 = l19.slice(), p13 = c21.findIndex((f21) => i16(f21, t15));
        return p13 === -1 ? c21.push(t15) : c21.splice(p13, 1), n17 == null ? void 0 : n17(c21);
      } });
    }, registerOption: k3(() => {
      let t15 = [], n17 = /* @__PURE__ */ new Set();
      return [(i16, s21) => {
        n17.has(s21) || (n17.add(s21), t15.push({ id: i16, dataRef: s21 }));
      }, () => (n17.clear(), this.send({ type: 6, options: t15.splice(0) }))];
    }), unregisterOption: k3(() => {
      let t15 = [];
      return [(n17) => t15.push(n17), () => {
        this.send({ type: 7, options: t15.splice(0) });
      }];
    }), goToOption: k3(() => {
      let t15 = null;
      return [(n17, i16) => {
        t15 = { type: 2, ...n17, trigger: i16 };
      }, () => t15 && this.send(t15)];
    }), closeListbox: () => {
      this.send({ type: 1 });
    }, openListbox: (t15) => {
      this.send({ type: 0, focus: t15 });
    }, selectActiveOption: () => {
      var t15;
      if (this.state.activeOptionIndex !== null) {
        let { dataRef: n17 } = this.state.options[this.state.activeOptionIndex];
        this.actions.selectOption(n17.current.value);
      } else this.state.dataRef.current.mode === 0 && (this.actions.closeListbox(), (t15 = this.state.buttonElement) == null || t15.focus({ preventScroll: true }));
    }, selectOption: (t15) => {
      this.send({ type: 5, value: t15 });
    }, search: (t15) => {
      this.send({ type: 3, value: t15 });
    }, clearSearch: () => {
      this.send({ type: 4 });
    }, setButtonElement: (t15) => {
      this.send({ type: 8, element: t15 });
    }, setOptionsElement: (t15) => {
      this.send({ type: 9, element: t15 });
    } });
    b11(this, "selectors", { activeDescendantId(t15) {
      var s21;
      let n17 = t15.activeOptionIndex, i16 = t15.options;
      return n17 === null || (s21 = i16[n17]) == null ? void 0 : s21.id;
    }, isActive(t15, n17) {
      var l19;
      let i16 = t15.activeOptionIndex, s21 = t15.options;
      return i16 !== null ? ((l19 = s21[i16]) == null ? void 0 : l19.id) === n17 : false;
    }, hasFrozenValue(t15) {
      return t15.frozenValue;
    }, shouldScrollIntoView(t15, n17) {
      return t15.__demoMode || t15.listboxState !== 0 || t15.activationTrigger === 0 ? false : this.isActive(t15, n17);
    }, didButtonMove(t15) {
      return t15.buttonPositionState.kind === "Moved";
    } });
    this.on(6, () => {
      requestAnimationFrame(() => {
        this.send({ type: 10 });
      });
    });
    {
      let n17 = this.state.id, i16 = x2.get(null);
      this.disposables.add(i16.on(k4.Push, (s21) => {
        !i16.selectors.isTop(s21, n17) && this.state.listboxState === 0 && this.actions.closeListbox();
      })), this.on(0, () => i16.actions.push(n17)), this.on(1, () => i16.actions.pop(n17));
    }
    this.disposables.group((n17) => {
      this.on(1, (i16) => {
        i16.buttonElement && (n17.dispose(), n17.add(p6(i16.buttonElement, i16.buttonPositionState, () => {
          this.send({ type: 11 });
        })));
      });
    }), this.on(5, (n17, i16) => {
      var s21;
      this.actions.onChange(i16.value), this.state.dataRef.current.mode === 0 && (this.actions.closeListbox(), (s21 = this.state.buttonElement) == null || s21.focus({ preventScroll: true }));
    });
  }
  static new({ id: t14, __demoMode: n17 = false }) {
    return new _h({ id: t14, dataRef: { current: {} }, listboxState: n17 ? 0 : 1, options: [], searchQuery: "", activeOptionIndex: null, activationTrigger: 1, buttonElement: null, optionsElement: null, pendingShouldSort: false, pendingFocus: { focus: c12.Nothing }, frozenValue: false, __demoMode: n17, buttonPositionState: c16.Idle });
  }
  reduce(t14, n17) {
    return u(n17.type, D9, t14, n17);
  }
};

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/listbox/listbox-machine-glue.js
var import_react129 = __toESM(require_react(), 1);
var c19 = (0, import_react129.createContext)(null);
function p10(o20) {
  let e9 = (0, import_react129.useContext)(c19);
  if (e9 === null) {
    let t14 = new Error(`<${o20} /> is missing a parent <Listbox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t14, u22), t14;
  }
  return e9;
}
function u22({ id: o20, __demoMode: e9 = false }) {
  let t14 = (0, import_react129.useMemo)(() => h10.new({ id: o20, __demoMode: e9 }), []);
  return c13(() => t14.dispose()), t14;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/listbox/listbox.js
var oe3 = (0, import_react130.createContext)(null);
oe3.displayName = "ListboxDataContext";
function Q3(b14) {
  let E13 = (0, import_react130.useContext)(oe3);
  if (E13 === null) {
    let m10 = new Error(`<${b14} /> is missing a parent <Listbox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(m10, Q3), m10;
  }
  return E13;
}
var Pt = import_react130.Fragment;
function gt(b14, E13) {
  let m10 = (0, import_react74.useId)(), u25 = a3(), { value: s21, defaultValue: a28, form: _10, name: i16, onChange: y10, by: o20, invalid: x10 = false, disabled: O5 = u25 || false, horizontal: l19 = false, multiple: t14 = false, __demoMode: p13 = false, ...S11 } = b14;
  const h16 = l19 ? "horizontal" : "vertical";
  let I10 = y(E13), R7 = l3(a28), [c21 = t14 ? [] : void 0, L7] = b2(s21, y10, R7), f21 = u22({ id: m10, __demoMode: p13 }), k13 = (0, import_react130.useRef)({ static: false, hold: false }), N4 = (0, import_react130.useRef)(/* @__PURE__ */ new Map()), C11 = u9(o20), V6 = (0, import_react130.useCallback)((P8) => u(n17.mode, { [P6.Multi]: () => c21.some((W5) => C11(W5, P8)), [P6.Single]: () => C11(c21, P8) }), [c21]), n17 = n2({ value: c21, disabled: O5, invalid: x10, mode: t14 ? P6.Multi : P6.Single, orientation: h16, onChange: L7, compare: C11, isSelected: V6, optionsPropsRef: k13, listRef: N4 });
  n(() => {
    f21.state.dataRef.current = n17;
  }, [n17]);
  let F7 = S3(f21, (P8) => P8.listboxState), U3 = x2.get(null), H9 = S3(U3, (0, import_react130.useCallback)((P8) => U3.selectors.isTop(P8, m10), [U3, m10])), [A5, $7] = S3(f21, (P8) => [P8.buttonElement, P8.optionsElement]);
  k5(H9, [A5, $7], (P8, W5) => {
    f21.send({ type: k9.CloseListbox }), H4(W5, I4.Loose) || (P8.preventDefault(), A5 == null || A5.focus());
  });
  let r22 = n2({ open: F7 === F6.Open, disabled: O5, invalid: x10, value: c21 }), [M12, ne4] = V2({ inherit: true }), re5 = { ref: I10 }, q5 = (0, import_react130.useCallback)(() => {
    if (R7 !== void 0) return L7 == null ? void 0 : L7(R7);
  }, [L7, R7]), le = K();
  return import_react130.default.createElement(ne4, { value: M12, props: { htmlFor: A5 == null ? void 0 : A5.id }, slot: { open: F7 === F6.Open, disabled: O5 } }, import_react130.default.createElement(Ae, null, import_react130.default.createElement(c19.Provider, { value: f21 }, import_react130.default.createElement(oe3.Provider, { value: n17 }, import_react130.default.createElement(c11, { value: u(F7, { [F6.Open]: i10.Open, [F6.Closed]: i10.Closed }) }, i16 != null && c21 != null && import_react130.default.createElement(j2, { disabled: O5, data: { [i16]: c21 }, form: _10, onReset: q5 }), le({ ourProps: re5, theirProps: S11, slot: r22, defaultTag: Pt, name: "Listbox" }))))));
}
var vt = "button";
function Et(b14, E13) {
  let m10 = (0, import_react74.useId)(), u25 = u4(), s21 = Q3("Listbox.Button"), a28 = p10("Listbox.Button"), { id: _10 = u25 || `headlessui-listbox-button-${m10}`, disabled: i16 = s21.disabled || false, autoFocus: y10 = false, ...o20 } = b14, x10 = y(E13, Fe(), a28.actions.setButtonElement), O5 = be(), [l19, t14, p13] = S3(a28, (r22) => [r22.listboxState, r22.buttonElement, r22.optionsElement]), S11 = l19 === F6.Open;
  L4(S11, { trigger: t14, action: (0, import_react130.useCallback)((r22) => {
    if (t14 != null && t14.contains(r22.target)) return S5.Ignore;
    let M12 = r22.target.closest('[role="option"]:not([data-disabled])');
    return n5(M12) ? S5.Select(M12) : p13 != null && p13.contains(r22.target) ? S5.Ignore : S5.Close;
  }, [t14, p13]), close: a28.actions.closeListbox, select: a28.actions.selectActiveOption });
  let h16 = o4((r22) => {
    switch (r22.key) {
      case o8.Enter:
        g(r22.currentTarget);
        break;
      case o8.Space:
      case o8.ArrowDown:
        r22.preventDefault(), a28.actions.openListbox({ focus: s21.value ? c12.Nothing : c12.First });
        break;
      case o8.ArrowUp:
        r22.preventDefault(), a28.actions.openListbox({ focus: s21.value ? c12.Nothing : c12.Last });
        break;
    }
  }), I10 = o4((r22) => {
    switch (r22.key) {
      case o8.Space:
        r22.preventDefault();
        break;
    }
  }), R7 = s8((r22) => {
    var M12;
    a28.state.listboxState === F6.Open ? ((0, import_react_dom11.flushSync)(() => a28.actions.closeListbox()), (M12 = a28.state.buttonElement) == null || M12.focus({ preventScroll: true })) : (r22.preventDefault(), a28.actions.openListbox({ focus: c12.Nothing }));
  }), c21 = o4((r22) => r22.preventDefault()), L7 = N([_10]), f21 = w3(), { isFocusVisible: k13, focusProps: N4 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: y10 }), { isHovered: C11, hoverProps: V6 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: i16 }), { pressed: n17, pressProps: F7 } = w({ disabled: i16 }), U3 = n2({ open: l19 === F6.Open, active: n17 || l19 === F6.Open, disabled: i16, invalid: s21.invalid, value: s21.value, hover: C11, focus: k13, autofocus: y10 }), H9 = S3(a28, (r22) => r22.listboxState === F6.Open), A5 = V(O5(), { ref: x10, id: _10, type: e5(b14, t14), "aria-haspopup": "listbox", "aria-controls": p13 == null ? void 0 : p13.id, "aria-expanded": H9, "aria-labelledby": L7, "aria-describedby": f21, disabled: i16 || void 0, autoFocus: y10, onKeyDown: h16, onKeyUp: I10, onKeyPress: c21 }, R7, N4, V6, F7);
  return K()({ ourProps: A5, theirProps: o20, slot: U3, defaultTag: vt, name: "Listbox.Button" });
}
var Oe2 = (0, import_react130.createContext)(false);
var ht2 = "div";
var At = A.RenderStrategy | A.Static;
function _t(b14, E13) {
  let m10 = (0, import_react74.useId)(), { id: u25 = `headlessui-listbox-options-${m10}`, anchor: s21, portal: a28 = false, modal: _10 = true, transition: i16 = false, ...y10 } = b14, o20 = ye(s21), [x10, O5] = (0, import_react130.useState)(null);
  o20 && (a28 = true);
  let l19 = Q3("Listbox.Options"), t14 = p10("Listbox.Options"), [p13, S11, h16, I10] = S3(t14, (e9) => [e9.listboxState, e9.buttonElement, e9.optionsElement, e9.__demoMode]), R7 = u13(S11), c21 = u13(h16), L7 = u17(), [f21, k13] = N2(i16, x10, L7 !== null ? (L7 & i10.Open) === i10.Open : p13 === F6.Open);
  p5(f21, S11, t14.actions.closeListbox);
  let N4 = I10 ? false : _10 && p13 === F6.Open;
  f11(N4, c21);
  let C11 = I10 ? false : _10 && p13 === F6.Open;
  y4(C11, { allowed: (0, import_react130.useCallback)(() => [S11, h16], [S11, h16]) });
  let n17 = S3(t14, t14.selectors.didButtonMove) ? false : f21, F7 = S3(t14, t14.selectors.hasFrozenValue) && !b14.static, U3 = u16(F7, l19.value), H9 = (0, import_react130.useCallback)((e9) => l19.compare(U3, e9), [l19.compare, U3]), A5 = S3(t14, (e9) => {
    var de6;
    if (o20 == null || !((de6 = o20 == null ? void 0 : o20.to) != null && de6.includes("selection"))) return null;
    let w12 = e9.options.findIndex((ve3) => H9(ve3.dataRef.current.value));
    return w12 === -1 && (w12 = 0), w12;
  }), $7 = (() => {
    if (o20 == null) return;
    if (A5 === null) return { ...o20, inner: void 0 };
    let e9 = Array.from(l19.listRef.current.values());
    return { ...o20, inner: { listRef: { current: e9 }, index: A5 } };
  })(), [r22, M12] = Re($7), ne4 = Te(), re5 = y(E13, o20 ? r22 : null, t14.actions.setOptionsElement, O5), q5 = p();
  (0, import_react130.useEffect)(() => {
    let e9 = h16;
    e9 && p13 === F6.Open && (d2(e9) || e9 == null || e9.focus({ preventScroll: true }));
  }, [p13, h16]);
  let le = o4((e9) => {
    var w12;
    switch (q5.dispose(), e9.key) {
      case o8.Space:
        if (t14.state.searchQuery !== "") return e9.preventDefault(), e9.stopPropagation(), t14.actions.search(e9.key);
      case o8.Enter:
        e9.preventDefault(), e9.stopPropagation(), t14.actions.selectActiveOption();
        break;
      case u(l19.orientation, { vertical: o8.ArrowDown, horizontal: o8.ArrowRight }):
        return e9.preventDefault(), e9.stopPropagation(), t14.actions.goToOption({ focus: c12.Next });
      case u(l19.orientation, { vertical: o8.ArrowUp, horizontal: o8.ArrowLeft }):
        return e9.preventDefault(), e9.stopPropagation(), t14.actions.goToOption({ focus: c12.Previous });
      case o8.Home:
      case o8.PageUp:
        return e9.preventDefault(), e9.stopPropagation(), t14.actions.goToOption({ focus: c12.First });
      case o8.End:
      case o8.PageDown:
        return e9.preventDefault(), e9.stopPropagation(), t14.actions.goToOption({ focus: c12.Last });
      case o8.Escape:
        e9.preventDefault(), e9.stopPropagation(), (0, import_react_dom11.flushSync)(() => t14.actions.closeListbox()), (w12 = t14.state.buttonElement) == null || w12.focus({ preventScroll: true });
        return;
      case o8.Tab:
        e9.preventDefault(), e9.stopPropagation(), (0, import_react_dom11.flushSync)(() => t14.actions.closeListbox()), R3(t14.state.buttonElement, e9.shiftKey ? T4.Previous : T4.Next);
        break;
      default:
        e9.key.length === 1 && (t14.actions.search(e9.key), q5.setTimeout(() => t14.actions.clearSearch(), 350));
        break;
    }
  }), P8 = S3(t14, (e9) => {
    var w12;
    return (w12 = e9.buttonElement) == null ? void 0 : w12.id;
  }), W5 = n2({ open: p13 === F6.Open }), Le6 = V(o20 ? ne4() : {}, { id: u25, ref: re5, "aria-activedescendant": S3(t14, t14.selectors.activeDescendantId), "aria-multiselectable": l19.mode === P6.Multi ? true : void 0, "aria-labelledby": P8, "aria-orientation": l19.orientation, onKeyDown: le, role: "listbox", tabIndex: p13 === F6.Open ? 0 : void 0, style: { ...y10.style, ...M12, "--button-width": w5(f21, S11, true).width }, ...x4(k13) }), Pe2 = K(), ge7 = (0, import_react130.useMemo)(() => l19.mode === P6.Multi ? l19 : { ...l19, isSelected: H9 }, [l19, H9]);
  return import_react130.default.createElement(te, { enabled: a28 ? b14.static || f21 : false, ownerDocument: R7 }, import_react130.default.createElement(oe3.Provider, { value: ge7 }, Pe2({ ourProps: Le6, theirProps: y10, slot: W5, defaultTag: ht2, features: At, visible: n17, name: "Listbox.Options" })));
}
var St = "div";
function Dt(b14, E13) {
  let m10 = (0, import_react74.useId)(), { id: u25 = `headlessui-listbox-option-${m10}`, disabled: s21 = false, value: a28, ..._10 } = b14, i16 = (0, import_react130.useContext)(Oe2) === true, y10 = Q3("Listbox.Option"), o20 = p10("Listbox.Option"), x10 = S3(o20, (n17) => o20.selectors.isActive(n17, u25)), O5 = y10.isSelected(a28), l19 = (0, import_react130.useRef)(null), t14 = s16(l19), p13 = s3({ disabled: s21, value: a28, domRef: l19, get textValue() {
    return t14();
  } }), S11 = y(E13, l19, (n17) => {
    n17 ? y10.listRef.current.set(u25, n17) : y10.listRef.current.delete(u25);
  }), h16 = S3(o20, (n17) => o20.selectors.shouldScrollIntoView(n17, u25));
  n(() => {
    if (h16) return o2().requestAnimationFrame(() => {
      var n17, F7;
      (F7 = (n17 = l19.current) == null ? void 0 : n17.scrollIntoView) == null || F7.call(n17, { block: "nearest" });
    });
  }, [h16, l19]), n(() => {
    if (!i16) return o20.actions.registerOption(u25, p13), () => o20.actions.unregisterOption(u25);
  }, [p13, u25, i16]);
  let I10 = o4((n17) => {
    if (s21) return n17.preventDefault();
    o20.actions.selectOption(a28);
  }), R7 = o4(() => {
    if (s21) return o20.actions.goToOption({ focus: c12.Nothing });
    o20.actions.goToOption({ focus: c12.Specific, id: u25 });
  }), c21 = u15(), L7 = o4((n17) => c21.update(n17)), f21 = o4((n17) => {
    c21.wasMoved(n17) && (s21 || x10 && o20.state.activationTrigger === C8.Pointer || o20.actions.goToOption({ focus: c12.Specific, id: u25 }, C8.Pointer));
  }), k13 = o4((n17) => {
    c21.wasMoved(n17) && (s21 || x10 && o20.state.activationTrigger === C8.Pointer && o20.actions.goToOption({ focus: c12.Nothing }));
  }), N4 = n2({ active: x10, focus: x10, selected: O5, disabled: s21, selectedOption: O5 && i16 }), C11 = i16 ? {} : { id: u25, ref: S11, role: "option", tabIndex: s21 === true ? void 0 : -1, "aria-disabled": s21 === true ? true : void 0, "aria-selected": O5, disabled: void 0, onClick: I10, onFocus: R7, onPointerEnter: L7, onMouseEnter: L7, onPointerMove: f21, onMouseMove: f21, onPointerLeave: k13, onMouseLeave: k13 }, V6 = K();
  return !O5 && i16 ? null : V6({ ourProps: C11, theirProps: _10, slot: N4, defaultTag: St, name: "Listbox.Option" });
}
var Rt = import_react130.Fragment;
function Ft(b14, E13) {
  let { options: m10, placeholder: u25, ...s21 } = b14, _10 = { ref: y(E13) }, i16 = Q3("ListboxSelectedOption"), y10 = n2({}), o20 = i16.value === void 0 || i16.value === null || i16.mode === P6.Multi && Array.isArray(i16.value) && i16.value.length === 0, x10 = K();
  return import_react130.default.createElement(Oe2.Provider, { value: true }, x10({ ourProps: _10, theirProps: { ...s21, children: import_react130.default.createElement(import_react130.default.Fragment, null, u25 && o20 ? u25 : m10) }, slot: y10, defaultTag: Rt, name: "ListboxSelectedOption" }));
}
var Ct = Y(gt);
var Mt = Y(Et);
var wt = Z;
var Bt = Y(_t);
var It = Y(Dt);
var kt = Y(Ft);
var Mo2 = Object.assign(Ct, { Button: Mt, Label: wt, Options: Bt, Option: It, SelectedOption: kt });

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/menu/menu.js
var import_react132 = __toESM(require_react(), 1);
var import_react_dom12 = __toESM(require_react_dom(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/menu/menu-machine.js
var y9 = Object.defineProperty;
var M9 = (e9, i16, t14) => i16 in e9 ? y9(e9, i16, { enumerable: true, configurable: true, writable: true, value: t14 }) : e9[i16] = t14;
var S9 = (e9, i16, t14) => (M9(e9, typeof i16 != "symbol" ? i16 + "" : i16, t14), t14);
var P7 = ((t14) => (t14[t14.Open = 0] = "Open", t14[t14.Closed = 1] = "Closed", t14))(P7 || {});
var D11 = ((t14) => (t14[t14.Pointer = 0] = "Pointer", t14[t14.Other = 1] = "Other", t14))(D11 || {});
var C9 = ((o20) => (o20[o20.OpenMenu = 0] = "OpenMenu", o20[o20.CloseMenu = 1] = "CloseMenu", o20[o20.GoToItem = 2] = "GoToItem", o20[o20.Search = 3] = "Search", o20[o20.ClearSearch = 4] = "ClearSearch", o20[o20.RegisterItems = 5] = "RegisterItems", o20[o20.UnregisterItems = 6] = "UnregisterItems", o20[o20.SetButtonElement = 7] = "SetButtonElement", o20[o20.SetItemsElement = 8] = "SetItemsElement", o20[o20.SortItems = 9] = "SortItems", o20[o20.MarkButtonAsMoved = 10] = "MarkButtonAsMoved", o20))(C9 || {});
function x9(e9, i16 = (t14) => t14) {
  let t14 = e9.activeItemIndex !== null ? e9.items[e9.activeItemIndex] : null, n17 = G2(i16(e9.items.slice()), (s21) => s21.dataRef.current.domRef.current), r22 = t14 ? n17.indexOf(t14) : null;
  return r22 === -1 && (r22 = null), { items: n17, activeItemIndex: r22 };
}
var k10 = { [1](e9) {
  if (e9.menuState === 1) return e9;
  let i16 = e9.buttonElement ? c16.Tracked(a18(e9.buttonElement)) : e9.buttonPositionState;
  return { ...e9, activeItemIndex: null, pendingFocus: { focus: c12.Nothing }, menuState: 1, buttonPositionState: i16 };
}, [0](e9, i16) {
  return e9.menuState === 0 ? e9 : { ...e9, __demoMode: false, pendingFocus: i16.focus, menuState: 0, buttonPositionState: c16.Idle };
}, [2]: (e9, i16) => {
  var s21, l19, a28, I10, f21;
  if (e9.menuState === 1) return e9;
  let t14 = { ...e9, searchQuery: "", activationTrigger: (s21 = i16.trigger) != null ? s21 : 1, __demoMode: false };
  if (i16.focus === c12.Nothing) return { ...t14, activeItemIndex: null };
  if (i16.focus === c12.Specific) return { ...t14, activeItemIndex: e9.items.findIndex((d14) => d14.id === i16.id) };
  if (i16.focus === c12.Previous) {
    let d14 = e9.activeItemIndex;
    if (d14 !== null) {
      let o20 = e9.items[d14].dataRef.current.domRef, c21 = f14(i16, { resolveItems: () => e9.items, resolveActiveIndex: () => e9.activeItemIndex, resolveId: (u25) => u25.id, resolveDisabled: (u25) => u25.dataRef.current.disabled });
      if (c21 !== null) {
        let u25 = e9.items[c21].dataRef.current.domRef;
        if (((l19 = o20.current) == null ? void 0 : l19.previousElementSibling) === u25.current || ((a28 = u25.current) == null ? void 0 : a28.previousElementSibling) === null) return { ...t14, activeItemIndex: c21 };
      }
    }
  } else if (i16.focus === c12.Next) {
    let d14 = e9.activeItemIndex;
    if (d14 !== null) {
      let o20 = e9.items[d14].dataRef.current.domRef, c21 = f14(i16, { resolveItems: () => e9.items, resolveActiveIndex: () => e9.activeItemIndex, resolveId: (u25) => u25.id, resolveDisabled: (u25) => u25.dataRef.current.disabled });
      if (c21 !== null) {
        let u25 = e9.items[c21].dataRef.current.domRef;
        if (((I10 = o20.current) == null ? void 0 : I10.nextElementSibling) === u25.current || ((f21 = u25.current) == null ? void 0 : f21.nextElementSibling) === null) return { ...t14, activeItemIndex: c21 };
      }
    }
  }
  let n17 = x9(e9), r22 = f14(i16, { resolveItems: () => n17.items, resolveActiveIndex: () => n17.activeItemIndex, resolveId: (d14) => d14.id, resolveDisabled: (d14) => d14.dataRef.current.disabled });
  return { ...t14, ...n17, activeItemIndex: r22 };
}, [3]: (e9, i16) => {
  let n17 = e9.searchQuery !== "" ? 0 : 1, r22 = e9.searchQuery + i16.value.toLowerCase(), l19 = (e9.activeItemIndex !== null ? e9.items.slice(e9.activeItemIndex + n17).concat(e9.items.slice(0, e9.activeItemIndex + n17)) : e9.items).find((I10) => {
    var f21;
    return ((f21 = I10.dataRef.current.textValue) == null ? void 0 : f21.startsWith(r22)) && !I10.dataRef.current.disabled;
  }), a28 = l19 ? e9.items.indexOf(l19) : -1;
  return a28 === -1 || a28 === e9.activeItemIndex ? { ...e9, searchQuery: r22 } : { ...e9, searchQuery: r22, activeItemIndex: a28, activationTrigger: 1 };
}, [4](e9) {
  return e9.searchQuery === "" ? e9 : { ...e9, searchQuery: "", searchActiveItemIndex: null };
}, [5]: (e9, i16) => {
  let t14 = e9.items.concat(i16.items.map((r22) => r22)), n17 = e9.activeItemIndex;
  return e9.pendingFocus.focus !== c12.Nothing && (n17 = f14(e9.pendingFocus, { resolveItems: () => t14, resolveActiveIndex: () => e9.activeItemIndex, resolveId: (r22) => r22.id, resolveDisabled: (r22) => r22.dataRef.current.disabled })), { ...e9, items: t14, activeItemIndex: n17, pendingFocus: { focus: c12.Nothing }, pendingShouldSort: true };
}, [6]: (e9, i16) => {
  let t14 = e9.items, n17 = [], r22 = new Set(i16.items);
  for (let [s21, l19] of t14.entries()) if (r22.has(l19.id) && (n17.push(s21), r22.delete(l19.id), r22.size === 0)) break;
  if (n17.length > 0) {
    t14 = t14.slice();
    for (let s21 of n17.reverse()) t14.splice(s21, 1);
  }
  return { ...e9, items: t14, activationTrigger: 1 };
}, [7]: (e9, i16) => e9.buttonElement === i16.element ? e9 : { ...e9, buttonElement: i16.element }, [8]: (e9, i16) => e9.itemsElement === i16.element ? e9 : { ...e9, itemsElement: i16.element }, [9]: (e9) => e9.pendingShouldSort ? { ...e9, ...x9(e9), pendingShouldSort: false } : e9, [10](e9) {
  return e9.buttonPositionState.kind !== "Tracked" ? e9 : { ...e9, buttonPositionState: c16.Moved };
} };
var h11 = class _h extends T3 {
  constructor(t14) {
    super(t14);
    S9(this, "actions", { registerItem: k3(() => {
      let t15 = [], n17 = /* @__PURE__ */ new Set();
      return [(r22, s21) => {
        n17.has(s21) || (n17.add(s21), t15.push({ id: r22, dataRef: s21 }));
      }, () => (n17.clear(), this.send({ type: 5, items: t15.splice(0) }))];
    }), unregisterItem: k3(() => {
      let t15 = [];
      return [(n17) => t15.push(n17), () => this.send({ type: 6, items: t15.splice(0) })];
    }) });
    S9(this, "selectors", { activeDescendantId(t15) {
      var s21;
      let n17 = t15.activeItemIndex, r22 = t15.items;
      return n17 === null || (s21 = r22[n17]) == null ? void 0 : s21.id;
    }, isActive(t15, n17) {
      var l19;
      let r22 = t15.activeItemIndex, s21 = t15.items;
      return r22 !== null ? ((l19 = s21[r22]) == null ? void 0 : l19.id) === n17 : false;
    }, shouldScrollIntoView(t15, n17) {
      return t15.__demoMode || t15.menuState !== 0 || t15.activationTrigger === 0 ? false : this.isActive(t15, n17);
    }, didButtonMove(t15) {
      return t15.buttonPositionState.kind === "Moved";
    } });
    this.on(5, () => {
      this.disposables.requestAnimationFrame(() => {
        this.send({ type: 9 });
      });
    });
    {
      let n17 = this.state.id, r22 = x2.get(null);
      this.disposables.add(r22.on(k4.Push, (s21) => {
        !r22.selectors.isTop(s21, n17) && this.state.menuState === 0 && this.send({ type: 1 });
      })), this.on(0, () => r22.actions.push(n17)), this.on(1, () => r22.actions.pop(n17));
    }
    this.disposables.group((n17) => {
      this.on(1, (r22) => {
        r22.buttonElement && (n17.dispose(), n17.add(p6(r22.buttonElement, r22.buttonPositionState, () => {
          this.send({ type: 10 });
        })));
      });
    });
  }
  static new({ id: t14, __demoMode: n17 = false }) {
    return new _h({ id: t14, __demoMode: n17, menuState: n17 ? 0 : 1, buttonElement: null, itemsElement: null, items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1, pendingShouldSort: false, pendingFocus: { focus: c12.Nothing }, buttonPositionState: c16.Idle });
  }
  reduce(t14, n17) {
    return u(n17.type, k10, t14, n17);
  }
};

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/menu/menu-machine-glue.js
var import_react131 = __toESM(require_react(), 1);
var a25 = (0, import_react131.createContext)(null);
function p11(t14) {
  let n17 = (0, import_react131.useContext)(a25);
  if (n17 === null) {
    let e9 = new Error(`<${t14} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(e9, s17), e9;
  }
  return n17;
}
function s17({ id: t14, __demoMode: n17 = false }) {
  let e9 = (0, import_react131.useMemo)(() => h11.new({ id: t14, __demoMode: n17 }), []);
  return c13(() => e9.dispose()), e9;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/menu/menu.js
var Ze = import_react132.Fragment;
function et(m10, y10) {
  let l19 = (0, import_react74.useId)(), { __demoMode: a28 = false, ...p13 } = m10, s21 = s17({ id: l19, __demoMode: a28 }), [n17, M12, f21] = S3(s21, (d14) => [d14.menuState, d14.itemsElement, d14.buttonElement]), _10 = y(y10), o20 = x2.get(null), F7 = S3(o20, (0, import_react132.useCallback)((d14) => o20.selectors.isTop(d14, l19), [o20, l19]));
  k5(F7, [f21, M12], (d14, T11) => {
    var P8;
    s21.send({ type: C9.CloseMenu }), H4(T11, I4.Loose) || (d14.preventDefault(), (P8 = s21.state.buttonElement) == null || P8.focus());
  });
  let I10 = o4(() => {
    s21.send({ type: C9.CloseMenu });
  }), b14 = n2({ open: n17 === P7.Open, close: I10 }), i16 = { ref: _10 }, g6 = K();
  return import_react132.default.createElement(Ae, null, import_react132.default.createElement(a25.Provider, { value: s21 }, import_react132.default.createElement(c11, { value: u(n17, { [P7.Open]: i10.Open, [P7.Closed]: i10.Closed }) }, g6({ ourProps: i16, theirProps: p13, slot: b14, defaultTag: Ze, name: "Menu" }))));
}
var tt = "button";
function ot(m10, y10) {
  let l19 = p11("Menu.Button"), a28 = (0, import_react74.useId)(), { id: p13 = `headlessui-menu-button-${a28}`, disabled: s21 = false, autoFocus: n17 = false, ...M12 } = m10, f21 = (0, import_react132.useRef)(null), _10 = be(), o20 = y(y10, f21, Fe(), o4((t14) => l19.send({ type: C9.SetButtonElement, element: t14 }))), F7 = o4((t14) => {
    switch (t14.key) {
      case o8.Space:
      case o8.Enter:
      case o8.ArrowDown:
        t14.preventDefault(), t14.stopPropagation(), l19.send({ type: C9.OpenMenu, focus: { focus: c12.First } });
        break;
      case o8.ArrowUp:
        t14.preventDefault(), t14.stopPropagation(), l19.send({ type: C9.OpenMenu, focus: { focus: c12.Last } });
        break;
    }
  }), I10 = o4((t14) => {
    switch (t14.key) {
      case o8.Space:
        t14.preventDefault();
        break;
    }
  }), [b14, i16, g6] = S3(l19, (t14) => [t14.menuState, t14.buttonElement, t14.itemsElement]), d14 = b14 === P7.Open;
  L4(d14, { trigger: i16, action: (0, import_react132.useCallback)((t14) => {
    if (i16 != null && i16.contains(t14.target)) return S5.Ignore;
    let S11 = t14.target.closest('[role="menuitem"]:not([data-disabled])');
    return n5(S11) ? S5.Select(S11) : g6 != null && g6.contains(t14.target) ? S5.Ignore : S5.Close;
  }, [i16, g6]), close: (0, import_react132.useCallback)(() => l19.send({ type: C9.CloseMenu }), []), select: (0, import_react132.useCallback)((t14) => t14.click(), []) });
  let T11 = s8((t14) => {
    var S11;
    s21 || (b14 === P7.Open ? ((0, import_react_dom12.flushSync)(() => l19.send({ type: C9.CloseMenu })), (S11 = f21.current) == null || S11.focus({ preventScroll: true })) : (t14.preventDefault(), l19.send({ type: C9.OpenMenu, focus: { focus: c12.Nothing }, trigger: D11.Pointer })));
  }), { isFocusVisible: P8, focusProps: L7 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: n17 }), { isHovered: O5, hoverProps: v11 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: s21 }), { pressed: D13, pressProps: U3 } = w({ disabled: s21 }), H9 = n2({ open: b14 === P7.Open, active: D13 || b14 === P7.Open, disabled: s21, hover: O5, focus: P8, autofocus: n17 }), G6 = V(_10(), { ref: o20, id: p13, type: e5(m10, f21.current), "aria-haspopup": "menu", "aria-controls": g6 == null ? void 0 : g6.id, "aria-expanded": b14 === P7.Open, disabled: s21 || void 0, autoFocus: n17, onKeyDown: F7, onKeyUp: I10 }, T11, L7, v11, U3);
  return K()({ ourProps: G6, theirProps: M12, slot: H9, defaultTag: tt, name: "Menu.Button" });
}
var nt = "div";
var rt = A.RenderStrategy | A.Static;
function at(m10, y10) {
  let l19 = (0, import_react74.useId)(), { id: a28 = `headlessui-menu-items-${l19}`, anchor: p13, portal: s21 = false, modal: n17 = true, transition: M12 = false, ...f21 } = m10, _10 = ye(p13), o20 = p11("Menu.Items"), [F7, I10] = Re(_10), b14 = Te(), [i16, g6] = (0, import_react132.useState)(null), d14 = y(y10, _10 ? F7 : null, o4((e9) => o20.send({ type: C9.SetItemsElement, element: e9 })), g6), [T11, P8] = S3(o20, (e9) => [e9.menuState, e9.buttonElement]), L7 = u13(P8), O5 = u13(i16);
  _10 && (s21 = true);
  let v11 = u17(), [D13, U3] = N2(M12, i16, v11 !== null ? (v11 & i10.Open) === i10.Open : T11 === P7.Open);
  p5(D13, P8, () => {
    o20.send({ type: C9.CloseMenu });
  });
  let H9 = S3(o20, (e9) => e9.__demoMode), G6 = H9 ? false : n17 && T11 === P7.Open;
  f11(G6, O5);
  let w12 = H9 ? false : n17 && T11 === P7.Open;
  y4(w12, { allowed: (0, import_react132.useCallback)(() => [P8, i16], [P8, i16]) });
  let S11 = S3(o20, o20.selectors.didButtonMove) ? false : D13;
  (0, import_react132.useEffect)(() => {
    let e9 = i16;
    e9 && T11 === P7.Open && (d2(e9) || e9.focus({ preventScroll: true }));
  }, [T11, i16]), F2(T11 === P7.Open, { container: i16, accept(e9) {
    return e9.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : e9.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(e9) {
    e9.setAttribute("role", "none");
  } });
  let z4 = p(), le = o4((e9) => {
    var N4, Y4, Z4;
    switch (z4.dispose(), e9.key) {
      case o8.Space:
        if (o20.state.searchQuery !== "") return e9.preventDefault(), e9.stopPropagation(), o20.send({ type: C9.Search, value: e9.key });
      case o8.Enter:
        if (e9.preventDefault(), e9.stopPropagation(), o20.state.activeItemIndex !== null) {
          let { dataRef: de6 } = o20.state.items[o20.state.activeItemIndex];
          (Y4 = (N4 = de6.current) == null ? void 0 : N4.domRef.current) == null || Y4.click();
        }
        o20.send({ type: C9.CloseMenu }), K2(o20.state.buttonElement);
        break;
      case o8.ArrowDown:
        return e9.preventDefault(), e9.stopPropagation(), o20.send({ type: C9.GoToItem, focus: c12.Next });
      case o8.ArrowUp:
        return e9.preventDefault(), e9.stopPropagation(), o20.send({ type: C9.GoToItem, focus: c12.Previous });
      case o8.Home:
      case o8.PageUp:
        return e9.preventDefault(), e9.stopPropagation(), o20.send({ type: C9.GoToItem, focus: c12.First });
      case o8.End:
      case o8.PageDown:
        return e9.preventDefault(), e9.stopPropagation(), o20.send({ type: C9.GoToItem, focus: c12.Last });
      case o8.Escape:
        e9.preventDefault(), e9.stopPropagation(), (0, import_react_dom12.flushSync)(() => o20.send({ type: C9.CloseMenu })), (Z4 = o20.state.buttonElement) == null || Z4.focus({ preventScroll: true });
        break;
      case o8.Tab:
        e9.preventDefault(), e9.stopPropagation(), (0, import_react_dom12.flushSync)(() => o20.send({ type: C9.CloseMenu })), R3(o20.state.buttonElement, e9.shiftKey ? T4.Previous : T4.Next);
        break;
      default:
        e9.key.length === 1 && (o20.send({ type: C9.Search, value: e9.key }), z4.setTimeout(() => o20.send({ type: C9.ClearSearch }), 350));
        break;
    }
  }), pe4 = o4((e9) => {
    switch (e9.key) {
      case o8.Space:
        e9.preventDefault();
        break;
    }
  }), ie4 = n2({ open: T11 === P7.Open }), ue5 = V(_10 ? b14() : {}, { "aria-activedescendant": S3(o20, o20.selectors.activeDescendantId), "aria-labelledby": S3(o20, (e9) => {
    var N4;
    return (N4 = e9.buttonElement) == null ? void 0 : N4.id;
  }), id: a28, onKeyDown: le, onKeyUp: pe4, role: "menu", tabIndex: T11 === P7.Open ? 0 : void 0, ref: d14, style: { ...f21.style, ...I10, "--button-width": w5(D13, P8, true).width }, ...x4(U3) }), me5 = K();
  return import_react132.default.createElement(te, { enabled: s21 ? m10.static || D13 : false, ownerDocument: L7 }, me5({ ourProps: ue5, theirProps: f21, slot: ie4, defaultTag: nt, features: rt, visible: S11, name: "Menu.Items" }));
}
var st = import_react132.Fragment;
function lt(m10, y10) {
  let l19 = (0, import_react74.useId)(), { id: a28 = `headlessui-menu-item-${l19}`, disabled: p13 = false, ...s21 } = m10, n17 = p11("Menu.Item"), M12 = S3(n17, (t14) => n17.selectors.isActive(t14, a28)), f21 = (0, import_react132.useRef)(null), _10 = y(y10, f21), o20 = S3(n17, (t14) => n17.selectors.shouldScrollIntoView(t14, a28));
  n(() => {
    if (o20) return o2().requestAnimationFrame(() => {
      var t14, S11;
      (S11 = (t14 = f21.current) == null ? void 0 : t14.scrollIntoView) == null || S11.call(t14, { block: "nearest" });
    });
  }, [o20, f21]);
  let F7 = s16(f21), I10 = (0, import_react132.useRef)({ disabled: p13, domRef: f21, get textValue() {
    return F7();
  } });
  n(() => {
    I10.current.disabled = p13;
  }, [I10, p13]), n(() => (n17.actions.registerItem(a28, I10), () => n17.actions.unregisterItem(a28)), [I10, a28]);
  let b14 = o4(() => {
    n17.send({ type: C9.CloseMenu });
  }), i16 = o4((t14) => {
    if (p13) return t14.preventDefault();
    n17.send({ type: C9.CloseMenu }), K2(n17.state.buttonElement);
  }), g6 = o4(() => {
    if (p13) return n17.send({ type: C9.GoToItem, focus: c12.Nothing });
    n17.send({ type: C9.GoToItem, focus: c12.Specific, id: a28 });
  }), d14 = u15(), T11 = o4((t14) => d14.update(t14)), P8 = o4((t14) => {
    d14.wasMoved(t14) && (p13 || M12 || n17.send({ type: C9.GoToItem, focus: c12.Specific, id: a28, trigger: D11.Pointer }));
  }), L7 = o4((t14) => {
    d14.wasMoved(t14) && (p13 || M12 && n17.state.activationTrigger === D11.Pointer && n17.send({ type: C9.GoToItem, focus: c12.Nothing }));
  }), [O5, v11] = V2(), [D13, U3] = H3(), H9 = n2({ active: M12, focus: M12, disabled: p13, close: b14 }), G6 = { id: a28, ref: _10, role: "menuitem", tabIndex: p13 === true ? void 0 : -1, "aria-disabled": p13 === true ? true : void 0, "aria-labelledby": O5, "aria-describedby": D13, disabled: void 0, onClick: i16, onFocus: g6, onPointerEnter: T11, onMouseEnter: T11, onPointerMove: P8, onMouseMove: P8, onPointerLeave: L7, onMouseLeave: L7 }, w12 = K();
  return import_react132.default.createElement(v11, null, import_react132.default.createElement(U3, null, w12({ ourProps: G6, theirProps: s21, slot: H9, defaultTag: st, name: "Menu.Item" })));
}
var pt = "div";
function it(m10, y10) {
  let [l19, a28] = V2(), p13 = m10, s21 = { ref: y10, "aria-labelledby": l19, role: "group" }, n17 = K();
  return import_react132.default.createElement(a28, null, n17({ ourProps: s21, theirProps: p13, slot: {}, defaultTag: pt, name: "Menu.Section" }));
}
var ut = "header";
function mt(m10, y10) {
  let l19 = (0, import_react74.useId)(), { id: a28 = `headlessui-menu-heading-${l19}`, ...p13 } = m10, s21 = C4();
  n(() => s21.register(a28), [a28, s21.register]);
  let n17 = { id: a28, ref: y10, role: "presentation", ...s21.props };
  return K()({ ourProps: n17, theirProps: p13, slot: {}, defaultTag: ut, name: "Menu.Heading" });
}
var dt = "div";
function Tt(m10, y10) {
  let l19 = m10, a28 = { ref: y10, role: "separator" };
  return K()({ ourProps: a28, theirProps: l19, slot: {}, defaultTag: dt, name: "Menu.Separator" });
}
var ct = Y(et);
var ft = Y(ot);
var yt = Y(at);
var gt2 = Y(lt);
var Pt2 = Y(it);
var Et2 = Y(mt);
var Mt2 = Y(Tt);
var lo = Object.assign(ct, { Button: ft, Items: yt, Item: gt2, Section: Pt2, Heading: Et2, Separator: Mt2 });

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/popover/popover.js
var import_react134 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/popover/popover-machine.js
var f18 = Object.defineProperty;
var b12 = (t14, n17, e9) => n17 in t14 ? f18(t14, n17, { enumerable: true, configurable: true, writable: true, value: e9 }) : t14[n17] = e9;
var p12 = (t14, n17, e9) => (b12(t14, typeof n17 != "symbol" ? n17 + "" : n17, e9), e9);
var v9 = ((e9) => (e9[e9.Open = 0] = "Open", e9[e9.Closed = 1] = "Closed", e9))(v9 || {});
var h13 = ((r22) => (r22[r22.OpenPopover = 0] = "OpenPopover", r22[r22.ClosePopover = 1] = "ClosePopover", r22[r22.SetButton = 2] = "SetButton", r22[r22.SetButtonId = 3] = "SetButtonId", r22[r22.SetPanel = 4] = "SetPanel", r22[r22.SetPanelId = 5] = "SetPanelId", r22))(h13 || {});
var E11 = { [0]: (t14) => t14.popoverState === 0 ? t14 : { ...t14, popoverState: 0, __demoMode: false }, [1](t14) {
  return t14.popoverState === 1 ? t14 : { ...t14, popoverState: 1, __demoMode: false };
}, [2](t14, n17) {
  return t14.button === n17.button ? t14 : { ...t14, button: n17.button };
}, [3](t14, n17) {
  return t14.buttonId === n17.buttonId ? t14 : { ...t14, buttonId: n17.buttonId };
}, [4](t14, n17) {
  return t14.panel === n17.panel ? t14 : { ...t14, panel: n17.panel };
}, [5](t14, n17) {
  return t14.panelId === n17.panelId ? t14 : { ...t14, panelId: n17.panelId };
} };
var d13 = class _d extends T3 {
  constructor(e9) {
    super(e9);
    p12(this, "actions", { close: () => this.send({ type: 1 }), refocusableClose: (e10) => {
      this.actions.close();
      let o20 = (() => e10 ? n5(e10) ? e10 : "current" in e10 && n5(e10.current) ? e10.current : this.state.button : this.state.button)();
      o20 == null || o20.focus();
    }, open: () => this.send({ type: 0 }), setButtonId: (e10) => this.send({ type: 3, buttonId: e10 }), setButton: (e10) => this.send({ type: 2, button: e10 }), setPanelId: (e10) => this.send({ type: 5, panelId: e10 }), setPanel: (e10) => this.send({ type: 4, panel: e10 }) });
    p12(this, "selectors", { isPortalled: (e10) => {
      var i16;
      if (!e10.button || !e10.panel) return false;
      let o20 = (i16 = l(e10.button)) != null ? i16 : document;
      for (let u25 of o20.querySelectorAll("body > *")) if (Number(u25 == null ? void 0 : u25.contains(e10.button)) ^ Number(u25 == null ? void 0 : u25.contains(e10.panel))) return true;
      let l19 = x3(o20), s21 = l19.indexOf(e10.button), r22 = (s21 + l19.length - 1) % l19.length, c21 = (s21 + 1) % l19.length, S11 = l19[r22], m10 = l19[c21];
      return !e10.panel.contains(S11) && !e10.panel.contains(m10);
    } });
    {
      let o20 = this.state.id, l19 = x2.get(null);
      this.on(0, () => l19.actions.push(o20)), this.on(1, () => l19.actions.pop(o20));
    }
  }
  static new({ id: e9, __demoMode: o20 = false }) {
    return new _d({ id: e9, __demoMode: o20, popoverState: o20 ? 0 : 1, buttons: { current: [] }, button: null, buttonId: null, panel: null, panelId: null, beforePanelSentinel: { current: null }, afterPanelSentinel: { current: null }, afterButtonSentinel: { current: null } });
  }
  reduce(e9, o20) {
    return u(o20.type, E11, e9, o20);
  }
};

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/popover/popover-machine-glue.js
var import_react133 = __toESM(require_react(), 1);
var a26 = (0, import_react133.createContext)(null);
function u24(r22) {
  let o20 = (0, import_react133.useContext)(a26);
  if (o20 === null) {
    let e9 = new Error(`<${r22} /> is missing a parent <Popover /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(e9, u24), e9;
  }
  return o20;
}
function f19({ id: r22, __demoMode: o20 = false }) {
  let e9 = (0, import_react133.useMemo)(() => d13.new({ id: r22, __demoMode: o20 }), []);
  return c13(() => e9.dispose()), e9;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/popover/popover.js
var Fe3 = (0, import_react134.createContext)(null);
Fe3.displayName = "PopoverGroupContext";
function we2() {
  return (0, import_react134.useContext)(Fe3);
}
var de5 = (0, import_react134.createContext)(null);
de5.displayName = "PopoverPanelContext";
function mt2() {
  return (0, import_react134.useContext)(de5);
}
var vt2 = "div";
function Tt2(E13, O5) {
  var M12;
  let R7 = (0, import_react74.useId)(), { __demoMode: B2 = false, ...T11 } = E13, n17 = f19({ id: R7, __demoMode: B2 }), b14 = (0, import_react134.useRef)(null), t14 = y(O5, T((r22) => {
    b14.current = r22;
  })), [A5, d14, o20, C11, y10] = S3(n17, (0, import_react134.useCallback)((r22) => [r22.popoverState, r22.button, r22.panel, r22.buttonId, r22.panelId], [])), D13 = c6((M12 = b14.current) != null ? M12 : d14), _10 = s3(C11), a28 = s3(y10), u25 = (0, import_react134.useMemo)(() => ({ buttonId: _10, panelId: a28, close: n17.actions.close }), [_10, a28, n17]), f21 = we2(), l19 = f21 == null ? void 0 : f21.registerPopover, c21 = o4(() => {
    var F7, G6;
    let r22 = e((F7 = b14.current) != null ? F7 : d14);
    return (G6 = f21 == null ? void 0 : f21.isFocusWithinPopoverGroup()) != null ? G6 : r22 && ((d14 == null ? void 0 : d14.contains(r22)) || (o20 == null ? void 0 : o20.contains(r22)));
  });
  (0, import_react134.useEffect)(() => l19 == null ? void 0 : l19(u25), [l19, u25]);
  let [m10, W5] = ee(), V6 = x6(d14), j11 = S8({ mainTreeNode: V6, portals: m10, defaultContainers: [{ get current() {
    return n17.state.button;
  } }, { get current() {
    return n17.state.panel;
  } }] });
  E7(D13, "focus", (r22) => {
    var F7, G6, h16, k13, I10, H9;
    r22.target !== window && i4(r22.target) && n17.state.popoverState === v9.Open && (c21() || n17.state.button && n17.state.panel && (j11.contains(r22.target) || (G6 = (F7 = n17.state.beforePanelSentinel.current) == null ? void 0 : F7.contains) != null && G6.call(F7, r22.target) || (k13 = (h16 = n17.state.afterPanelSentinel.current) == null ? void 0 : h16.contains) != null && k13.call(h16, r22.target) || (H9 = (I10 = n17.state.afterButtonSentinel.current) == null ? void 0 : I10.contains) != null && H9.call(I10, r22.target) || n17.actions.close()));
  }, true);
  let L7 = A5 === v9.Open;
  k5(L7, j11.resolveContainers, (r22, F7) => {
    n17.actions.close(), H4(F7, I4.Loose) || (r22.preventDefault(), d14 == null || d14.focus());
  });
  let Y4 = n2({ open: A5 === v9.Open, close: n17.actions.refocusableClose }), $7 = S3(n17, (0, import_react134.useCallback)((r22) => u(r22.popoverState, { [v9.Open]: i10.Open, [v9.Closed]: i10.Closed }), [])), Q7 = { ref: t14 }, Z4 = K();
  return import_react134.default.createElement(j9, { node: V6 }, import_react134.default.createElement(Ae, null, import_react134.default.createElement(de5.Provider, { value: null }, import_react134.default.createElement(a26.Provider, { value: n17 }, import_react134.default.createElement(C5, { value: n17.actions.refocusableClose }, import_react134.default.createElement(c11, { value: $7 }, import_react134.default.createElement(W5, null, Z4({ ourProps: Q7, theirProps: T11, slot: Y4, defaultTag: vt2, name: "Popover" }))))))));
}
var Et3 = "button";
function bt(E13, O5) {
  let R7 = (0, import_react74.useId)(), { id: B2 = `headlessui-popover-button-${R7}`, disabled: T11 = false, autoFocus: n17 = false, ...b14 } = E13, t14 = u24("Popover.Button"), [A5, d14, o20, C11, y10, D13, _10] = S3(t14, (0, import_react134.useCallback)((e9) => [e9.popoverState, t14.selectors.isPortalled(e9), e9.button, e9.buttonId, e9.panel, e9.panelId, e9.afterButtonSentinel], [])), a28 = (0, import_react134.useRef)(null), u25 = `headlessui-focus-sentinel-${(0, import_react74.useId)()}`, f21 = we2(), l19 = f21 == null ? void 0 : f21.closeOthers, m10 = mt2() !== null;
  (0, import_react134.useEffect)(() => {
    if (!m10) return t14.actions.setButtonId(B2), () => t14.actions.setButtonId(null);
  }, [m10, B2, t14]);
  let [W5] = (0, import_react134.useState)(() => Symbol()), V6 = y(a28, O5, Fe(), o4((e9) => {
    if (!m10) {
      if (e9) t14.state.buttons.current.push(W5);
      else {
        let p13 = t14.state.buttons.current.indexOf(W5);
        p13 !== -1 && t14.state.buttons.current.splice(p13, 1);
      }
      t14.state.buttons.current.length > 1 && console.warn("You are already using a <Popover.Button /> but only 1 <Popover.Button /> is supported."), e9 && t14.actions.setButton(e9);
    }
  })), j11 = y(a28, O5), L7 = o4((e9) => {
    var p13, i16, x10;
    if (m10) {
      if (t14.state.popoverState === v9.Closed) return;
      switch (e9.key) {
        case o8.Space:
        case o8.Enter:
          e9.preventDefault(), (i16 = (p13 = e9.target).click) == null || i16.call(p13), t14.actions.close(), (x10 = t14.state.button) == null || x10.focus();
          break;
      }
    } else switch (e9.key) {
      case o8.Space:
      case o8.Enter:
        e9.preventDefault(), e9.stopPropagation(), t14.state.popoverState === v9.Closed ? (l19 == null || l19(t14.state.buttonId), t14.actions.open()) : t14.actions.close();
        break;
      case o8.Escape:
        if (t14.state.popoverState !== v9.Open) return l19 == null ? void 0 : l19(t14.state.buttonId);
        if (!a28.current) return;
        let S11 = e(a28.current);
        if (S11 && !a28.current.contains(S11)) return;
        e9.preventDefault(), e9.stopPropagation(), t14.actions.close();
        break;
    }
  }), Y4 = o4((e9) => {
    m10 || e9.key === o8.Space && e9.preventDefault();
  }), $7 = o4((e9) => {
    var p13, i16;
    s6(e9.currentTarget) || T11 || (m10 ? (t14.actions.close(), (p13 = t14.state.button) == null || p13.focus()) : (e9.preventDefault(), e9.stopPropagation(), t14.state.popoverState === v9.Closed ? (l19 == null || l19(t14.state.buttonId), t14.actions.open()) : t14.actions.close(), (i16 = t14.state.button) == null || i16.focus()));
  }), Q7 = o4((e9) => {
    e9.preventDefault(), e9.stopPropagation();
  }), { isFocusVisible: Z4, focusProps: M12 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: n17 }), { isHovered: r22, hoverProps: F7 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: T11 }), { pressed: G6, pressProps: h16 } = w({ disabled: T11 }), k13 = A5 === v9.Open, I10 = n2({ open: k13, active: G6 || k13, disabled: T11, hover: r22, focus: Z4, autofocus: n17 }), H9 = e5(E13, o20), fe7 = m10 ? V({ ref: j11, type: H9, onKeyDown: L7, onClick: $7, disabled: T11 || void 0, autoFocus: n17 }, M12, F7, h16) : V({ ref: V6, id: C11, type: H9, "aria-expanded": A5 === v9.Open, "aria-controls": y10 ? D13 : void 0, disabled: T11 || void 0, autoFocus: n17, onKeyDown: L7, onKeyUp: Y4, onClick: $7, onMouseDown: Q7 }, M12, F7, h16), ae5 = u21(), Pe2 = o4(() => {
    if (!n5(t14.state.panel)) return;
    let e9 = t14.state.panel;
    function p13() {
      u(ae5.current, { [a21.Forwards]: () => v5(e9, T4.First), [a21.Backwards]: () => v5(e9, T4.Last) }) === A2.Error && v5(x3(r3(t14.state.button)).filter((x10) => x10.dataset.headlessuiFocusGuard !== "true"), u(ae5.current, { [a21.Forwards]: T4.Next, [a21.Backwards]: T4.Previous }), { relativeTo: t14.state.button });
    }
    p13();
  }), s21 = K();
  return import_react134.default.createElement(import_react134.default.Fragment, null, s21({ ourProps: fe7, theirProps: b14, slot: I10, defaultTag: Et3, name: "Popover.Button" }), k13 && !m10 && d14 && import_react134.default.createElement(f4, { id: u25, ref: _10, features: s5.Focusable, "data-headlessui-focus-guard": true, as: "button", type: "button", onFocus: Pe2 }));
}
var yt2 = "div";
var gt3 = A.RenderStrategy | A.Static;
function Ne2(E13, O5) {
  let R7 = (0, import_react74.useId)(), { id: B2 = `headlessui-popover-backdrop-${R7}`, transition: T11 = false, ...n17 } = E13, b14 = u24("Popover.Backdrop"), t14 = S3(b14, (0, import_react134.useCallback)((l19) => l19.popoverState, [])), [A5, d14] = (0, import_react134.useState)(null), o20 = y(O5, d14), C11 = u17(), [y10, D13] = N2(T11, A5, C11 !== null ? (C11 & i10.Open) === i10.Open : t14 === v9.Open), _10 = o4((l19) => {
    if (s6(l19.currentTarget)) return l19.preventDefault();
    b14.actions.close();
  }), a28 = n2({ open: t14 === v9.Open }), u25 = { ref: o20, id: B2, "aria-hidden": true, onClick: _10, ...x4(D13) };
  return K()({ ourProps: u25, theirProps: n17, slot: a28, defaultTag: yt2, features: gt3, visible: y10, name: "Popover.Backdrop" });
}
var Rt2 = "div";
var Ft2 = A.RenderStrategy | A.Static;
function Bt2(E13, O5) {
  let R7 = (0, import_react74.useId)(), { id: B2 = `headlessui-popover-panel-${R7}`, focus: T11 = false, anchor: n17, portal: b14 = false, modal: t14 = false, transition: A5 = false, ...d14 } = E13, o20 = u24("Popover.Panel"), C11 = S3(o20, o20.selectors.isPortalled), [y10, D13, _10, a28, u25] = S3(o20, (0, import_react134.useCallback)((s21) => [s21.popoverState, s21.button, s21.__demoMode, s21.beforePanelSentinel, s21.afterPanelSentinel], [])), f21 = `headlessui-focus-sentinel-before-${R7}`, l19 = `headlessui-focus-sentinel-after-${R7}`, c21 = (0, import_react134.useRef)(null), m10 = ye(n17), [W5, V6] = Re(m10), j11 = Te();
  m10 && (b14 = true);
  let [L7, Y4] = (0, import_react134.useState)(null), $7 = y(c21, O5, m10 ? W5 : null, o20.actions.setPanel, Y4), Q7 = u13(D13), Z4 = u13(c21.current);
  n(() => (o20.actions.setPanelId(B2), () => o20.actions.setPanelId(null)), [B2, o20]);
  let M12 = u17(), [r22, F7] = N2(A5, L7, M12 !== null ? (M12 & i10.Open) === i10.Open : y10 === v9.Open);
  p5(r22, D13, o20.actions.close), f11(_10 ? false : t14 && r22, Z4);
  let h16 = o4((s21) => {
    var e9;
    switch (s21.key) {
      case o8.Escape:
        if (o20.state.popoverState !== v9.Open || !c21.current) return;
        let p13 = e(c21.current);
        if (p13 && !c21.current.contains(p13)) return;
        s21.preventDefault(), s21.stopPropagation(), o20.actions.close(), (e9 = o20.state.button) == null || e9.focus();
        break;
    }
  });
  (0, import_react134.useEffect)(() => {
    var s21;
    E13.static || y10 === v9.Closed && ((s21 = E13.unmount) == null || s21) && o20.actions.setPanel(null);
  }, [y10, E13.unmount, E13.static, o20]), (0, import_react134.useEffect)(() => {
    if (_10 || !T11 || y10 !== v9.Open || !c21.current) return;
    let s21 = e(c21.current);
    c21.current.contains(s21) || v5(c21.current, T4.First);
  }, [_10, T11, c21.current, y10]);
  let k13 = n2({ open: y10 === v9.Open, close: o20.actions.refocusableClose }), I10 = V(m10 ? j11() : {}, { ref: $7, id: B2, onKeyDown: h16, onBlur: T11 && y10 === v9.Open ? (s21) => {
    var p13, i16, x10, S11, me5;
    let e9 = s21.relatedTarget;
    e9 && c21.current && ((p13 = c21.current) != null && p13.contains(e9) || (o20.actions.close(), ((x10 = (i16 = a28.current) == null ? void 0 : i16.contains) != null && x10.call(i16, e9) || (me5 = (S11 = u25.current) == null ? void 0 : S11.contains) != null && me5.call(S11, e9)) && e9.focus({ preventScroll: true })));
  } : void 0, tabIndex: -1, style: { ...d14.style, ...V6, "--button-width": w5(r22, D13, true).width }, ...x4(F7) }), H9 = u21(), fe7 = o4(() => {
    let s21 = c21.current;
    if (!s21) return;
    function e9() {
      u(H9.current, { [a21.Forwards]: () => {
        var i16;
        v5(s21, T4.First) === A2.Error && ((i16 = o20.state.afterPanelSentinel.current) == null || i16.focus());
      }, [a21.Backwards]: () => {
        var p13;
        (p13 = o20.state.button) == null || p13.focus({ preventScroll: true });
      } });
    }
    e9();
  }), ae5 = o4(() => {
    let s21 = c21.current;
    if (!s21) return;
    function e9() {
      u(H9.current, { [a21.Forwards]: () => {
        var Be4;
        if (!o20.state.button) return;
        let p13 = (Be4 = r3(o20.state.button)) != null ? Be4 : document.body, i16 = x3(p13), x10 = i16.indexOf(o20.state.button), S11 = i16.slice(0, x10 + 1), se2 = [...i16.slice(x10 + 1), ...S11];
        for (let ve3 of se2.slice()) if (ve3.dataset.headlessuiFocusGuard === "true" || L7 != null && L7.contains(ve3)) {
          let Ae7 = se2.indexOf(ve3);
          Ae7 !== -1 && se2.splice(Ae7, 1);
        }
        v5(se2, T4.First, { sorted: false });
      }, [a21.Backwards]: () => {
        var i16;
        v5(s21, T4.Previous) === A2.Error && ((i16 = o20.state.button) == null || i16.focus());
      } });
    }
    e9();
  }), Pe2 = K();
  return import_react134.default.createElement(s13, null, import_react134.default.createElement(de5.Provider, { value: B2 }, import_react134.default.createElement(C5, { value: o20.actions.refocusableClose }, import_react134.default.createElement(te, { enabled: b14 ? E13.static || r22 : false, ownerDocument: Q7 }, r22 && C11 && import_react134.default.createElement(f4, { id: f21, ref: a28, features: s5.Focusable, "data-headlessui-focus-guard": true, as: "button", type: "button", onFocus: fe7 }), Pe2({ ourProps: I10, theirProps: d14, slot: k13, defaultTag: Rt2, features: Ft2, visible: r22, name: "Popover.Panel" }), r22 && C11 && import_react134.default.createElement(f4, { id: l19, ref: u25, features: s5.Focusable, "data-headlessui-focus-guard": true, as: "button", type: "button", onFocus: ae5 })))));
}
var At2 = "div";
function _t2(E13, O5) {
  let R7 = (0, import_react134.useRef)(null), B2 = y(R7, O5), [T11, n17] = (0, import_react134.useState)([]), b14 = o4((a28) => {
    n17((u25) => {
      let f21 = u25.indexOf(a28);
      if (f21 !== -1) {
        let l19 = u25.slice();
        return l19.splice(f21, 1), l19;
      }
      return u25;
    });
  }), t14 = o4((a28) => (n17((u25) => [...u25, a28]), () => b14(a28))), A5 = o4(() => {
    var f21;
    let a28 = r3(R7.current);
    if (!a28) return false;
    let u25 = e(R7.current);
    return (f21 = R7.current) != null && f21.contains(u25) ? true : T11.some((l19) => {
      var c21, m10;
      return ((c21 = a28.getElementById(l19.buttonId.current)) == null ? void 0 : c21.contains(u25)) || ((m10 = a28.getElementById(l19.panelId.current)) == null ? void 0 : m10.contains(u25));
    });
  }), d14 = o4((a28) => {
    for (let u25 of T11) u25.buttonId.current !== a28 && u25.close();
  }), o20 = (0, import_react134.useMemo)(() => ({ registerPopover: t14, unregisterPopover: b14, isFocusWithinPopoverGroup: A5, closeOthers: d14 }), [t14, b14, A5, d14]), C11 = n2({}), y10 = E13, D13 = { ref: B2 }, _10 = K();
  return import_react134.default.createElement(j9, null, import_react134.default.createElement(Fe3.Provider, { value: o20 }, _10({ ourProps: D13, theirProps: y10, slot: C11, defaultTag: At2, name: "Popover.Group" })));
}
var Ct2 = Y(Tt2);
var Dt2 = Y(bt);
var Ot = Y(Ne2);
var xt = Y(Ne2);
var Lt2 = Y(Bt2);
var ht3 = Y(_t2);
var vo = Object.assign(Ct2, { Button: Dt2, Backdrop: xt, Overlay: Ot, Panel: Lt2, Group: ht3 });

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/radio-group/radio-group.js
var import_react135 = __toESM(require_react(), 1);
var Ie3 = ((e9) => (e9[e9.RegisterOption = 0] = "RegisterOption", e9[e9.UnregisterOption = 1] = "UnregisterOption", e9))(Ie3 || {});
var Fe4 = { [0](o20, t14) {
  let e9 = [...o20.options, { id: t14.id, element: t14.element, propsRef: t14.propsRef }];
  return { ...o20, options: G2(e9, (n17) => n17.element.current) };
}, [1](o20, t14) {
  let e9 = o20.options.slice(), n17 = o20.options.findIndex((P8) => P8.id === t14.id);
  return n17 === -1 ? o20 : (e9.splice(n17, 1), { ...o20, options: e9 });
} };
var X4 = (0, import_react135.createContext)(null);
X4.displayName = "RadioGroupDataContext";
function z2(o20) {
  let t14 = (0, import_react135.useContext)(X4);
  if (t14 === null) {
    let e9 = new Error(`<${o20} /> is missing a parent <RadioGroup /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(e9, z2), e9;
  }
  return t14;
}
var q3 = (0, import_react135.createContext)(null);
q3.displayName = "RadioGroupActionsContext";
function Q5(o20) {
  let t14 = (0, import_react135.useContext)(q3);
  if (t14 === null) {
    let e9 = new Error(`<${o20} /> is missing a parent <RadioGroup /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(e9, Q5), e9;
  }
  return t14;
}
function Ue2(o20, t14) {
  return u(t14.type, Fe4, o20, t14);
}
var we3 = "div";
function Se3(o20, t14) {
  let e9 = (0, import_react74.useId)(), n17 = a3(), { id: P8 = `headlessui-radiogroup-${e9}`, value: R7, form: D13, name: i16, onChange: c21, by: d14, disabled: a28 = n17 || false, defaultValue: h16, tabIndex: f21 = 0, ...L7 } = o20, T11 = u9(d14), [v11, y10] = (0, import_react135.useReducer)(Ue2, { options: [] }), p13 = v11.options, [k13, G6] = V2(), [I10, F7] = H3(), E13 = (0, import_react135.useRef)(null), m10 = y(E13, t14), b14 = l3(h16), [s21, x10] = b2(R7, c21, b14), g6 = (0, import_react135.useMemo)(() => p13.find((r22) => !r22.propsRef.current.disabled), [p13]), O5 = (0, import_react135.useMemo)(() => p13.some((r22) => T11(r22.propsRef.current.value, s21)), [p13, s21]), l19 = o4((r22) => {
    var U3;
    if (a28 || T11(r22, s21)) return false;
    let S11 = (U3 = p13.find((u25) => T11(u25.propsRef.current.value, r22))) == null ? void 0 : U3.propsRef.current;
    return S11 != null && S11.disabled ? false : (x10 == null || x10(r22), true);
  }), ce3 = o4((r22) => {
    if (!E13.current) return;
    let U3 = p13.filter((u25) => u25.propsRef.current.disabled === false).map((u25) => u25.element.current);
    switch (r22.key) {
      case o8.Enter:
        g(r22.currentTarget);
        break;
      case o8.ArrowLeft:
      case o8.ArrowUp:
        if (r22.preventDefault(), r22.stopPropagation(), v5(U3, T4.Previous | T4.WrapAround) === A2.Success) {
          let A5 = p13.find((N4) => d2(N4.element.current));
          A5 && l19(A5.propsRef.current.value);
        }
        break;
      case o8.ArrowRight:
      case o8.ArrowDown:
        if (r22.preventDefault(), r22.stopPropagation(), v5(U3, T4.Next | T4.WrapAround) === A2.Success) {
          let A5 = p13.find((N4) => d2(N4.element.current));
          A5 && l19(A5.propsRef.current.value);
        }
        break;
      case o8.Space:
        {
          r22.preventDefault(), r22.stopPropagation();
          let u25 = p13.find((A5) => d2(A5.element.current));
          u25 && l19(u25.propsRef.current.value);
        }
        break;
    }
  }), Y4 = o4((r22) => (y10({ type: 0, ...r22 }), () => y10({ type: 1, id: r22.id }))), fe7 = (0, import_react135.useMemo)(() => ({ value: s21, firstOption: g6, containsCheckedOption: O5, disabled: a28, compare: T11, tabIndex: f21, ...v11 }), [s21, g6, O5, a28, T11, f21, v11]), Te5 = (0, import_react135.useMemo)(() => ({ registerOption: Y4, change: l19 }), [Y4, l19]), me5 = { ref: m10, id: P8, role: "radiogroup", "aria-labelledby": k13, "aria-describedby": I10, onKeyDown: ce3 }, Re4 = n2({ value: s21 }), ye4 = (0, import_react135.useCallback)(() => {
    if (b14 !== void 0) return l19(b14);
  }, [l19, b14]), be3 = K();
  return import_react135.default.createElement(F7, { name: "RadioGroup.Description" }, import_react135.default.createElement(G6, { name: "RadioGroup.Label" }, import_react135.default.createElement(q3.Provider, { value: Te5 }, import_react135.default.createElement(X4.Provider, { value: fe7 }, i16 != null && import_react135.default.createElement(j2, { disabled: a28, data: { [i16]: s21 || "on" }, overrides: { type: "radio", checked: s21 != null }, form: D13, onReset: ye4 }), be3({ ourProps: me5, theirProps: L7, slot: Re4, defaultTag: we3, name: "RadioGroup" })))));
}
var Me = "div";
function He3(o20, t14) {
  var g6;
  let e9 = z2("RadioGroup.Option"), n17 = Q5("RadioGroup.Option"), P8 = (0, import_react74.useId)(), { id: R7 = `headlessui-radiogroup-option-${P8}`, value: D13, disabled: i16 = e9.disabled || false, autoFocus: c21 = false, ...d14 } = o20, a28 = (0, import_react135.useRef)(null), h16 = y(a28, t14), [f21, L7] = V2(), [T11, v11] = H3(), y10 = s3({ value: D13, disabled: i16 });
  n(() => n17.registerOption({ id: R7, element: a28, propsRef: y10 }), [R7, n17, a28, y10]);
  let p13 = o4((O5) => {
    var l19;
    if (s6(O5.currentTarget)) return O5.preventDefault();
    n17.change(D13) && ((l19 = a28.current) == null || l19.focus());
  }), k13 = ((g6 = e9.firstOption) == null ? void 0 : g6.id) === R7, { isFocusVisible: G6, focusProps: I10 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: c21 }), { isHovered: F7, hoverProps: E13 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: i16 }), m10 = e9.compare(e9.value, D13), b14 = V({ ref: h16, id: R7, role: "radio", "aria-checked": m10 ? "true" : "false", "aria-labelledby": f21, "aria-describedby": T11, "aria-disabled": i16 ? true : void 0, tabIndex: (() => i16 ? -1 : m10 || !e9.containsCheckedOption && k13 ? e9.tabIndex : -1)(), onClick: i16 ? void 0 : p13, autoFocus: c21 }, I10, E13), s21 = n2({ checked: m10, disabled: i16, active: G6, hover: F7, focus: G6, autofocus: c21 }), x10 = K();
  return import_react135.default.createElement(v11, { name: "RadioGroup.Description" }, import_react135.default.createElement(L7, { name: "RadioGroup.Label" }, x10({ ourProps: b14, theirProps: d14, slot: s21, defaultTag: Me, name: "RadioGroup.Option" })));
}
var Ne3 = "span";
function We2(o20, t14) {
  var g6;
  let e9 = z2("Radio"), n17 = Q5("Radio"), P8 = (0, import_react74.useId)(), R7 = u4(), D13 = a3(), { id: i16 = R7 || `headlessui-radio-${P8}`, value: c21, disabled: d14 = e9.disabled || D13 || false, autoFocus: a28 = false, ...h16 } = o20, f21 = (0, import_react135.useRef)(null), L7 = y(f21, t14), T11 = N(), v11 = w3(), y10 = s3({ value: c21, disabled: d14 });
  n(() => n17.registerOption({ id: i16, element: f21, propsRef: y10 }), [i16, n17, f21, y10]);
  let p13 = o4((O5) => {
    var l19;
    if (s6(O5.currentTarget)) return O5.preventDefault();
    n17.change(c21) && ((l19 = f21.current) == null || l19.focus());
  }), { isFocusVisible: k13, focusProps: G6 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: a28 }), { isHovered: I10, hoverProps: F7 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: d14 }), E13 = ((g6 = e9.firstOption) == null ? void 0 : g6.id) === i16, m10 = e9.compare(e9.value, c21), b14 = V({ ref: L7, id: i16, role: "radio", "aria-checked": m10 ? "true" : "false", "aria-labelledby": T11, "aria-describedby": v11, "aria-disabled": d14 ? true : void 0, tabIndex: (() => d14 ? -1 : m10 || !e9.containsCheckedOption && E13 ? e9.tabIndex : -1)(), autoFocus: a28, onClick: d14 ? void 0 : p13 }, G6, F7), s21 = n2({ checked: m10, disabled: d14, hover: I10, focus: k13, autofocus: a28 });
  return K()({ ourProps: b14, theirProps: h16, slot: s21, defaultTag: Ne3, name: "Radio" });
}
var Be2 = Y(Se3);
var Ve2 = Y(He3);
var Ke4 = Y(We2);
var $e2 = Z;
var je2 = M2;
var yt3 = Object.assign(Be2, { Option: Ve2, Radio: Ke4, Label: $e2, Description: je2 });

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/select/select.js
var H7 = "select";
function B(r22, l19) {
  let s21 = (0, import_react74.useId)(), a28 = u4(), i16 = a3(), { id: p13 = a28 || `headlessui-select-${s21}`, disabled: e9 = i16 || false, invalid: t14 = false, autoFocus: o20 = false, ...d14 } = r22, n17 = N(), c21 = w3(), { isFocusVisible: m10, focusProps: f21 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: o20 }), { isHovered: u25, hoverProps: T11 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e9 }), { pressed: b14, pressProps: y10 } = w({ disabled: e9 }), P8 = V({ ref: l19, id: p13, "aria-labelledby": n17, "aria-describedby": c21, "aria-invalid": t14 ? "true" : void 0, disabled: e9 || void 0, autoFocus: o20 }, f21, T11, y10), S11 = n2({ disabled: e9, invalid: t14, hover: u25, focus: m10, active: b14, autofocus: o20 });
  return K()({ ourProps: P8, theirProps: d14, slot: S11, defaultTag: H7, name: "Select" });
}
var k12 = Y(B);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/switch/switch.js
var import_react136 = __toESM(require_react(), 1);
var E12 = (0, import_react136.createContext)(null);
E12.displayName = "GroupContext";
var ve = import_react136.Fragment;
function xe3(n17) {
  var c21;
  let [t14, a28] = (0, import_react136.useState)(null), [f21, h16] = V2(), [b14, o20] = H3(), s21 = (0, import_react136.useMemo)(() => ({ switch: t14, setSwitch: a28 }), [t14, a28]), T11 = {}, y10 = n17, p13 = K();
  return import_react136.default.createElement(o20, { name: "Switch.Description", value: b14 }, import_react136.default.createElement(h16, { name: "Switch.Label", value: f21, props: { htmlFor: (c21 = s21.switch) == null ? void 0 : c21.id, onClick(u25) {
    t14 && (m4(u25.currentTarget) && u25.preventDefault(), t14.click(), t14.focus({ preventScroll: true }));
  } } }, import_react136.default.createElement(E12.Provider, { value: s21 }, p13({ ourProps: T11, theirProps: y10, slot: {}, defaultTag: ve, name: "Switch.Group" }))));
}
var Ce3 = "button";
function Le4(n17, t14) {
  var g6;
  let a28 = (0, import_react74.useId)(), f21 = u4(), h16 = a3(), { id: b14 = f21 || `headlessui-switch-${a28}`, disabled: o20 = h16 || false, checked: s21, defaultChecked: T11, onChange: y10, name: p13, value: c21, form: u25, autoFocus: S11 = false, ...C11 } = n17, _10 = (0, import_react136.useContext)(E12), [L7, R7] = (0, import_react136.useState)(null), G6 = (0, import_react136.useRef)(null), A5 = y(G6, t14, _10 === null ? null : _10.setSwitch, R7), l19 = l3(T11), [d14, r22] = b2(s21, y10, l19 != null ? l19 : false), F7 = p(), [H9, P8] = (0, import_react136.useState)(false), D13 = o4(() => {
    P8(true), r22 == null || r22(!d14), F7.nextFrame(() => {
      P8(false);
    });
  }), k13 = o4((e9) => {
    if (s6(e9.currentTarget)) return e9.preventDefault();
    e9.preventDefault(), D13();
  }), M12 = o4((e9) => {
    e9.key === o8.Space ? (e9.preventDefault(), D13()) : e9.key === o8.Enter && g(e9.currentTarget);
  }), U3 = o4((e9) => e9.preventDefault()), I10 = N(), B2 = w3(), { isFocusVisible: K4, focusProps: O5 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: S11 }), { isHovered: W5, hoverProps: N4 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: o20 }), { pressed: J4, pressProps: V6 } = w({ disabled: o20 }), X5 = n2({ checked: d14, disabled: o20, hover: W5, focus: K4, active: J4, autofocus: S11, changing: H9 }), j11 = V({ id: b14, ref: A5, role: "switch", type: e5(n17, L7), tabIndex: n17.tabIndex === -1 ? 0 : (g6 = n17.tabIndex) != null ? g6 : 0, "aria-checked": d14, "aria-labelledby": I10, "aria-describedby": B2, disabled: o20 || void 0, autoFocus: S11, onClick: k13, onKeyUp: M12, onKeyPress: U3 }, O5, N4, V6), $7 = (0, import_react136.useCallback)(() => {
    if (l19 !== void 0) return r22 == null ? void 0 : r22(l19);
  }, [r22, l19]), q5 = K();
  return import_react136.default.createElement(import_react136.default.Fragment, null, p13 != null && import_react136.default.createElement(j2, { disabled: o20, data: { [p13]: c21 || "on" }, overrides: { type: "checkbox", checked: d14 }, form: u25, onReset: $7 }), q5({ ourProps: j11, theirProps: C11, slot: X5, defaultTag: Ce3, name: "Switch" }));
}
var Re3 = Y(Le4);
var Ge = xe3;
var Ae6 = Z;
var Fe5 = M2;
var tt2 = Object.assign(Re3, { Group: Ge, Label: Ae6, Description: Fe5 });

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/tabs/tabs.js
var import_react138 = __toESM(require_react(), 1);

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/internal/focus-sentinel.js
var import_react137 = __toESM(require_react(), 1);
function b13({ onFocus: n17 }) {
  let [r22, o20] = (0, import_react137.useState)(true), u25 = f17();
  return r22 ? import_react137.default.createElement(f4, { as: "button", type: "button", features: s5.Focusable, onFocus: (a28) => {
    a28.preventDefault();
    let e9, i16 = 50;
    function t14() {
      if (i16-- <= 0) {
        e9 && cancelAnimationFrame(e9);
        return;
      }
      if (n17()) {
        if (cancelAnimationFrame(e9), !u25.current) return;
        o20(false);
        return;
      }
      e9 = requestAnimationFrame(t14);
    }
    e9 = requestAnimationFrame(t14);
  } }) : null;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/utils/stable-collection.js
var l18 = __toESM(require_react(), 1);
var s19 = l18.createContext(null);
function a27() {
  return { groups: /* @__PURE__ */ new Map(), get(o20, e9) {
    var i16;
    let t14 = this.groups.get(o20);
    t14 || (t14 = /* @__PURE__ */ new Map(), this.groups.set(o20, t14));
    let n17 = (i16 = t14.get(e9)) != null ? i16 : 0;
    t14.set(e9, n17 + 1);
    let r22 = Array.from(t14.keys()).indexOf(e9);
    function u25() {
      let c21 = t14.get(e9);
      c21 > 1 ? t14.set(e9, c21 - 1) : t14.delete(e9);
    }
    return [r22, u25];
  } };
}
function f20({ children: o20 }) {
  let e9 = l18.useRef(a27());
  return l18.createElement(s19.Provider, { value: e9 }, o20);
}
function C10(o20) {
  let e9 = l18.useContext(s19);
  if (!e9) throw new Error("You must wrap your component in a <StableCollection>");
  let t14 = l18.useId(), [n17, r22] = e9.current.get(o20, t14);
  return l18.useEffect(() => r22, []), n17;
}

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/tabs/tabs.js
var Le5 = ((t14) => (t14[t14.Forwards = 0] = "Forwards", t14[t14.Backwards = 1] = "Backwards", t14))(Le5 || {});
var _e3 = ((l19) => (l19[l19.Less = -1] = "Less", l19[l19.Equal = 0] = "Equal", l19[l19.Greater = 1] = "Greater", l19))(_e3 || {});
var Se4 = ((n17) => (n17[n17.SetSelectedIndex = 0] = "SetSelectedIndex", n17[n17.RegisterTab = 1] = "RegisterTab", n17[n17.UnregisterTab = 2] = "UnregisterTab", n17[n17.RegisterPanel = 3] = "RegisterPanel", n17[n17.UnregisterPanel = 4] = "UnregisterPanel", n17))(Se4 || {});
var De4 = { [0](e9, r22) {
  var d14;
  let t14 = G2(e9.tabs, (u25) => u25.current), l19 = G2(e9.panels, (u25) => u25.current), a28 = t14.filter((u25) => {
    var T11;
    return !((T11 = u25.current) != null && T11.hasAttribute("disabled"));
  }), n17 = { ...e9, tabs: t14, panels: l19 };
  if (r22.index < 0 || r22.index > t14.length - 1) {
    let u25 = u(Math.sign(r22.index - e9.selectedIndex), { [-1]: () => 1, [0]: () => u(Math.sign(r22.index), { [-1]: () => 0, [0]: () => 0, [1]: () => 1 }), [1]: () => 0 });
    if (a28.length === 0) return n17;
    let T11 = u(u25, { [0]: () => t14.indexOf(a28[0]), [1]: () => t14.indexOf(a28[a28.length - 1]) });
    return { ...n17, selectedIndex: T11 === -1 ? e9.selectedIndex : T11 };
  }
  let s21 = t14.slice(0, r22.index), f21 = [...t14.slice(r22.index), ...s21].find((u25) => a28.includes(u25));
  if (!f21) return n17;
  let b14 = (d14 = t14.indexOf(f21)) != null ? d14 : e9.selectedIndex;
  return b14 === -1 && (b14 = e9.selectedIndex), { ...n17, selectedIndex: b14 };
}, [1](e9, r22) {
  if (e9.tabs.includes(r22.tab)) return e9;
  let t14 = e9.tabs[e9.selectedIndex], l19 = G2([...e9.tabs, r22.tab], (n17) => n17.current), a28 = e9.selectedIndex;
  return e9.info.current.isControlled || (a28 = l19.indexOf(t14), a28 === -1 && (a28 = e9.selectedIndex)), { ...e9, tabs: l19, selectedIndex: a28 };
}, [2](e9, r22) {
  return { ...e9, tabs: e9.tabs.filter((t14) => t14 !== r22.tab) };
}, [3](e9, r22) {
  return e9.panels.includes(r22.panel) ? e9 : { ...e9, panels: G2([...e9.panels, r22.panel], (t14) => t14.current) };
}, [4](e9, r22) {
  return { ...e9, panels: e9.panels.filter((t14) => t14 !== r22.panel) };
} };
var z3 = (0, import_react138.createContext)(null);
z3.displayName = "TabsDataContext";
function h14(e9) {
  let r22 = (0, import_react138.useContext)(z3);
  if (r22 === null) {
    let t14 = new Error(`<${e9} /> is missing a parent <Tab.Group /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t14, h14), t14;
  }
  return r22;
}
var V5 = (0, import_react138.createContext)(null);
V5.displayName = "TabsActionsContext";
function Q6(e9) {
  let r22 = (0, import_react138.useContext)(V5);
  if (r22 === null) {
    let t14 = new Error(`<${e9} /> is missing a parent <Tab.Group /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t14, Q6), t14;
  }
  return r22;
}
function Fe6(e9, r22) {
  return u(r22.type, De4, e9, r22);
}
var Ie4 = "div";
function he2(e9, r22) {
  let { defaultIndex: t14 = 0, vertical: l19 = false, manual: a28 = false, onChange: n17, selectedIndex: s21 = null, ...g6 } = e9;
  const f21 = l19 ? "vertical" : "horizontal", b14 = a28 ? "manual" : "auto";
  let d14 = s21 !== null, u25 = s3({ isControlled: d14 }), T11 = y(r22), [p13, c21] = (0, import_react138.useReducer)(Fe6, { info: u25, selectedIndex: s21 != null ? s21 : t14, tabs: [], panels: [] }), v11 = n2({ selectedIndex: p13.selectedIndex }), m10 = s3(n17 || (() => {
  })), C11 = s3(p13.tabs), D13 = (0, import_react138.useMemo)(() => ({ orientation: f21, activation: b14, ...p13 }), [f21, b14, p13]), P8 = o4((i16) => (c21({ type: 1, tab: i16 }), () => c21({ type: 2, tab: i16 }))), R7 = o4((i16) => (c21({ type: 3, panel: i16 }), () => c21({ type: 4, panel: i16 }))), A5 = o4((i16) => {
    L7.current !== i16 && m10.current(i16), d14 || c21({ type: 0, index: i16 });
  }), L7 = s3(d14 ? e9.selectedIndex : p13.selectedIndex), _10 = (0, import_react138.useMemo)(() => ({ registerTab: P8, registerPanel: R7, change: A5 }), []);
  n(() => {
    c21({ type: 0, index: s21 != null ? s21 : t14 });
  }, [s21]), n(() => {
    if (L7.current === void 0 || p13.tabs.length <= 0) return;
    let i16 = G2(p13.tabs, (S11) => S11.current);
    i16.some((S11, $7) => p13.tabs[$7] !== S11) && A5(i16.indexOf(p13.tabs[L7.current]));
  });
  let J4 = { ref: T11 }, X5 = K();
  return import_react138.default.createElement(f20, null, import_react138.default.createElement(V5.Provider, { value: _10 }, import_react138.default.createElement(z3.Provider, { value: D13 }, D13.tabs.length <= 0 && import_react138.default.createElement(b13, { onFocus: () => {
    var i16, M12;
    for (let S11 of C11.current) if (((i16 = S11.current) == null ? void 0 : i16.tabIndex) === 0) return (M12 = S11.current) == null || M12.focus(), true;
    return false;
  } }), X5({ ourProps: J4, theirProps: g6, slot: v11, defaultTag: Ie4, name: "Tabs" }))));
}
var ve2 = "div";
function Ce4(e9, r22) {
  let { orientation: t14, selectedIndex: l19 } = h14("Tab.List"), a28 = y(r22), n17 = n2({ selectedIndex: l19 }), s21 = e9, g6 = { ref: a28, role: "tablist", "aria-orientation": t14 };
  return K()({ ourProps: g6, theirProps: s21, slot: n17, defaultTag: ve2, name: "Tabs.List" });
}
var Me2 = "button";
function Ge2(e9, r22) {
  var Y4, Z4;
  let t14 = (0, import_react74.useId)(), { id: l19 = `headlessui-tabs-tab-${t14}`, disabled: a28 = false, autoFocus: n17 = false, ...s21 } = e9, { orientation: g6, activation: f21, selectedIndex: b14, tabs: d14, panels: u25 } = h14("Tab"), T11 = Q6("Tab"), p13 = h14("Tab"), [c21, v11] = (0, import_react138.useState)(null), m10 = (0, import_react138.useRef)(null), C11 = y(m10, r22, v11);
  n(() => T11.registerTab(m10), [T11, m10]);
  let D13 = C10("tabs"), P8 = d14.indexOf(m10);
  P8 === -1 && (P8 = D13);
  let R7 = P8 === b14, A5 = o4((o20) => {
    let E13 = o20();
    if (E13 === A2.Success && f21 === "auto") {
      let ee7 = e(m10.current), B2 = p13.tabs.findIndex((ce3) => ce3.current === ee7);
      B2 !== -1 && T11.change(B2);
    }
    return E13;
  }), L7 = o4((o20) => {
    let E13 = d14.map((B2) => B2.current).filter(Boolean);
    if (o20.key === o8.Space || o20.key === o8.Enter) {
      o20.preventDefault(), o20.stopPropagation(), T11.change(P8);
      return;
    }
    switch (o20.key) {
      case o8.Home:
      case o8.PageUp:
        return o20.preventDefault(), o20.stopPropagation(), A5(() => v5(E13, T4.First));
      case o8.End:
      case o8.PageDown:
        return o20.preventDefault(), o20.stopPropagation(), A5(() => v5(E13, T4.Last));
    }
    if (A5(() => u(g6, { vertical() {
      return o20.key === o8.ArrowUp ? v5(E13, T4.Previous | T4.WrapAround) : o20.key === o8.ArrowDown ? v5(E13, T4.Next | T4.WrapAround) : A2.Error;
    }, horizontal() {
      return o20.key === o8.ArrowLeft ? v5(E13, T4.Previous | T4.WrapAround) : o20.key === o8.ArrowRight ? v5(E13, T4.Next | T4.WrapAround) : A2.Error;
    } })) === A2.Success) return o20.preventDefault();
  }), _10 = (0, import_react138.useRef)(false), J4 = o4(() => {
    var o20;
    _10.current || (_10.current = true, (o20 = m10.current) == null || o20.focus({ preventScroll: true }), T11.change(P8), t(() => {
      _10.current = false;
    }));
  }), X5 = o4((o20) => {
    o20.preventDefault();
  }), { isFocusVisible: i16, focusProps: M12 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: n17 }), { isHovered: S11, hoverProps: $7 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: a28 }), { pressed: pe4, pressProps: ue5 } = w({ disabled: a28 }), Te5 = n2({ selected: R7, hover: S11, active: pe4, focus: i16, autofocus: n17, disabled: a28 }), de6 = V({ ref: C11, onKeyDown: L7, onMouseDown: X5, onClick: J4, id: l19, role: "tab", type: e5(e9, c21), "aria-controls": (Z4 = (Y4 = u25[P8]) == null ? void 0 : Y4.current) == null ? void 0 : Z4.id, "aria-selected": R7, tabIndex: R7 ? 0 : -1, disabled: a28 || void 0, autoFocus: n17 }, M12, $7, ue5);
  return K()({ ourProps: de6, theirProps: s21, slot: Te5, defaultTag: Me2, name: "Tabs.Tab" });
}
var Ue3 = "div";
function He4(e9, r22) {
  let { selectedIndex: t14 } = h14("Tab.Panels"), l19 = y(r22), a28 = n2({ selectedIndex: t14 }), n17 = e9, s21 = { ref: l19 };
  return K()({ ourProps: s21, theirProps: n17, slot: a28, defaultTag: Ue3, name: "Tabs.Panels" });
}
var we4 = "div";
var Oe4 = A.RenderStrategy | A.Static;
function Ne4(e9, r22) {
  var R7, A5, L7, _10;
  let t14 = (0, import_react74.useId)(), { id: l19 = `headlessui-tabs-panel-${t14}`, tabIndex: a28 = 0, ...n17 } = e9, { selectedIndex: s21, tabs: g6, panels: f21 } = h14("Tab.Panel"), b14 = Q6("Tab.Panel"), d14 = (0, import_react138.useRef)(null), u25 = y(d14, r22);
  n(() => b14.registerPanel(d14), [b14, d14]);
  let T11 = C10("panels"), p13 = f21.indexOf(d14);
  p13 === -1 && (p13 = T11);
  let c21 = p13 === s21, { isFocusVisible: v11, focusProps: m10 } = $f7dceffc5ad7768b$export$4e328f61c538687f(), C11 = n2({ selected: c21, focus: v11 }), D13 = V({ ref: u25, id: l19, role: "tabpanel", "aria-labelledby": (A5 = (R7 = g6[p13]) == null ? void 0 : R7.current) == null ? void 0 : A5.id, tabIndex: c21 ? a28 : -1 }, m10), P8 = K();
  return !c21 && ((L7 = n17.unmount) == null || L7) && !((_10 = n17.static) != null && _10) ? import_react138.default.createElement(f4, { "aria-hidden": "true", ...D13 }) : P8({ ourProps: D13, theirProps: n17, slot: C11, defaultTag: we4, features: Oe4, visible: c21, name: "Tabs.Panel" });
}
var ke = Y(Ge2);
var Be3 = Y(he2);
var We3 = Y(Ce4);
var je3 = Y(He4);
var Ke5 = Y(Ne4);
var dt2 = Object.assign(ke, { Group: Be3, List: We3, Panels: je3, Panel: Ke5 });

// node_modules/@copilotkit/react-ui/node_modules/@headlessui/react/dist/components/textarea/textarea.js
var L6 = "textarea";
function H8(a28, t14) {
  let s21 = (0, import_react74.useId)(), l19 = u4(), d14 = a3(), { id: i16 = l19 || `headlessui-textarea-${s21}`, disabled: e9 = d14 || false, autoFocus: r22 = false, invalid: o20 = false, ...p13 } = a28, n17 = N(), T11 = w3(), { isFocused: f21, focusProps: m10 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: r22 }), { isHovered: u25, hoverProps: b14 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e9 }), y10 = V({ ref: t14, id: i16, "aria-labelledby": n17, "aria-describedby": T11, "aria-invalid": o20 ? "true" : void 0, disabled: e9 || void 0, autoFocus: r22 }, m10, b14), x10 = n2({ disabled: e9, invalid: o20, hover: u25, focus: f21, autofocus: r22 });
  return K()({ ourProps: y10, theirProps: p13, slot: x10, defaultTag: L6, name: "Textarea" });
}
var M11 = Y(H8);

// node_modules/@copilotkit/react-ui/dist/chunk-FFJHOZX6.mjs
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
function CopilotDevConsole() {
  const currentVersion = COPILOTKIT_VERSION;
  const context = useCopilotContext();
  const [showDevConsole, setShowDevConsole] = (0, import_react139.useState)(false);
  (0, import_react139.useEffect)(() => {
    setShowDevConsole(shouldShowDevConsole(context.showDevConsole));
  }, [context.showDevConsole]);
  const dontRunTwiceInDevMode = (0, import_react139.useRef)(false);
  const [versionStatus, setVersionStatus] = (0, import_react139.useState)("unknown");
  const [latestVersion, setLatestVersion] = (0, import_react139.useState)("");
  const consoleRef = (0, import_react139.useRef)(null);
  const [debugButtonMode, setDebugButtonMode] = (0, import_react139.useState)("full");
  const checkForUpdates = (force = false) => {
    setVersionStatus("checking");
    getPublishedCopilotKitVersion(currentVersion, force).then((v11) => {
      setLatestVersion(v11.latest);
      let versionOk = false;
      if (v11.current === v11.latest) {
        versionOk = true;
      } else if (/[a-zA-Z]/.test(v11.current)) {
        versionOk = true;
      }
      if (versionOk) {
        setVersionStatus("latest");
      } else if (v11.severity !== "low") {
        setVersionStatus("outdated");
      } else {
        setVersionStatus("update-available");
      }
    }).catch((e9) => {
      console.error(e9);
      setVersionStatus("unknown");
    });
  };
  (0, import_react139.useEffect)(() => {
    if (dontRunTwiceInDevMode.current === true) {
      return;
    }
    dontRunTwiceInDevMode.current = true;
    checkForUpdates();
  }, []);
  if (!showDevConsole) {
    return null;
  }
  return (0, import_jsx_runtime7.jsxs)(
    "div",
    {
      ref: consoleRef,
      className: "copilotKitDevConsole " + (versionStatus === "update-available" ? "copilotKitDevConsoleUpgrade" : "") + (versionStatus === "outdated" ? "copilotKitDevConsoleWarnOutdated" : ""),
      children: [
        (0, import_jsx_runtime7.jsx)(
          VersionInfo,
          {
            showDevConsole: context.showDevConsole,
            versionStatus,
            currentVersion,
            latestVersion
          }
        ),
        (0, import_jsx_runtime7.jsx)(CopilotKitHelpModal, {}),
        (0, import_jsx_runtime7.jsx)(
          DebugMenuButton,
          {
            setShowDevConsole,
            checkForUpdates,
            mode: debugButtonMode
          }
        )
      ]
    }
  );
}
function VersionInfo({
  showDevConsole,
  versionStatus,
  currentVersion,
  latestVersion
}) {
  const [copyStatus, setCopyStatus] = (0, import_react139.useState)("");
  let versionLabel = "";
  let versionIcon = "";
  let currentVersionLabel = currentVersion;
  if (versionStatus === "latest") {
    versionLabel = "latest";
    versionIcon = CheckIcon2;
  } else if (versionStatus === "checking") {
    versionLabel = "checking";
    versionIcon = SmallSpinnerIcon;
  } else if (versionStatus === "update-available") {
    versionLabel = "update available";
    versionIcon = ExclamationMarkIcon;
    currentVersionLabel = `${currentVersion}  ${latestVersion}`;
  } else if (versionStatus === "outdated") {
    versionLabel = "outdated";
    versionIcon = ExclamationMarkTriangleIcon;
    currentVersionLabel = `${currentVersion}  ${latestVersion}`;
  }
  let asideLabel = "";
  if (showDevConsole === true) {
    asideLabel = "(enabled)";
  }
  const installCommand = [
    `npm install`,
    `@copilotkit/react-core@${latestVersion}`,
    `@copilotkit/react-ui@${latestVersion}`,
    `@copilotkit/react-textarea@${latestVersion}`,
    `&& npm install @copilotkit/runtime@${latestVersion}`
  ].join(" ");
  const handleCopyClick = () => {
    navigator.clipboard.writeText(installCommand.trim()).then(() => {
      setCopyStatus("Command copied to clipboard!");
      setTimeout(() => setCopyStatus(""), 1e3);
    });
  };
  if (versionStatus === "update-available" || versionStatus === "outdated") {
    return (0, import_jsx_runtime7.jsxs)("div", { className: "copilotKitVersionInfo", children: [
      (0, import_jsx_runtime7.jsxs)("p", { children: [
        currentVersionLabel,
        " ",
        versionIcon
      ] }),
      (0, import_jsx_runtime7.jsx)("button", { onClick: handleCopyClick, children: copyStatus || installCommand })
    ] });
  }
  return null;
}
function DebugMenuButton({
  setShowDevConsole,
  checkForUpdates,
  mode
}) {
  const context = useCopilotContext();
  const messagesContext = useCopilotMessagesContext();
  return (0, import_jsx_runtime7.jsx)(import_jsx_runtime7.Fragment, { children: (0, import_jsx_runtime7.jsxs)(lo, { children: [
    (0, import_jsx_runtime7.jsx)(
      ft,
      {
        className: `copilotKitDebugMenuTriggerButton ${mode === "compact" ? "compact" : ""}`,
        children: mode == "compact" ? "Debug" : (0, import_jsx_runtime7.jsxs)(import_jsx_runtime7.Fragment, { children: [
          "Debug ",
          ChevronDownIcon
        ] })
      }
    ),
    (0, import_jsx_runtime7.jsxs)(
      yt,
      {
        transition: true,
        anchor: "bottom end",
        className: "copilotKitDebugMenu",
        style: { zIndex: 40 },
        children: [
          (0, import_jsx_runtime7.jsx)(gt2, { children: (0, import_jsx_runtime7.jsx)("button", { className: "copilotKitDebugMenuItem", onClick: () => logReadables(context), children: "Log Readables" }) }),
          (0, import_jsx_runtime7.jsx)(gt2, { children: (0, import_jsx_runtime7.jsx)("button", { className: "copilotKitDebugMenuItem", onClick: () => logActions(context), children: "Log Actions" }) }),
          (0, import_jsx_runtime7.jsx)(gt2, { children: (0, import_jsx_runtime7.jsx)(
            "button",
            {
              className: "copilotKitDebugMenuItem",
              onClick: () => logMessages(messagesContext),
              children: "Log Messages"
            }
          ) }),
          (0, import_jsx_runtime7.jsx)(gt2, { children: (0, import_jsx_runtime7.jsx)("button", { className: "copilotKitDebugMenuItem", onClick: () => checkForUpdates(true), children: "Check for Updates" }) }),
          (0, import_jsx_runtime7.jsx)("hr", {}),
          (0, import_jsx_runtime7.jsx)(gt2, { children: (0, import_jsx_runtime7.jsx)("button", { className: "copilotKitDebugMenuItem", onClick: () => setShowDevConsole(false), children: "Hide Dev Console" }) })
        ]
      }
    )
  ] }) });
}

// node_modules/@copilotkit/react-ui/dist/chunk-GDSZGYCE.mjs
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var Header = ({}) => {
  const { setOpen, icons, labels } = useChatContext();
  return (0, import_jsx_runtime8.jsxs)("div", { className: "copilotKitHeader", children: [
    (0, import_jsx_runtime8.jsx)("div", { children: labels.title }),
    (0, import_jsx_runtime8.jsxs)("div", { className: "copilotKitHeaderControls", children: [
      (0, import_jsx_runtime8.jsx)(CopilotDevConsole, {}),
      (0, import_jsx_runtime8.jsx)(
        "button",
        {
          onClick: () => setOpen(false),
          "aria-label": "Close",
          className: "copilotKitHeaderCloseButton",
          children: icons.headerCloseIcon
        }
      )
    ] })
  ] });
};

// node_modules/@copilotkit/react-ui/dist/chunk-UFN2VWSR.mjs
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var Button = ({}) => {
  const { open: open2, setOpen, icons } = useChatContext();
  return (0, import_jsx_runtime9.jsx)("div", { onClick: () => setOpen(!open2), children: (0, import_jsx_runtime9.jsxs)(
    "button",
    {
      className: `copilotKitButton ${open2 ? "open" : ""}`,
      "aria-label": open2 ? "Close Chat" : "Open Chat",
      children: [
        (0, import_jsx_runtime9.jsx)("div", { className: "copilotKitButtonIcon copilotKitButtonIconOpen", children: icons.openIcon }),
        (0, import_jsx_runtime9.jsx)("div", { className: "copilotKitButtonIcon copilotKitButtonIconClose", children: icons.closeIcon })
      ]
    }
  ) });
};

// node_modules/@copilotkit/react-ui/dist/chunk-W26XFBEG.mjs
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
function Suggestion({ title, onClick, partial, className }) {
  if (!title)
    return null;
  const { isLoading } = useCopilotChat();
  return (0, import_jsx_runtime10.jsx)(
    "button",
    {
      disabled: partial || isLoading,
      onClick: (e9) => {
        e9.preventDefault();
        onClick();
      },
      className: className || (partial ? "suggestion loading" : "suggestion"),
      "data-test-id": "suggestion",
      children: partial ? SmallSpinnerIcon : (0, import_jsx_runtime10.jsx)("span", { children: title })
    }
  );
}

// node_modules/@copilotkit/react-ui/dist/chunk-226ZMOE3.mjs
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
function Suggestions({ suggestions, onSuggestionClick }) {
  return (0, import_jsx_runtime11.jsx)("div", { className: "suggestions", children: suggestions.map((suggestion, index4) => (0, import_jsx_runtime11.jsx)(
    Suggestion,
    {
      title: suggestion.title,
      message: suggestion.message,
      partial: suggestion.partial,
      className: suggestion.className,
      onClick: () => onSuggestionClick(suggestion.message)
    },
    index4
  )) });
}

// node_modules/@copilotkit/react-ui/dist/chunk-PLHTVHUW.mjs
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var ImageUploadQueue = ({
  images,
  onRemoveImage,
  className = ""
}) => {
  if (images.length === 0)
    return null;
  return (0, import_jsx_runtime12.jsx)(
    "div",
    {
      className: `copilotKitImageUploadQueue ${className}`,
      style: {
        display: "flex",
        flexWrap: "wrap",
        gap: "8px",
        margin: "8px",
        padding: "8px"
      },
      children: images.map((image3, index4) => (0, import_jsx_runtime12.jsxs)(
        "div",
        {
          className: "copilotKitImageUploadQueueItem",
          style: {
            position: "relative",
            display: "inline-block",
            width: "60px",
            height: "60px",
            borderRadius: "4px",
            overflow: "hidden"
          },
          children: [
            (0, import_jsx_runtime12.jsx)(
              "img",
              {
                src: `data:${image3.contentType};base64,${image3.bytes}`,
                alt: `Selected image ${index4 + 1}`,
                style: {
                  width: "100%",
                  height: "100%",
                  objectFit: "cover"
                }
              }
            ),
            (0, import_jsx_runtime12.jsx)(
              "button",
              {
                onClick: () => onRemoveImage(index4),
                className: "copilotKitImageUploadQueueRemoveButton",
                style: {
                  position: "absolute",
                  top: "2px",
                  right: "2px",
                  background: "rgba(0,0,0,0.6)",
                  color: "white",
                  border: "none",
                  borderRadius: "50%",
                  width: "18px",
                  height: "18px",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  cursor: "pointer",
                  fontSize: "10px",
                  padding: 0
                },
                children: ""
              }
            )
          ]
        },
        index4
      ))
    }
  );
};

// node_modules/@copilotkit/react-ui/dist/chunk-JGMFJZMG.mjs
var useDarkMode = () => {
  if (typeof window === "undefined")
    return false;
  return document.documentElement.classList.contains("dark") || document.body.classList.contains("dark") || document.documentElement.getAttribute("data-theme") === "dark" || document.body.getAttribute("data-theme") === "dark" || window.matchMedia("(prefers-color-scheme: dark)").matches;
};

// node_modules/@copilotkit/react-ui/dist/chunk-ELGRNEAO.mjs
var import_react141 = __toESM(require_react(), 1);
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
function PoweredByTag({ showPoweredBy = true }) {
  const [mounted, setMounted] = (0, import_react141.useState)(false);
  const isDark = useDarkMode();
  (0, import_react141.useEffect)(() => {
    setMounted(true);
  }, []);
  if (!showPoweredBy) {
    return null;
  }
  const poweredByStyle = {
    visibility: "visible",
    display: "block",
    position: "static",
    textAlign: "center",
    fontSize: "12px",
    padding: "3px 0",
    color: mounted && isDark ? "rgb(69, 69, 69)" : "rgb(214, 214, 214)"
  };
  return (0, import_jsx_runtime13.jsx)("div", { children: (0, import_jsx_runtime13.jsx)("p", { className: "poweredBy", style: poweredByStyle, children: "Powered by CopilotKit" }) });
}

// node_modules/@copilotkit/react-ui/dist/chunk-QIOJXTIQ.mjs
var import_react142 = __toESM(require_react(), 1);
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var AutoResizingTextarea = (0, import_react142.forwardRef)(
  ({
    maxRows = 1,
    placeholder,
    value,
    onChange,
    onKeyDown,
    onCompositionStart,
    onCompositionEnd,
    autoFocus
  }, ref) => {
    const internalTextareaRef = (0, import_react142.useRef)(null);
    const [maxHeight, setMaxHeight] = (0, import_react142.useState)(0);
    (0, import_react142.useImperativeHandle)(ref, () => internalTextareaRef.current);
    (0, import_react142.useEffect)(() => {
      const calculateMaxHeight = () => {
        const textarea = internalTextareaRef.current;
        if (textarea) {
          textarea.style.height = "auto";
          const singleRowHeight = textarea.scrollHeight;
          setMaxHeight(singleRowHeight * maxRows);
          if (autoFocus) {
            textarea.focus();
          }
        }
      };
      calculateMaxHeight();
    }, [maxRows]);
    (0, import_react142.useEffect)(() => {
      const textarea = internalTextareaRef.current;
      if (textarea) {
        textarea.style.height = "auto";
        textarea.style.height = `${Math.min(textarea.scrollHeight, maxHeight)}px`;
      }
    }, [value, maxHeight]);
    return (0, import_jsx_runtime14.jsx)(
      "textarea",
      {
        ref: internalTextareaRef,
        value,
        onChange,
        onKeyDown,
        onCompositionStart,
        onCompositionEnd,
        placeholder,
        style: {
          overflow: "auto",
          resize: "none",
          maxHeight: `${maxHeight}px`
        },
        rows: 1
      }
    );
  }
);
var Textarea_default = AutoResizingTextarea;

// node_modules/@copilotkit/react-ui/dist/chunk-O72ZB5V3.mjs
var import_react143 = __toESM(require_react(), 1);
var startRecording = (mediaStreamRef, mediaRecorderRef, audioContextRef, recordedChunks, onStop) => __async(void 0, null, function* () {
  if (!mediaStreamRef.current || !audioContextRef.current) {
    mediaStreamRef.current = yield navigator.mediaDevices.getUserMedia({ audio: true });
    audioContextRef.current = new window.AudioContext();
    yield audioContextRef.current.resume();
  }
  mediaRecorderRef.current = new MediaRecorder(mediaStreamRef.current);
  mediaRecorderRef.current.start(1e3);
  mediaRecorderRef.current.ondataavailable = (event) => {
    recordedChunks.push(event.data);
  };
  mediaRecorderRef.current.onstop = onStop;
});
var stopRecording = (mediaRecorderRef) => {
  if (mediaRecorderRef.current && mediaRecorderRef.current.state !== "inactive") {
    mediaRecorderRef.current.stop();
  }
};
var transcribeAudio = (recordedChunks, transcribeAudioUrl) => __async(void 0, null, function* () {
  const completeBlob = new Blob(recordedChunks, { type: "audio/mp4" });
  const formData = new FormData();
  formData.append("file", completeBlob, "recording.mp4");
  const response = yield fetch(transcribeAudioUrl, {
    method: "POST",
    body: formData
  });
  if (!response.ok) {
    throw new Error(`Error: ${response.statusText}`);
  }
  const transcription = yield response.json();
  return transcription.text;
});
var playAudioResponse = (text10, textToSpeechUrl, audioContext) => {
  const encodedText = encodeURIComponent(text10);
  const url = `${textToSpeechUrl}?text=${encodedText}`;
  fetch(url).then((response) => response.arrayBuffer()).then((arrayBuffer) => audioContext.decodeAudioData(arrayBuffer)).then((audioBuffer) => {
    const source = audioContext.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(audioContext.destination);
    source.start(0);
  }).catch((error2) => {
    console.error("Error with decoding audio data", error2);
  });
};
var usePushToTalk = ({
  sendFunction,
  inProgress
}) => {
  const [pushToTalkState, setPushToTalkState] = (0, import_react143.useState)("idle");
  const mediaStreamRef = (0, import_react143.useRef)(null);
  const audioContextRef = (0, import_react143.useRef)(null);
  const mediaRecorderRef = (0, import_react143.useRef)(null);
  const recordedChunks = (0, import_react143.useRef)([]);
  const generalContext = useCopilotContext();
  const messagesContext = useCopilotMessagesContext();
  const context = __spreadValues(__spreadValues({}, generalContext), messagesContext);
  const [startReadingFromMessageId, setStartReadingFromMessageId] = (0, import_react143.useState)(null);
  (0, import_react143.useEffect)(() => {
    if (pushToTalkState === "recording") {
      startRecording(
        mediaStreamRef,
        mediaRecorderRef,
        audioContextRef,
        recordedChunks.current,
        () => {
          setPushToTalkState("transcribing");
        }
      );
    } else {
      stopRecording(mediaRecorderRef);
      if (pushToTalkState === "transcribing") {
        transcribeAudio(recordedChunks.current, context.copilotApiConfig.transcribeAudioUrl).then(
          (transcription) => __async(void 0, null, function* () {
            recordedChunks.current = [];
            setPushToTalkState("idle");
            const message = yield sendFunction(transcription);
            setStartReadingFromMessageId(message.id);
          })
        );
      }
    }
    return () => {
      stopRecording(mediaRecorderRef);
    };
  }, [pushToTalkState]);
  (0, import_react143.useEffect)(() => {
    if (inProgress === false && startReadingFromMessageId) {
      const lastMessageIndex = context.messages.findIndex(
        (message) => message.id === startReadingFromMessageId
      );
      const aguiMessages = gqlToAGUI(context.messages);
      const messagesAfterLast = aguiMessages.slice(lastMessageIndex + 1).filter((message) => message.role === "assistant");
      const text10 = messagesAfterLast.map((message) => message.content).join("\n");
      playAudioResponse(text10, context.copilotApiConfig.textToSpeechUrl, audioContextRef.current);
      setStartReadingFromMessageId(null);
    }
  }, [startReadingFromMessageId, inProgress]);
  return { pushToTalkState, setPushToTalkState };
};

// node_modules/@copilotkit/react-ui/dist/chunk-EZQA3UPQ.mjs
var import_react144 = __toESM(require_react(), 1);
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var MAX_NEWLINES = 6;
var Input = ({
  inProgress,
  onSend,
  isVisible = false,
  onStop,
  onUpload,
  hideStopButton = false
}) => {
  var _a2, _b;
  const context = useChatContext();
  const copilotContext = useCopilotContext();
  const showPoweredBy = !((_a2 = copilotContext.copilotApiConfig) == null ? void 0 : _a2.publicApiKey);
  const pushToTalkConfigured = copilotContext.copilotApiConfig.textToSpeechUrl !== void 0 && copilotContext.copilotApiConfig.transcribeAudioUrl !== void 0;
  const textareaRef = (0, import_react144.useRef)(null);
  const [isComposing, setIsComposing] = (0, import_react144.useState)(false);
  const handleDivClick = (event) => {
    var _a22;
    const target = event.target;
    if (target.closest("button"))
      return;
    if (target.tagName === "TEXTAREA")
      return;
    (_a22 = textareaRef.current) == null ? void 0 : _a22.focus();
  };
  const [text10, setText] = (0, import_react144.useState)("");
  const send = () => {
    var _a22;
    if (inProgress)
      return;
    onSend(text10);
    setText("");
    (_a22 = textareaRef.current) == null ? void 0 : _a22.focus();
  };
  const { pushToTalkState, setPushToTalkState } = usePushToTalk({
    sendFunction: onSend,
    inProgress
  });
  const isInProgress = inProgress || pushToTalkState === "transcribing";
  const buttonIcon = isInProgress && !hideStopButton ? context.icons.stopIcon : context.icons.sendIcon;
  const showPushToTalk = pushToTalkConfigured && (pushToTalkState === "idle" || pushToTalkState === "recording") && !inProgress;
  const canSend = (0, import_react144.useMemo)(() => {
    var _a22;
    const interruptEvent = (_a22 = copilotContext.langGraphInterruptAction) == null ? void 0 : _a22.event;
    const interruptInProgress = (interruptEvent == null ? void 0 : interruptEvent.name) === "LangGraphInterruptEvent" && !(interruptEvent == null ? void 0 : interruptEvent.response);
    return !isInProgress && text10.trim().length > 0 && pushToTalkState === "idle" && !interruptInProgress;
  }, [(_b = copilotContext.langGraphInterruptAction) == null ? void 0 : _b.event, isInProgress, text10, pushToTalkState]);
  const canStop = (0, import_react144.useMemo)(() => {
    return isInProgress && !hideStopButton;
  }, [isInProgress, hideStopButton]);
  const sendDisabled = !canSend && !canStop;
  return (0, import_jsx_runtime15.jsxs)("div", { className: `copilotKitInputContainer ${showPoweredBy ? "poweredByContainer" : ""}`, children: [
    (0, import_jsx_runtime15.jsxs)("div", { className: "copilotKitInput", onClick: handleDivClick, children: [
      (0, import_jsx_runtime15.jsx)(
        Textarea_default,
        {
          ref: textareaRef,
          placeholder: context.labels.placeholder,
          autoFocus: false,
          maxRows: MAX_NEWLINES,
          value: text10,
          onChange: (event) => setText(event.target.value),
          onCompositionStart: () => setIsComposing(true),
          onCompositionEnd: () => setIsComposing(false),
          onKeyDown: (event) => {
            if (event.key === "Enter" && !event.shiftKey && !isComposing) {
              event.preventDefault();
              if (canSend) {
                send();
              }
            }
          }
        }
      ),
      (0, import_jsx_runtime15.jsxs)("div", { className: "copilotKitInputControls", children: [
        onUpload && (0, import_jsx_runtime15.jsx)("button", { onClick: onUpload, className: "copilotKitInputControlButton", children: context.icons.uploadIcon }),
        (0, import_jsx_runtime15.jsx)("div", { style: { flexGrow: 1 } }),
        showPushToTalk && (0, import_jsx_runtime15.jsx)(
          "button",
          {
            onClick: () => setPushToTalkState(pushToTalkState === "idle" ? "recording" : "transcribing"),
            className: pushToTalkState === "recording" ? "copilotKitInputControlButton copilotKitPushToTalkRecording" : "copilotKitInputControlButton",
            children: context.icons.pushToTalkIcon
          }
        ),
        (0, import_jsx_runtime15.jsx)(
          "button",
          {
            disabled: sendDisabled,
            onClick: isInProgress && !hideStopButton ? onStop : send,
            "data-copilotkit-in-progress": inProgress,
            "data-test-id": inProgress ? "copilot-chat-request-in-progress" : "copilot-chat-ready",
            className: "copilotKitInputControlButton",
            children: buttonIcon
          }
        )
      ] })
    ] }),
    (0, import_jsx_runtime15.jsx)(PoweredByTag, { showPoweredBy })
  ] });
};

// node_modules/@copilotkit/react-ui/dist/chunk-54JAUBUJ.mjs
var React6 = __toESM(require_react(), 1);
function useCopyToClipboard({ timeout = 2e3 }) {
  const [isCopied, setIsCopied] = React6.useState(false);
  const copyToClipboard = (value) => {
    var _a2;
    if (typeof window === "undefined" || !((_a2 = navigator.clipboard) == null ? void 0 : _a2.writeText)) {
      return;
    }
    if (!value) {
      return;
    }
    navigator.clipboard.writeText(value).then(() => {
      setIsCopied(true);
      setTimeout(() => {
        setIsCopied(false);
      }, timeout);
    });
  };
  return { isCopied, copyToClipboard };
}

// node_modules/@copilotkit/react-ui/dist/chunk-IK2BPURM.mjs
var import_react148 = __toESM(require_react(), 1);

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r22, e9) {
  if (null == r22) return {};
  var t14 = {};
  for (var n17 in r22) if ({}.hasOwnProperty.call(r22, n17)) {
    if (-1 !== e9.indexOf(n17)) continue;
    t14[n17] = r22[n17];
  }
  return t14;
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(e9, t14) {
  if (null == e9) return {};
  var o20, r22, i16 = _objectWithoutPropertiesLoose(e9, t14);
  if (Object.getOwnPropertySymbols) {
    var n17 = Object.getOwnPropertySymbols(e9);
    for (r22 = 0; r22 < n17.length; r22++) o20 = n17[r22], -1 === t14.indexOf(o20) && {}.propertyIsEnumerable.call(e9, o20) && (i16[o20] = e9[o20]);
  }
  return i16;
}

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(r22, a28) {
  (null == a28 || a28 > r22.length) && (a28 = r22.length);
  for (var e9 = 0, n17 = Array(a28); e9 < a28; e9++) n17[e9] = r22[e9];
  return n17;
}

// node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(r22) {
  if (Array.isArray(r22)) return _arrayLikeToArray(r22);
}

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(r22) {
  if ("undefined" != typeof Symbol && null != r22[Symbol.iterator] || null != r22["@@iterator"]) return Array.from(r22);
}

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(r22, a28) {
  if (r22) {
    if ("string" == typeof r22) return _arrayLikeToArray(r22, a28);
    var t14 = {}.toString.call(r22).slice(8, -1);
    return "Object" === t14 && r22.constructor && (t14 = r22.constructor.name), "Map" === t14 || "Set" === t14 ? Array.from(r22) : "Arguments" === t14 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t14) ? _arrayLikeToArray(r22, a28) : void 0;
  }
}

// node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(r22) {
  return _arrayWithoutHoles(r22) || _iterableToArray(r22) || _unsupportedIterableToArray(r22) || _nonIterableSpread();
}

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o20) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o21) {
    return typeof o21;
  } : function(o21) {
    return o21 && "function" == typeof Symbol && o21.constructor === Symbol && o21 !== Symbol.prototype ? "symbol" : typeof o21;
  }, _typeof(o20);
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t14, r22) {
  if ("object" != _typeof(t14) || !t14) return t14;
  var e9 = t14[Symbol.toPrimitive];
  if (void 0 !== e9) {
    var i16 = e9.call(t14, r22 || "default");
    if ("object" != _typeof(i16)) return i16;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r22 ? String : Number)(t14);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t14) {
  var i16 = toPrimitive(t14, "string");
  return "symbol" == _typeof(i16) ? i16 : i16 + "";
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e9, r22, t14) {
  return (r22 = toPropertyKey(r22)) in e9 ? Object.defineProperty(e9, r22, {
    value: t14,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e9[r22] = t14, e9;
}

// node_modules/react-syntax-highlighter/dist/esm/highlight.js
var import_react146 = __toESM(require_react());

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends2() {
  return _extends2 = Object.assign ? Object.assign.bind() : function(n17) {
    for (var e9 = 1; e9 < arguments.length; e9++) {
      var t14 = arguments[e9];
      for (var r22 in t14) ({}).hasOwnProperty.call(t14, r22) && (n17[r22] = t14[r22]);
    }
    return n17;
  }, _extends2.apply(null, arguments);
}

// node_modules/react-syntax-highlighter/dist/esm/create-element.js
var import_react145 = __toESM(require_react());
function ownKeys(e9, r22) {
  var t14 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var o20 = Object.getOwnPropertySymbols(e9);
    r22 && (o20 = o20.filter(function(r23) {
      return Object.getOwnPropertyDescriptor(e9, r23).enumerable;
    })), t14.push.apply(t14, o20);
  }
  return t14;
}
function _objectSpread(e9) {
  for (var r22 = 1; r22 < arguments.length; r22++) {
    var t14 = null != arguments[r22] ? arguments[r22] : {};
    r22 % 2 ? ownKeys(Object(t14), true).forEach(function(r23) {
      _defineProperty(e9, r23, t14[r23]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(t14)) : ownKeys(Object(t14)).forEach(function(r23) {
      Object.defineProperty(e9, r23, Object.getOwnPropertyDescriptor(t14, r23));
    });
  }
  return e9;
}
function powerSetPermutations(arr) {
  var arrLength = arr.length;
  if (arrLength === 0 || arrLength === 1) return arr;
  if (arrLength === 2) {
    return [arr[0], arr[1], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0])];
  }
  if (arrLength === 3) {
    return [arr[0], arr[1], arr[2], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  }
  if (arrLength >= 4) {
    return [arr[0], arr[1], arr[2], arr[3], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3]), "".concat(arr[3], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  }
}
var classNameCombinations = {};
function getClassNameCombinations(classNames) {
  if (classNames.length === 0 || classNames.length === 1) return classNames;
  var key = classNames.join(".");
  if (!classNameCombinations[key]) {
    classNameCombinations[key] = powerSetPermutations(classNames);
  }
  return classNameCombinations[key];
}
function createStyleObject(classNames) {
  var elementStyle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var stylesheet = arguments.length > 2 ? arguments[2] : void 0;
  var nonTokenClassNames = classNames.filter(function(className) {
    return className !== "token";
  });
  var classNamesCombinations = getClassNameCombinations(nonTokenClassNames);
  return classNamesCombinations.reduce(function(styleObject, className) {
    return _objectSpread(_objectSpread({}, styleObject), stylesheet[className]);
  }, elementStyle);
}
function createClassNameString(classNames) {
  return classNames.join(" ");
}
function createChildren(stylesheet, useInlineStyles) {
  var childrenCount = 0;
  return function(children) {
    childrenCount += 1;
    return children.map(function(child, i16) {
      return createElement4({
        node: child,
        stylesheet,
        useInlineStyles,
        key: "code-segment-".concat(childrenCount, "-").concat(i16)
      });
    });
  };
}
function createElement4(_ref) {
  var node2 = _ref.node, stylesheet = _ref.stylesheet, _ref$style = _ref.style, style2 = _ref$style === void 0 ? {} : _ref$style, useInlineStyles = _ref.useInlineStyles, key = _ref.key;
  var properties = node2.properties, type = node2.type, TagName = node2.tagName, value = node2.value;
  if (type === "text") {
    return value;
  } else if (TagName) {
    var childrenCreator = createChildren(stylesheet, useInlineStyles);
    var props;
    if (!useInlineStyles) {
      props = _objectSpread(_objectSpread({}, properties), {}, {
        className: createClassNameString(properties.className)
      });
    } else {
      var allStylesheetSelectors = Object.keys(stylesheet).reduce(function(classes, selector) {
        selector.split(".").forEach(function(className2) {
          if (!classes.includes(className2)) classes.push(className2);
        });
        return classes;
      }, []);
      var startingClassName = properties.className && properties.className.includes("token") ? ["token"] : [];
      var className = properties.className && startingClassName.concat(properties.className.filter(function(className2) {
        return !allStylesheetSelectors.includes(className2);
      }));
      props = _objectSpread(_objectSpread({}, properties), {}, {
        className: createClassNameString(className) || void 0,
        style: createStyleObject(properties.className, Object.assign({}, properties.style, style2), stylesheet)
      });
    }
    var children = childrenCreator(node2.children);
    return import_react145.default.createElement(TagName, _extends2({
      key
    }, props), children);
  }
}

// node_modules/react-syntax-highlighter/dist/esm/checkForListedLanguage.js
var checkForListedLanguage_default = function(astGenerator, language) {
  var langs = astGenerator.listLanguages();
  return langs.indexOf(language) !== -1;
};

// node_modules/react-syntax-highlighter/dist/esm/highlight.js
var _excluded = ["language", "children", "style", "customStyle", "codeTagProps", "useInlineStyles", "showLineNumbers", "showInlineLineNumbers", "startingLineNumber", "lineNumberContainerStyle", "lineNumberStyle", "wrapLines", "wrapLongLines", "lineProps", "renderer", "PreTag", "CodeTag", "code", "astGenerator"];
function ownKeys2(e9, r22) {
  var t14 = Object.keys(e9);
  if (Object.getOwnPropertySymbols) {
    var o20 = Object.getOwnPropertySymbols(e9);
    r22 && (o20 = o20.filter(function(r23) {
      return Object.getOwnPropertyDescriptor(e9, r23).enumerable;
    })), t14.push.apply(t14, o20);
  }
  return t14;
}
function _objectSpread2(e9) {
  for (var r22 = 1; r22 < arguments.length; r22++) {
    var t14 = null != arguments[r22] ? arguments[r22] : {};
    r22 % 2 ? ownKeys2(Object(t14), true).forEach(function(r23) {
      _defineProperty(e9, r23, t14[r23]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e9, Object.getOwnPropertyDescriptors(t14)) : ownKeys2(Object(t14)).forEach(function(r23) {
      Object.defineProperty(e9, r23, Object.getOwnPropertyDescriptor(t14, r23));
    });
  }
  return e9;
}
var newLineRegex = /\n/g;
function getNewLines(str) {
  return str.match(newLineRegex);
}
function getAllLineNumbers(_ref) {
  var lines = _ref.lines, startingLineNumber = _ref.startingLineNumber, style2 = _ref.style;
  return lines.map(function(_10, i16) {
    var number3 = i16 + startingLineNumber;
    return import_react146.default.createElement("span", {
      key: "line-".concat(i16),
      className: "react-syntax-highlighter-line-number",
      style: typeof style2 === "function" ? style2(number3) : style2
    }, "".concat(number3, "\n"));
  });
}
function AllLineNumbers(_ref2) {
  var codeString = _ref2.codeString, codeStyle = _ref2.codeStyle, _ref2$containerStyle = _ref2.containerStyle, containerStyle = _ref2$containerStyle === void 0 ? {
    "float": "left",
    paddingRight: "10px"
  } : _ref2$containerStyle, _ref2$numberStyle = _ref2.numberStyle, numberStyle = _ref2$numberStyle === void 0 ? {} : _ref2$numberStyle, startingLineNumber = _ref2.startingLineNumber;
  return import_react146.default.createElement("code", {
    style: Object.assign({}, codeStyle, containerStyle)
  }, getAllLineNumbers({
    lines: codeString.replace(/\n$/, "").split("\n"),
    style: numberStyle,
    startingLineNumber
  }));
}
function getEmWidthOfNumber(num) {
  return "".concat(num.toString().length, ".25em");
}
function getInlineLineNumber(lineNumber, inlineLineNumberStyle) {
  return {
    type: "element",
    tagName: "span",
    properties: {
      key: "line-number--".concat(lineNumber),
      className: ["comment", "linenumber", "react-syntax-highlighter-line-number"],
      style: inlineLineNumberStyle
    },
    children: [{
      type: "text",
      value: lineNumber
    }]
  };
}
function assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber) {
  var defaultLineNumberStyle = {
    display: "inline-block",
    minWidth: getEmWidthOfNumber(largestLineNumber),
    paddingRight: "1em",
    textAlign: "right",
    userSelect: "none"
  };
  var customLineNumberStyle = typeof lineNumberStyle === "function" ? lineNumberStyle(lineNumber) : lineNumberStyle;
  var assembledStyle = _objectSpread2(_objectSpread2({}, defaultLineNumberStyle), customLineNumberStyle);
  return assembledStyle;
}
function createLineElement(_ref3) {
  var children = _ref3.children, lineNumber = _ref3.lineNumber, lineNumberStyle = _ref3.lineNumberStyle, largestLineNumber = _ref3.largestLineNumber, showInlineLineNumbers = _ref3.showInlineLineNumbers, _ref3$lineProps = _ref3.lineProps, lineProps = _ref3$lineProps === void 0 ? {} : _ref3$lineProps, _ref3$className = _ref3.className, className = _ref3$className === void 0 ? [] : _ref3$className, showLineNumbers = _ref3.showLineNumbers, wrapLongLines = _ref3.wrapLongLines, _ref3$wrapLines = _ref3.wrapLines, wrapLines = _ref3$wrapLines === void 0 ? false : _ref3$wrapLines;
  var properties = wrapLines ? _objectSpread2({}, typeof lineProps === "function" ? lineProps(lineNumber) : lineProps) : {};
  properties["className"] = properties["className"] ? [].concat(_toConsumableArray(properties["className"].trim().split(/\s+/)), _toConsumableArray(className)) : className;
  if (lineNumber && showInlineLineNumbers) {
    var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber);
    children.unshift(getInlineLineNumber(lineNumber, inlineLineNumberStyle));
  }
  if (wrapLongLines & showLineNumbers) {
    properties.style = _objectSpread2({
      display: "flex"
    }, properties.style);
  }
  return {
    type: "element",
    tagName: "span",
    properties,
    children
  };
}
function flattenCodeTree(tree) {
  var className = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var newTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  for (var i16 = 0; i16 < tree.length; i16++) {
    var node2 = tree[i16];
    if (node2.type === "text") {
      newTree.push(createLineElement({
        children: [node2],
        className: _toConsumableArray(new Set(className))
      }));
    } else if (node2.children) {
      var classNames = className.concat(node2.properties.className);
      flattenCodeTree(node2.children, classNames).forEach(function(i17) {
        return newTree.push(i17);
      });
    }
  }
  return newTree;
}
function processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines) {
  var _ref4;
  var tree = flattenCodeTree(codeTree.value);
  var newTree = [];
  var lastLineBreakIndex = -1;
  var index4 = 0;
  function createWrappedLine(children2, lineNumber2) {
    var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return createLineElement({
      children: children2,
      lineNumber: lineNumber2,
      lineNumberStyle,
      largestLineNumber,
      showInlineLineNumbers,
      lineProps,
      className,
      showLineNumbers,
      wrapLongLines,
      wrapLines
    });
  }
  function createUnwrappedLine(children2, lineNumber2) {
    if (showLineNumbers && lineNumber2 && showInlineLineNumbers) {
      var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber2, largestLineNumber);
      children2.unshift(getInlineLineNumber(lineNumber2, inlineLineNumberStyle));
    }
    return children2;
  }
  function createLine(children2, lineNumber2) {
    var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return wrapLines || className.length > 0 ? createWrappedLine(children2, lineNumber2, className) : createUnwrappedLine(children2, lineNumber2);
  }
  var _loop = function _loop2() {
    var node2 = tree[index4];
    var value = node2.children[0].value;
    var newLines = getNewLines(value);
    if (newLines) {
      var splitValue = value.split("\n");
      splitValue.forEach(function(text10, i16) {
        var lineNumber2 = showLineNumbers && newTree.length + startingLineNumber;
        var newChild = {
          type: "text",
          value: "".concat(text10, "\n")
        };
        if (i16 === 0) {
          var _children = tree.slice(lastLineBreakIndex + 1, index4).concat(createLineElement({
            children: [newChild],
            className: node2.properties.className
          }));
          var _line = createLine(_children, lineNumber2);
          newTree.push(_line);
        } else if (i16 === splitValue.length - 1) {
          var stringChild = tree[index4 + 1] && tree[index4 + 1].children && tree[index4 + 1].children[0];
          var lastLineInPreviousSpan = {
            type: "text",
            value: "".concat(text10)
          };
          if (stringChild) {
            var newElem = createLineElement({
              children: [lastLineInPreviousSpan],
              className: node2.properties.className
            });
            tree.splice(index4 + 1, 0, newElem);
          } else {
            var _children2 = [lastLineInPreviousSpan];
            var _line2 = createLine(_children2, lineNumber2, node2.properties.className);
            newTree.push(_line2);
          }
        } else {
          var _children3 = [newChild];
          var _line3 = createLine(_children3, lineNumber2, node2.properties.className);
          newTree.push(_line3);
        }
      });
      lastLineBreakIndex = index4;
    }
    index4++;
  };
  while (index4 < tree.length) {
    _loop();
  }
  if (lastLineBreakIndex !== tree.length - 1) {
    var children = tree.slice(lastLineBreakIndex + 1, tree.length);
    if (children && children.length) {
      var lineNumber = showLineNumbers && newTree.length + startingLineNumber;
      var line = createLine(children, lineNumber);
      newTree.push(line);
    }
  }
  return wrapLines ? newTree : (_ref4 = []).concat.apply(_ref4, newTree);
}
function defaultRenderer(_ref5) {
  var rows = _ref5.rows, stylesheet = _ref5.stylesheet, useInlineStyles = _ref5.useInlineStyles;
  return rows.map(function(node2, i16) {
    return createElement4({
      node: node2,
      stylesheet,
      useInlineStyles,
      key: "code-segment-".concat(i16)
    });
  });
}
function isHighlightJs(astGenerator) {
  return astGenerator && typeof astGenerator.highlightAuto !== "undefined";
}
function getCodeTree(_ref6) {
  var astGenerator = _ref6.astGenerator, language = _ref6.language, code4 = _ref6.code, defaultCodeValue = _ref6.defaultCodeValue;
  if (isHighlightJs(astGenerator)) {
    var hasLanguage = checkForListedLanguage_default(astGenerator, language);
    if (language === "text") {
      return {
        value: defaultCodeValue,
        language: "text"
      };
    } else if (hasLanguage) {
      return astGenerator.highlight(language, code4);
    } else {
      return astGenerator.highlightAuto(code4);
    }
  }
  try {
    return language && language !== "text" ? {
      value: astGenerator.highlight(code4, language)
    } : {
      value: defaultCodeValue
    };
  } catch (e9) {
    return {
      value: defaultCodeValue
    };
  }
}
function highlight_default(defaultAstGenerator, defaultStyle) {
  return function SyntaxHighlighter3(_ref7) {
    var _code$match$length, _code$match;
    var language = _ref7.language, children = _ref7.children, _ref7$style = _ref7.style, style2 = _ref7$style === void 0 ? defaultStyle : _ref7$style, _ref7$customStyle = _ref7.customStyle, customStyle = _ref7$customStyle === void 0 ? {} : _ref7$customStyle, _ref7$codeTagProps = _ref7.codeTagProps, codeTagProps = _ref7$codeTagProps === void 0 ? {
      className: language ? "language-".concat(language) : void 0,
      style: _objectSpread2(_objectSpread2({}, style2['code[class*="language-"]']), style2['code[class*="language-'.concat(language, '"]')])
    } : _ref7$codeTagProps, _ref7$useInlineStyles = _ref7.useInlineStyles, useInlineStyles = _ref7$useInlineStyles === void 0 ? true : _ref7$useInlineStyles, _ref7$showLineNumbers = _ref7.showLineNumbers, showLineNumbers = _ref7$showLineNumbers === void 0 ? false : _ref7$showLineNumbers, _ref7$showInlineLineN = _ref7.showInlineLineNumbers, showInlineLineNumbers = _ref7$showInlineLineN === void 0 ? true : _ref7$showInlineLineN, _ref7$startingLineNum = _ref7.startingLineNumber, startingLineNumber = _ref7$startingLineNum === void 0 ? 1 : _ref7$startingLineNum, lineNumberContainerStyle = _ref7.lineNumberContainerStyle, _ref7$lineNumberStyle = _ref7.lineNumberStyle, lineNumberStyle = _ref7$lineNumberStyle === void 0 ? {} : _ref7$lineNumberStyle, wrapLines = _ref7.wrapLines, _ref7$wrapLongLines = _ref7.wrapLongLines, wrapLongLines = _ref7$wrapLongLines === void 0 ? false : _ref7$wrapLongLines, _ref7$lineProps = _ref7.lineProps, lineProps = _ref7$lineProps === void 0 ? {} : _ref7$lineProps, renderer = _ref7.renderer, _ref7$PreTag = _ref7.PreTag, PreTag = _ref7$PreTag === void 0 ? "pre" : _ref7$PreTag, _ref7$CodeTag = _ref7.CodeTag, CodeTag = _ref7$CodeTag === void 0 ? "code" : _ref7$CodeTag, _ref7$code = _ref7.code, code4 = _ref7$code === void 0 ? (Array.isArray(children) ? children[0] : children) || "" : _ref7$code, astGenerator = _ref7.astGenerator, rest = _objectWithoutProperties(_ref7, _excluded);
    astGenerator = astGenerator || defaultAstGenerator;
    var allLineNumbers = showLineNumbers ? import_react146.default.createElement(AllLineNumbers, {
      containerStyle: lineNumberContainerStyle,
      codeStyle: codeTagProps.style || {},
      numberStyle: lineNumberStyle,
      startingLineNumber,
      codeString: code4
    }) : null;
    var defaultPreStyle = style2.hljs || style2['pre[class*="language-"]'] || {
      backgroundColor: "#fff"
    };
    var generatorClassName = isHighlightJs(astGenerator) ? "hljs" : "prismjs";
    var preProps = useInlineStyles ? Object.assign({}, rest, {
      style: Object.assign({}, defaultPreStyle, customStyle)
    }) : Object.assign({}, rest, {
      className: rest.className ? "".concat(generatorClassName, " ").concat(rest.className) : generatorClassName,
      style: Object.assign({}, customStyle)
    });
    if (wrapLongLines) {
      codeTagProps.style = _objectSpread2({
        whiteSpace: "pre-wrap"
      }, codeTagProps.style);
    } else {
      codeTagProps.style = _objectSpread2({
        whiteSpace: "pre"
      }, codeTagProps.style);
    }
    if (!astGenerator) {
      return import_react146.default.createElement(PreTag, preProps, allLineNumbers, import_react146.default.createElement(CodeTag, codeTagProps, code4));
    }
    if (wrapLines === void 0 && renderer || wrapLongLines) wrapLines = true;
    renderer = renderer || defaultRenderer;
    var defaultCodeValue = [{
      type: "text",
      value: code4
    }];
    var codeTree = getCodeTree({
      astGenerator,
      language,
      code: code4,
      defaultCodeValue
    });
    if (codeTree.language === null) {
      codeTree.value = defaultCodeValue;
    }
    var lineBreakCount = (_code$match$length = (_code$match = code4.match(/\n/g)) === null || _code$match === void 0 ? void 0 : _code$match.length) !== null && _code$match$length !== void 0 ? _code$match$length : 0;
    var largestLineNumber = startingLineNumber + lineBreakCount;
    var rows = processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines);
    return import_react146.default.createElement(PreTag, preProps, import_react146.default.createElement(CodeTag, codeTagProps, !showInlineLineNumbers && allLineNumbers, renderer({
      rows,
      stylesheet: style2,
      useInlineStyles
    })));
  };
}

// node_modules/react-syntax-highlighter/dist/esm/styles/hljs/default-style.js
var default_style_default = {
  "hljs": {
    "display": "block",
    "overflowX": "auto",
    "padding": "0.5em",
    "background": "#F0F0F0",
    "color": "#444"
  },
  "hljs-subst": {
    "color": "#444"
  },
  "hljs-comment": {
    "color": "#888888"
  },
  "hljs-keyword": {
    "fontWeight": "bold"
  },
  "hljs-attribute": {
    "fontWeight": "bold"
  },
  "hljs-selector-tag": {
    "fontWeight": "bold"
  },
  "hljs-meta-keyword": {
    "fontWeight": "bold"
  },
  "hljs-doctag": {
    "fontWeight": "bold"
  },
  "hljs-name": {
    "fontWeight": "bold"
  },
  "hljs-type": {
    "color": "#880000"
  },
  "hljs-string": {
    "color": "#880000"
  },
  "hljs-number": {
    "color": "#880000"
  },
  "hljs-selector-id": {
    "color": "#880000"
  },
  "hljs-selector-class": {
    "color": "#880000"
  },
  "hljs-quote": {
    "color": "#880000"
  },
  "hljs-template-tag": {
    "color": "#880000"
  },
  "hljs-deletion": {
    "color": "#880000"
  },
  "hljs-title": {
    "color": "#880000",
    "fontWeight": "bold"
  },
  "hljs-section": {
    "color": "#880000",
    "fontWeight": "bold"
  },
  "hljs-regexp": {
    "color": "#BC6060"
  },
  "hljs-symbol": {
    "color": "#BC6060"
  },
  "hljs-variable": {
    "color": "#BC6060"
  },
  "hljs-template-variable": {
    "color": "#BC6060"
  },
  "hljs-link": {
    "color": "#BC6060"
  },
  "hljs-selector-attr": {
    "color": "#BC6060"
  },
  "hljs-selector-pseudo": {
    "color": "#BC6060"
  },
  "hljs-literal": {
    "color": "#78A960"
  },
  "hljs-built_in": {
    "color": "#397300"
  },
  "hljs-bullet": {
    "color": "#397300"
  },
  "hljs-code": {
    "color": "#397300"
  },
  "hljs-addition": {
    "color": "#397300"
  },
  "hljs-meta": {
    "color": "#1f7199"
  },
  "hljs-meta-string": {
    "color": "#4d99bf"
  },
  "hljs-emphasis": {
    "fontStyle": "italic"
  },
  "hljs-strong": {
    "fontWeight": "bold"
  }
};

// node_modules/react-syntax-highlighter/dist/esm/default-highlight.js
var import_lowlight = __toESM(require_lowlight());

// node_modules/react-syntax-highlighter/dist/esm/languages/hljs/supported-languages.js
var supported_languages_default = ["1c", "abnf", "accesslog", "actionscript", "ada", "angelscript", "apache", "applescript", "arcade", "arduino", "armasm", "asciidoc", "aspectj", "autohotkey", "autoit", "avrasm", "awk", "axapta", "bash", "basic", "bnf", "brainfuck", "c-like", "c", "cal", "capnproto", "ceylon", "clean", "clojure-repl", "clojure", "cmake", "coffeescript", "coq", "cos", "cpp", "crmsh", "crystal", "csharp", "csp", "css", "d", "dart", "delphi", "diff", "django", "dns", "dockerfile", "dos", "dsconfig", "dts", "dust", "ebnf", "elixir", "elm", "erb", "erlang-repl", "erlang", "excel", "fix", "flix", "fortran", "fsharp", "gams", "gauss", "gcode", "gherkin", "glsl", "gml", "go", "golo", "gradle", "groovy", "haml", "handlebars", "haskell", "haxe", "hsp", "htmlbars", "http", "hy", "inform7", "ini", "irpf90", "isbl", "java", "javascript", "jboss-cli", "json", "julia-repl", "julia", "kotlin", "lasso", "latex", "ldif", "leaf", "less", "lisp", "livecodeserver", "livescript", "llvm", "lsl", "lua", "makefile", "markdown", "mathematica", "matlab", "maxima", "mel", "mercury", "mipsasm", "mizar", "mojolicious", "monkey", "moonscript", "n1ql", "nginx", "nim", "nix", "node-repl", "nsis", "objectivec", "ocaml", "openscad", "oxygene", "parser3", "perl", "pf", "pgsql", "php-template", "php", "plaintext", "pony", "powershell", "processing", "profile", "prolog", "properties", "protobuf", "puppet", "purebasic", "python-repl", "python", "q", "qml", "r", "reasonml", "rib", "roboconf", "routeros", "rsl", "ruby", "ruleslanguage", "rust", "sas", "scala", "scheme", "scilab", "scss", "shell", "smali", "smalltalk", "sml", "sqf", "sql", "sql_more", "stan", "stata", "step21", "stylus", "subunit", "swift", "taggerscript", "tap", "tcl", "thrift", "tp", "twig", "typescript", "vala", "vbnet", "vbscript-html", "vbscript", "verilog", "vhdl", "vim", "x86asm", "xl", "xml", "xquery", "yaml", "zephir"];

// node_modules/react-syntax-highlighter/dist/esm/default-highlight.js
var highlighter = highlight_default(import_lowlight.default, default_style_default);
highlighter.supportedLanguages = supported_languages_default;

// node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(n17, t14, e9, r22, o20, a28, c21) {
  try {
    var i16 = n17[a28](c21), u25 = i16.value;
  } catch (n18) {
    return void e9(n18);
  }
  i16.done ? t14(u25) : Promise.resolve(u25).then(r22, o20);
}
function _asyncToGenerator(n17) {
  return function() {
    var t14 = this, e9 = arguments;
    return new Promise(function(r22, o20) {
      var a28 = n17.apply(t14, e9);
      function _next(n18) {
        asyncGeneratorStep(a28, r22, o20, _next, _throw, "next", n18);
      }
      function _throw(n18) {
        asyncGeneratorStep(a28, r22, o20, _next, _throw, "throw", n18);
      }
      _next(void 0);
    });
  };
}

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(a28, n17) {
  if (!(a28 instanceof n17)) throw new TypeError("Cannot call a class as a function");
}

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(e9, r22) {
  for (var t14 = 0; t14 < r22.length; t14++) {
    var o20 = r22[t14];
    o20.enumerable = o20.enumerable || false, o20.configurable = true, "value" in o20 && (o20.writable = true), Object.defineProperty(e9, toPropertyKey(o20.key), o20);
  }
}
function _createClass(e9, r22, t14) {
  return r22 && _defineProperties(e9.prototype, r22), t14 && _defineProperties(e9, t14), Object.defineProperty(e9, "prototype", {
    writable: false
  }), e9;
}

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e9) {
  if (void 0 === e9) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e9;
}

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(t14, e9) {
  if (e9 && ("object" == _typeof(e9) || "function" == typeof e9)) return e9;
  if (void 0 !== e9) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t14);
}

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(t14) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t15) {
    return t15.__proto__ || Object.getPrototypeOf(t15);
  }, _getPrototypeOf(t14);
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t14, e9) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t15, e10) {
    return t15.__proto__ = e10, t15;
  }, _setPrototypeOf(t14, e9);
}

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(t14, e9) {
  if ("function" != typeof e9 && null !== e9) throw new TypeError("Super expression must either be null or a function");
  t14.prototype = Object.create(e9 && e9.prototype, {
    constructor: {
      value: t14,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t14, "prototype", {
    writable: false
  }), e9 && _setPrototypeOf(t14, e9);
}

// node_modules/react-syntax-highlighter/dist/esm/async-syntax-highlighter.js
var import_react147 = __toESM(require_react());
function _regeneratorRuntime() {
  "use strict";
  _regeneratorRuntime = function _regeneratorRuntime3() {
    return e9;
  };
  var t14, e9 = {}, r22 = Object.prototype, n17 = r22.hasOwnProperty, o20 = Object.defineProperty || function(t15, e10, r23) {
    t15[e10] = r23.value;
  }, i16 = "function" == typeof Symbol ? Symbol : {}, a28 = i16.iterator || "@@iterator", c21 = i16.asyncIterator || "@@asyncIterator", u25 = i16.toStringTag || "@@toStringTag";
  function define(t15, e10, r23) {
    return Object.defineProperty(t15, e10, { value: r23, enumerable: true, configurable: true, writable: true }), t15[e10];
  }
  try {
    define({}, "");
  } catch (t15) {
    define = function define2(t16, e10, r23) {
      return t16[e10] = r23;
    };
  }
  function wrap2(t15, e10, r23, n18) {
    var i17 = e10 && e10.prototype instanceof Generator ? e10 : Generator, a29 = Object.create(i17.prototype), c22 = new Context(n18 || []);
    return o20(a29, "_invoke", { value: makeInvokeMethod(t15, r23, c22) }), a29;
  }
  function tryCatch(t15, e10, r23) {
    try {
      return { type: "normal", arg: t15.call(e10, r23) };
    } catch (t16) {
      return { type: "throw", arg: t16 };
    }
  }
  e9.wrap = wrap2;
  var h16 = "suspendedStart", l19 = "suspendedYield", f21 = "executing", s21 = "completed", y10 = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var p13 = {};
  define(p13, a28, function() {
    return this;
  });
  var d14 = Object.getPrototypeOf, v11 = d14 && d14(d14(values2([])));
  v11 && v11 !== r22 && n17.call(v11, a28) && (p13 = v11);
  var g6 = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p13);
  function defineIteratorMethods(t15) {
    ["next", "throw", "return"].forEach(function(e10) {
      define(t15, e10, function(t16) {
        return this._invoke(e10, t16);
      });
    });
  }
  function AsyncIterator(t15, e10) {
    function invoke(r24, o21, i17, a29) {
      var c22 = tryCatch(t15[r24], t15, o21);
      if ("throw" !== c22.type) {
        var u26 = c22.arg, h17 = u26.value;
        return h17 && "object" == _typeof(h17) && n17.call(h17, "__await") ? e10.resolve(h17.__await).then(function(t16) {
          invoke("next", t16, i17, a29);
        }, function(t16) {
          invoke("throw", t16, i17, a29);
        }) : e10.resolve(h17).then(function(t16) {
          u26.value = t16, i17(u26);
        }, function(t16) {
          return invoke("throw", t16, i17, a29);
        });
      }
      a29(c22.arg);
    }
    var r23;
    o20(this, "_invoke", { value: function value(t16, n18) {
      function callInvokeWithMethodAndArg() {
        return new e10(function(e11, r24) {
          invoke(t16, n18, e11, r24);
        });
      }
      return r23 = r23 ? r23.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } });
  }
  function makeInvokeMethod(e10, r23, n18) {
    var o21 = h16;
    return function(i17, a29) {
      if (o21 === f21) throw Error("Generator is already running");
      if (o21 === s21) {
        if ("throw" === i17) throw a29;
        return { value: t14, done: true };
      }
      for (n18.method = i17, n18.arg = a29; ; ) {
        var c22 = n18.delegate;
        if (c22) {
          var u26 = maybeInvokeDelegate(c22, n18);
          if (u26) {
            if (u26 === y10) continue;
            return u26;
          }
        }
        if ("next" === n18.method) n18.sent = n18._sent = n18.arg;
        else if ("throw" === n18.method) {
          if (o21 === h16) throw o21 = s21, n18.arg;
          n18.dispatchException(n18.arg);
        } else "return" === n18.method && n18.abrupt("return", n18.arg);
        o21 = f21;
        var p14 = tryCatch(e10, r23, n18);
        if ("normal" === p14.type) {
          if (o21 = n18.done ? s21 : l19, p14.arg === y10) continue;
          return { value: p14.arg, done: n18.done };
        }
        "throw" === p14.type && (o21 = s21, n18.method = "throw", n18.arg = p14.arg);
      }
    };
  }
  function maybeInvokeDelegate(e10, r23) {
    var n18 = r23.method, o21 = e10.iterator[n18];
    if (o21 === t14) return r23.delegate = null, "throw" === n18 && e10.iterator["return"] && (r23.method = "return", r23.arg = t14, maybeInvokeDelegate(e10, r23), "throw" === r23.method) || "return" !== n18 && (r23.method = "throw", r23.arg = new TypeError("The iterator does not provide a '" + n18 + "' method")), y10;
    var i17 = tryCatch(o21, e10.iterator, r23.arg);
    if ("throw" === i17.type) return r23.method = "throw", r23.arg = i17.arg, r23.delegate = null, y10;
    var a29 = i17.arg;
    return a29 ? a29.done ? (r23[e10.resultName] = a29.value, r23.next = e10.nextLoc, "return" !== r23.method && (r23.method = "next", r23.arg = t14), r23.delegate = null, y10) : a29 : (r23.method = "throw", r23.arg = new TypeError("iterator result is not an object"), r23.delegate = null, y10);
  }
  function pushTryEntry(t15) {
    var e10 = { tryLoc: t15[0] };
    1 in t15 && (e10.catchLoc = t15[1]), 2 in t15 && (e10.finallyLoc = t15[2], e10.afterLoc = t15[3]), this.tryEntries.push(e10);
  }
  function resetTryEntry(t15) {
    var e10 = t15.completion || {};
    e10.type = "normal", delete e10.arg, t15.completion = e10;
  }
  function Context(t15) {
    this.tryEntries = [{ tryLoc: "root" }], t15.forEach(pushTryEntry, this), this.reset(true);
  }
  function values2(e10) {
    if (e10 || "" === e10) {
      var r23 = e10[a28];
      if (r23) return r23.call(e10);
      if ("function" == typeof e10.next) return e10;
      if (!isNaN(e10.length)) {
        var o21 = -1, i17 = function next2() {
          for (; ++o21 < e10.length; ) if (n17.call(e10, o21)) return next2.value = e10[o21], next2.done = false, next2;
          return next2.value = t14, next2.done = true, next2;
        };
        return i17.next = i17;
      }
    }
    throw new TypeError(_typeof(e10) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o20(g6, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o20(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u25, "GeneratorFunction"), e9.isGeneratorFunction = function(t15) {
    var e10 = "function" == typeof t15 && t15.constructor;
    return !!e10 && (e10 === GeneratorFunction || "GeneratorFunction" === (e10.displayName || e10.name));
  }, e9.mark = function(t15) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t15, GeneratorFunctionPrototype) : (t15.__proto__ = GeneratorFunctionPrototype, define(t15, u25, "GeneratorFunction")), t15.prototype = Object.create(g6), t15;
  }, e9.awrap = function(t15) {
    return { __await: t15 };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c21, function() {
    return this;
  }), e9.AsyncIterator = AsyncIterator, e9.async = function(t15, r23, n18, o21, i17) {
    void 0 === i17 && (i17 = Promise);
    var a29 = new AsyncIterator(wrap2(t15, r23, n18, o21), i17);
    return e9.isGeneratorFunction(r23) ? a29 : a29.next().then(function(t16) {
      return t16.done ? t16.value : a29.next();
    });
  }, defineIteratorMethods(g6), define(g6, u25, "Generator"), define(g6, a28, function() {
    return this;
  }), define(g6, "toString", function() {
    return "[object Generator]";
  }), e9.keys = function(t15) {
    var e10 = Object(t15), r23 = [];
    for (var n18 in e10) r23.push(n18);
    return r23.reverse(), function next2() {
      for (; r23.length; ) {
        var t16 = r23.pop();
        if (t16 in e10) return next2.value = t16, next2.done = false, next2;
      }
      return next2.done = true, next2;
    };
  }, e9.values = values2, Context.prototype = { constructor: Context, reset: function reset(e10) {
    if (this.prev = 0, this.next = 0, this.sent = this._sent = t14, this.done = false, this.delegate = null, this.method = "next", this.arg = t14, this.tryEntries.forEach(resetTryEntry), !e10) for (var r23 in this) "t" === r23.charAt(0) && n17.call(this, r23) && !isNaN(+r23.slice(1)) && (this[r23] = t14);
  }, stop: function stop() {
    this.done = true;
    var t15 = this.tryEntries[0].completion;
    if ("throw" === t15.type) throw t15.arg;
    return this.rval;
  }, dispatchException: function dispatchException(e10) {
    if (this.done) throw e10;
    var r23 = this;
    function handle2(n18, o22) {
      return a29.type = "throw", a29.arg = e10, r23.next = n18, o22 && (r23.method = "next", r23.arg = t14), !!o22;
    }
    for (var o21 = this.tryEntries.length - 1; o21 >= 0; --o21) {
      var i17 = this.tryEntries[o21], a29 = i17.completion;
      if ("root" === i17.tryLoc) return handle2("end");
      if (i17.tryLoc <= this.prev) {
        var c22 = n17.call(i17, "catchLoc"), u26 = n17.call(i17, "finallyLoc");
        if (c22 && u26) {
          if (this.prev < i17.catchLoc) return handle2(i17.catchLoc, true);
          if (this.prev < i17.finallyLoc) return handle2(i17.finallyLoc);
        } else if (c22) {
          if (this.prev < i17.catchLoc) return handle2(i17.catchLoc, true);
        } else {
          if (!u26) throw Error("try statement without catch or finally");
          if (this.prev < i17.finallyLoc) return handle2(i17.finallyLoc);
        }
      }
    }
  }, abrupt: function abrupt(t15, e10) {
    for (var r23 = this.tryEntries.length - 1; r23 >= 0; --r23) {
      var o21 = this.tryEntries[r23];
      if (o21.tryLoc <= this.prev && n17.call(o21, "finallyLoc") && this.prev < o21.finallyLoc) {
        var i17 = o21;
        break;
      }
    }
    i17 && ("break" === t15 || "continue" === t15) && i17.tryLoc <= e10 && e10 <= i17.finallyLoc && (i17 = null);
    var a29 = i17 ? i17.completion : {};
    return a29.type = t15, a29.arg = e10, i17 ? (this.method = "next", this.next = i17.finallyLoc, y10) : this.complete(a29);
  }, complete: function complete(t15, e10) {
    if ("throw" === t15.type) throw t15.arg;
    return "break" === t15.type || "continue" === t15.type ? this.next = t15.arg : "return" === t15.type ? (this.rval = this.arg = t15.arg, this.method = "return", this.next = "end") : "normal" === t15.type && e10 && (this.next = e10), y10;
  }, finish: function finish(t15) {
    for (var e10 = this.tryEntries.length - 1; e10 >= 0; --e10) {
      var r23 = this.tryEntries[e10];
      if (r23.finallyLoc === t15) return this.complete(r23.completion, r23.afterLoc), resetTryEntry(r23), y10;
    }
  }, "catch": function _catch(t15) {
    for (var e10 = this.tryEntries.length - 1; e10 >= 0; --e10) {
      var r23 = this.tryEntries[e10];
      if (r23.tryLoc === t15) {
        var n18 = r23.completion;
        if ("throw" === n18.type) {
          var o21 = n18.arg;
          resetTryEntry(r23);
        }
        return o21;
      }
    }
    throw Error("illegal catch attempt");
  }, delegateYield: function delegateYield(e10, r23, n18) {
    return this.delegate = { iterator: values2(e10), resultName: r23, nextLoc: n18 }, "next" === this.method && (this.arg = t14), y10;
  } }, e9;
}
function _callSuper(t14, o20, e9) {
  return o20 = _getPrototypeOf(o20), _possibleConstructorReturn(t14, _isNativeReflectConstruct() ? Reflect.construct(o20, e9 || [], _getPrototypeOf(t14).constructor) : o20.apply(t14, e9));
}
function _isNativeReflectConstruct() {
  try {
    var t14 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t15) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
    return !!t14;
  })();
}
var async_syntax_highlighter_default = function(options) {
  var _ReactAsyncHighlighter;
  var loader4 = options.loader, isLanguageRegistered3 = options.isLanguageRegistered, registerLanguage3 = options.registerLanguage, languageLoaders = options.languageLoaders, noAsyncLoadingLanguages = options.noAsyncLoadingLanguages;
  var ReactAsyncHighlighter = function(_React$PureComponent) {
    function ReactAsyncHighlighter2() {
      _classCallCheck(this, ReactAsyncHighlighter2);
      return _callSuper(this, ReactAsyncHighlighter2, arguments);
    }
    _inherits(ReactAsyncHighlighter2, _React$PureComponent);
    return _createClass(ReactAsyncHighlighter2, [{
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        if (!ReactAsyncHighlighter2.isRegistered(this.props.language) && languageLoaders) {
          this.loadLanguage();
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this = this;
        if (!ReactAsyncHighlighter2.astGeneratorPromise) {
          ReactAsyncHighlighter2.loadAstGenerator();
        }
        if (!ReactAsyncHighlighter2.astGenerator) {
          ReactAsyncHighlighter2.astGeneratorPromise.then(function() {
            _this.forceUpdate();
          });
        }
        if (!ReactAsyncHighlighter2.isRegistered(this.props.language) && languageLoaders) {
          this.loadLanguage();
        }
      }
    }, {
      key: "loadLanguage",
      value: function loadLanguage() {
        var _this2 = this;
        var language = this.props.language;
        if (language === "text") {
          return;
        }
        ReactAsyncHighlighter2.loadLanguage(language).then(function() {
          return _this2.forceUpdate();
        })["catch"](function() {
        });
      }
    }, {
      key: "normalizeLanguage",
      value: function normalizeLanguage(language) {
        return ReactAsyncHighlighter2.isSupportedLanguage(language) ? language : "text";
      }
    }, {
      key: "render",
      value: function render3() {
        return import_react147.default.createElement(ReactAsyncHighlighter2.highlightInstance, _extends2({}, this.props, {
          language: this.normalizeLanguage(this.props.language),
          astGenerator: ReactAsyncHighlighter2.astGenerator
        }));
      }
    }], [{
      key: "preload",
      value: function preload() {
        return ReactAsyncHighlighter2.loadAstGenerator();
      }
    }, {
      key: "loadLanguage",
      value: function() {
        var _loadLanguage = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(language) {
          var languageLoader;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                languageLoader = languageLoaders[language];
                if (!(typeof languageLoader === "function")) {
                  _context.next = 5;
                  break;
                }
                return _context.abrupt("return", languageLoader(ReactAsyncHighlighter2.registerLanguage));
              case 5:
                throw new Error("Language ".concat(language, " not supported"));
              case 6:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        function loadLanguage(_x) {
          return _loadLanguage.apply(this, arguments);
        }
        return loadLanguage;
      }()
    }, {
      key: "isSupportedLanguage",
      value: function isSupportedLanguage(language) {
        return ReactAsyncHighlighter2.isRegistered(language) || typeof languageLoaders[language] === "function";
      }
    }, {
      key: "loadAstGenerator",
      value: function loadAstGenerator() {
        ReactAsyncHighlighter2.astGeneratorPromise = loader4().then(function(astGenerator) {
          ReactAsyncHighlighter2.astGenerator = astGenerator;
          if (registerLanguage3) {
            ReactAsyncHighlighter2.languages.forEach(function(language, name2) {
              return registerLanguage3(astGenerator, name2, language);
            });
          }
        });
        return ReactAsyncHighlighter2.astGeneratorPromise;
      }
    }]);
  }(import_react147.default.PureComponent);
  _ReactAsyncHighlighter = ReactAsyncHighlighter;
  _defineProperty(ReactAsyncHighlighter, "astGenerator", null);
  _defineProperty(ReactAsyncHighlighter, "highlightInstance", highlight_default(null, {}));
  _defineProperty(ReactAsyncHighlighter, "astGeneratorPromise", null);
  _defineProperty(ReactAsyncHighlighter, "languages", /* @__PURE__ */ new Map());
  _defineProperty(ReactAsyncHighlighter, "supportedLanguages", options.supportedLanguages || Object.keys(languageLoaders || {}));
  _defineProperty(ReactAsyncHighlighter, "isRegistered", function(language) {
    if (noAsyncLoadingLanguages) {
      return true;
    }
    if (!registerLanguage3) {
      throw new Error("Current syntax highlighter doesn't support registration of languages");
    }
    if (!_ReactAsyncHighlighter.astGenerator) {
      return _ReactAsyncHighlighter.languages.has(language);
    }
    return isLanguageRegistered3(_ReactAsyncHighlighter.astGenerator, language);
  });
  _defineProperty(ReactAsyncHighlighter, "registerLanguage", function(name2, language) {
    if (!registerLanguage3) {
      throw new Error("Current syntax highlighter doesn't support registration of languages");
    }
    if (_ReactAsyncHighlighter.astGenerator) {
      return registerLanguage3(_ReactAsyncHighlighter.astGenerator, name2, language);
    } else {
      _ReactAsyncHighlighter.languages.set(name2, language);
    }
  });
  return ReactAsyncHighlighter;
};

// node_modules/react-syntax-highlighter/dist/esm/async-languages/create-language-async-loader.js
function _regeneratorRuntime2() {
  "use strict";
  _regeneratorRuntime2 = function _regeneratorRuntime3() {
    return e9;
  };
  var t14, e9 = {}, r22 = Object.prototype, n17 = r22.hasOwnProperty, o20 = Object.defineProperty || function(t15, e10, r23) {
    t15[e10] = r23.value;
  }, i16 = "function" == typeof Symbol ? Symbol : {}, a28 = i16.iterator || "@@iterator", c21 = i16.asyncIterator || "@@asyncIterator", u25 = i16.toStringTag || "@@toStringTag";
  function define(t15, e10, r23) {
    return Object.defineProperty(t15, e10, { value: r23, enumerable: true, configurable: true, writable: true }), t15[e10];
  }
  try {
    define({}, "");
  } catch (t15) {
    define = function define2(t16, e10, r23) {
      return t16[e10] = r23;
    };
  }
  function wrap2(t15, e10, r23, n18) {
    var i17 = e10 && e10.prototype instanceof Generator ? e10 : Generator, a29 = Object.create(i17.prototype), c22 = new Context(n18 || []);
    return o20(a29, "_invoke", { value: makeInvokeMethod(t15, r23, c22) }), a29;
  }
  function tryCatch(t15, e10, r23) {
    try {
      return { type: "normal", arg: t15.call(e10, r23) };
    } catch (t16) {
      return { type: "throw", arg: t16 };
    }
  }
  e9.wrap = wrap2;
  var h16 = "suspendedStart", l19 = "suspendedYield", f21 = "executing", s21 = "completed", y10 = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var p13 = {};
  define(p13, a28, function() {
    return this;
  });
  var d14 = Object.getPrototypeOf, v11 = d14 && d14(d14(values2([])));
  v11 && v11 !== r22 && n17.call(v11, a28) && (p13 = v11);
  var g6 = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p13);
  function defineIteratorMethods(t15) {
    ["next", "throw", "return"].forEach(function(e10) {
      define(t15, e10, function(t16) {
        return this._invoke(e10, t16);
      });
    });
  }
  function AsyncIterator(t15, e10) {
    function invoke(r24, o21, i17, a29) {
      var c22 = tryCatch(t15[r24], t15, o21);
      if ("throw" !== c22.type) {
        var u26 = c22.arg, h17 = u26.value;
        return h17 && "object" == _typeof(h17) && n17.call(h17, "__await") ? e10.resolve(h17.__await).then(function(t16) {
          invoke("next", t16, i17, a29);
        }, function(t16) {
          invoke("throw", t16, i17, a29);
        }) : e10.resolve(h17).then(function(t16) {
          u26.value = t16, i17(u26);
        }, function(t16) {
          return invoke("throw", t16, i17, a29);
        });
      }
      a29(c22.arg);
    }
    var r23;
    o20(this, "_invoke", { value: function value(t16, n18) {
      function callInvokeWithMethodAndArg() {
        return new e10(function(e11, r24) {
          invoke(t16, n18, e11, r24);
        });
      }
      return r23 = r23 ? r23.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } });
  }
  function makeInvokeMethod(e10, r23, n18) {
    var o21 = h16;
    return function(i17, a29) {
      if (o21 === f21) throw Error("Generator is already running");
      if (o21 === s21) {
        if ("throw" === i17) throw a29;
        return { value: t14, done: true };
      }
      for (n18.method = i17, n18.arg = a29; ; ) {
        var c22 = n18.delegate;
        if (c22) {
          var u26 = maybeInvokeDelegate(c22, n18);
          if (u26) {
            if (u26 === y10) continue;
            return u26;
          }
        }
        if ("next" === n18.method) n18.sent = n18._sent = n18.arg;
        else if ("throw" === n18.method) {
          if (o21 === h16) throw o21 = s21, n18.arg;
          n18.dispatchException(n18.arg);
        } else "return" === n18.method && n18.abrupt("return", n18.arg);
        o21 = f21;
        var p14 = tryCatch(e10, r23, n18);
        if ("normal" === p14.type) {
          if (o21 = n18.done ? s21 : l19, p14.arg === y10) continue;
          return { value: p14.arg, done: n18.done };
        }
        "throw" === p14.type && (o21 = s21, n18.method = "throw", n18.arg = p14.arg);
      }
    };
  }
  function maybeInvokeDelegate(e10, r23) {
    var n18 = r23.method, o21 = e10.iterator[n18];
    if (o21 === t14) return r23.delegate = null, "throw" === n18 && e10.iterator["return"] && (r23.method = "return", r23.arg = t14, maybeInvokeDelegate(e10, r23), "throw" === r23.method) || "return" !== n18 && (r23.method = "throw", r23.arg = new TypeError("The iterator does not provide a '" + n18 + "' method")), y10;
    var i17 = tryCatch(o21, e10.iterator, r23.arg);
    if ("throw" === i17.type) return r23.method = "throw", r23.arg = i17.arg, r23.delegate = null, y10;
    var a29 = i17.arg;
    return a29 ? a29.done ? (r23[e10.resultName] = a29.value, r23.next = e10.nextLoc, "return" !== r23.method && (r23.method = "next", r23.arg = t14), r23.delegate = null, y10) : a29 : (r23.method = "throw", r23.arg = new TypeError("iterator result is not an object"), r23.delegate = null, y10);
  }
  function pushTryEntry(t15) {
    var e10 = { tryLoc: t15[0] };
    1 in t15 && (e10.catchLoc = t15[1]), 2 in t15 && (e10.finallyLoc = t15[2], e10.afterLoc = t15[3]), this.tryEntries.push(e10);
  }
  function resetTryEntry(t15) {
    var e10 = t15.completion || {};
    e10.type = "normal", delete e10.arg, t15.completion = e10;
  }
  function Context(t15) {
    this.tryEntries = [{ tryLoc: "root" }], t15.forEach(pushTryEntry, this), this.reset(true);
  }
  function values2(e10) {
    if (e10 || "" === e10) {
      var r23 = e10[a28];
      if (r23) return r23.call(e10);
      if ("function" == typeof e10.next) return e10;
      if (!isNaN(e10.length)) {
        var o21 = -1, i17 = function next2() {
          for (; ++o21 < e10.length; ) if (n17.call(e10, o21)) return next2.value = e10[o21], next2.done = false, next2;
          return next2.value = t14, next2.done = true, next2;
        };
        return i17.next = i17;
      }
    }
    throw new TypeError(_typeof(e10) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o20(g6, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o20(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u25, "GeneratorFunction"), e9.isGeneratorFunction = function(t15) {
    var e10 = "function" == typeof t15 && t15.constructor;
    return !!e10 && (e10 === GeneratorFunction || "GeneratorFunction" === (e10.displayName || e10.name));
  }, e9.mark = function(t15) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t15, GeneratorFunctionPrototype) : (t15.__proto__ = GeneratorFunctionPrototype, define(t15, u25, "GeneratorFunction")), t15.prototype = Object.create(g6), t15;
  }, e9.awrap = function(t15) {
    return { __await: t15 };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c21, function() {
    return this;
  }), e9.AsyncIterator = AsyncIterator, e9.async = function(t15, r23, n18, o21, i17) {
    void 0 === i17 && (i17 = Promise);
    var a29 = new AsyncIterator(wrap2(t15, r23, n18, o21), i17);
    return e9.isGeneratorFunction(r23) ? a29 : a29.next().then(function(t16) {
      return t16.done ? t16.value : a29.next();
    });
  }, defineIteratorMethods(g6), define(g6, u25, "Generator"), define(g6, a28, function() {
    return this;
  }), define(g6, "toString", function() {
    return "[object Generator]";
  }), e9.keys = function(t15) {
    var e10 = Object(t15), r23 = [];
    for (var n18 in e10) r23.push(n18);
    return r23.reverse(), function next2() {
      for (; r23.length; ) {
        var t16 = r23.pop();
        if (t16 in e10) return next2.value = t16, next2.done = false, next2;
      }
      return next2.done = true, next2;
    };
  }, e9.values = values2, Context.prototype = { constructor: Context, reset: function reset(e10) {
    if (this.prev = 0, this.next = 0, this.sent = this._sent = t14, this.done = false, this.delegate = null, this.method = "next", this.arg = t14, this.tryEntries.forEach(resetTryEntry), !e10) for (var r23 in this) "t" === r23.charAt(0) && n17.call(this, r23) && !isNaN(+r23.slice(1)) && (this[r23] = t14);
  }, stop: function stop() {
    this.done = true;
    var t15 = this.tryEntries[0].completion;
    if ("throw" === t15.type) throw t15.arg;
    return this.rval;
  }, dispatchException: function dispatchException(e10) {
    if (this.done) throw e10;
    var r23 = this;
    function handle2(n18, o22) {
      return a29.type = "throw", a29.arg = e10, r23.next = n18, o22 && (r23.method = "next", r23.arg = t14), !!o22;
    }
    for (var o21 = this.tryEntries.length - 1; o21 >= 0; --o21) {
      var i17 = this.tryEntries[o21], a29 = i17.completion;
      if ("root" === i17.tryLoc) return handle2("end");
      if (i17.tryLoc <= this.prev) {
        var c22 = n17.call(i17, "catchLoc"), u26 = n17.call(i17, "finallyLoc");
        if (c22 && u26) {
          if (this.prev < i17.catchLoc) return handle2(i17.catchLoc, true);
          if (this.prev < i17.finallyLoc) return handle2(i17.finallyLoc);
        } else if (c22) {
          if (this.prev < i17.catchLoc) return handle2(i17.catchLoc, true);
        } else {
          if (!u26) throw Error("try statement without catch or finally");
          if (this.prev < i17.finallyLoc) return handle2(i17.finallyLoc);
        }
      }
    }
  }, abrupt: function abrupt(t15, e10) {
    for (var r23 = this.tryEntries.length - 1; r23 >= 0; --r23) {
      var o21 = this.tryEntries[r23];
      if (o21.tryLoc <= this.prev && n17.call(o21, "finallyLoc") && this.prev < o21.finallyLoc) {
        var i17 = o21;
        break;
      }
    }
    i17 && ("break" === t15 || "continue" === t15) && i17.tryLoc <= e10 && e10 <= i17.finallyLoc && (i17 = null);
    var a29 = i17 ? i17.completion : {};
    return a29.type = t15, a29.arg = e10, i17 ? (this.method = "next", this.next = i17.finallyLoc, y10) : this.complete(a29);
  }, complete: function complete(t15, e10) {
    if ("throw" === t15.type) throw t15.arg;
    return "break" === t15.type || "continue" === t15.type ? this.next = t15.arg : "return" === t15.type ? (this.rval = this.arg = t15.arg, this.method = "return", this.next = "end") : "normal" === t15.type && e10 && (this.next = e10), y10;
  }, finish: function finish(t15) {
    for (var e10 = this.tryEntries.length - 1; e10 >= 0; --e10) {
      var r23 = this.tryEntries[e10];
      if (r23.finallyLoc === t15) return this.complete(r23.completion, r23.afterLoc), resetTryEntry(r23), y10;
    }
  }, "catch": function _catch(t15) {
    for (var e10 = this.tryEntries.length - 1; e10 >= 0; --e10) {
      var r23 = this.tryEntries[e10];
      if (r23.tryLoc === t15) {
        var n18 = r23.completion;
        if ("throw" === n18.type) {
          var o21 = n18.arg;
          resetTryEntry(r23);
        }
        return o21;
      }
    }
    throw Error("illegal catch attempt");
  }, delegateYield: function delegateYield(e10, r23, n18) {
    return this.delegate = { iterator: values2(e10), resultName: r23, nextLoc: n18 }, "next" === this.method && (this.arg = t14), y10;
  } }, e9;
}
var create_language_async_loader_default = function(name2, loader4) {
  return function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime2().mark(function _callee(registerLanguage3) {
      var module;
      return _regeneratorRuntime2().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return loader4();
          case 2:
            module = _context.sent;
            registerLanguage3(name2, module["default"] || module);
          case 4:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function(_x) {
      return _ref.apply(this, arguments);
    };
  }();
};

// node_modules/react-syntax-highlighter/dist/esm/async-languages/hljs.js
var hljs_default = {
  oneC: create_language_async_loader_default("oneC", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_oneC" */
      "./1c-SAWRANV4.js"
    );
  }),
  abnf: create_language_async_loader_default("abnf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_abnf" */
      "./abnf-XMICKN3H.js"
    );
  }),
  accesslog: create_language_async_loader_default("accesslog", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_accesslog" */
      "./accesslog-V5Y2BMZX.js"
    );
  }),
  actionscript: create_language_async_loader_default("actionscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_actionscript" */
      "./actionscript-JG4BBLCB.js"
    );
  }),
  ada: create_language_async_loader_default("ada", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ada" */
      "./ada-TQUIR44V.js"
    );
  }),
  angelscript: create_language_async_loader_default("angelscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_angelscript" */
      "./angelscript-XFYRDGXS.js"
    );
  }),
  apache: create_language_async_loader_default("apache", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_apache" */
      "./apache-GPYF64BN.js"
    );
  }),
  applescript: create_language_async_loader_default("applescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_applescript" */
      "./applescript-2NM7ZJHK.js"
    );
  }),
  arcade: create_language_async_loader_default("arcade", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_arcade" */
      "./arcade-YR3CCUTP.js"
    );
  }),
  arduino: create_language_async_loader_default("arduino", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_arduino" */
      "./arduino-6C4CK5DS.js"
    );
  }),
  armasm: create_language_async_loader_default("armasm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_armasm" */
      "./armasm-U3GXKKVI.js"
    );
  }),
  asciidoc: create_language_async_loader_default("asciidoc", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_asciidoc" */
      "./asciidoc-EGDO4IPB.js"
    );
  }),
  aspectj: create_language_async_loader_default("aspectj", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_aspectj" */
      "./aspectj-WXWAZ5GX.js"
    );
  }),
  autohotkey: create_language_async_loader_default("autohotkey", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_autohotkey" */
      "./autohotkey-5JDPRDN7.js"
    );
  }),
  autoit: create_language_async_loader_default("autoit", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_autoit" */
      "./autoit-TFC6AXDX.js"
    );
  }),
  avrasm: create_language_async_loader_default("avrasm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_avrasm" */
      "./avrasm-WEYANIII.js"
    );
  }),
  awk: create_language_async_loader_default("awk", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_awk" */
      "./awk-ULCHHXC7.js"
    );
  }),
  axapta: create_language_async_loader_default("axapta", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_axapta" */
      "./axapta-7T5MINY5.js"
    );
  }),
  bash: create_language_async_loader_default("bash", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_bash" */
      "./bash-NVRI4DWN.js"
    );
  }),
  basic: create_language_async_loader_default("basic", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_basic" */
      "./basic-6SGOQMMC.js"
    );
  }),
  bnf: create_language_async_loader_default("bnf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_bnf" */
      "./bnf-26FNNQM4.js"
    );
  }),
  brainfuck: create_language_async_loader_default("brainfuck", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_brainfuck" */
      "./brainfuck-WRBGBAGB.js"
    );
  }),
  cLike: create_language_async_loader_default("cLike", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cLike" */
      "./c-like-4TWTV2MY.js"
    );
  }),
  c: create_language_async_loader_default("c", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_c" */
      "./c-NH6QWEQE.js"
    );
  }),
  cal: create_language_async_loader_default("cal", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cal" */
      "./cal-FL34GMA3.js"
    );
  }),
  capnproto: create_language_async_loader_default("capnproto", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_capnproto" */
      "./capnproto-QSND6G6R.js"
    );
  }),
  ceylon: create_language_async_loader_default("ceylon", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ceylon" */
      "./ceylon-623KOLB5.js"
    );
  }),
  clean: create_language_async_loader_default("clean", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_clean" */
      "./clean-GY7I7OKF.js"
    );
  }),
  clojureRepl: create_language_async_loader_default("clojureRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_clojureRepl" */
      "./clojure-repl-LZDMPBDL.js"
    );
  }),
  clojure: create_language_async_loader_default("clojure", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_clojure" */
      "./clojure-V37GZQBW.js"
    );
  }),
  cmake: create_language_async_loader_default("cmake", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cmake" */
      "./cmake-L6J5NO2T.js"
    );
  }),
  coffeescript: create_language_async_loader_default("coffeescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_coffeescript" */
      "./coffeescript-J7O3RDLH.js"
    );
  }),
  coq: create_language_async_loader_default("coq", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_coq" */
      "./coq-SPZYSOGW.js"
    );
  }),
  cos: create_language_async_loader_default("cos", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cos" */
      "./cos-LZBCLWDM.js"
    );
  }),
  cpp: create_language_async_loader_default("cpp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_cpp" */
      "./cpp-SCLMFF52.js"
    );
  }),
  crmsh: create_language_async_loader_default("crmsh", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_crmsh" */
      "./crmsh-5NHESQSB.js"
    );
  }),
  crystal: create_language_async_loader_default("crystal", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_crystal" */
      "./crystal-V6LY7RUS.js"
    );
  }),
  csharp: create_language_async_loader_default("csharp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_csharp" */
      "./csharp-MSHF4IDL.js"
    );
  }),
  csp: create_language_async_loader_default("csp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_csp" */
      "./csp-S6LFBOZI.js"
    );
  }),
  css: create_language_async_loader_default("css", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_css" */
      "./css-C45DQFYG.js"
    );
  }),
  d: create_language_async_loader_default("d", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_d" */
      "./d-MSZMMSNJ.js"
    );
  }),
  dart: create_language_async_loader_default("dart", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dart" */
      "./dart-X6EKZ5OO.js"
    );
  }),
  delphi: create_language_async_loader_default("delphi", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_delphi" */
      "./delphi-SYWRRORL.js"
    );
  }),
  diff: create_language_async_loader_default("diff", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_diff" */
      "./diff-R7FIPTFE.js"
    );
  }),
  django: create_language_async_loader_default("django", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_django" */
      "./django-FG2TSWSV.js"
    );
  }),
  dns: create_language_async_loader_default("dns", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dns" */
      "./dns-Z2ENMS4R.js"
    );
  }),
  dockerfile: create_language_async_loader_default("dockerfile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dockerfile" */
      "./dockerfile-7K22JI7A.js"
    );
  }),
  dos: create_language_async_loader_default("dos", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dos" */
      "./dos-2INPIJZZ.js"
    );
  }),
  dsconfig: create_language_async_loader_default("dsconfig", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dsconfig" */
      "./dsconfig-CLVQO7SU.js"
    );
  }),
  dts: create_language_async_loader_default("dts", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dts" */
      "./dts-NA3R3OTE.js"
    );
  }),
  dust: create_language_async_loader_default("dust", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_dust" */
      "./dust-D4LMO25Y.js"
    );
  }),
  ebnf: create_language_async_loader_default("ebnf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ebnf" */
      "./ebnf-7Y3TPQWI.js"
    );
  }),
  elixir: create_language_async_loader_default("elixir", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_elixir" */
      "./elixir-UKEA2DQK.js"
    );
  }),
  elm: create_language_async_loader_default("elm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_elm" */
      "./elm-LO5XU6WB.js"
    );
  }),
  erb: create_language_async_loader_default("erb", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_erb" */
      "./erb-URWNBDXF.js"
    );
  }),
  erlangRepl: create_language_async_loader_default("erlangRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_erlangRepl" */
      "./erlang-repl-LPYN2PUC.js"
    );
  }),
  erlang: create_language_async_loader_default("erlang", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_erlang" */
      "./erlang-PL6YOF5X.js"
    );
  }),
  excel: create_language_async_loader_default("excel", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_excel" */
      "./excel-7TCYVZQW.js"
    );
  }),
  fix: create_language_async_loader_default("fix", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_fix" */
      "./fix-EJPSGONK.js"
    );
  }),
  flix: create_language_async_loader_default("flix", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_flix" */
      "./flix-F37ETEAL.js"
    );
  }),
  fortran: create_language_async_loader_default("fortran", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_fortran" */
      "./fortran-F3FTRMAR.js"
    );
  }),
  fsharp: create_language_async_loader_default("fsharp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_fsharp" */
      "./fsharp-A7J7Q23Q.js"
    );
  }),
  gams: create_language_async_loader_default("gams", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gams" */
      "./gams-MYODLMRX.js"
    );
  }),
  gauss: create_language_async_loader_default("gauss", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gauss" */
      "./gauss-56T53HTE.js"
    );
  }),
  gcode: create_language_async_loader_default("gcode", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gcode" */
      "./gcode-VYCU4CMY.js"
    );
  }),
  gherkin: create_language_async_loader_default("gherkin", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gherkin" */
      "./gherkin-SWT7XUV3.js"
    );
  }),
  glsl: create_language_async_loader_default("glsl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_glsl" */
      "./glsl-ZTAC7F7K.js"
    );
  }),
  gml: create_language_async_loader_default("gml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gml" */
      "./gml-WFQBX4CO.js"
    );
  }),
  go: create_language_async_loader_default("go", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_go" */
      "./go-TQ6TKLHQ.js"
    );
  }),
  golo: create_language_async_loader_default("golo", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_golo" */
      "./golo-TAN26OL6.js"
    );
  }),
  gradle: create_language_async_loader_default("gradle", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_gradle" */
      "./gradle-SBVC3EIG.js"
    );
  }),
  groovy: create_language_async_loader_default("groovy", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_groovy" */
      "./groovy-NSU273CG.js"
    );
  }),
  haml: create_language_async_loader_default("haml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_haml" */
      "./haml-5DDHDNY5.js"
    );
  }),
  handlebars: create_language_async_loader_default("handlebars", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_handlebars" */
      "./handlebars-A6SHKFWN.js"
    );
  }),
  haskell: create_language_async_loader_default("haskell", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_haskell" */
      "./haskell-CJKIUV5S.js"
    );
  }),
  haxe: create_language_async_loader_default("haxe", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_haxe" */
      "./haxe-2NZKHW6D.js"
    );
  }),
  hsp: create_language_async_loader_default("hsp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_hsp" */
      "./hsp-VLRD7JFR.js"
    );
  }),
  htmlbars: create_language_async_loader_default("htmlbars", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_htmlbars" */
      "./htmlbars-TORBCRU7.js"
    );
  }),
  http: create_language_async_loader_default("http", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_http" */
      "./http-KSFIYATZ.js"
    );
  }),
  hy: create_language_async_loader_default("hy", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_hy" */
      "./hy-B7BJ6N32.js"
    );
  }),
  inform7: create_language_async_loader_default("inform7", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_inform7" */
      "./inform7-KZTHHZIB.js"
    );
  }),
  ini: create_language_async_loader_default("ini", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ini" */
      "./ini-YTTL2VGO.js"
    );
  }),
  irpf90: create_language_async_loader_default("irpf90", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_irpf90" */
      "./irpf90-ZLO5HHHG.js"
    );
  }),
  isbl: create_language_async_loader_default("isbl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_isbl" */
      "./isbl-MXTZUCIA.js"
    );
  }),
  java: create_language_async_loader_default("java", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_java" */
      "./java-MEKF5N7M.js"
    );
  }),
  javascript: create_language_async_loader_default("javascript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_javascript" */
      "./javascript-SGGAWTLV.js"
    );
  }),
  jbossCli: create_language_async_loader_default("jbossCli", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_jbossCli" */
      "./jboss-cli-UB65CLNF.js"
    );
  }),
  json: create_language_async_loader_default("json", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_json" */
      "./json-KYE5EFYQ.js"
    );
  }),
  juliaRepl: create_language_async_loader_default("juliaRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_juliaRepl" */
      "./julia-repl-G76ZEDTV.js"
    );
  }),
  julia: create_language_async_loader_default("julia", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_julia" */
      "./julia-CTCALQXY.js"
    );
  }),
  kotlin: create_language_async_loader_default("kotlin", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_kotlin" */
      "./kotlin-7RT46B7W.js"
    );
  }),
  lasso: create_language_async_loader_default("lasso", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_lasso" */
      "./lasso-HM7SN4DI.js"
    );
  }),
  latex: create_language_async_loader_default("latex", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_latex" */
      "./latex-CMARVNKC.js"
    );
  }),
  ldif: create_language_async_loader_default("ldif", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ldif" */
      "./ldif-7QTRIKP5.js"
    );
  }),
  leaf: create_language_async_loader_default("leaf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_leaf" */
      "./leaf-T67MACCY.js"
    );
  }),
  less: create_language_async_loader_default("less", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_less" */
      "./less-4RYQLDFW.js"
    );
  }),
  lisp: create_language_async_loader_default("lisp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_lisp" */
      "./lisp-QJOL6GSW.js"
    );
  }),
  livecodeserver: create_language_async_loader_default("livecodeserver", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_livecodeserver" */
      "./livecodeserver-6WE63EUP.js"
    );
  }),
  livescript: create_language_async_loader_default("livescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_livescript" */
      "./livescript-ZKY7TK32.js"
    );
  }),
  llvm: create_language_async_loader_default("llvm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_llvm" */
      "./llvm-WI7KROZI.js"
    );
  }),
  lsl: create_language_async_loader_default("lsl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_lsl" */
      "./lsl-L6ZE6UHZ.js"
    );
  }),
  lua: create_language_async_loader_default("lua", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_lua" */
      "./lua-N5X2HID5.js"
    );
  }),
  makefile: create_language_async_loader_default("makefile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_makefile" */
      "./makefile-JCTOCU7I.js"
    );
  }),
  markdown: create_language_async_loader_default("markdown", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_markdown" */
      "./markdown-6KEF45X5.js"
    );
  }),
  mathematica: create_language_async_loader_default("mathematica", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mathematica" */
      "./mathematica-LWB7GDBZ.js"
    );
  }),
  matlab: create_language_async_loader_default("matlab", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_matlab" */
      "./matlab-HXZFLM3R.js"
    );
  }),
  maxima: create_language_async_loader_default("maxima", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_maxima" */
      "./maxima-SFL4AATF.js"
    );
  }),
  mel: create_language_async_loader_default("mel", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mel" */
      "./mel-NJ436MH3.js"
    );
  }),
  mercury: create_language_async_loader_default("mercury", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mercury" */
      "./mercury-2KAPPUUK.js"
    );
  }),
  mipsasm: create_language_async_loader_default("mipsasm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mipsasm" */
      "./mipsasm-3ZAYURVX.js"
    );
  }),
  mizar: create_language_async_loader_default("mizar", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mizar" */
      "./mizar-DMBSQVX4.js"
    );
  }),
  mojolicious: create_language_async_loader_default("mojolicious", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_mojolicious" */
      "./mojolicious-EGBUGHQB.js"
    );
  }),
  monkey: create_language_async_loader_default("monkey", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_monkey" */
      "./monkey-N6UUG23V.js"
    );
  }),
  moonscript: create_language_async_loader_default("moonscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_moonscript" */
      "./moonscript-AJ2OYBLB.js"
    );
  }),
  n1ql: create_language_async_loader_default("n1ql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_n1ql" */
      "./n1ql-MTZ2PQRN.js"
    );
  }),
  nginx: create_language_async_loader_default("nginx", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nginx" */
      "./nginx-7VD4JBIU.js"
    );
  }),
  nim: create_language_async_loader_default("nim", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nim" */
      "./nim-5KGF2EL3.js"
    );
  }),
  nix: create_language_async_loader_default("nix", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nix" */
      "./nix-TV7DKP4G.js"
    );
  }),
  nodeRepl: create_language_async_loader_default("nodeRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nodeRepl" */
      "./node-repl-L7ASW2CZ.js"
    );
  }),
  nsis: create_language_async_loader_default("nsis", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_nsis" */
      "./nsis-NXFMSHH5.js"
    );
  }),
  objectivec: create_language_async_loader_default("objectivec", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_objectivec" */
      "./objectivec-4CKUYSEJ.js"
    );
  }),
  ocaml: create_language_async_loader_default("ocaml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ocaml" */
      "./ocaml-DTSL2U4T.js"
    );
  }),
  openscad: create_language_async_loader_default("openscad", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_openscad" */
      "./openscad-4NNBDDBI.js"
    );
  }),
  oxygene: create_language_async_loader_default("oxygene", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_oxygene" */
      "./oxygene-POPOY4U7.js"
    );
  }),
  parser3: create_language_async_loader_default("parser3", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_parser3" */
      "./parser3-624HSBZ3.js"
    );
  }),
  perl: create_language_async_loader_default("perl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_perl" */
      "./perl-EWJXO5OR.js"
    );
  }),
  pf: create_language_async_loader_default("pf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_pf" */
      "./pf-TXGBFKUG.js"
    );
  }),
  pgsql: create_language_async_loader_default("pgsql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_pgsql" */
      "./pgsql-MGJHEKCV.js"
    );
  }),
  phpTemplate: create_language_async_loader_default("phpTemplate", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_phpTemplate" */
      "./php-template-S4MIBKZP.js"
    );
  }),
  php: create_language_async_loader_default("php", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_php" */
      "./php-QOKXNEKF.js"
    );
  }),
  plaintext: create_language_async_loader_default("plaintext", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_plaintext" */
      "./plaintext-AEKVBP2C.js"
    );
  }),
  pony: create_language_async_loader_default("pony", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_pony" */
      "./pony-D4XOXXMV.js"
    );
  }),
  powershell: create_language_async_loader_default("powershell", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_powershell" */
      "./powershell-7HTX5KG3.js"
    );
  }),
  processing: create_language_async_loader_default("processing", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_processing" */
      "./processing-ZG46FG2R.js"
    );
  }),
  profile: create_language_async_loader_default("profile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_profile" */
      "./profile-S43E6KHY.js"
    );
  }),
  prolog: create_language_async_loader_default("prolog", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_prolog" */
      "./prolog-ZIBJTPIE.js"
    );
  }),
  properties: create_language_async_loader_default("properties", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_properties" */
      "./properties-AFEPOYEF.js"
    );
  }),
  protobuf: create_language_async_loader_default("protobuf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_protobuf" */
      "./protobuf-RKVP2EIC.js"
    );
  }),
  puppet: create_language_async_loader_default("puppet", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_puppet" */
      "./puppet-AVPR4XQY.js"
    );
  }),
  purebasic: create_language_async_loader_default("purebasic", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_purebasic" */
      "./purebasic-AL7K6ZOX.js"
    );
  }),
  pythonRepl: create_language_async_loader_default("pythonRepl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_pythonRepl" */
      "./python-repl-LAGVYDBY.js"
    );
  }),
  python: create_language_async_loader_default("python", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_python" */
      "./python-ILBIJD5L.js"
    );
  }),
  q: create_language_async_loader_default("q", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_q" */
      "./q-ZG7ZKDR2.js"
    );
  }),
  qml: create_language_async_loader_default("qml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_qml" */
      "./qml-NH2IPRP2.js"
    );
  }),
  r: create_language_async_loader_default("r", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_r" */
      "./r-Y63Q6XHS.js"
    );
  }),
  reasonml: create_language_async_loader_default("reasonml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_reasonml" */
      "./reasonml-JGFI4XJZ.js"
    );
  }),
  rib: create_language_async_loader_default("rib", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_rib" */
      "./rib-2CPN5QUY.js"
    );
  }),
  roboconf: create_language_async_loader_default("roboconf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_roboconf" */
      "./roboconf-PDDQFTWH.js"
    );
  }),
  routeros: create_language_async_loader_default("routeros", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_routeros" */
      "./routeros-FC56LLEV.js"
    );
  }),
  rsl: create_language_async_loader_default("rsl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_rsl" */
      "./rsl-I66NDXGT.js"
    );
  }),
  ruby: create_language_async_loader_default("ruby", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ruby" */
      "./ruby-IJCI6W4H.js"
    );
  }),
  ruleslanguage: create_language_async_loader_default("ruleslanguage", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_ruleslanguage" */
      "./ruleslanguage-M6GXUOOD.js"
    );
  }),
  rust: create_language_async_loader_default("rust", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_rust" */
      "./rust-2NP6KAK5.js"
    );
  }),
  sas: create_language_async_loader_default("sas", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sas" */
      "./sas-63CYBKOX.js"
    );
  }),
  scala: create_language_async_loader_default("scala", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_scala" */
      "./scala-PGMYP7QC.js"
    );
  }),
  scheme: create_language_async_loader_default("scheme", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_scheme" */
      "./scheme-PLJLWCHH.js"
    );
  }),
  scilab: create_language_async_loader_default("scilab", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_scilab" */
      "./scilab-CN6W5ZQW.js"
    );
  }),
  scss: create_language_async_loader_default("scss", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_scss" */
      "./scss-A7BLE7MD.js"
    );
  }),
  shell: create_language_async_loader_default("shell", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_shell" */
      "./shell-XBRB7CNB.js"
    );
  }),
  smali: create_language_async_loader_default("smali", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_smali" */
      "./smali-FBES5VMH.js"
    );
  }),
  smalltalk: create_language_async_loader_default("smalltalk", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_smalltalk" */
      "./smalltalk-KKGJWPPF.js"
    );
  }),
  sml: create_language_async_loader_default("sml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sml" */
      "./sml-SULLOU6H.js"
    );
  }),
  sqf: create_language_async_loader_default("sqf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sqf" */
      "./sqf-4OUCNRDS.js"
    );
  }),
  sql: create_language_async_loader_default("sql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sql" */
      "./sql-EQYXXQAX.js"
    );
  }),
  sqlMore: create_language_async_loader_default("sqlMore", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_sqlMore" */
      "./sql_more-3P3PILSP.js"
    );
  }),
  stan: create_language_async_loader_default("stan", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_stan" */
      "./stan-V7BMJA53.js"
    );
  }),
  stata: create_language_async_loader_default("stata", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_stata" */
      "./stata-2LA37RL3.js"
    );
  }),
  step21: create_language_async_loader_default("step21", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_step21" */
      "./step21-Y3HW2BTO.js"
    );
  }),
  stylus: create_language_async_loader_default("stylus", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_stylus" */
      "./stylus-Z5KBLWFM.js"
    );
  }),
  subunit: create_language_async_loader_default("subunit", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_subunit" */
      "./subunit-VX4YHER3.js"
    );
  }),
  swift: create_language_async_loader_default("swift", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_swift" */
      "./swift-DAMHPZTG.js"
    );
  }),
  taggerscript: create_language_async_loader_default("taggerscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_taggerscript" */
      "./taggerscript-OZVYJ5Z5.js"
    );
  }),
  tap: create_language_async_loader_default("tap", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_tap" */
      "./tap-HWPHC5RH.js"
    );
  }),
  tcl: create_language_async_loader_default("tcl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_tcl" */
      "./tcl-R4PYWWIS.js"
    );
  }),
  thrift: create_language_async_loader_default("thrift", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_thrift" */
      "./thrift-QWLSCNM2.js"
    );
  }),
  tp: create_language_async_loader_default("tp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_tp" */
      "./tp-RG5VCNF2.js"
    );
  }),
  twig: create_language_async_loader_default("twig", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_twig" */
      "./twig-LSFNQD3P.js"
    );
  }),
  typescript: create_language_async_loader_default("typescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_typescript" */
      "./typescript-AKUJ3MFD.js"
    );
  }),
  vala: create_language_async_loader_default("vala", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vala" */
      "./vala-5K4OJBGG.js"
    );
  }),
  vbnet: create_language_async_loader_default("vbnet", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vbnet" */
      "./vbnet-L7XXQDOG.js"
    );
  }),
  vbscriptHtml: create_language_async_loader_default("vbscriptHtml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vbscriptHtml" */
      "./vbscript-html-BCZWBMNX.js"
    );
  }),
  vbscript: create_language_async_loader_default("vbscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vbscript" */
      "./vbscript-GBHCDVBM.js"
    );
  }),
  verilog: create_language_async_loader_default("verilog", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_verilog" */
      "./verilog-DYHCYED7.js"
    );
  }),
  vhdl: create_language_async_loader_default("vhdl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vhdl" */
      "./vhdl-MRSVBZRF.js"
    );
  }),
  vim: create_language_async_loader_default("vim", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_vim" */
      "./vim-QIWJLHQX.js"
    );
  }),
  x86asm: create_language_async_loader_default("x86asm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_x86asm" */
      "./x86asm-TSIEMVMA.js"
    );
  }),
  xl: create_language_async_loader_default("xl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_xl" */
      "./xl-S7CQ4XRX.js"
    );
  }),
  xml: create_language_async_loader_default("xml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_xml" */
      "./xml-UJEJIFZZ.js"
    );
  }),
  xquery: create_language_async_loader_default("xquery", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_xquery" */
      "./xquery-GCDJT4QM.js"
    );
  }),
  yaml: create_language_async_loader_default("yaml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_yaml" */
      "./yaml-B7YFJ4UX.js"
    );
  }),
  zephir: create_language_async_loader_default("zephir", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_highlight_zephir" */
      "./zephir-MIA2YJFA.js"
    );
  })
};

// node_modules/react-syntax-highlighter/dist/esm/light-async.js
var light_async_default = async_syntax_highlighter_default({
  loader: function loader() {
    return import(
      /* webpackChunkName:"react-syntax-highlighter/lowlight-import" */
      "./core-HML4NUMJ.js"
    ).then(function(module) {
      return module["default"] || module;
    });
  },
  isLanguageRegistered: function isLanguageRegistered(instance, language) {
    return !!checkForListedLanguage_default(instance, language);
  },
  languageLoaders: hljs_default,
  registerLanguage: function registerLanguage(instance, name2, language) {
    return instance.registerLanguage(name2, language);
  }
});

// node_modules/react-syntax-highlighter/dist/esm/light.js
var import_core2 = __toESM(require_core());
var SyntaxHighlighter = highlight_default(import_core2.default, {});
SyntaxHighlighter.registerLanguage = import_core2.default.registerLanguage;
var light_default = SyntaxHighlighter;

// node_modules/react-syntax-highlighter/dist/esm/async-languages/prism.js
var prism_default = {
  abap: create_language_async_loader_default("abap", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_abap" */
      "./abap-WNYZWDTG.js"
    );
  }),
  abnf: create_language_async_loader_default("abnf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_abnf" */
      "./abnf-ZC36ITC3.js"
    );
  }),
  actionscript: create_language_async_loader_default("actionscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_actionscript" */
      "./actionscript-MJVA6IQ2.js"
    );
  }),
  ada: create_language_async_loader_default("ada", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_ada" */
      "./ada-F7YYTBZF.js"
    );
  }),
  agda: create_language_async_loader_default("agda", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_agda" */
      "./agda-ECIL2JNR.js"
    );
  }),
  al: create_language_async_loader_default("al", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_al" */
      "./al-JOQMEYMU.js"
    );
  }),
  antlr4: create_language_async_loader_default("antlr4", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_antlr4" */
      "./antlr4-3RK6OZKK.js"
    );
  }),
  apacheconf: create_language_async_loader_default("apacheconf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_apacheconf" */
      "./apacheconf-NXFUHMZG.js"
    );
  }),
  apex: create_language_async_loader_default("apex", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_apex" */
      "./apex-GBAVZXRK.js"
    );
  }),
  apl: create_language_async_loader_default("apl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_apl" */
      "./apl-KFDK7CJR.js"
    );
  }),
  applescript: create_language_async_loader_default("applescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_applescript" */
      "./applescript-SNHPMAKT.js"
    );
  }),
  aql: create_language_async_loader_default("aql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_aql" */
      "./aql-2EPJQTZS.js"
    );
  }),
  arduino: create_language_async_loader_default("arduino", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_arduino" */
      "./arduino-RI7DHVRU.js"
    );
  }),
  arff: create_language_async_loader_default("arff", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_arff" */
      "./arff-JMILTANM.js"
    );
  }),
  asciidoc: create_language_async_loader_default("asciidoc", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_asciidoc" */
      "./asciidoc-UU5FR4Q3.js"
    );
  }),
  asm6502: create_language_async_loader_default("asm6502", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_asm6502" */
      "./asm6502-PP7GCXTD.js"
    );
  }),
  asmatmel: create_language_async_loader_default("asmatmel", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_asmatmel" */
      "./asmatmel-GZMZKSE7.js"
    );
  }),
  aspnet: create_language_async_loader_default("aspnet", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_aspnet" */
      "./aspnet-EK6DTADZ.js"
    );
  }),
  autohotkey: create_language_async_loader_default("autohotkey", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_autohotkey" */
      "./autohotkey-BUCQ2LTC.js"
    );
  }),
  autoit: create_language_async_loader_default("autoit", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_autoit" */
      "./autoit-G63XNWW7.js"
    );
  }),
  avisynth: create_language_async_loader_default("avisynth", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_avisynth" */
      "./avisynth-HDSK5HHK.js"
    );
  }),
  avroIdl: create_language_async_loader_default("avroIdl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_avroIdl" */
      "./avro-idl-764E2QU5.js"
    );
  }),
  bash: create_language_async_loader_default("bash", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_bash" */
      "./bash-B56TSSOM.js"
    );
  }),
  basic: create_language_async_loader_default("basic", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_basic" */
      "./basic-IBKYVQEQ.js"
    );
  }),
  batch: create_language_async_loader_default("batch", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_batch" */
      "./batch-VPMECY5A.js"
    );
  }),
  bbcode: create_language_async_loader_default("bbcode", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_bbcode" */
      "./bbcode-5YSWQS6Q.js"
    );
  }),
  bicep: create_language_async_loader_default("bicep", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_bicep" */
      "./bicep-4LDKX7E5.js"
    );
  }),
  birb: create_language_async_loader_default("birb", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_birb" */
      "./birb-4TU3BOSE.js"
    );
  }),
  bison: create_language_async_loader_default("bison", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_bison" */
      "./bison-37ZIP7I4.js"
    );
  }),
  bnf: create_language_async_loader_default("bnf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_bnf" */
      "./bnf-6DV4FOGL.js"
    );
  }),
  brainfuck: create_language_async_loader_default("brainfuck", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_brainfuck" */
      "./brainfuck-MXDFUXQF.js"
    );
  }),
  brightscript: create_language_async_loader_default("brightscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_brightscript" */
      "./brightscript-WT6WUC3D.js"
    );
  }),
  bro: create_language_async_loader_default("bro", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_bro" */
      "./bro-ZEU4Z7TS.js"
    );
  }),
  bsl: create_language_async_loader_default("bsl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_bsl" */
      "./bsl-ASXWOIYH.js"
    );
  }),
  c: create_language_async_loader_default("c", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_c" */
      "./c-YZCZ3HCZ.js"
    );
  }),
  cfscript: create_language_async_loader_default("cfscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_cfscript" */
      "./cfscript-HDNMB2FO.js"
    );
  }),
  chaiscript: create_language_async_loader_default("chaiscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_chaiscript" */
      "./chaiscript-44G52GN7.js"
    );
  }),
  cil: create_language_async_loader_default("cil", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_cil" */
      "./cil-GDRRPSHV.js"
    );
  }),
  clike: create_language_async_loader_default("clike", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_clike" */
      "./clike-FUXLNUIO.js"
    );
  }),
  clojure: create_language_async_loader_default("clojure", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_clojure" */
      "./clojure-N5IITXAG.js"
    );
  }),
  cmake: create_language_async_loader_default("cmake", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_cmake" */
      "./cmake-NC42FI5B.js"
    );
  }),
  cobol: create_language_async_loader_default("cobol", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_cobol" */
      "./cobol-BMYPCQ72.js"
    );
  }),
  coffeescript: create_language_async_loader_default("coffeescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_coffeescript" */
      "./coffeescript-LP4YWKKO.js"
    );
  }),
  concurnas: create_language_async_loader_default("concurnas", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_concurnas" */
      "./concurnas-DKCXULGH.js"
    );
  }),
  coq: create_language_async_loader_default("coq", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_coq" */
      "./coq-EVW5IRWH.js"
    );
  }),
  cpp: create_language_async_loader_default("cpp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_cpp" */
      "./cpp-KMA4MFUU.js"
    );
  }),
  crystal: create_language_async_loader_default("crystal", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_crystal" */
      "./crystal-3JMFFUON.js"
    );
  }),
  csharp: create_language_async_loader_default("csharp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_csharp" */
      "./csharp-BDYJ7ZPY.js"
    );
  }),
  cshtml: create_language_async_loader_default("cshtml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_cshtml" */
      "./cshtml-YSHLH5FN.js"
    );
  }),
  csp: create_language_async_loader_default("csp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_csp" */
      "./csp-3HFBFJQM.js"
    );
  }),
  cssExtras: create_language_async_loader_default("cssExtras", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_cssExtras" */
      "./css-extras-63QFDMVO.js"
    );
  }),
  css: create_language_async_loader_default("css", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_css" */
      "./css-OTXF5KZX.js"
    );
  }),
  csv: create_language_async_loader_default("csv", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_csv" */
      "./csv-57L5SRK6.js"
    );
  }),
  cypher: create_language_async_loader_default("cypher", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_cypher" */
      "./cypher-Q4WHYINL.js"
    );
  }),
  d: create_language_async_loader_default("d", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_d" */
      "./d-74NEISNG.js"
    );
  }),
  dart: create_language_async_loader_default("dart", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_dart" */
      "./dart-H6WMIOJR.js"
    );
  }),
  dataweave: create_language_async_loader_default("dataweave", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_dataweave" */
      "./dataweave-TME2UYLD.js"
    );
  }),
  dax: create_language_async_loader_default("dax", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_dax" */
      "./dax-TUIDKDS2.js"
    );
  }),
  dhall: create_language_async_loader_default("dhall", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_dhall" */
      "./dhall-G4LO3B6N.js"
    );
  }),
  diff: create_language_async_loader_default("diff", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_diff" */
      "./diff-DQSBIABC.js"
    );
  }),
  django: create_language_async_loader_default("django", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_django" */
      "./django-LW2U4I7S.js"
    );
  }),
  dnsZoneFile: create_language_async_loader_default("dnsZoneFile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_dnsZoneFile" */
      "./dns-zone-file-AXIUOUME.js"
    );
  }),
  docker: create_language_async_loader_default("docker", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_docker" */
      "./docker-JC5VYLF3.js"
    );
  }),
  dot: create_language_async_loader_default("dot", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_dot" */
      "./dot-MK2YW2KU.js"
    );
  }),
  ebnf: create_language_async_loader_default("ebnf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_ebnf" */
      "./ebnf-VCAAOG5F.js"
    );
  }),
  editorconfig: create_language_async_loader_default("editorconfig", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_editorconfig" */
      "./editorconfig-AFEKZN24.js"
    );
  }),
  eiffel: create_language_async_loader_default("eiffel", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_eiffel" */
      "./eiffel-3LAHXQ5Q.js"
    );
  }),
  ejs: create_language_async_loader_default("ejs", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_ejs" */
      "./ejs-DZ3R4UE5.js"
    );
  }),
  elixir: create_language_async_loader_default("elixir", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_elixir" */
      "./elixir-47NVCCXZ.js"
    );
  }),
  elm: create_language_async_loader_default("elm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_elm" */
      "./elm-UAYINSJ4.js"
    );
  }),
  erb: create_language_async_loader_default("erb", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_erb" */
      "./erb-L2Y7XDHM.js"
    );
  }),
  erlang: create_language_async_loader_default("erlang", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_erlang" */
      "./erlang-UFXD6JXW.js"
    );
  }),
  etlua: create_language_async_loader_default("etlua", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_etlua" */
      "./etlua-OU373ZJO.js"
    );
  }),
  excelFormula: create_language_async_loader_default("excelFormula", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_excelFormula" */
      "./excel-formula-FZ5ZSBDQ.js"
    );
  }),
  factor: create_language_async_loader_default("factor", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_factor" */
      "./factor-6ES25MVY.js"
    );
  }),
  falselang: create_language_async_loader_default("falselang", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_falselang" */
      "./false-QGUMGMXH.js"
    );
  }),
  firestoreSecurityRules: create_language_async_loader_default("firestoreSecurityRules", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_firestoreSecurityRules" */
      "./firestore-security-rules-WRGUUYLB.js"
    );
  }),
  flow: create_language_async_loader_default("flow", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_flow" */
      "./flow-ASOCVKJ3.js"
    );
  }),
  fortran: create_language_async_loader_default("fortran", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_fortran" */
      "./fortran-3C2CQWVY.js"
    );
  }),
  fsharp: create_language_async_loader_default("fsharp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_fsharp" */
      "./fsharp-632TEITU.js"
    );
  }),
  ftl: create_language_async_loader_default("ftl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_ftl" */
      "./ftl-36AUFLAH.js"
    );
  }),
  gap: create_language_async_loader_default("gap", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_gap" */
      "./gap-J6DJND6L.js"
    );
  }),
  gcode: create_language_async_loader_default("gcode", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_gcode" */
      "./gcode-WV572MVG.js"
    );
  }),
  gdscript: create_language_async_loader_default("gdscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_gdscript" */
      "./gdscript-WBOL4GWG.js"
    );
  }),
  gedcom: create_language_async_loader_default("gedcom", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_gedcom" */
      "./gedcom-V4QQP2EW.js"
    );
  }),
  gherkin: create_language_async_loader_default("gherkin", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_gherkin" */
      "./gherkin-NUZYUJBM.js"
    );
  }),
  git: create_language_async_loader_default("git", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_git" */
      "./git-2TYPPD75.js"
    );
  }),
  glsl: create_language_async_loader_default("glsl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_glsl" */
      "./glsl-O3UJ56GM.js"
    );
  }),
  gml: create_language_async_loader_default("gml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_gml" */
      "./gml-YWKT2YL5.js"
    );
  }),
  gn: create_language_async_loader_default("gn", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_gn" */
      "./gn-JEI5KARX.js"
    );
  }),
  goModule: create_language_async_loader_default("goModule", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_goModule" */
      "./go-module-JBSBGB26.js"
    );
  }),
  go: create_language_async_loader_default("go", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_go" */
      "./go-YAADQLQP.js"
    );
  }),
  graphql: create_language_async_loader_default("graphql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_graphql" */
      "./graphql-3BPEZZ42.js"
    );
  }),
  groovy: create_language_async_loader_default("groovy", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_groovy" */
      "./groovy-E2ZFRHQT.js"
    );
  }),
  haml: create_language_async_loader_default("haml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_haml" */
      "./haml-LIYW55EF.js"
    );
  }),
  handlebars: create_language_async_loader_default("handlebars", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_handlebars" */
      "./handlebars-WYCUY2E2.js"
    );
  }),
  haskell: create_language_async_loader_default("haskell", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_haskell" */
      "./haskell-6FRQO225.js"
    );
  }),
  haxe: create_language_async_loader_default("haxe", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_haxe" */
      "./haxe-Q2BG57UL.js"
    );
  }),
  hcl: create_language_async_loader_default("hcl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_hcl" */
      "./hcl-JPWJJF4E.js"
    );
  }),
  hlsl: create_language_async_loader_default("hlsl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_hlsl" */
      "./hlsl-JPE5334L.js"
    );
  }),
  hoon: create_language_async_loader_default("hoon", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_hoon" */
      "./hoon-SKHSBWI5.js"
    );
  }),
  hpkp: create_language_async_loader_default("hpkp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_hpkp" */
      "./hpkp-RADWMJRD.js"
    );
  }),
  hsts: create_language_async_loader_default("hsts", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_hsts" */
      "./hsts-3COOTQKM.js"
    );
  }),
  http: create_language_async_loader_default("http", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_http" */
      "./http-CYUFBMQ4.js"
    );
  }),
  ichigojam: create_language_async_loader_default("ichigojam", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_ichigojam" */
      "./ichigojam-YOMIHH3Y.js"
    );
  }),
  icon: create_language_async_loader_default("icon", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_icon" */
      "./icon-YYIQPTXY.js"
    );
  }),
  icuMessageFormat: create_language_async_loader_default("icuMessageFormat", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_icuMessageFormat" */
      "./icu-message-format-OCFKGP53.js"
    );
  }),
  idris: create_language_async_loader_default("idris", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_idris" */
      "./idris-MBO5GQPJ.js"
    );
  }),
  iecst: create_language_async_loader_default("iecst", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_iecst" */
      "./iecst-SKXAWZJB.js"
    );
  }),
  ignore: create_language_async_loader_default("ignore", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_ignore" */
      "./ignore-NL4ODE7T.js"
    );
  }),
  inform7: create_language_async_loader_default("inform7", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_inform7" */
      "./inform7-FMYBX5TB.js"
    );
  }),
  ini: create_language_async_loader_default("ini", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_ini" */
      "./ini-QGRT4TYP.js"
    );
  }),
  io: create_language_async_loader_default("io", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_io" */
      "./io-5CWW24CP.js"
    );
  }),
  j: create_language_async_loader_default("j", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_j" */
      "./j-2RJIR36G.js"
    );
  }),
  java: create_language_async_loader_default("java", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_java" */
      "./java-2ONJNJ6D.js"
    );
  }),
  javadoc: create_language_async_loader_default("javadoc", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_javadoc" */
      "./javadoc-3CE4SW3R.js"
    );
  }),
  javadoclike: create_language_async_loader_default("javadoclike", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_javadoclike" */
      "./javadoclike-75EQ2YL6.js"
    );
  }),
  javascript: create_language_async_loader_default("javascript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_javascript" */
      "./javascript-Q372AW2K.js"
    );
  }),
  javastacktrace: create_language_async_loader_default("javastacktrace", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_javastacktrace" */
      "./javastacktrace-IBXG72UK.js"
    );
  }),
  jexl: create_language_async_loader_default("jexl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_jexl" */
      "./jexl-CMHMVWRY.js"
    );
  }),
  jolie: create_language_async_loader_default("jolie", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_jolie" */
      "./jolie-DN7C6EAO.js"
    );
  }),
  jq: create_language_async_loader_default("jq", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_jq" */
      "./jq-GSTK2SWV.js"
    );
  }),
  jsExtras: create_language_async_loader_default("jsExtras", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_jsExtras" */
      "./js-extras-54CTZ4KO.js"
    );
  }),
  jsTemplates: create_language_async_loader_default("jsTemplates", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_jsTemplates" */
      "./js-templates-KN663CA3.js"
    );
  }),
  jsdoc: create_language_async_loader_default("jsdoc", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_jsdoc" */
      "./jsdoc-FMSAAJLI.js"
    );
  }),
  json: create_language_async_loader_default("json", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_json" */
      "./json-26HRQ3MF.js"
    );
  }),
  json5: create_language_async_loader_default("json5", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_json5" */
      "./json5-GCMXPVLK.js"
    );
  }),
  jsonp: create_language_async_loader_default("jsonp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_jsonp" */
      "./jsonp-T2WY7DTC.js"
    );
  }),
  jsstacktrace: create_language_async_loader_default("jsstacktrace", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_jsstacktrace" */
      "./jsstacktrace-7XO36T7Z.js"
    );
  }),
  jsx: create_language_async_loader_default("jsx", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_jsx" */
      "./jsx-EG6WRDTI.js"
    );
  }),
  julia: create_language_async_loader_default("julia", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_julia" */
      "./julia-DTIYNM2H.js"
    );
  }),
  keepalived: create_language_async_loader_default("keepalived", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_keepalived" */
      "./keepalived-Y6W54FR3.js"
    );
  }),
  keyman: create_language_async_loader_default("keyman", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_keyman" */
      "./keyman-O3OI55IV.js"
    );
  }),
  kotlin: create_language_async_loader_default("kotlin", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_kotlin" */
      "./kotlin-MMCBVBRG.js"
    );
  }),
  kumir: create_language_async_loader_default("kumir", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_kumir" */
      "./kumir-LPSXINP5.js"
    );
  }),
  kusto: create_language_async_loader_default("kusto", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_kusto" */
      "./kusto-BENYYJSW.js"
    );
  }),
  latex: create_language_async_loader_default("latex", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_latex" */
      "./latex-LQBDGSB2.js"
    );
  }),
  latte: create_language_async_loader_default("latte", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_latte" */
      "./latte-Q34BBUIW.js"
    );
  }),
  less: create_language_async_loader_default("less", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_less" */
      "./less-DQOFAJXO.js"
    );
  }),
  lilypond: create_language_async_loader_default("lilypond", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_lilypond" */
      "./lilypond-5BTX6P4Y.js"
    );
  }),
  liquid: create_language_async_loader_default("liquid", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_liquid" */
      "./liquid-L3ATM6JT.js"
    );
  }),
  lisp: create_language_async_loader_default("lisp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_lisp" */
      "./lisp-HIVJ6DJJ.js"
    );
  }),
  livescript: create_language_async_loader_default("livescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_livescript" */
      "./livescript-ANELOUSX.js"
    );
  }),
  llvm: create_language_async_loader_default("llvm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_llvm" */
      "./llvm-427TYNEU.js"
    );
  }),
  log: create_language_async_loader_default("log", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_log" */
      "./log-6IVO5UP2.js"
    );
  }),
  lolcode: create_language_async_loader_default("lolcode", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_lolcode" */
      "./lolcode-6DKWIDAB.js"
    );
  }),
  lua: create_language_async_loader_default("lua", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_lua" */
      "./lua-3PVJNZUA.js"
    );
  }),
  magma: create_language_async_loader_default("magma", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_magma" */
      "./magma-ECA3MPAR.js"
    );
  }),
  makefile: create_language_async_loader_default("makefile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_makefile" */
      "./makefile-I7KPQ5BR.js"
    );
  }),
  markdown: create_language_async_loader_default("markdown", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_markdown" */
      "./markdown-5QAOIN3V.js"
    );
  }),
  markupTemplating: create_language_async_loader_default("markupTemplating", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_markupTemplating" */
      "./markup-templating-TT4YRWLM.js"
    );
  }),
  markup: create_language_async_loader_default("markup", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_markup" */
      "./markup-VJDKNIDY.js"
    );
  }),
  matlab: create_language_async_loader_default("matlab", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_matlab" */
      "./matlab-Q3WCQZ64.js"
    );
  }),
  maxscript: create_language_async_loader_default("maxscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_maxscript" */
      "./maxscript-VI6ROFI3.js"
    );
  }),
  mel: create_language_async_loader_default("mel", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_mel" */
      "./mel-BDNJXJGM.js"
    );
  }),
  mermaid: create_language_async_loader_default("mermaid", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_mermaid" */
      "./mermaid-TYTAPDQM.js"
    );
  }),
  mizar: create_language_async_loader_default("mizar", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_mizar" */
      "./mizar-IQRA24LM.js"
    );
  }),
  mongodb: create_language_async_loader_default("mongodb", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_mongodb" */
      "./mongodb-FAMR64KC.js"
    );
  }),
  monkey: create_language_async_loader_default("monkey", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_monkey" */
      "./monkey-2DDXSC5I.js"
    );
  }),
  moonscript: create_language_async_loader_default("moonscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_moonscript" */
      "./moonscript-WAP446JG.js"
    );
  }),
  n1ql: create_language_async_loader_default("n1ql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_n1ql" */
      "./n1ql-GSPRH2EZ.js"
    );
  }),
  n4js: create_language_async_loader_default("n4js", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_n4js" */
      "./n4js-V4LE354K.js"
    );
  }),
  nand2tetrisHdl: create_language_async_loader_default("nand2tetrisHdl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_nand2tetrisHdl" */
      "./nand2tetris-hdl-P6YCZGZ4.js"
    );
  }),
  naniscript: create_language_async_loader_default("naniscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_naniscript" */
      "./naniscript-EU3BX3YG.js"
    );
  }),
  nasm: create_language_async_loader_default("nasm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_nasm" */
      "./nasm-6UFS5LDT.js"
    );
  }),
  neon: create_language_async_loader_default("neon", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_neon" */
      "./neon-YMUT5GY5.js"
    );
  }),
  nevod: create_language_async_loader_default("nevod", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_nevod" */
      "./nevod-JREJXB45.js"
    );
  }),
  nginx: create_language_async_loader_default("nginx", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_nginx" */
      "./nginx-2AKMILAW.js"
    );
  }),
  nim: create_language_async_loader_default("nim", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_nim" */
      "./nim-RMKVD5EY.js"
    );
  }),
  nix: create_language_async_loader_default("nix", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_nix" */
      "./nix-FUZNCEBK.js"
    );
  }),
  nsis: create_language_async_loader_default("nsis", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_nsis" */
      "./nsis-DI52NCEY.js"
    );
  }),
  objectivec: create_language_async_loader_default("objectivec", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_objectivec" */
      "./objectivec-QIV7XQDY.js"
    );
  }),
  ocaml: create_language_async_loader_default("ocaml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_ocaml" */
      "./ocaml-VAMM724B.js"
    );
  }),
  opencl: create_language_async_loader_default("opencl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_opencl" */
      "./opencl-IDVM2XZ5.js"
    );
  }),
  openqasm: create_language_async_loader_default("openqasm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_openqasm" */
      "./openqasm-ZEJUGRZZ.js"
    );
  }),
  oz: create_language_async_loader_default("oz", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_oz" */
      "./oz-W637QDVK.js"
    );
  }),
  parigp: create_language_async_loader_default("parigp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_parigp" */
      "./parigp-2G762RE6.js"
    );
  }),
  parser: create_language_async_loader_default("parser", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_parser" */
      "./parser-MKPE54CF.js"
    );
  }),
  pascal: create_language_async_loader_default("pascal", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_pascal" */
      "./pascal-JQHE7W3L.js"
    );
  }),
  pascaligo: create_language_async_loader_default("pascaligo", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_pascaligo" */
      "./pascaligo-J7DQVFHU.js"
    );
  }),
  pcaxis: create_language_async_loader_default("pcaxis", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_pcaxis" */
      "./pcaxis-SNWQ3V5X.js"
    );
  }),
  peoplecode: create_language_async_loader_default("peoplecode", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_peoplecode" */
      "./peoplecode-5HX6GYAI.js"
    );
  }),
  perl: create_language_async_loader_default("perl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_perl" */
      "./perl-DDIM56PP.js"
    );
  }),
  phpExtras: create_language_async_loader_default("phpExtras", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_phpExtras" */
      "./php-extras-J6JUYTZL.js"
    );
  }),
  php: create_language_async_loader_default("php", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_php" */
      "./php-WN4BMFUP.js"
    );
  }),
  phpdoc: create_language_async_loader_default("phpdoc", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_phpdoc" */
      "./phpdoc-DHRAWQB4.js"
    );
  }),
  plsql: create_language_async_loader_default("plsql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_plsql" */
      "./plsql-3LBT3YT6.js"
    );
  }),
  powerquery: create_language_async_loader_default("powerquery", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_powerquery" */
      "./powerquery-L47376J2.js"
    );
  }),
  powershell: create_language_async_loader_default("powershell", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_powershell" */
      "./powershell-JEVKNXYL.js"
    );
  }),
  processing: create_language_async_loader_default("processing", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_processing" */
      "./processing-2ENIUDNE.js"
    );
  }),
  prolog: create_language_async_loader_default("prolog", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_prolog" */
      "./prolog-MP5FYOJW.js"
    );
  }),
  promql: create_language_async_loader_default("promql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_promql" */
      "./promql-YMCUSY2B.js"
    );
  }),
  properties: create_language_async_loader_default("properties", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_properties" */
      "./properties-E5AV6LFC.js"
    );
  }),
  protobuf: create_language_async_loader_default("protobuf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_protobuf" */
      "./protobuf-EQMV2PRV.js"
    );
  }),
  psl: create_language_async_loader_default("psl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_psl" */
      "./psl-EQEWND43.js"
    );
  }),
  pug: create_language_async_loader_default("pug", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_pug" */
      "./pug-LMZYU5HU.js"
    );
  }),
  puppet: create_language_async_loader_default("puppet", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_puppet" */
      "./puppet-RQ3FINKB.js"
    );
  }),
  pure: create_language_async_loader_default("pure", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_pure" */
      "./pure-AHBTXDWO.js"
    );
  }),
  purebasic: create_language_async_loader_default("purebasic", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_purebasic" */
      "./purebasic-JXKESR6U.js"
    );
  }),
  purescript: create_language_async_loader_default("purescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_purescript" */
      "./purescript-FSBRXRCL.js"
    );
  }),
  python: create_language_async_loader_default("python", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_python" */
      "./python-UAVQEM3B.js"
    );
  }),
  q: create_language_async_loader_default("q", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_q" */
      "./q-TJQIKM2B.js"
    );
  }),
  qml: create_language_async_loader_default("qml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_qml" */
      "./qml-GEEXLRN6.js"
    );
  }),
  qore: create_language_async_loader_default("qore", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_qore" */
      "./qore-5KSYKLV6.js"
    );
  }),
  qsharp: create_language_async_loader_default("qsharp", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_qsharp" */
      "./qsharp-KS4FKVM2.js"
    );
  }),
  r: create_language_async_loader_default("r", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_r" */
      "./r-BCVCZIJS.js"
    );
  }),
  racket: create_language_async_loader_default("racket", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_racket" */
      "./racket-YWLT7C2N.js"
    );
  }),
  reason: create_language_async_loader_default("reason", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_reason" */
      "./reason-O5VDNCPT.js"
    );
  }),
  regex: create_language_async_loader_default("regex", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_regex" */
      "./regex-UWWHWKCH.js"
    );
  }),
  rego: create_language_async_loader_default("rego", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_rego" */
      "./rego-WFHVLA2K.js"
    );
  }),
  renpy: create_language_async_loader_default("renpy", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_renpy" */
      "./renpy-FIQJC22A.js"
    );
  }),
  rest: create_language_async_loader_default("rest", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_rest" */
      "./rest-O32I4RM2.js"
    );
  }),
  rip: create_language_async_loader_default("rip", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_rip" */
      "./rip-53HS545W.js"
    );
  }),
  roboconf: create_language_async_loader_default("roboconf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_roboconf" */
      "./roboconf-HA7RFOXN.js"
    );
  }),
  robotframework: create_language_async_loader_default("robotframework", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_robotframework" */
      "./robotframework-L47R7QA6.js"
    );
  }),
  ruby: create_language_async_loader_default("ruby", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_ruby" */
      "./ruby-NKHLLQYR.js"
    );
  }),
  rust: create_language_async_loader_default("rust", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_rust" */
      "./rust-43UZFOMX.js"
    );
  }),
  sas: create_language_async_loader_default("sas", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_sas" */
      "./sas-324WBYQR.js"
    );
  }),
  sass: create_language_async_loader_default("sass", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_sass" */
      "./sass-4DS5D23E.js"
    );
  }),
  scala: create_language_async_loader_default("scala", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_scala" */
      "./scala-4DOIBSWQ.js"
    );
  }),
  scheme: create_language_async_loader_default("scheme", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_scheme" */
      "./scheme-3C2CC673.js"
    );
  }),
  scss: create_language_async_loader_default("scss", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_scss" */
      "./scss-CU47T65J.js"
    );
  }),
  shellSession: create_language_async_loader_default("shellSession", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_shellSession" */
      "./shell-session-SOY2YFIA.js"
    );
  }),
  smali: create_language_async_loader_default("smali", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_smali" */
      "./smali-6NDM3U6Z.js"
    );
  }),
  smalltalk: create_language_async_loader_default("smalltalk", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_smalltalk" */
      "./smalltalk-WZ25NL5S.js"
    );
  }),
  smarty: create_language_async_loader_default("smarty", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_smarty" */
      "./smarty-CDHTHEWE.js"
    );
  }),
  sml: create_language_async_loader_default("sml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_sml" */
      "./sml-2P5MNAXU.js"
    );
  }),
  solidity: create_language_async_loader_default("solidity", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_solidity" */
      "./solidity-RCQJHEC3.js"
    );
  }),
  solutionFile: create_language_async_loader_default("solutionFile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_solutionFile" */
      "./solution-file-BUF6F5YZ.js"
    );
  }),
  soy: create_language_async_loader_default("soy", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_soy" */
      "./soy-QTI3LRT5.js"
    );
  }),
  sparql: create_language_async_loader_default("sparql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_sparql" */
      "./sparql-GPLT7GSQ.js"
    );
  }),
  splunkSpl: create_language_async_loader_default("splunkSpl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_splunkSpl" */
      "./splunk-spl-HNVDURBD.js"
    );
  }),
  sqf: create_language_async_loader_default("sqf", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_sqf" */
      "./sqf-NKKFXL7X.js"
    );
  }),
  sql: create_language_async_loader_default("sql", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_sql" */
      "./sql-KO7NSVUS.js"
    );
  }),
  squirrel: create_language_async_loader_default("squirrel", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_squirrel" */
      "./squirrel-L4YJ2BBU.js"
    );
  }),
  stan: create_language_async_loader_default("stan", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_stan" */
      "./stan-7TSBPAYJ.js"
    );
  }),
  stylus: create_language_async_loader_default("stylus", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_stylus" */
      "./stylus-QDTIKIUJ.js"
    );
  }),
  swift: create_language_async_loader_default("swift", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_swift" */
      "./swift-TI2GG6K7.js"
    );
  }),
  systemd: create_language_async_loader_default("systemd", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_systemd" */
      "./systemd-764N5RVN.js"
    );
  }),
  t4Cs: create_language_async_loader_default("t4Cs", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_t4Cs" */
      "./t4-cs-Q2EOECWB.js"
    );
  }),
  t4Templating: create_language_async_loader_default("t4Templating", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_t4Templating" */
      "./t4-templating-HH5OGQJ7.js"
    );
  }),
  t4Vb: create_language_async_loader_default("t4Vb", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_t4Vb" */
      "./t4-vb-C5PPMGAS.js"
    );
  }),
  tap: create_language_async_loader_default("tap", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_tap" */
      "./tap-HLIOSCJF.js"
    );
  }),
  tcl: create_language_async_loader_default("tcl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_tcl" */
      "./tcl-DNFV6FQW.js"
    );
  }),
  textile: create_language_async_loader_default("textile", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_textile" */
      "./textile-D4BQ3PYS.js"
    );
  }),
  toml: create_language_async_loader_default("toml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_toml" */
      "./toml-4HO2ORD5.js"
    );
  }),
  tremor: create_language_async_loader_default("tremor", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_tremor" */
      "./tremor-6CSKQ7FP.js"
    );
  }),
  tsx: create_language_async_loader_default("tsx", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_tsx" */
      "./tsx-57SHNHE2.js"
    );
  }),
  tt2: create_language_async_loader_default("tt2", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_tt2" */
      "./tt2-OQZQ5QR4.js"
    );
  }),
  turtle: create_language_async_loader_default("turtle", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_turtle" */
      "./turtle-GCHVFTAE.js"
    );
  }),
  twig: create_language_async_loader_default("twig", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_twig" */
      "./twig-FYMSEGHL.js"
    );
  }),
  typescript: create_language_async_loader_default("typescript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_typescript" */
      "./typescript-6YKPHASJ.js"
    );
  }),
  typoscript: create_language_async_loader_default("typoscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_typoscript" */
      "./typoscript-RKE7SN7W.js"
    );
  }),
  unrealscript: create_language_async_loader_default("unrealscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_unrealscript" */
      "./unrealscript-ZGSC4AOA.js"
    );
  }),
  uorazor: create_language_async_loader_default("uorazor", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_uorazor" */
      "./uorazor-NGJIXDUS.js"
    );
  }),
  uri: create_language_async_loader_default("uri", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_uri" */
      "./uri-5E2TCIZC.js"
    );
  }),
  v: create_language_async_loader_default("v", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_v" */
      "./v-2OLCLAX5.js"
    );
  }),
  vala: create_language_async_loader_default("vala", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_vala" */
      "./vala-QPM5IEN3.js"
    );
  }),
  vbnet: create_language_async_loader_default("vbnet", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_vbnet" */
      "./vbnet-H4USBI3F.js"
    );
  }),
  velocity: create_language_async_loader_default("velocity", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_velocity" */
      "./velocity-U2VNUKQD.js"
    );
  }),
  verilog: create_language_async_loader_default("verilog", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_verilog" */
      "./verilog-HMBKUJ4M.js"
    );
  }),
  vhdl: create_language_async_loader_default("vhdl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_vhdl" */
      "./vhdl-TVEYOZPV.js"
    );
  }),
  vim: create_language_async_loader_default("vim", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_vim" */
      "./vim-6MPQQY34.js"
    );
  }),
  visualBasic: create_language_async_loader_default("visualBasic", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_visualBasic" */
      "./visual-basic-RXE3ESSM.js"
    );
  }),
  warpscript: create_language_async_loader_default("warpscript", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_warpscript" */
      "./warpscript-PRFK4BI5.js"
    );
  }),
  wasm: create_language_async_loader_default("wasm", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_wasm" */
      "./wasm-P4ATMD2H.js"
    );
  }),
  webIdl: create_language_async_loader_default("webIdl", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_webIdl" */
      "./web-idl-3LJPDLNS.js"
    );
  }),
  wiki: create_language_async_loader_default("wiki", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_wiki" */
      "./wiki-V22ZSINO.js"
    );
  }),
  wolfram: create_language_async_loader_default("wolfram", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_wolfram" */
      "./wolfram-L4ADTYSD.js"
    );
  }),
  wren: create_language_async_loader_default("wren", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_wren" */
      "./wren-UD73JKFA.js"
    );
  }),
  xeora: create_language_async_loader_default("xeora", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_xeora" */
      "./xeora-IVOF4SWM.js"
    );
  }),
  xmlDoc: create_language_async_loader_default("xmlDoc", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_xmlDoc" */
      "./xml-doc-3L3QP7S6.js"
    );
  }),
  xojo: create_language_async_loader_default("xojo", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_xojo" */
      "./xojo-E34DY27O.js"
    );
  }),
  xquery: create_language_async_loader_default("xquery", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_xquery" */
      "./xquery-WYFV5N67.js"
    );
  }),
  yaml: create_language_async_loader_default("yaml", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_yaml" */
      "./yaml-GEJ565AC.js"
    );
  }),
  yang: create_language_async_loader_default("yang", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_yang" */
      "./yang-ZW7K7HJJ.js"
    );
  }),
  zig: create_language_async_loader_default("zig", function() {
    return import(
      /* webpackChunkName: "react-syntax-highlighter_languages_refractor_zig" */
      "./zig-IZYJ2XLX.js"
    );
  })
};

// node_modules/react-syntax-highlighter/dist/esm/prism-async-light.js
var prism_async_light_default = async_syntax_highlighter_default({
  loader: function loader2() {
    return import(
      /* webpackChunkName:"react-syntax-highlighter/refractor-core-import" */
      "./core-IHGW5EX7.js"
    ).then(function(module) {
      return module["default"] || module;
    });
  },
  isLanguageRegistered: function isLanguageRegistered2(instance, language) {
    return instance.registered(language);
  },
  languageLoaders: prism_default,
  registerLanguage: function registerLanguage2(instance, name2, language) {
    return instance.register(language);
  }
});

// node_modules/react-syntax-highlighter/dist/esm/languages/prism/supported-languages.js
var supported_languages_default2 = ["abap", "abnf", "actionscript", "ada", "agda", "al", "antlr4", "apacheconf", "apex", "apl", "applescript", "aql", "arduino", "arff", "asciidoc", "asm6502", "asmatmel", "aspnet", "autohotkey", "autoit", "avisynth", "avro-idl", "bash", "basic", "batch", "bbcode", "bicep", "birb", "bison", "bnf", "brainfuck", "brightscript", "bro", "bsl", "c", "cfscript", "chaiscript", "cil", "clike", "clojure", "cmake", "cobol", "coffeescript", "concurnas", "coq", "cpp", "crystal", "csharp", "cshtml", "csp", "css-extras", "css", "csv", "cypher", "d", "dart", "dataweave", "dax", "dhall", "diff", "django", "dns-zone-file", "docker", "dot", "ebnf", "editorconfig", "eiffel", "ejs", "elixir", "elm", "erb", "erlang", "etlua", "excel-formula", "factor", "false", "firestore-security-rules", "flow", "fortran", "fsharp", "ftl", "gap", "gcode", "gdscript", "gedcom", "gherkin", "git", "glsl", "gml", "gn", "go-module", "go", "graphql", "groovy", "haml", "handlebars", "haskell", "haxe", "hcl", "hlsl", "hoon", "hpkp", "hsts", "http", "ichigojam", "icon", "icu-message-format", "idris", "iecst", "ignore", "inform7", "ini", "io", "j", "java", "javadoc", "javadoclike", "javascript", "javastacktrace", "jexl", "jolie", "jq", "js-extras", "js-templates", "jsdoc", "json", "json5", "jsonp", "jsstacktrace", "jsx", "julia", "keepalived", "keyman", "kotlin", "kumir", "kusto", "latex", "latte", "less", "lilypond", "liquid", "lisp", "livescript", "llvm", "log", "lolcode", "lua", "magma", "makefile", "markdown", "markup-templating", "markup", "matlab", "maxscript", "mel", "mermaid", "mizar", "mongodb", "monkey", "moonscript", "n1ql", "n4js", "nand2tetris-hdl", "naniscript", "nasm", "neon", "nevod", "nginx", "nim", "nix", "nsis", "objectivec", "ocaml", "opencl", "openqasm", "oz", "parigp", "parser", "pascal", "pascaligo", "pcaxis", "peoplecode", "perl", "php-extras", "php", "phpdoc", "plsql", "powerquery", "powershell", "processing", "prolog", "promql", "properties", "protobuf", "psl", "pug", "puppet", "pure", "purebasic", "purescript", "python", "q", "qml", "qore", "qsharp", "r", "racket", "reason", "regex", "rego", "renpy", "rest", "rip", "roboconf", "robotframework", "ruby", "rust", "sas", "sass", "scala", "scheme", "scss", "shell-session", "smali", "smalltalk", "smarty", "sml", "solidity", "solution-file", "soy", "sparql", "splunk-spl", "sqf", "sql", "squirrel", "stan", "stylus", "swift", "systemd", "t4-cs", "t4-templating", "t4-vb", "tap", "tcl", "textile", "toml", "tremor", "tsx", "tt2", "turtle", "twig", "typescript", "typoscript", "unrealscript", "uorazor", "uri", "v", "vala", "vbnet", "velocity", "verilog", "vhdl", "vim", "visual-basic", "warpscript", "wasm", "web-idl", "wiki", "wolfram", "wren", "xeora", "xml-doc", "xojo", "xquery", "yaml", "yang", "zig"];

// node_modules/react-syntax-highlighter/dist/esm/prism-async.js
var prism_async_default = async_syntax_highlighter_default({
  loader: function loader3() {
    return import(
      /* webpackChunkName:"react-syntax-highlighter/refractor-import" */
      "./refractor-RJOSABSI.js"
    ).then(function(module) {
      return module["default"] || module;
    });
  },
  noAsyncLoadingLanguages: true,
  supportedLanguages: supported_languages_default2
});

// node_modules/react-syntax-highlighter/dist/esm/prism-light.js
var import_core3 = __toESM(require_core2());
var SyntaxHighlighter2 = highlight_default(import_core3.default, {});
SyntaxHighlighter2.registerLanguage = function(_10, language) {
  return import_core3.default.register(language);
};
SyntaxHighlighter2.alias = function(name2, aliases) {
  return import_core3.default.alias(name2, aliases);
};

// node_modules/react-syntax-highlighter/dist/esm/styles/prism/prism.js
var prism_default2 = {
  'code[class*="language-"]': {
    "color": "black",
    "background": "none",
    "textShadow": "0 1px white",
    "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
    "fontSize": "1em",
    "textAlign": "left",
    "whiteSpace": "pre",
    "wordSpacing": "normal",
    "wordBreak": "normal",
    "wordWrap": "normal",
    "lineHeight": "1.5",
    "MozTabSize": "4",
    "OTabSize": "4",
    "tabSize": "4",
    "WebkitHyphens": "none",
    "MozHyphens": "none",
    "msHyphens": "none",
    "hyphens": "none"
  },
  'pre[class*="language-"]': {
    "color": "black",
    "background": "#f5f2f0",
    "textShadow": "0 1px white",
    "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
    "fontSize": "1em",
    "textAlign": "left",
    "whiteSpace": "pre",
    "wordSpacing": "normal",
    "wordBreak": "normal",
    "wordWrap": "normal",
    "lineHeight": "1.5",
    "MozTabSize": "4",
    "OTabSize": "4",
    "tabSize": "4",
    "WebkitHyphens": "none",
    "MozHyphens": "none",
    "msHyphens": "none",
    "hyphens": "none",
    "padding": "1em",
    "margin": ".5em 0",
    "overflow": "auto"
  },
  'pre[class*="language-"]::-moz-selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  'pre[class*="language-"] ::-moz-selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  'code[class*="language-"]::-moz-selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  'code[class*="language-"] ::-moz-selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  'pre[class*="language-"]::selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  'pre[class*="language-"] ::selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  'code[class*="language-"]::selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  'code[class*="language-"] ::selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  ':not(pre) > code[class*="language-"]': {
    "background": "#f5f2f0",
    "padding": ".1em",
    "borderRadius": ".3em",
    "whiteSpace": "normal"
  },
  "comment": {
    "color": "slategray"
  },
  "prolog": {
    "color": "slategray"
  },
  "doctype": {
    "color": "slategray"
  },
  "cdata": {
    "color": "slategray"
  },
  "punctuation": {
    "color": "#999"
  },
  "namespace": {
    "Opacity": ".7"
  },
  "property": {
    "color": "#905"
  },
  "tag": {
    "color": "#905"
  },
  "boolean": {
    "color": "#905"
  },
  "number": {
    "color": "#905"
  },
  "constant": {
    "color": "#905"
  },
  "symbol": {
    "color": "#905"
  },
  "deleted": {
    "color": "#905"
  },
  "selector": {
    "color": "#690"
  },
  "attr-name": {
    "color": "#690"
  },
  "string": {
    "color": "#690"
  },
  "char": {
    "color": "#690"
  },
  "builtin": {
    "color": "#690"
  },
  "inserted": {
    "color": "#690"
  },
  "operator": {
    "color": "#9a6e3a",
    "background": "hsla(0, 0%, 100%, .5)"
  },
  "entity": {
    "color": "#9a6e3a",
    "background": "hsla(0, 0%, 100%, .5)",
    "cursor": "help"
  },
  "url": {
    "color": "#9a6e3a",
    "background": "hsla(0, 0%, 100%, .5)"
  },
  ".language-css .token.string": {
    "color": "#9a6e3a",
    "background": "hsla(0, 0%, 100%, .5)"
  },
  ".style .token.string": {
    "color": "#9a6e3a",
    "background": "hsla(0, 0%, 100%, .5)"
  },
  "atrule": {
    "color": "#07a"
  },
  "attr-value": {
    "color": "#07a"
  },
  "keyword": {
    "color": "#07a"
  },
  "function": {
    "color": "#DD4A68"
  },
  "class-name": {
    "color": "#DD4A68"
  },
  "regex": {
    "color": "#e90"
  },
  "important": {
    "color": "#e90",
    "fontWeight": "bold"
  },
  "variable": {
    "color": "#e90"
  },
  "bold": {
    "fontWeight": "bold"
  },
  "italic": {
    "fontStyle": "italic"
  }
};

// node_modules/react-syntax-highlighter/dist/esm/prism.js
var import_refractor = __toESM(require_refractor());
var highlighter2 = highlight_default(import_refractor.default, prism_default2);
highlighter2.supportedLanguages = supported_languages_default2;
var prism_default3 = highlighter2;

// node_modules/@copilotkit/react-ui/dist/chunk-IK2BPURM.mjs
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var programmingLanguages = {
  javascript: ".js",
  python: ".py",
  java: ".java",
  c: ".c",
  cpp: ".cpp",
  "c++": ".cpp",
  "c#": ".cs",
  ruby: ".rb",
  php: ".php",
  swift: ".swift",
  "objective-c": ".m",
  kotlin: ".kt",
  typescript: ".ts",
  go: ".go",
  perl: ".pl",
  rust: ".rs",
  scala: ".scala",
  haskell: ".hs",
  lua: ".lua",
  shell: ".sh",
  sql: ".sql",
  html: ".html",
  css: ".css"
  // add more file extensions here, make sure the key is same as language prop in CodeBlock.tsx component
};
var generateRandomString = (length, lowercase = false) => {
  const chars = "ABCDEFGHJKLMNPQRSTUVWXY3456789";
  let result = "";
  for (let i16 = 0; i16 < length; i16++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return lowercase ? result.toLowerCase() : result;
};
var CodeBlock = (0, import_react148.memo)(({ language, value }) => {
  const { isCopied, copyToClipboard } = useCopyToClipboard({ timeout: 2e3 });
  const [SyntaxHighlighter3, setSyntaxHighlighter] = (0, import_react148.useState)(
    () => light_default
  );
  (0, import_react148.useEffect)(() => {
    try {
      new RegExp("(?<=#)\\w+");
      setSyntaxHighlighter(() => prism_default3);
    } catch (e9) {
      setSyntaxHighlighter(() => light_default);
    }
  }, []);
  const downloadAsFile = () => {
    if (typeof window === "undefined") {
      return;
    }
    const fileExtension = programmingLanguages[language] || ".file";
    const suggestedFileName = `file-${generateRandomString(3, true)}${fileExtension}`;
    const fileName = window.prompt("Enter file name", suggestedFileName);
    if (!fileName) {
      return;
    }
    const blob = new Blob([value], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const link3 = document.createElement("a");
    link3.download = fileName;
    link3.href = url;
    link3.style.display = "none";
    document.body.appendChild(link3);
    link3.click();
    document.body.removeChild(link3);
    URL.revokeObjectURL(url);
  };
  const onCopy = () => {
    if (isCopied)
      return;
    copyToClipboard(value);
  };
  return (0, import_jsx_runtime16.jsxs)("div", { className: "copilotKitCodeBlock", children: [
    (0, import_jsx_runtime16.jsxs)("div", { className: "copilotKitCodeBlockToolbar", children: [
      (0, import_jsx_runtime16.jsx)("span", { className: "copilotKitCodeBlockToolbarLanguage", children: language }),
      (0, import_jsx_runtime16.jsxs)("div", { className: "copilotKitCodeBlockToolbarButtons", children: [
        (0, import_jsx_runtime16.jsx)("button", { className: "copilotKitCodeBlockToolbarButton", onClick: downloadAsFile, children: DownloadIcon }),
        (0, import_jsx_runtime16.jsx)("button", { className: "copilotKitCodeBlockToolbarButton", onClick: onCopy, children: isCopied ? CheckIcon : CopyIcon })
      ] })
    ] }),
    (0, import_jsx_runtime16.jsx)(
      SyntaxHighlighter3,
      {
        language,
        style: highlightStyle,
        PreTag: "div",
        customStyle: {
          margin: 0,
          borderBottomLeftRadius: "0.375rem",
          borderBottomRightRadius: "0.375rem"
        },
        children: value
      }
    )
  ] });
});
CodeBlock.displayName = "CodeBlock";
var highlightStyle = {
  'pre[class*="language-"]': {
    color: "#d4d4d4",
    fontSize: "13px",
    textShadow: "none",
    fontFamily: 'Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace',
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none",
    padding: "1em",
    margin: ".5em 0",
    overflow: "auto",
    background: "#1e1e1e"
  },
  'code[class*="language-"]': {
    color: "#d4d4d4",
    fontSize: "13px",
    textShadow: "none",
    fontFamily: 'Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace',
    direction: "ltr",
    textAlign: "left",
    whiteSpace: "pre",
    wordSpacing: "normal",
    wordBreak: "normal",
    lineHeight: "1.5",
    MozTabSize: "4",
    OTabSize: "4",
    tabSize: "4",
    WebkitHyphens: "none",
    MozHyphens: "none",
    msHyphens: "none",
    hyphens: "none"
  },
  'pre[class*="language-"]::selection': {
    textShadow: "none",
    background: "#264F78"
  },
  'code[class*="language-"]::selection': {
    textShadow: "none",
    background: "#264F78"
  },
  'pre[class*="language-"] *::selection': {
    textShadow: "none",
    background: "#264F78"
  },
  'code[class*="language-"] *::selection': {
    textShadow: "none",
    background: "#264F78"
  },
  ':not(pre) > code[class*="language-"]': {
    padding: ".1em .3em",
    borderRadius: ".3em",
    color: "#db4c69",
    background: "#1e1e1e"
  },
  ".namespace": {
    Opacity: ".7"
  },
  "doctype.doctype-tag": {
    color: "#569CD6"
  },
  "doctype.name": {
    color: "#9cdcfe"
  },
  comment: {
    color: "#6a9955"
  },
  prolog: {
    color: "#6a9955"
  },
  punctuation: {
    color: "#d4d4d4"
  },
  ".language-html .language-css .token.punctuation": {
    color: "#d4d4d4"
  },
  ".language-html .language-javascript .token.punctuation": {
    color: "#d4d4d4"
  },
  property: {
    color: "#9cdcfe"
  },
  tag: {
    color: "#569cd6"
  },
  boolean: {
    color: "#569cd6"
  },
  number: {
    color: "#b5cea8"
  },
  constant: {
    color: "#9cdcfe"
  },
  symbol: {
    color: "#b5cea8"
  },
  inserted: {
    color: "#b5cea8"
  },
  unit: {
    color: "#b5cea8"
  },
  selector: {
    color: "#d7ba7d"
  },
  "attr-name": {
    color: "#9cdcfe"
  },
  string: {
    color: "#ce9178"
  },
  char: {
    color: "#ce9178"
  },
  builtin: {
    color: "#ce9178"
  },
  deleted: {
    color: "#ce9178"
  },
  ".language-css .token.string.url": {
    textDecoration: "underline"
  },
  operator: {
    color: "#d4d4d4"
  },
  entity: {
    color: "#569cd6"
  },
  "operator.arrow": {
    color: "#569CD6"
  },
  atrule: {
    color: "#ce9178"
  },
  "atrule.rule": {
    color: "#c586c0"
  },
  "atrule.url": {
    color: "#9cdcfe"
  },
  "atrule.url.function": {
    color: "#dcdcaa"
  },
  "atrule.url.punctuation": {
    color: "#d4d4d4"
  },
  keyword: {
    color: "#569CD6"
  },
  "keyword.module": {
    color: "#c586c0"
  },
  "keyword.control-flow": {
    color: "#c586c0"
  },
  function: {
    color: "#dcdcaa"
  },
  "function.maybe-class-name": {
    color: "#dcdcaa"
  },
  regex: {
    color: "#d16969"
  },
  important: {
    color: "#569cd6"
  },
  italic: {
    fontStyle: "italic"
  },
  "class-name": {
    color: "#4ec9b0"
  },
  "maybe-class-name": {
    color: "#4ec9b0"
  },
  console: {
    color: "#9cdcfe"
  },
  parameter: {
    color: "#9cdcfe"
  },
  interpolation: {
    color: "#9cdcfe"
  },
  "punctuation.interpolation-punctuation": {
    color: "#569cd6"
  },
  variable: {
    color: "#9cdcfe"
  },
  "imports.maybe-class-name": {
    color: "#9cdcfe"
  },
  "exports.maybe-class-name": {
    color: "#9cdcfe"
  },
  escape: {
    color: "#d7ba7d"
  },
  "tag.punctuation": {
    color: "#808080"
  },
  cdata: {
    color: "#808080"
  },
  "attr-value": {
    color: "#ce9178"
  },
  "attr-value.punctuation": {
    color: "#ce9178"
  },
  "attr-value.punctuation.attr-equals": {
    color: "#d4d4d4"
  },
  namespace: {
    color: "#4ec9b0"
  },
  'pre[class*="language-javascript"]': {
    color: "#9cdcfe"
  },
  'code[class*="language-javascript"]': {
    color: "#9cdcfe"
  },
  'pre[class*="language-jsx"]': {
    color: "#9cdcfe"
  },
  'code[class*="language-jsx"]': {
    color: "#9cdcfe"
  },
  'pre[class*="language-typescript"]': {
    color: "#9cdcfe"
  },
  'code[class*="language-typescript"]': {
    color: "#9cdcfe"
  },
  'pre[class*="language-tsx"]': {
    color: "#9cdcfe"
  },
  'code[class*="language-tsx"]': {
    color: "#9cdcfe"
  },
  'pre[class*="language-css"]': {
    color: "#ce9178"
  },
  'code[class*="language-css"]': {
    color: "#ce9178"
  },
  'pre[class*="language-html"]': {
    color: "#d4d4d4"
  },
  'code[class*="language-html"]': {
    color: "#d4d4d4"
  },
  ".language-regex .token.anchor": {
    color: "#dcdcaa"
  },
  ".language-html .token.punctuation": {
    color: "#808080"
  },
  'pre[class*="language-"] > code[class*="language-"]': {
    position: "relative",
    zIndex: "1"
  },
  ".line-highlight.line-highlight": {
    background: "#f7ebc6",
    boxShadow: "inset 5px 0 0 #f7d87c",
    zIndex: "0"
  }
};

// node_modules/@copilotkit/react-ui/dist/chunk-JZ3RFQQ6.mjs
var import_react150 = __toESM(require_react(), 1);

// node_modules/devlop/lib/development.js
var AssertionError = class extends Error {
  /**
   * Create an assertion error.
   *
   * @param {string} message
   *   Message explaining error.
   * @param {unknown} actual
   *   Value.
   * @param {unknown} expected
   *   Baseline.
   * @param {string} operator
   *   Name of equality operation.
   * @param {boolean} generated
   *   Whether `message` is a custom message or not
   * @returns
   *   Instance.
   */
  // eslint-disable-next-line max-params
  constructor(message, actual, expected, operator, generated) {
    super(message);
    __publicField(
      this,
      "name",
      /** @type {const} */
      "Assertion"
    );
    __publicField(
      this,
      "code",
      /** @type {const} */
      "ERR_ASSERTION"
    );
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.actual = actual;
    this.expected = expected;
    this.generated = generated;
    this.operator = operator;
  }
};
function ok(value, message) {
  assert(
    Boolean(value),
    false,
    true,
    "ok",
    "Expected value to be truthy",
    message
  );
}
function unreachable(message) {
  assert(false, false, true, "ok", "Unreachable", message);
}
function assert(bool, actual, expected, operator, defaultMessage, userMessage) {
  if (!bool) {
    throw userMessage instanceof Error ? userMessage : new AssertionError(
      userMessage || defaultMessage,
      actual,
      expected,
      operator,
      !userMessage
    );
  }
}

// node_modules/estree-util-is-identifier-name/lib/index.js
var nameRe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
var nameReJsx = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
var emptyOptions = {};
function name(name2, options) {
  const settings = options || emptyOptions;
  const re5 = settings.jsx ? nameReJsx : nameRe;
  return re5.test(name2);
}

// node_modules/hast-util-to-jsx-runtime/node_modules/hast-util-whitespace/lib/index.js
var re4 = /[ \t\n\f\r]/g;
function whitespace(thing) {
  return typeof thing === "object" ? thing.type === "text" ? empty(thing.value) : false : empty(thing);
}
function empty(value) {
  return value.replace(re4, "") === "";
}

// node_modules/hast-util-to-jsx-runtime/node_modules/property-information/lib/util/schema.js
var Schema = class {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(property, normal, space) {
    this.normal = normal;
    this.property = property;
    if (space) {
      this.space = space;
    }
  }
};
Schema.prototype.normal = {};
Schema.prototype.property = {};
Schema.prototype.space = void 0;

// node_modules/hast-util-to-jsx-runtime/node_modules/property-information/lib/util/merge.js
function merge(definitions, space) {
  const property = {};
  const normal = {};
  for (const definition3 of definitions) {
    Object.assign(property, definition3.property);
    Object.assign(normal, definition3.normal);
  }
  return new Schema(property, normal, space);
}

// node_modules/hast-util-to-jsx-runtime/node_modules/property-information/lib/normalize.js
function normalize(value) {
  return value.toLowerCase();
}

// node_modules/hast-util-to-jsx-runtime/node_modules/property-information/lib/util/info.js
var Info = class {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(property, attribute) {
    this.attribute = attribute;
    this.property = property;
  }
};
Info.prototype.attribute = "";
Info.prototype.booleanish = false;
Info.prototype.boolean = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.commaSeparated = false;
Info.prototype.defined = false;
Info.prototype.mustUseProperty = false;
Info.prototype.number = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.property = "";
Info.prototype.spaceSeparated = false;
Info.prototype.space = void 0;

// node_modules/hast-util-to-jsx-runtime/node_modules/property-information/lib/util/types.js
var types_exports = {};
__export(types_exports, {
  boolean: () => boolean,
  booleanish: () => booleanish,
  commaOrSpaceSeparated: () => commaOrSpaceSeparated,
  commaSeparated: () => commaSeparated,
  number: () => number,
  overloadedBoolean: () => overloadedBoolean,
  spaceSeparated: () => spaceSeparated
});
var powers = 0;
var boolean = increment();
var booleanish = increment();
var overloadedBoolean = increment();
var number = increment();
var spaceSeparated = increment();
var commaSeparated = increment();
var commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}

// node_modules/hast-util-to-jsx-runtime/node_modules/property-information/lib/util/defined-info.js
var checks = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(types_exports)
);
var DefinedInfo = class extends Info {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(property, attribute, mask, space) {
    let index4 = -1;
    super(property, attribute);
    mark(this, "space", space);
    if (typeof mask === "number") {
      while (++index4 < checks.length) {
        const check = checks[index4];
        mark(this, checks[index4], (mask & types_exports[check]) === types_exports[check]);
      }
    }
  }
};
DefinedInfo.prototype.defined = true;
function mark(values2, key, value) {
  if (value) {
    values2[key] = value;
  }
}

// node_modules/hast-util-to-jsx-runtime/node_modules/property-information/lib/util/create.js
function create(definition3) {
  const properties = {};
  const normals = {};
  for (const [property, value] of Object.entries(definition3.properties)) {
    const info = new DefinedInfo(
      property,
      definition3.transform(definition3.attributes || {}, property),
      value,
      definition3.space
    );
    if (definition3.mustUseProperty && definition3.mustUseProperty.includes(property)) {
      info.mustUseProperty = true;
    }
    properties[property] = info;
    normals[normalize(property)] = property;
    normals[normalize(info.attribute)] = property;
  }
  return new Schema(properties, normals, definition3.space);
}

// node_modules/hast-util-to-jsx-runtime/node_modules/property-information/lib/aria.js
var aria = create({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  },
  transform(_10, property) {
    return property === "role" ? property : "aria-" + property.slice(4).toLowerCase();
  }
});

// node_modules/hast-util-to-jsx-runtime/node_modules/property-information/lib/util/case-sensitive-transform.js
function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}

// node_modules/hast-util-to-jsx-runtime/node_modules/property-information/lib/util/case-insensitive-transform.js
function caseInsensitiveTransform(attributes, property) {
  return caseSensitiveTransform(attributes, property.toLowerCase());
}

// node_modules/hast-util-to-jsx-runtime/node_modules/property-information/lib/html.js
var html2 = create({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: null,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: overloadedBoolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shadowRootClonable: boolean,
    shadowRootDelegatesFocus: boolean,
    shadowRootMode: null,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number,
    // `<img>` and `<object>`
    leftMargin: number,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number,
    // `<body>`
    marginWidth: number,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: caseInsensitiveTransform
});

// node_modules/hast-util-to-jsx-runtime/node_modules/property-information/lib/svg.js
var svg2 = create({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: caseSensitiveTransform
});

// node_modules/hast-util-to-jsx-runtime/node_modules/property-information/lib/xlink.js
var xlink = create({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(_10, property) {
    return "xlink:" + property.slice(5).toLowerCase();
  }
});

// node_modules/hast-util-to-jsx-runtime/node_modules/property-information/lib/xmlns.js
var xmlns = create({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: caseInsensitiveTransform
});

// node_modules/hast-util-to-jsx-runtime/node_modules/property-information/lib/xml.js
var xml = create({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(_10, property) {
    return "xml:" + property.slice(3).toLowerCase();
  }
});

// node_modules/hast-util-to-jsx-runtime/node_modules/property-information/lib/hast-to-react.js
var hastToReact = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
};

// node_modules/hast-util-to-jsx-runtime/node_modules/property-information/lib/find.js
var cap = /[A-Z]/g;
var dash = /-[a-z]/g;
var valid = /^data[-\w.:]+$/i;
function find2(schema, value) {
  const normal = normalize(value);
  let property = value;
  let Type = Info;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash, camelcase);
      property = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash.test(rest)) {
        let dashes = rest.replace(cap, kebab);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type = DefinedInfo;
  }
  return new Type(property, value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}

// node_modules/hast-util-to-jsx-runtime/node_modules/property-information/index.js
var html3 = merge([aria, html2, xlink, xmlns, xml], "html");
var svg3 = merge([aria, svg2, xlink, xmlns, xml], "svg");

// node_modules/hast-util-to-jsx-runtime/lib/index.js
var import_style_to_js = __toESM(require_cjs2(), 1);

// node_modules/unist-util-position/lib/index.js
var pointEnd = point("end");
var pointStart = point("start");
function point(type) {
  return point5;
  function point5(node2) {
    const point6 = node2 && node2.position && node2.position[type] || {};
    if (typeof point6.line === "number" && point6.line > 0 && typeof point6.column === "number" && point6.column > 0) {
      return {
        line: point6.line,
        column: point6.column,
        offset: typeof point6.offset === "number" && point6.offset > -1 ? point6.offset : void 0
      };
    }
  }
}
function position(node2) {
  const start2 = pointStart(node2);
  const end = pointEnd(node2);
  if (start2 && end) {
    return { start: start2, end };
  }
}

// node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position2(value.position);
  }
  if ("start" in value || "end" in value) {
    return position2(value);
  }
  if ("line" in value || "column" in value) {
    return point2(value);
  }
  return "";
}
function point2(point5) {
  return index3(point5 && point5.line) + ":" + index3(point5 && point5.column);
}
function position2(pos) {
  return point2(pos && pos.start) + "-" + point2(pos && pos.end);
}
function index3(value) {
  return value && typeof value === "number" ? value : 1;
}

// node_modules/hast-util-to-jsx-runtime/node_modules/vfile-message/lib/index.js
var VFileMessage = class extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(causeOrReason, optionsOrParentOrPlace, origin) {
    super();
    if (typeof optionsOrParentOrPlace === "string") {
      origin = optionsOrParentOrPlace;
      optionsOrParentOrPlace = void 0;
    }
    let reason = "";
    let options = {};
    let legacyCause = false;
    if (optionsOrParentOrPlace) {
      if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("type" in optionsOrParentOrPlace) {
        options = {
          ancestors: [optionsOrParentOrPlace],
          place: optionsOrParentOrPlace.position
        };
      } else {
        options = { ...optionsOrParentOrPlace };
      }
    }
    if (typeof causeOrReason === "string") {
      reason = causeOrReason;
    } else if (!options.cause && causeOrReason) {
      legacyCause = true;
      reason = causeOrReason.message;
      options.cause = causeOrReason;
    }
    if (!options.ruleId && !options.source && typeof origin === "string") {
      const index4 = origin.indexOf(":");
      if (index4 === -1) {
        options.ruleId = origin;
      } else {
        options.source = origin.slice(0, index4);
        options.ruleId = origin.slice(index4 + 1);
      }
    }
    if (!options.place && options.ancestors && options.ancestors) {
      const parent = options.ancestors[options.ancestors.length - 1];
      if (parent) {
        options.place = parent.position;
      }
    }
    const start2 = options.place && "start" in options.place ? options.place.start : options.place;
    this.ancestors = options.ancestors || void 0;
    this.cause = options.cause || void 0;
    this.column = start2 ? start2.column : void 0;
    this.fatal = void 0;
    this.file = "";
    this.message = reason;
    this.line = start2 ? start2.line : void 0;
    this.name = stringifyPosition(options.place) || "1:1";
    this.place = options.place || void 0;
    this.reason = this.message;
    this.ruleId = options.ruleId || void 0;
    this.source = options.source || void 0;
    this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
    this.actual = void 0;
    this.expected = void 0;
    this.note = void 0;
    this.url = void 0;
  }
};
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.column = void 0;
VFileMessage.prototype.line = void 0;
VFileMessage.prototype.ancestors = void 0;
VFileMessage.prototype.cause = void 0;
VFileMessage.prototype.fatal = void 0;
VFileMessage.prototype.place = void 0;
VFileMessage.prototype.ruleId = void 0;
VFileMessage.prototype.source = void 0;

// node_modules/hast-util-to-jsx-runtime/lib/index.js
var own = {}.hasOwnProperty;
var emptyMap = /* @__PURE__ */ new Map();
var cap2 = /[A-Z]/g;
var tableElements2 = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]);
var tableCellElement = /* @__PURE__ */ new Set(["td", "th"]);
var docs = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function toJsxRuntime(tree, options) {
  if (!options || options.Fragment === void 0) {
    throw new TypeError("Expected `Fragment` in options");
  }
  const filePath = options.filePath || void 0;
  let create3;
  if (options.development) {
    if (typeof options.jsxDEV !== "function") {
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    }
    create3 = developmentCreate(filePath, options.jsxDEV);
  } else {
    if (typeof options.jsx !== "function") {
      throw new TypeError("Expected `jsx` in production options");
    }
    if (typeof options.jsxs !== "function") {
      throw new TypeError("Expected `jsxs` in production options");
    }
    create3 = productionCreate(filePath, options.jsx, options.jsxs);
  }
  const state = {
    Fragment: options.Fragment,
    ancestors: [],
    components: options.components || {},
    create: create3,
    elementAttributeNameCase: options.elementAttributeNameCase || "react",
    evaluater: options.createEvaluater ? options.createEvaluater() : void 0,
    filePath,
    ignoreInvalidStyle: options.ignoreInvalidStyle || false,
    passKeys: options.passKeys !== false,
    passNode: options.passNode || false,
    schema: options.space === "svg" ? svg3 : html3,
    stylePropertyNameCase: options.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: options.tableCellAlignToStyle !== false
  };
  const result = one(state, tree, void 0);
  if (result && typeof result !== "string") {
    return result;
  }
  return state.create(
    tree,
    state.Fragment,
    { children: result || void 0 },
    void 0
  );
}
function one(state, node2, key) {
  if (node2.type === "element") {
    return element(state, node2, key);
  }
  if (node2.type === "mdxFlowExpression" || node2.type === "mdxTextExpression") {
    return mdxExpression(state, node2);
  }
  if (node2.type === "mdxJsxFlowElement" || node2.type === "mdxJsxTextElement") {
    return mdxJsxElement(state, node2, key);
  }
  if (node2.type === "mdxjsEsm") {
    return mdxEsm(state, node2);
  }
  if (node2.type === "root") {
    return root(state, node2, key);
  }
  if (node2.type === "text") {
    return text(state, node2);
  }
}
function element(state, node2, key) {
  const parentSchema = state.schema;
  let schema = parentSchema;
  if (node2.tagName.toLowerCase() === "svg" && parentSchema.space === "html") {
    schema = svg3;
    state.schema = schema;
  }
  state.ancestors.push(node2);
  const type = findComponentFromName(state, node2.tagName, false);
  const props = createElementProps(state, node2);
  let children = createChildren2(state, node2);
  if (tableElements2.has(node2.tagName)) {
    children = children.filter(function(child) {
      return typeof child === "string" ? !whitespace(child) : true;
    });
  }
  addNode(state, props, type, node2);
  addChildren(props, children);
  state.ancestors.pop();
  state.schema = parentSchema;
  return state.create(node2, type, props, key);
}
function mdxExpression(state, node2) {
  if (node2.data && node2.data.estree && state.evaluater) {
    const program = node2.data.estree;
    const expression = program.body[0];
    ok(expression.type === "ExpressionStatement");
    return (
      /** @type {Child | undefined} */
      state.evaluater.evaluateExpression(expression.expression)
    );
  }
  crashEstree(state, node2.position);
}
function mdxEsm(state, node2) {
  if (node2.data && node2.data.estree && state.evaluater) {
    return (
      /** @type {Child | undefined} */
      state.evaluater.evaluateProgram(node2.data.estree)
    );
  }
  crashEstree(state, node2.position);
}
function mdxJsxElement(state, node2, key) {
  const parentSchema = state.schema;
  let schema = parentSchema;
  if (node2.name === "svg" && parentSchema.space === "html") {
    schema = svg3;
    state.schema = schema;
  }
  state.ancestors.push(node2);
  const type = node2.name === null ? state.Fragment : findComponentFromName(state, node2.name, true);
  const props = createJsxElementProps(state, node2);
  const children = createChildren2(state, node2);
  addNode(state, props, type, node2);
  addChildren(props, children);
  state.ancestors.pop();
  state.schema = parentSchema;
  return state.create(node2, type, props, key);
}
function root(state, node2, key) {
  const props = {};
  addChildren(props, createChildren2(state, node2));
  return state.create(node2, state.Fragment, props, key);
}
function text(_10, node2) {
  return node2.value;
}
function addNode(state, props, type, node2) {
  if (typeof type !== "string" && type !== state.Fragment && state.passNode) {
    props.node = node2;
  }
}
function addChildren(props, children) {
  if (children.length > 0) {
    const value = children.length > 1 ? children : children[0];
    if (value) {
      props.children = value;
    }
  }
}
function productionCreate(_10, jsx29, jsxs17) {
  return create3;
  function create3(_11, type, props, key) {
    const isStaticChildren = Array.isArray(props.children);
    const fn = isStaticChildren ? jsxs17 : jsx29;
    return key ? fn(type, props, key) : fn(type, props);
  }
}
function developmentCreate(filePath, jsxDEV) {
  return create3;
  function create3(node2, type, props, key) {
    const isStaticChildren = Array.isArray(props.children);
    const point5 = pointStart(node2);
    return jsxDEV(
      type,
      props,
      key,
      isStaticChildren,
      {
        columnNumber: point5 ? point5.column - 1 : void 0,
        fileName: filePath,
        lineNumber: point5 ? point5.line : void 0
      },
      void 0
    );
  }
}
function createElementProps(state, node2) {
  const props = {};
  let alignValue;
  let prop;
  for (prop in node2.properties) {
    if (prop !== "children" && own.call(node2.properties, prop)) {
      const result = createProperty(state, prop, node2.properties[prop]);
      if (result) {
        const [key, value] = result;
        if (state.tableCellAlignToStyle && key === "align" && typeof value === "string" && tableCellElement.has(node2.tagName)) {
          alignValue = value;
        } else {
          props[key] = value;
        }
      }
    }
  }
  if (alignValue) {
    const style2 = (
      /** @type {Style} */
      props.style || (props.style = {})
    );
    style2[state.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = alignValue;
  }
  return props;
}
function createJsxElementProps(state, node2) {
  const props = {};
  for (const attribute of node2.attributes) {
    if (attribute.type === "mdxJsxExpressionAttribute") {
      if (attribute.data && attribute.data.estree && state.evaluater) {
        const program = attribute.data.estree;
        const expression = program.body[0];
        ok(expression.type === "ExpressionStatement");
        const objectExpression = expression.expression;
        ok(objectExpression.type === "ObjectExpression");
        const property = objectExpression.properties[0];
        ok(property.type === "SpreadElement");
        Object.assign(
          props,
          state.evaluater.evaluateExpression(property.argument)
        );
      } else {
        crashEstree(state, node2.position);
      }
    } else {
      const name2 = attribute.name;
      let value;
      if (attribute.value && typeof attribute.value === "object") {
        if (attribute.value.data && attribute.value.data.estree && state.evaluater) {
          const program = attribute.value.data.estree;
          const expression = program.body[0];
          ok(expression.type === "ExpressionStatement");
          value = state.evaluater.evaluateExpression(expression.expression);
        } else {
          crashEstree(state, node2.position);
        }
      } else {
        value = attribute.value === null ? true : attribute.value;
      }
      props[name2] = /** @type {Props[keyof Props]} */
      value;
    }
  }
  return props;
}
function createChildren2(state, node2) {
  const children = [];
  let index4 = -1;
  const countsByName = state.passKeys ? /* @__PURE__ */ new Map() : emptyMap;
  while (++index4 < node2.children.length) {
    const child = node2.children[index4];
    let key;
    if (state.passKeys) {
      const name2 = child.type === "element" ? child.tagName : child.type === "mdxJsxFlowElement" || child.type === "mdxJsxTextElement" ? child.name : void 0;
      if (name2) {
        const count2 = countsByName.get(name2) || 0;
        key = name2 + "-" + count2;
        countsByName.set(name2, count2 + 1);
      }
    }
    const result = one(state, child, key);
    if (result !== void 0) children.push(result);
  }
  return children;
}
function createProperty(state, prop, value) {
  const info = find2(state.schema, prop);
  if (value === null || value === void 0 || typeof value === "number" && Number.isNaN(value)) {
    return;
  }
  if (Array.isArray(value)) {
    value = info.commaSeparated ? stringify2(value) : stringify(value);
  }
  if (info.property === "style") {
    let styleObject = typeof value === "object" ? value : parseStyle(state, String(value));
    if (state.stylePropertyNameCase === "css") {
      styleObject = transformStylesToCssCasing(styleObject);
    }
    return ["style", styleObject];
  }
  return [
    state.elementAttributeNameCase === "react" && info.space ? hastToReact[info.property] || info.property : info.attribute,
    value
  ];
}
function parseStyle(state, value) {
  try {
    return (0, import_style_to_js.default)(value, { reactCompat: true });
  } catch (error2) {
    if (state.ignoreInvalidStyle) {
      return {};
    }
    const cause = (
      /** @type {Error} */
      error2
    );
    const message = new VFileMessage("Cannot parse `style` attribute", {
      ancestors: state.ancestors,
      cause,
      ruleId: "style",
      source: "hast-util-to-jsx-runtime"
    });
    message.file = state.filePath || void 0;
    message.url = docs + "#cannot-parse-style-attribute";
    throw message;
  }
}
function findComponentFromName(state, name2, allowExpression) {
  let result;
  if (!allowExpression) {
    result = { type: "Literal", value: name2 };
  } else if (name2.includes(".")) {
    const identifiers = name2.split(".");
    let index4 = -1;
    let node2;
    while (++index4 < identifiers.length) {
      const prop = name(identifiers[index4]) ? { type: "Identifier", name: identifiers[index4] } : { type: "Literal", value: identifiers[index4] };
      node2 = node2 ? {
        type: "MemberExpression",
        object: node2,
        property: prop,
        computed: Boolean(index4 && prop.type === "Literal"),
        optional: false
      } : prop;
    }
    ok(node2, "always a result");
    result = node2;
  } else {
    result = name(name2) && !/^[a-z]/.test(name2) ? { type: "Identifier", name: name2 } : { type: "Literal", value: name2 };
  }
  if (result.type === "Literal") {
    const name3 = (
      /** @type {string | number} */
      result.value
    );
    return own.call(state.components, name3) ? state.components[name3] : name3;
  }
  if (state.evaluater) {
    return state.evaluater.evaluateExpression(result);
  }
  crashEstree(state);
}
function crashEstree(state, place) {
  const message = new VFileMessage(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: state.ancestors,
      place,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  message.file = state.filePath || void 0;
  message.url = docs + "#cannot-handle-mdx-estrees-without-createevaluater";
  throw message;
}
function transformStylesToCssCasing(domCasing) {
  const cssCasing = {};
  let from;
  for (from in domCasing) {
    if (own.call(domCasing, from)) {
      cssCasing[transformStyleToCssCasing(from)] = domCasing[from];
    }
  }
  return cssCasing;
}
function transformStyleToCssCasing(from) {
  let to = from.replace(cap2, toDash);
  if (to.slice(0, 3) === "ms-") to = "-" + to;
  return to;
}
function toDash($0) {
  return "-" + $0.toLowerCase();
}

// node_modules/html-url-attributes/lib/index.js
var urlAttributes = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
};

// node_modules/@copilotkit/react-ui/node_modules/react-markdown/lib/index.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_react149 = __toESM(require_react(), 1);

// node_modules/mdast-util-to-string/lib/index.js
var emptyOptions2 = {};
function toString(value, options) {
  const settings = options || emptyOptions2;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one2(value, includeImageAlt, includeHtml);
}
function one2(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all(values2, includeImageAlt, includeHtml) {
  const result = [];
  let index4 = -1;
  while (++index4 < values2.length) {
    result[index4] = one2(values2[index4], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value) {
  return Boolean(value && typeof value === "object");
}

// node_modules/micromark-util-symbol/lib/codes.js
var codes = (
  /** @type {const} */
  {
    carriageReturn: -5,
    lineFeed: -4,
    carriageReturnLineFeed: -3,
    horizontalTab: -2,
    virtualSpace: -1,
    eof: null,
    nul: 0,
    soh: 1,
    stx: 2,
    etx: 3,
    eot: 4,
    enq: 5,
    ack: 6,
    bel: 7,
    bs: 8,
    ht: 9,
    // `\t`
    lf: 10,
    // `\n`
    vt: 11,
    // `\v`
    ff: 12,
    // `\f`
    cr: 13,
    // `\r`
    so: 14,
    si: 15,
    dle: 16,
    dc1: 17,
    dc2: 18,
    dc3: 19,
    dc4: 20,
    nak: 21,
    syn: 22,
    etb: 23,
    can: 24,
    em: 25,
    sub: 26,
    esc: 27,
    fs: 28,
    gs: 29,
    rs: 30,
    us: 31,
    space: 32,
    exclamationMark: 33,
    // `!`
    quotationMark: 34,
    // `"`
    numberSign: 35,
    // `#`
    dollarSign: 36,
    // `$`
    percentSign: 37,
    // `%`
    ampersand: 38,
    // `&`
    apostrophe: 39,
    // `'`
    leftParenthesis: 40,
    // `(`
    rightParenthesis: 41,
    // `)`
    asterisk: 42,
    // `*`
    plusSign: 43,
    // `+`
    comma: 44,
    // `,`
    dash: 45,
    // `-`
    dot: 46,
    // `.`
    slash: 47,
    // `/`
    digit0: 48,
    // `0`
    digit1: 49,
    // `1`
    digit2: 50,
    // `2`
    digit3: 51,
    // `3`
    digit4: 52,
    // `4`
    digit5: 53,
    // `5`
    digit6: 54,
    // `6`
    digit7: 55,
    // `7`
    digit8: 56,
    // `8`
    digit9: 57,
    // `9`
    colon: 58,
    // `:`
    semicolon: 59,
    // `;`
    lessThan: 60,
    // `<`
    equalsTo: 61,
    // `=`
    greaterThan: 62,
    // `>`
    questionMark: 63,
    // `?`
    atSign: 64,
    // `@`
    uppercaseA: 65,
    // `A`
    uppercaseB: 66,
    // `B`
    uppercaseC: 67,
    // `C`
    uppercaseD: 68,
    // `D`
    uppercaseE: 69,
    // `E`
    uppercaseF: 70,
    // `F`
    uppercaseG: 71,
    // `G`
    uppercaseH: 72,
    // `H`
    uppercaseI: 73,
    // `I`
    uppercaseJ: 74,
    // `J`
    uppercaseK: 75,
    // `K`
    uppercaseL: 76,
    // `L`
    uppercaseM: 77,
    // `M`
    uppercaseN: 78,
    // `N`
    uppercaseO: 79,
    // `O`
    uppercaseP: 80,
    // `P`
    uppercaseQ: 81,
    // `Q`
    uppercaseR: 82,
    // `R`
    uppercaseS: 83,
    // `S`
    uppercaseT: 84,
    // `T`
    uppercaseU: 85,
    // `U`
    uppercaseV: 86,
    // `V`
    uppercaseW: 87,
    // `W`
    uppercaseX: 88,
    // `X`
    uppercaseY: 89,
    // `Y`
    uppercaseZ: 90,
    // `Z`
    leftSquareBracket: 91,
    // `[`
    backslash: 92,
    // `\`
    rightSquareBracket: 93,
    // `]`
    caret: 94,
    // `^`
    underscore: 95,
    // `_`
    graveAccent: 96,
    // `` ` ``
    lowercaseA: 97,
    // `a`
    lowercaseB: 98,
    // `b`
    lowercaseC: 99,
    // `c`
    lowercaseD: 100,
    // `d`
    lowercaseE: 101,
    // `e`
    lowercaseF: 102,
    // `f`
    lowercaseG: 103,
    // `g`
    lowercaseH: 104,
    // `h`
    lowercaseI: 105,
    // `i`
    lowercaseJ: 106,
    // `j`
    lowercaseK: 107,
    // `k`
    lowercaseL: 108,
    // `l`
    lowercaseM: 109,
    // `m`
    lowercaseN: 110,
    // `n`
    lowercaseO: 111,
    // `o`
    lowercaseP: 112,
    // `p`
    lowercaseQ: 113,
    // `q`
    lowercaseR: 114,
    // `r`
    lowercaseS: 115,
    // `s`
    lowercaseT: 116,
    // `t`
    lowercaseU: 117,
    // `u`
    lowercaseV: 118,
    // `v`
    lowercaseW: 119,
    // `w`
    lowercaseX: 120,
    // `x`
    lowercaseY: 121,
    // `y`
    lowercaseZ: 122,
    // `z`
    leftCurlyBrace: 123,
    // `{`
    verticalBar: 124,
    // `|`
    rightCurlyBrace: 125,
    // `}`
    tilde: 126,
    // `~`
    del: 127,
    // Unicode Specials block.
    byteOrderMarker: 65279,
    // Unicode Specials block.
    replacementCharacter: 65533
    // ``
  }
);

// node_modules/micromark-util-symbol/lib/constants.js
var constants = (
  /** @type {const} */
  {
    attentionSideAfter: 2,
    // Symbol to mark an attention sequence as after content: `a*`
    attentionSideBefore: 1,
    // Symbol to mark an attention sequence as before content: `*a`
    atxHeadingOpeningFenceSizeMax: 6,
    // 6 number signs is fine, 7 isnt.
    autolinkDomainSizeMax: 63,
    // 63 characters is fine, 64 is too many.
    autolinkSchemeSizeMax: 32,
    // 32 characters is fine, 33 is too many.
    cdataOpeningString: "CDATA[",
    // And preceded by `<![`.
    characterGroupPunctuation: 2,
    // Symbol used to indicate a character is punctuation
    characterGroupWhitespace: 1,
    // Symbol used to indicate a character is whitespace
    characterReferenceDecimalSizeMax: 7,
    // `&#9999999;`.
    characterReferenceHexadecimalSizeMax: 6,
    // `&#xff9999;`.
    characterReferenceNamedSizeMax: 31,
    // `&CounterClockwiseContourIntegral;`.
    codeFencedSequenceSizeMin: 3,
    // At least 3 ticks or tildes are needed.
    contentTypeContent: "content",
    contentTypeDocument: "document",
    contentTypeFlow: "flow",
    contentTypeString: "string",
    contentTypeText: "text",
    hardBreakPrefixSizeMin: 2,
    // At least 2 trailing spaces are needed.
    htmlBasic: 6,
    // Symbol for `<div`
    htmlCdata: 5,
    // Symbol for `<![CDATA[]]>`
    htmlComment: 2,
    // Symbol for `<!---->`
    htmlComplete: 7,
    // Symbol for `<x>`
    htmlDeclaration: 4,
    // Symbol for `<!doctype>`
    htmlInstruction: 3,
    // Symbol for `<?php?>`
    htmlRawSizeMax: 8,
    // Length of `textarea`.
    htmlRaw: 1,
    // Symbol for `<script>`
    linkResourceDestinationBalanceMax: 32,
    // See: <https://spec.commonmark.org/0.30/#link-destination>, <https://github.com/remarkjs/react-markdown/issues/658#issuecomment-984345577>
    linkReferenceSizeMax: 999,
    // See: <https://spec.commonmark.org/0.30/#link-label>
    listItemValueSizeMax: 10,
    // See: <https://spec.commonmark.org/0.30/#ordered-list-marker>
    numericBaseDecimal: 10,
    numericBaseHexadecimal: 16,
    tabSize: 4,
    // Tabs have a hard-coded size of 4, per CommonMark.
    thematicBreakMarkerCountMin: 3,
    // At least 3 asterisks, dashes, or underscores are needed.
    v8MaxSafeChunkSize: 1e4
    // V8 (and potentially others) have problems injecting giant arrays into other arrays, hence we operate in chunks.
  }
);

// node_modules/micromark-util-symbol/lib/types.js
var types = (
  /** @type {const} */
  {
    // Generic type for data, such as in a title, a destination, etc.
    data: "data",
    // Generic type for syntactic whitespace (tabs, virtual spaces, spaces).
    // Such as, between a fenced code fence and an info string.
    whitespace: "whitespace",
    // Generic type for line endings (line feed, carriage return, carriage return +
    // line feed).
    lineEnding: "lineEnding",
    // A line ending, but ending a blank line.
    lineEndingBlank: "lineEndingBlank",
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a
    // line.
    linePrefix: "linePrefix",
    // Generic type for whitespace (tabs, virtual spaces, spaces) at the end of a
    // line.
    lineSuffix: "lineSuffix",
    // Whole ATX heading:
    //
    // ```markdown
    // #
    // ## Alpha
    // ### Bravo ###
    // ```
    //
    // Includes `atxHeadingSequence`, `whitespace`, `atxHeadingText`.
    atxHeading: "atxHeading",
    // Sequence of number signs in an ATX heading (`###`).
    atxHeadingSequence: "atxHeadingSequence",
    // Content in an ATX heading (`alpha`).
    // Includes text.
    atxHeadingText: "atxHeadingText",
    // Whole autolink (`<https://example.com>` or `<admin@example.com>`)
    // Includes `autolinkMarker` and `autolinkProtocol` or `autolinkEmail`.
    autolink: "autolink",
    // Email autolink w/o markers (`admin@example.com`)
    autolinkEmail: "autolinkEmail",
    // Marker around an `autolinkProtocol` or `autolinkEmail` (`<` or `>`).
    autolinkMarker: "autolinkMarker",
    // Protocol autolink w/o markers (`https://example.com`)
    autolinkProtocol: "autolinkProtocol",
    // A whole character escape (`\-`).
    // Includes `escapeMarker` and `characterEscapeValue`.
    characterEscape: "characterEscape",
    // The escaped character (`-`).
    characterEscapeValue: "characterEscapeValue",
    // A whole character reference (`&amp;`, `&#8800;`, or `&#x1D306;`).
    // Includes `characterReferenceMarker`, an optional
    // `characterReferenceMarkerNumeric`, in which case an optional
    // `characterReferenceMarkerHexadecimal`, and a `characterReferenceValue`.
    characterReference: "characterReference",
    // The start or end marker (`&` or `;`).
    characterReferenceMarker: "characterReferenceMarker",
    // Mark reference as numeric (`#`).
    characterReferenceMarkerNumeric: "characterReferenceMarkerNumeric",
    // Mark reference as numeric (`x` or `X`).
    characterReferenceMarkerHexadecimal: "characterReferenceMarkerHexadecimal",
    // Value of character reference w/o markers (`amp`, `8800`, or `1D306`).
    characterReferenceValue: "characterReferenceValue",
    // Whole fenced code:
    //
    // ````markdown
    // ```js
    // alert(1)
    // ```
    // ````
    codeFenced: "codeFenced",
    // A fenced code fence, including whitespace, sequence, info, and meta
    // (` ```js `).
    codeFencedFence: "codeFencedFence",
    // Sequence of grave accent or tilde characters (` ``` `) in a fence.
    codeFencedFenceSequence: "codeFencedFenceSequence",
    // Info word (`js`) in a fence.
    // Includes string.
    codeFencedFenceInfo: "codeFencedFenceInfo",
    // Meta words (`highlight="1"`) in a fence.
    // Includes string.
    codeFencedFenceMeta: "codeFencedFenceMeta",
    // A line of code.
    codeFlowValue: "codeFlowValue",
    // Whole indented code:
    //
    // ```markdown
    //     alert(1)
    // ```
    //
    // Includes `lineEnding`, `linePrefix`, and `codeFlowValue`.
    codeIndented: "codeIndented",
    // A text code (``` `alpha` ```).
    // Includes `codeTextSequence`, `codeTextData`, `lineEnding`, and can include
    // `codeTextPadding`.
    codeText: "codeText",
    codeTextData: "codeTextData",
    // A space or line ending right after or before a tick.
    codeTextPadding: "codeTextPadding",
    // A text code fence (` `` `).
    codeTextSequence: "codeTextSequence",
    // Whole content:
    //
    // ```markdown
    // [a]: b
    // c
    // =
    // d
    // ```
    //
    // Includes `paragraph` and `definition`.
    content: "content",
    // Whole definition:
    //
    // ```markdown
    // [micromark]: https://github.com/micromark/micromark
    // ```
    //
    // Includes `definitionLabel`, `definitionMarker`, `whitespace`,
    // `definitionDestination`, and optionally `lineEnding` and `definitionTitle`.
    definition: "definition",
    // Destination of a definition (`https://github.com/micromark/micromark` or
    // `<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteral` or `definitionDestinationRaw`.
    definitionDestination: "definitionDestination",
    // Enclosed destination of a definition
    // (`<https://github.com/micromark/micromark>`).
    // Includes `definitionDestinationLiteralMarker` and optionally
    // `definitionDestinationString`.
    definitionDestinationLiteral: "definitionDestinationLiteral",
    // Markers of an enclosed definition destination (`<` or `>`).
    definitionDestinationLiteralMarker: "definitionDestinationLiteralMarker",
    // Unenclosed destination of a definition
    // (`https://github.com/micromark/micromark`).
    // Includes `definitionDestinationString`.
    definitionDestinationRaw: "definitionDestinationRaw",
    // Text in an destination (`https://github.com/micromark/micromark`).
    // Includes string.
    definitionDestinationString: "definitionDestinationString",
    // Label of a definition (`[micromark]`).
    // Includes `definitionLabelMarker` and `definitionLabelString`.
    definitionLabel: "definitionLabel",
    // Markers of a definition label (`[` or `]`).
    definitionLabelMarker: "definitionLabelMarker",
    // Value of a definition label (`micromark`).
    // Includes string.
    definitionLabelString: "definitionLabelString",
    // Marker between a label and a destination (`:`).
    definitionMarker: "definitionMarker",
    // Title of a definition (`"x"`, `'y'`, or `(z)`).
    // Includes `definitionTitleMarker` and optionally `definitionTitleString`.
    definitionTitle: "definitionTitle",
    // Marker around a title of a definition (`"`, `'`, `(`, or `)`).
    definitionTitleMarker: "definitionTitleMarker",
    // Data without markers in a title (`z`).
    // Includes string.
    definitionTitleString: "definitionTitleString",
    // Emphasis (`*alpha*`).
    // Includes `emphasisSequence` and `emphasisText`.
    emphasis: "emphasis",
    // Sequence of emphasis markers (`*` or `_`).
    emphasisSequence: "emphasisSequence",
    // Emphasis text (`alpha`).
    // Includes text.
    emphasisText: "emphasisText",
    // The character escape marker (`\`).
    escapeMarker: "escapeMarker",
    // A hard break created with a backslash (`\\n`).
    // Note: does not include the line ending.
    hardBreakEscape: "hardBreakEscape",
    // A hard break created with trailing spaces (`  \n`).
    // Does not include the line ending.
    hardBreakTrailing: "hardBreakTrailing",
    // Flow HTML:
    //
    // ```markdown
    // <div
    // ```
    //
    // Inlcudes `lineEnding`, `htmlFlowData`.
    htmlFlow: "htmlFlow",
    htmlFlowData: "htmlFlowData",
    // HTML in text (the tag in `a <i> b`).
    // Includes `lineEnding`, `htmlTextData`.
    htmlText: "htmlText",
    htmlTextData: "htmlTextData",
    // Whole image (`![alpha](bravo)`, `![alpha][bravo]`, `![alpha][]`, or
    // `![alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    image: "image",
    // Whole link label (`[*alpha*]`).
    // Includes `labelLink` or `labelImage`, `labelText`, and `labelEnd`.
    label: "label",
    // Text in an label (`*alpha*`).
    // Includes text.
    labelText: "labelText",
    // Start a link label (`[`).
    // Includes a `labelMarker`.
    labelLink: "labelLink",
    // Start an image label (`![`).
    // Includes `labelImageMarker` and `labelMarker`.
    labelImage: "labelImage",
    // Marker of a label (`[` or `]`).
    labelMarker: "labelMarker",
    // Marker to start an image (`!`).
    labelImageMarker: "labelImageMarker",
    // End a label (`]`).
    // Includes `labelMarker`.
    labelEnd: "labelEnd",
    // Whole link (`[alpha](bravo)`, `[alpha][bravo]`, `[alpha][]`, or `[alpha]`).
    // Includes `label` and an optional `resource` or `reference`.
    link: "link",
    // Whole paragraph:
    //
    // ```markdown
    // alpha
    // bravo.
    // ```
    //
    // Includes text.
    paragraph: "paragraph",
    // A reference (`[alpha]` or `[]`).
    // Includes `referenceMarker` and an optional `referenceString`.
    reference: "reference",
    // A reference marker (`[` or `]`).
    referenceMarker: "referenceMarker",
    // Reference text (`alpha`).
    // Includes string.
    referenceString: "referenceString",
    // A resource (`(https://example.com "alpha")`).
    // Includes `resourceMarker`, an optional `resourceDestination` with an optional
    // `whitespace` and `resourceTitle`.
    resource: "resource",
    // A resource destination (`https://example.com`).
    // Includes `resourceDestinationLiteral` or `resourceDestinationRaw`.
    resourceDestination: "resourceDestination",
    // A literal resource destination (`<https://example.com>`).
    // Includes `resourceDestinationLiteralMarker` and optionally
    // `resourceDestinationString`.
    resourceDestinationLiteral: "resourceDestinationLiteral",
    // A resource destination marker (`<` or `>`).
    resourceDestinationLiteralMarker: "resourceDestinationLiteralMarker",
    // A raw resource destination (`https://example.com`).
    // Includes `resourceDestinationString`.
    resourceDestinationRaw: "resourceDestinationRaw",
    // Resource destination text (`https://example.com`).
    // Includes string.
    resourceDestinationString: "resourceDestinationString",
    // A resource marker (`(` or `)`).
    resourceMarker: "resourceMarker",
    // A resource title (`"alpha"`, `'alpha'`, or `(alpha)`).
    // Includes `resourceTitleMarker` and optionally `resourceTitleString`.
    resourceTitle: "resourceTitle",
    // A resource title marker (`"`, `'`, `(`, or `)`).
    resourceTitleMarker: "resourceTitleMarker",
    // Resource destination title (`alpha`).
    // Includes string.
    resourceTitleString: "resourceTitleString",
    // Whole setext heading:
    //
    // ```markdown
    // alpha
    // bravo
    // =====
    // ```
    //
    // Includes `setextHeadingText`, `lineEnding`, `linePrefix`, and
    // `setextHeadingLine`.
    setextHeading: "setextHeading",
    // Content in a setext heading (`alpha\nbravo`).
    // Includes text.
    setextHeadingText: "setextHeadingText",
    // Underline in a setext heading, including whitespace suffix (`==`).
    // Includes `setextHeadingLineSequence`.
    setextHeadingLine: "setextHeadingLine",
    // Sequence of equals or dash characters in underline in a setext heading (`-`).
    setextHeadingLineSequence: "setextHeadingLineSequence",
    // Strong (`**alpha**`).
    // Includes `strongSequence` and `strongText`.
    strong: "strong",
    // Sequence of strong markers (`**` or `__`).
    strongSequence: "strongSequence",
    // Strong text (`alpha`).
    // Includes text.
    strongText: "strongText",
    // Whole thematic break:
    //
    // ```markdown
    // * * *
    // ```
    //
    // Includes `thematicBreakSequence` and `whitespace`.
    thematicBreak: "thematicBreak",
    // A sequence of one or more thematic break markers (`***`).
    thematicBreakSequence: "thematicBreakSequence",
    // Whole block quote:
    //
    // ```markdown
    // > a
    // >
    // > b
    // ```
    //
    // Includes `blockQuotePrefix` and flow.
    blockQuote: "blockQuote",
    // The `>` or `> ` of a block quote.
    blockQuotePrefix: "blockQuotePrefix",
    // The `>` of a block quote prefix.
    blockQuoteMarker: "blockQuoteMarker",
    // The optional ` ` of a block quote prefix.
    blockQuotePrefixWhitespace: "blockQuotePrefixWhitespace",
    // Whole ordered list:
    //
    // ```markdown
    // 1. a
    //    b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listOrdered: "listOrdered",
    // Whole unordered list:
    //
    // ```markdown
    // - a
    //   b
    // ```
    //
    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
    // lines.
    listUnordered: "listUnordered",
    // The indent of further list item lines.
    listItemIndent: "listItemIndent",
    // A marker, as in, `*`, `+`, `-`, `.`, or `)`.
    listItemMarker: "listItemMarker",
    // The thing that starts a list item, such as `1. `.
    // Includes `listItemValue` if ordered, `listItemMarker`, and
    // `listItemPrefixWhitespace` (unless followed by a line ending).
    listItemPrefix: "listItemPrefix",
    // The whitespace after a marker.
    listItemPrefixWhitespace: "listItemPrefixWhitespace",
    // The numerical value of an ordered item.
    listItemValue: "listItemValue",
    // Internal types used for subtokenizers, compiled away
    chunkDocument: "chunkDocument",
    chunkContent: "chunkContent",
    chunkFlow: "chunkFlow",
    chunkText: "chunkText",
    chunkString: "chunkString"
  }
);

// node_modules/micromark-util-symbol/lib/values.js
var values = (
  /** @type {const} */
  {
    ht: "	",
    lf: "\n",
    cr: "\r",
    space: " ",
    exclamationMark: "!",
    quotationMark: '"',
    numberSign: "#",
    dollarSign: "$",
    percentSign: "%",
    ampersand: "&",
    apostrophe: "'",
    leftParenthesis: "(",
    rightParenthesis: ")",
    asterisk: "*",
    plusSign: "+",
    comma: ",",
    dash: "-",
    dot: ".",
    slash: "/",
    digit0: "0",
    digit1: "1",
    digit2: "2",
    digit3: "3",
    digit4: "4",
    digit5: "5",
    digit6: "6",
    digit7: "7",
    digit8: "8",
    digit9: "9",
    colon: ":",
    semicolon: ";",
    lessThan: "<",
    equalsTo: "=",
    greaterThan: ">",
    questionMark: "?",
    atSign: "@",
    uppercaseA: "A",
    uppercaseB: "B",
    uppercaseC: "C",
    uppercaseD: "D",
    uppercaseE: "E",
    uppercaseF: "F",
    uppercaseG: "G",
    uppercaseH: "H",
    uppercaseI: "I",
    uppercaseJ: "J",
    uppercaseK: "K",
    uppercaseL: "L",
    uppercaseM: "M",
    uppercaseN: "N",
    uppercaseO: "O",
    uppercaseP: "P",
    uppercaseQ: "Q",
    uppercaseR: "R",
    uppercaseS: "S",
    uppercaseT: "T",
    uppercaseU: "U",
    uppercaseV: "V",
    uppercaseW: "W",
    uppercaseX: "X",
    uppercaseY: "Y",
    uppercaseZ: "Z",
    leftSquareBracket: "[",
    backslash: "\\",
    rightSquareBracket: "]",
    caret: "^",
    underscore: "_",
    graveAccent: "`",
    lowercaseA: "a",
    lowercaseB: "b",
    lowercaseC: "c",
    lowercaseD: "d",
    lowercaseE: "e",
    lowercaseF: "f",
    lowercaseG: "g",
    lowercaseH: "h",
    lowercaseI: "i",
    lowercaseJ: "j",
    lowercaseK: "k",
    lowercaseL: "l",
    lowercaseM: "m",
    lowercaseN: "n",
    lowercaseO: "o",
    lowercaseP: "p",
    lowercaseQ: "q",
    lowercaseR: "r",
    lowercaseS: "s",
    lowercaseT: "t",
    lowercaseU: "u",
    lowercaseV: "v",
    lowercaseW: "w",
    lowercaseX: "x",
    lowercaseY: "y",
    lowercaseZ: "z",
    leftCurlyBrace: "{",
    verticalBar: "|",
    rightCurlyBrace: "}",
    tilde: "~",
    replacementCharacter: ""
  }
);

// node_modules/micromark-util-chunked/dev/index.js
function splice(list4, start2, remove, items) {
  const end = list4.length;
  let chunkStart = 0;
  let parameters;
  if (start2 < 0) {
    start2 = -start2 > end ? 0 : end + start2;
  } else {
    start2 = start2 > end ? end : start2;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < constants.v8MaxSafeChunkSize) {
    parameters = Array.from(items);
    parameters.unshift(start2, remove);
    list4.splice(...parameters);
  } else {
    if (remove) list4.splice(start2, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(
        chunkStart,
        chunkStart + constants.v8MaxSafeChunkSize
      );
      parameters.unshift(start2, 0);
      list4.splice(...parameters);
      chunkStart += constants.v8MaxSafeChunkSize;
      start2 += constants.v8MaxSafeChunkSize;
    }
  }
}
function push(list4, items) {
  if (list4.length > 0) {
    splice(list4, list4.length, 0, items);
    return list4;
  }
  return items;
}

// node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all5 = {};
  let index4 = -1;
  while (++index4 < extensions.length) {
    syntaxExtension(all5, extensions[index4]);
  }
  return all5;
}
function syntaxExtension(all5, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all5, hook) ? all5[hook] : void 0;
    const left = maybe || (all5[hook] = {});
    const right = extension2[hook];
    let code4;
    if (right) {
      for (code4 in right) {
        if (!hasOwnProperty.call(left, code4)) left[code4] = [];
        const value = right[code4];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code4],
          Array.isArray(value) ? value : value ? [value] : []
        );
      }
    }
  }
}
function constructs(existing, list4) {
  let index4 = -1;
  const before = [];
  while (++index4 < list4.length) {
    ;
    (list4[index4].add === "after" ? existing : before).push(list4[index4]);
  }
  splice(existing, 0, 0, before);
}

// node_modules/micromark-util-decode-numeric-character-reference/dev/index.js
function decodeNumericCharacterReference(value, base) {
  const code4 = Number.parseInt(value, base);
  if (
    // C0 except for HT, LF, FF, CR, space.
    code4 < codes.ht || code4 === codes.vt || code4 > codes.cr && code4 < codes.space || // Control character (DEL) of C0, and C1 controls.
    code4 > codes.tilde && code4 < 160 || // Lone high surrogates and low surrogates.
    code4 > 55295 && code4 < 57344 || // Noncharacters.
    code4 > 64975 && code4 < 65008 || /* eslint-disable no-bitwise */
    (code4 & 65535) === 65535 || (code4 & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    code4 > 1114111
  ) {
    return values.replacementCharacter;
  }
  return String.fromCodePoint(code4);
}

// node_modules/micromark-util-normalize-identifier/dev/index.js
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, values.space).replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// node_modules/micromark-util-character/dev/index.js
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code4) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code4 !== null && (code4 < codes.space || code4 === codes.del)
  );
}
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(code4) {
  return code4 !== null && code4 < codes.horizontalTab;
}
function markdownLineEndingOrSpace(code4) {
  return code4 !== null && (code4 < codes.nul || code4 === codes.space);
}
function markdownSpace(code4) {
  return code4 === codes.horizontalTab || code4 === codes.virtualSpace || code4 === codes.space;
}
var unicodePunctuation = regexCheck(new RegExp("\\p{P}|\\p{S}", "u"));
var unicodeWhitespace = regexCheck(/\s/);
function regexCheck(regex) {
  return check;
  function check(code4) {
    return code4 !== null && code4 > -1 && regex.test(String.fromCharCode(code4));
  }
}

// node_modules/micromark-util-sanitize-uri/dev/index.js
function normalizeUri(value) {
  const result = [];
  let index4 = -1;
  let start2 = 0;
  let skip = 0;
  while (++index4 < value.length) {
    const code4 = value.charCodeAt(index4);
    let replace2 = "";
    if (code4 === codes.percentSign && asciiAlphanumeric(value.charCodeAt(index4 + 1)) && asciiAlphanumeric(value.charCodeAt(index4 + 2))) {
      skip = 2;
    } else if (code4 < 128) {
      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code4))) {
        replace2 = String.fromCharCode(code4);
      }
    } else if (code4 > 55295 && code4 < 57344) {
      const next2 = value.charCodeAt(index4 + 1);
      if (code4 < 56320 && next2 > 56319 && next2 < 57344) {
        replace2 = String.fromCharCode(code4, next2);
        skip = 1;
      } else {
        replace2 = values.replacementCharacter;
      }
    } else {
      replace2 = String.fromCharCode(code4);
    }
    if (replace2) {
      result.push(value.slice(start2, index4), encodeURIComponent(replace2));
      start2 = index4 + skip + 1;
      replace2 = "";
    }
    if (skip) {
      index4 += skip;
      skip = 0;
    }
  }
  return result.join("") + value.slice(start2);
}

// node_modules/micromark/dev/lib/compile.js
var hasOwnProperty2 = {}.hasOwnProperty;

// node_modules/micromark-factory-space/dev/index.js
function factorySpace(effects, ok3, type, max2) {
  const limit = max2 ? max2 - 1 : Number.POSITIVE_INFINITY;
  let size4 = 0;
  return start2;
  function start2(code4) {
    if (markdownSpace(code4)) {
      effects.enter(type);
      return prefix(code4);
    }
    return ok3(code4);
  }
  function prefix(code4) {
    if (markdownSpace(code4) && size4++ < limit) {
      effects.consume(code4);
      return prefix;
    }
    effects.exit(type);
    return ok3(code4);
  }
}

// node_modules/micromark/dev/lib/initialize/content.js
var content = { tokenize: initializeContent };
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  let previous4;
  return contentStart;
  function afterContentStartConstruct(code4) {
    ok(
      code4 === codes.eof || markdownLineEnding(code4),
      "expected eol or eof"
    );
    if (code4 === codes.eof) {
      effects.consume(code4);
      return;
    }
    effects.enter(types.lineEnding);
    effects.consume(code4);
    effects.exit(types.lineEnding);
    return factorySpace(effects, contentStart, types.linePrefix);
  }
  function paragraphInitial(code4) {
    ok(
      code4 !== codes.eof && !markdownLineEnding(code4),
      "expected anything other than a line ending or EOF"
    );
    effects.enter(types.paragraph);
    return lineStart(code4);
  }
  function lineStart(code4) {
    const token = effects.enter(types.chunkText, {
      contentType: constants.contentTypeText,
      previous: previous4
    });
    if (previous4) {
      previous4.next = token;
    }
    previous4 = token;
    return data(code4);
  }
  function data(code4) {
    if (code4 === codes.eof) {
      effects.exit(types.chunkText);
      effects.exit(types.paragraph);
      effects.consume(code4);
      return;
    }
    if (markdownLineEnding(code4)) {
      effects.consume(code4);
      effects.exit(types.chunkText);
      return lineStart;
    }
    effects.consume(code4);
    return data;
  }
}

// node_modules/micromark/dev/lib/initialize/document.js
var document2 = { tokenize: initializeDocument };
var containerConstruct = { tokenize: tokenizeContainer };
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start2;
  function start2(code4) {
    if (continued < stack.length) {
      const item = stack[continued];
      self2.containerState = item[1];
      ok(
        item[0].continuation,
        "expected `continuation` to be defined on container construct"
      );
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code4);
    }
    return checkNewContainers(code4);
  }
  function documentContinue(code4) {
    ok(
      self2.containerState,
      "expected `containerState` to be defined after continuation"
    );
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point5;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types.chunkFlow) {
          point5 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      ok(point5, "could not find previous flow chunk");
      exitContainers(continued);
      let index4 = indexBeforeExits;
      while (index4 < self2.events.length) {
        self2.events[index4][1].end = { ...point5 };
        index4++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index4;
      return checkNewContainers(code4);
    }
    return start2(code4);
  }
  function checkNewContainers(code4) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code4);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code4);
      }
      self2.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }
    self2.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code4);
  }
  function thereIsANewContainer(code4) {
    if (childFlow) closeFlow();
    exitContainers(continued);
    return documentContinued(code4);
  }
  function thereIsNoNewContainer(code4) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code4);
  }
  function documentContinued(code4) {
    self2.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code4);
  }
  function containerContinue(code4) {
    ok(
      self2.currentConstruct,
      "expected `currentConstruct` to be defined on tokenizer"
    );
    ok(
      self2.containerState,
      "expected `containerState` to be defined on tokenizer"
    );
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code4);
  }
  function flowStart(code4) {
    if (code4 === codes.eof) {
      if (childFlow) closeFlow();
      exitContainers(0);
      effects.consume(code4);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter(types.chunkFlow, {
      _tokenizer: childFlow,
      contentType: constants.contentTypeFlow,
      previous: childToken
    });
    return flowContinue(code4);
  }
  function flowContinue(code4) {
    if (code4 === codes.eof) {
      writeToChild(effects.exit(types.chunkFlow), true);
      exitContainers(0);
      effects.consume(code4);
      return;
    }
    if (markdownLineEnding(code4)) {
      effects.consume(code4);
      writeToChild(effects.exit(types.chunkFlow));
      continued = 0;
      self2.interrupt = void 0;
      return start2;
    }
    effects.consume(code4);
    return flowContinue;
  }
  function writeToChild(token, endOfFile) {
    ok(childFlow, "expected `childFlow` to be defined when continuing");
    const stream = self2.sliceStream(token);
    if (endOfFile) stream.push(null);
    token.previous = childToken;
    if (childToken) childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token.start.line]) {
      let index4 = childFlow.events.length;
      while (index4--) {
        if (
          // The token starts before the line ending
          childFlow.events[index4][1].start.offset < lineStartOffset && // and either is not ended yet
          (!childFlow.events[index4][1].end || // or ends after it.
          childFlow.events[index4][1].end.offset > lineStartOffset)
        ) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point5;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === types.chunkFlow) {
          if (seen) {
            point5 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      ok(point5, "could not find previous flow chunk");
      exitContainers(continued);
      index4 = indexBeforeExits;
      while (index4 < self2.events.length) {
        self2.events[index4][1].end = { ...point5 };
        index4++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index4;
    }
  }
  function exitContainers(size4) {
    let index4 = stack.length;
    while (index4-- > size4) {
      const entry = stack[index4];
      self2.containerState = entry[1];
      ok(
        entry[0].exit,
        "expected `exit` to be defined on container construct"
      );
      entry[0].exit.call(self2, effects);
    }
    stack.length = size4;
  }
  function closeFlow() {
    ok(
      self2.containerState,
      "expected `containerState` to be defined when closing flow"
    );
    ok(childFlow, "expected `childFlow` to be defined when closing it");
    childFlow.write([codes.eof]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok3, nok) {
  ok(
    this.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok3, nok),
    types.linePrefix,
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
  );
}

// node_modules/micromark-util-classify-character/dev/index.js
function classifyCharacter(code4) {
  if (code4 === codes.eof || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)) {
    return constants.characterGroupWhitespace;
  }
  if (unicodePunctuation(code4)) {
    return constants.characterGroupPunctuation;
  }
}

// node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
  const called = [];
  let index4 = -1;
  while (++index4 < constructs2.length) {
    const resolve = constructs2[index4].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}

// node_modules/micromark-core-commonmark/dev/lib/attention.js
var attention = {
  name: "attention",
  resolveAll: resolveAllAttention,
  tokenize: tokenizeAttention
};
function resolveAllAttention(events, context) {
  let index4 = -1;
  let open2;
  let group;
  let text10;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset4;
  while (++index4 < events.length) {
    if (events[index4][0] === "enter" && events[index4][1].type === "attentionSequence" && events[index4][1]._close) {
      open2 = index4;
      while (open2--) {
        if (events[open2][0] === "exit" && events[open2][1].type === "attentionSequence" && events[open2][1]._open && // If the markers are the same:
        context.sliceSerialize(events[open2][1]).charCodeAt(0) === context.sliceSerialize(events[index4][1]).charCodeAt(0)) {
          if ((events[open2][1]._close || events[index4][1]._open) && (events[index4][1].end.offset - events[index4][1].start.offset) % 3 && !((events[open2][1].end.offset - events[open2][1].start.offset + events[index4][1].end.offset - events[index4][1].start.offset) % 3)) {
            continue;
          }
          use = events[open2][1].end.offset - events[open2][1].start.offset > 1 && events[index4][1].end.offset - events[index4][1].start.offset > 1 ? 2 : 1;
          const start2 = { ...events[open2][1].end };
          const end = { ...events[index4][1].start };
          movePoint(start2, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? types.strongSequence : types.emphasisSequence,
            start: start2,
            end: { ...events[open2][1].end }
          };
          closingSequence = {
            type: use > 1 ? types.strongSequence : types.emphasisSequence,
            start: { ...events[index4][1].start },
            end
          };
          text10 = {
            type: use > 1 ? types.strongText : types.emphasisText,
            start: { ...events[open2][1].end },
            end: { ...events[index4][1].start }
          };
          group = {
            type: use > 1 ? types.strong : types.emphasis,
            start: { ...openingSequence.start },
            end: { ...closingSequence.end }
          };
          events[open2][1].end = { ...openingSequence.start };
          events[index4][1].start = { ...closingSequence.end };
          nextEvents = [];
          if (events[open2][1].end.offset - events[open2][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open2][1], context],
              ["exit", events[open2][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text10, context]
          ]);
          ok(
            context.parser.constructs.insideSpan.null,
            "expected `insideSpan` to be populated"
          );
          nextEvents = push(
            nextEvents,
            resolveAll(
              context.parser.constructs.insideSpan.null,
              events.slice(open2 + 1, index4),
              context
            )
          );
          nextEvents = push(nextEvents, [
            ["exit", text10, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index4][1].end.offset - events[index4][1].start.offset) {
            offset4 = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index4][1], context],
              ["exit", events[index4][1], context]
            ]);
          } else {
            offset4 = 0;
          }
          splice(events, open2 - 1, index4 - open2 + 3, nextEvents);
          index4 = open2 + nextEvents.length - offset4 - 2;
          break;
        }
      }
    }
  }
  index4 = -1;
  while (++index4 < events.length) {
    if (events[index4][1].type === "attentionSequence") {
      events[index4][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok3) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous4 = this.previous;
  const before = classifyCharacter(previous4);
  let marker;
  return start2;
  function start2(code4) {
    ok(
      code4 === codes.asterisk || code4 === codes.underscore,
      "expected asterisk or underscore"
    );
    marker = code4;
    effects.enter("attentionSequence");
    return inside(code4);
  }
  function inside(code4) {
    if (code4 === marker) {
      effects.consume(code4);
      return inside;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code4);
    ok(attentionMarkers2, "expected `attentionMarkers` to be populated");
    const open2 = !after || after === constants.characterGroupPunctuation && before || attentionMarkers2.includes(code4);
    const close2 = !before || before === constants.characterGroupPunctuation && after || attentionMarkers2.includes(previous4);
    token._open = Boolean(
      marker === codes.asterisk ? open2 : open2 && (before || !close2)
    );
    token._close = Boolean(
      marker === codes.asterisk ? close2 : close2 && (after || !open2)
    );
    return ok3(code4);
  }
}
function movePoint(point5, offset4) {
  point5.column += offset4;
  point5.offset += offset4;
  point5._bufferIndex += offset4;
}

// node_modules/micromark-core-commonmark/dev/lib/autolink.js
var autolink = { name: "autolink", tokenize: tokenizeAutolink };
function tokenizeAutolink(effects, ok3, nok) {
  let size4 = 0;
  return start2;
  function start2(code4) {
    ok(code4 === codes.lessThan, "expected `<`");
    effects.enter(types.autolink);
    effects.enter(types.autolinkMarker);
    effects.consume(code4);
    effects.exit(types.autolinkMarker);
    effects.enter(types.autolinkProtocol);
    return open2;
  }
  function open2(code4) {
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      return schemeOrEmailAtext;
    }
    if (code4 === codes.atSign) {
      return nok(code4);
    }
    return emailAtext(code4);
  }
  function schemeOrEmailAtext(code4) {
    if (code4 === codes.plusSign || code4 === codes.dash || code4 === codes.dot || asciiAlphanumeric(code4)) {
      size4 = 1;
      return schemeInsideOrEmailAtext(code4);
    }
    return emailAtext(code4);
  }
  function schemeInsideOrEmailAtext(code4) {
    if (code4 === codes.colon) {
      effects.consume(code4);
      size4 = 0;
      return urlInside;
    }
    if ((code4 === codes.plusSign || code4 === codes.dash || code4 === codes.dot || asciiAlphanumeric(code4)) && size4++ < constants.autolinkSchemeSizeMax) {
      effects.consume(code4);
      return schemeInsideOrEmailAtext;
    }
    size4 = 0;
    return emailAtext(code4);
  }
  function urlInside(code4) {
    if (code4 === codes.greaterThan) {
      effects.exit(types.autolinkProtocol);
      effects.enter(types.autolinkMarker);
      effects.consume(code4);
      effects.exit(types.autolinkMarker);
      effects.exit(types.autolink);
      return ok3;
    }
    if (code4 === codes.eof || code4 === codes.space || code4 === codes.lessThan || asciiControl(code4)) {
      return nok(code4);
    }
    effects.consume(code4);
    return urlInside;
  }
  function emailAtext(code4) {
    if (code4 === codes.atSign) {
      effects.consume(code4);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code4)) {
      effects.consume(code4);
      return emailAtext;
    }
    return nok(code4);
  }
  function emailAtSignOrDot(code4) {
    return asciiAlphanumeric(code4) ? emailLabel(code4) : nok(code4);
  }
  function emailLabel(code4) {
    if (code4 === codes.dot) {
      effects.consume(code4);
      size4 = 0;
      return emailAtSignOrDot;
    }
    if (code4 === codes.greaterThan) {
      effects.exit(types.autolinkProtocol).type = types.autolinkEmail;
      effects.enter(types.autolinkMarker);
      effects.consume(code4);
      effects.exit(types.autolinkMarker);
      effects.exit(types.autolink);
      return ok3;
    }
    return emailValue(code4);
  }
  function emailValue(code4) {
    if ((code4 === codes.dash || asciiAlphanumeric(code4)) && size4++ < constants.autolinkDomainSizeMax) {
      const next2 = code4 === codes.dash ? emailValue : emailLabel;
      effects.consume(code4);
      return next2;
    }
    return nok(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/blank-line.js
var blankLine = { partial: true, tokenize: tokenizeBlankLine };
function tokenizeBlankLine(effects, ok3, nok) {
  return start2;
  function start2(code4) {
    return markdownSpace(code4) ? factorySpace(effects, after, types.linePrefix)(code4) : after(code4);
  }
  function after(code4) {
    return code4 === codes.eof || markdownLineEnding(code4) ? ok3(code4) : nok(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/block-quote.js
var blockQuote = {
  continuation: { tokenize: tokenizeBlockQuoteContinuation },
  exit,
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart
};
function tokenizeBlockQuoteStart(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code4) {
    if (code4 === codes.greaterThan) {
      const state = self2.containerState;
      ok(state, "expected `containerState` to be defined in container");
      if (!state.open) {
        effects.enter(types.blockQuote, { _container: true });
        state.open = true;
      }
      effects.enter(types.blockQuotePrefix);
      effects.enter(types.blockQuoteMarker);
      effects.consume(code4);
      effects.exit(types.blockQuoteMarker);
      return after;
    }
    return nok(code4);
  }
  function after(code4) {
    if (markdownSpace(code4)) {
      effects.enter(types.blockQuotePrefixWhitespace);
      effects.consume(code4);
      effects.exit(types.blockQuotePrefixWhitespace);
      effects.exit(types.blockQuotePrefix);
      return ok3;
    }
    effects.exit(types.blockQuotePrefix);
    return ok3(code4);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok3, nok) {
  const self2 = this;
  return contStart;
  function contStart(code4) {
    if (markdownSpace(code4)) {
      ok(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      return factorySpace(
        effects,
        contBefore,
        types.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code4);
    }
    return contBefore(code4);
  }
  function contBefore(code4) {
    return effects.attempt(blockQuote, ok3, nok)(code4);
  }
}
function exit(effects) {
  effects.exit(types.blockQuote);
}

// node_modules/micromark-core-commonmark/dev/lib/character-escape.js
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok3, nok) {
  return start2;
  function start2(code4) {
    ok(code4 === codes.backslash, "expected `\\`");
    effects.enter(types.characterEscape);
    effects.enter(types.escapeMarker);
    effects.consume(code4);
    effects.exit(types.escapeMarker);
    return inside;
  }
  function inside(code4) {
    if (asciiPunctuation(code4)) {
      effects.enter(types.characterEscapeValue);
      effects.consume(code4);
      effects.exit(types.characterEscapeValue);
      effects.exit(types.characterEscape);
      return ok3;
    }
    return nok(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/character-reference.js
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok3, nok) {
  const self2 = this;
  let size4 = 0;
  let max2;
  let test;
  return start2;
  function start2(code4) {
    ok(code4 === codes.ampersand, "expected `&`");
    effects.enter(types.characterReference);
    effects.enter(types.characterReferenceMarker);
    effects.consume(code4);
    effects.exit(types.characterReferenceMarker);
    return open2;
  }
  function open2(code4) {
    if (code4 === codes.numberSign) {
      effects.enter(types.characterReferenceMarkerNumeric);
      effects.consume(code4);
      effects.exit(types.characterReferenceMarkerNumeric);
      return numeric;
    }
    effects.enter(types.characterReferenceValue);
    max2 = constants.characterReferenceNamedSizeMax;
    test = asciiAlphanumeric;
    return value(code4);
  }
  function numeric(code4) {
    if (code4 === codes.uppercaseX || code4 === codes.lowercaseX) {
      effects.enter(types.characterReferenceMarkerHexadecimal);
      effects.consume(code4);
      effects.exit(types.characterReferenceMarkerHexadecimal);
      effects.enter(types.characterReferenceValue);
      max2 = constants.characterReferenceHexadecimalSizeMax;
      test = asciiHexDigit;
      return value;
    }
    effects.enter(types.characterReferenceValue);
    max2 = constants.characterReferenceDecimalSizeMax;
    test = asciiDigit;
    return value(code4);
  }
  function value(code4) {
    if (code4 === codes.semicolon && size4) {
      const token = effects.exit(types.characterReferenceValue);
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
        return nok(code4);
      }
      effects.enter(types.characterReferenceMarker);
      effects.consume(code4);
      effects.exit(types.characterReferenceMarker);
      effects.exit(types.characterReference);
      return ok3;
    }
    if (test(code4) && size4++ < max2) {
      effects.consume(code4);
      return value;
    }
    return nok(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-fenced.js
var nonLazyContinuation = {
  partial: true,
  tokenize: tokenizeNonLazyContinuation
};
var codeFenced = {
  concrete: true,
  name: "codeFenced",
  tokenize: tokenizeCodeFenced
};
function tokenizeCodeFenced(effects, ok3, nok) {
  const self2 = this;
  const closeStart = { partial: true, tokenize: tokenizeCloseStart };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start2;
  function start2(code4) {
    return beforeSequenceOpen(code4);
  }
  function beforeSequenceOpen(code4) {
    ok(
      code4 === codes.graveAccent || code4 === codes.tilde,
      "expected `` ` `` or `~`"
    );
    const tail = self2.events[self2.events.length - 1];
    initialPrefix = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code4;
    effects.enter(types.codeFenced);
    effects.enter(types.codeFencedFence);
    effects.enter(types.codeFencedFenceSequence);
    return sequenceOpen(code4);
  }
  function sequenceOpen(code4) {
    if (code4 === marker) {
      sizeOpen++;
      effects.consume(code4);
      return sequenceOpen;
    }
    if (sizeOpen < constants.codeFencedSequenceSizeMin) {
      return nok(code4);
    }
    effects.exit(types.codeFencedFenceSequence);
    return markdownSpace(code4) ? factorySpace(effects, infoBefore, types.whitespace)(code4) : infoBefore(code4);
  }
  function infoBefore(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types.codeFencedFence);
      return self2.interrupt ? ok3(code4) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code4);
    }
    effects.enter(types.codeFencedFenceInfo);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return info(code4);
  }
  function info(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceInfo);
      return infoBefore(code4);
    }
    if (markdownSpace(code4)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceInfo);
      return factorySpace(effects, metaBefore, types.whitespace)(code4);
    }
    if (code4 === codes.graveAccent && code4 === marker) {
      return nok(code4);
    }
    effects.consume(code4);
    return info;
  }
  function metaBefore(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      return infoBefore(code4);
    }
    effects.enter(types.codeFencedFenceMeta);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return meta(code4);
  }
  function meta(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types.chunkString);
      effects.exit(types.codeFencedFenceMeta);
      return infoBefore(code4);
    }
    if (code4 === codes.graveAccent && code4 === marker) {
      return nok(code4);
    }
    effects.consume(code4);
    return meta;
  }
  function atNonLazyBreak(code4) {
    ok(markdownLineEnding(code4), "expected eol");
    return effects.attempt(closeStart, after, contentBefore)(code4);
  }
  function contentBefore(code4) {
    ok(markdownLineEnding(code4), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code4);
    effects.exit(types.lineEnding);
    return contentStart;
  }
  function contentStart(code4) {
    return initialPrefix > 0 && markdownSpace(code4) ? factorySpace(
      effects,
      beforeContentChunk,
      types.linePrefix,
      initialPrefix + 1
    )(code4) : beforeContentChunk(code4);
  }
  function beforeContentChunk(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code4);
    }
    effects.enter(types.codeFlowValue);
    return contentChunk(code4);
  }
  function contentChunk(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types.codeFlowValue);
      return beforeContentChunk(code4);
    }
    effects.consume(code4);
    return contentChunk;
  }
  function after(code4) {
    effects.exit(types.codeFenced);
    return ok3(code4);
  }
  function tokenizeCloseStart(effects2, ok4, nok2) {
    let size4 = 0;
    return startBefore;
    function startBefore(code4) {
      ok(markdownLineEnding(code4), "expected eol");
      effects2.enter(types.lineEnding);
      effects2.consume(code4);
      effects2.exit(types.lineEnding);
      return start3;
    }
    function start3(code4) {
      ok(
        self2.parser.constructs.disable.null,
        "expected `disable.null` to be populated"
      );
      effects2.enter(types.codeFencedFence);
      return markdownSpace(code4) ? factorySpace(
        effects2,
        beforeSequenceClose,
        types.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code4) : beforeSequenceClose(code4);
    }
    function beforeSequenceClose(code4) {
      if (code4 === marker) {
        effects2.enter(types.codeFencedFenceSequence);
        return sequenceClose(code4);
      }
      return nok2(code4);
    }
    function sequenceClose(code4) {
      if (code4 === marker) {
        size4++;
        effects2.consume(code4);
        return sequenceClose;
      }
      if (size4 >= sizeOpen) {
        effects2.exit(types.codeFencedFenceSequence);
        return markdownSpace(code4) ? factorySpace(effects2, sequenceCloseAfter, types.whitespace)(code4) : sequenceCloseAfter(code4);
      }
      return nok2(code4);
    }
    function sequenceCloseAfter(code4) {
      if (code4 === codes.eof || markdownLineEnding(code4)) {
        effects2.exit(types.codeFencedFence);
        return ok4(code4);
      }
      return nok2(code4);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code4) {
    if (code4 === codes.eof) {
      return nok(code4);
    }
    ok(markdownLineEnding(code4), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code4);
    effects.exit(types.lineEnding);
    return lineStart;
  }
  function lineStart(code4) {
    return self2.parser.lazy[self2.now().line] ? nok(code4) : ok3(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-indented.js
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var furtherStart = { partial: true, tokenize: tokenizeFurtherStart };
function tokenizeCodeIndented(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code4) {
    ok(markdownSpace(code4));
    effects.enter(types.codeIndented);
    return factorySpace(
      effects,
      afterPrefix,
      types.linePrefix,
      constants.tabSize + 1
    )(code4);
  }
  function afterPrefix(code4) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? atBreak(code4) : nok(code4);
  }
  function atBreak(code4) {
    if (code4 === codes.eof) {
      return after(code4);
    }
    if (markdownLineEnding(code4)) {
      return effects.attempt(furtherStart, atBreak, after)(code4);
    }
    effects.enter(types.codeFlowValue);
    return inside(code4);
  }
  function inside(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types.codeFlowValue);
      return atBreak(code4);
    }
    effects.consume(code4);
    return inside;
  }
  function after(code4) {
    effects.exit(types.codeIndented);
    return ok3(code4);
  }
}
function tokenizeFurtherStart(effects, ok3, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code4) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code4);
    }
    if (markdownLineEnding(code4)) {
      effects.enter(types.lineEnding);
      effects.consume(code4);
      effects.exit(types.lineEnding);
      return furtherStart2;
    }
    return factorySpace(
      effects,
      afterPrefix,
      types.linePrefix,
      constants.tabSize + 1
    )(code4);
  }
  function afterPrefix(code4) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? ok3(code4) : markdownLineEnding(code4) ? furtherStart2(code4) : nok(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/code-text.js
var codeText = {
  name: "codeText",
  previous,
  resolve: resolveCodeText,
  tokenize: tokenizeCodeText
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index4;
  let enter;
  if ((events[headEnterIndex][1].type === types.lineEnding || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === types.lineEnding || events[tailExitIndex][1].type === "space")) {
    index4 = headEnterIndex;
    while (++index4 < tailExitIndex) {
      if (events[index4][1].type === types.codeTextData) {
        events[headEnterIndex][1].type = types.codeTextPadding;
        events[tailExitIndex][1].type = types.codeTextPadding;
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index4 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index4 <= tailExitIndex) {
    if (enter === void 0) {
      if (index4 !== tailExitIndex && events[index4][1].type !== types.lineEnding) {
        enter = index4;
      }
    } else if (index4 === tailExitIndex || events[index4][1].type === types.lineEnding) {
      events[enter][1].type = types.codeTextData;
      if (index4 !== enter + 2) {
        events[enter][1].end = events[index4 - 1][1].end;
        events.splice(enter + 2, index4 - enter - 2);
        tailExitIndex -= index4 - enter - 2;
        index4 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code4) {
  return code4 !== codes.graveAccent || this.events[this.events.length - 1][1].type === types.characterEscape;
}
function tokenizeCodeText(effects, ok3, nok) {
  const self2 = this;
  let sizeOpen = 0;
  let size4;
  let token;
  return start2;
  function start2(code4) {
    ok(code4 === codes.graveAccent, "expected `` ` ``");
    ok(previous.call(self2, self2.previous), "expected correct previous");
    effects.enter(types.codeText);
    effects.enter(types.codeTextSequence);
    return sequenceOpen(code4);
  }
  function sequenceOpen(code4) {
    if (code4 === codes.graveAccent) {
      effects.consume(code4);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit(types.codeTextSequence);
    return between(code4);
  }
  function between(code4) {
    if (code4 === codes.eof) {
      return nok(code4);
    }
    if (code4 === codes.space) {
      effects.enter("space");
      effects.consume(code4);
      effects.exit("space");
      return between;
    }
    if (code4 === codes.graveAccent) {
      token = effects.enter(types.codeTextSequence);
      size4 = 0;
      return sequenceClose(code4);
    }
    if (markdownLineEnding(code4)) {
      effects.enter(types.lineEnding);
      effects.consume(code4);
      effects.exit(types.lineEnding);
      return between;
    }
    effects.enter(types.codeTextData);
    return data(code4);
  }
  function data(code4) {
    if (code4 === codes.eof || code4 === codes.space || code4 === codes.graveAccent || markdownLineEnding(code4)) {
      effects.exit(types.codeTextData);
      return between(code4);
    }
    effects.consume(code4);
    return data;
  }
  function sequenceClose(code4) {
    if (code4 === codes.graveAccent) {
      effects.consume(code4);
      size4++;
      return sequenceClose;
    }
    if (size4 === sizeOpen) {
      effects.exit(types.codeTextSequence);
      effects.exit(types.codeText);
      return ok3(code4);
    }
    token.type = types.codeTextData;
    return data(code4);
  }
}

// node_modules/micromark-util-subtokenize/dev/lib/splice-buffer.js
var SpliceBuffer = class {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(initial) {
    this.left = initial ? [...initial] : [];
    this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(index4) {
    if (index4 < 0 || index4 >= this.left.length + this.right.length) {
      throw new RangeError(
        "Cannot access index `" + index4 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`"
      );
    }
    if (index4 < this.left.length) return this.left[index4];
    return this.right[this.right.length - index4 + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    this.setCursor(0);
    return this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(start2, end) {
    const stop = end === null || end === void 0 ? Number.POSITIVE_INFINITY : end;
    if (stop < this.left.length) {
      return this.left.slice(start2, stop);
    }
    if (start2 > this.left.length) {
      return this.right.slice(
        this.right.length - stop + this.left.length,
        this.right.length - start2 + this.left.length
      ).reverse();
    }
    return this.left.slice(start2).concat(
      this.right.slice(this.right.length - stop + this.left.length).reverse()
    );
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(start2, deleteCount, items) {
    const count2 = deleteCount || 0;
    this.setCursor(Math.trunc(start2));
    const removed = this.right.splice(
      this.right.length - count2,
      Number.POSITIVE_INFINITY
    );
    if (items) chunkedPush(this.left, items);
    return removed.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    this.setCursor(Number.POSITIVE_INFINITY);
    return this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(item) {
    this.setCursor(Number.POSITIVE_INFINITY);
    this.left.push(item);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(items) {
    this.setCursor(Number.POSITIVE_INFINITY);
    chunkedPush(this.left, items);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(item) {
    this.setCursor(0);
    this.right.push(item);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(items) {
    this.setCursor(0);
    chunkedPush(this.right, items.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(n17) {
    if (n17 === this.left.length || n17 > this.left.length && this.right.length === 0 || n17 < 0 && this.left.length === 0)
      return;
    if (n17 < this.left.length) {
      const removed = this.left.splice(n17, Number.POSITIVE_INFINITY);
      chunkedPush(this.right, removed.reverse());
    } else {
      const removed = this.right.splice(
        this.left.length + this.right.length - n17,
        Number.POSITIVE_INFINITY
      );
      chunkedPush(this.left, removed.reverse());
    }
  }
};
function chunkedPush(list4, right) {
  let chunkStart = 0;
  if (right.length < constants.v8MaxSafeChunkSize) {
    list4.push(...right);
  } else {
    while (chunkStart < right.length) {
      list4.push(
        ...right.slice(chunkStart, chunkStart + constants.v8MaxSafeChunkSize)
      );
      chunkStart += constants.v8MaxSafeChunkSize;
    }
  }
}

// node_modules/micromark-util-subtokenize/dev/index.js
function subtokenize(eventsArray) {
  const jumps = {};
  let index4 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  const events = new SpliceBuffer(eventsArray);
  while (++index4 < events.length) {
    while (index4 in jumps) {
      index4 = jumps[index4];
    }
    event = events.get(index4);
    if (index4 && event[1].type === types.chunkFlow && events.get(index4 - 1)[1].type === types.listItemPrefix) {
      ok(event[1]._tokenizer, "expected `_tokenizer` on subtokens");
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types.lineEndingBlank) {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types.content) {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === types.content) {
            break;
          }
          if (subevents[otherIndex][1].type === types.chunkText) {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index4));
        index4 = jumps[index4];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index4;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events.get(otherIndex);
        if (otherEvent[1].type === types.lineEnding || otherEvent[1].type === types.lineEndingBlank) {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events.get(lineIndex)[1].type = types.lineEndingBlank;
            }
            otherEvent[1].type = types.lineEnding;
            lineIndex = otherIndex;
          }
        } else if (otherEvent[1].type === types.linePrefix || otherEvent[1].type === types.listItemIndent) {
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = { ...events.get(lineIndex)[1].start };
        parameters = events.slice(lineIndex, index4);
        parameters.unshift(event);
        events.splice(lineIndex, index4 - lineIndex + 1, parameters);
      }
    }
  }
  splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events.get(eventIndex)[1];
  const context = events.get(eventIndex)[2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  ok(token.contentType, "expected `contentType` on subtokens");
  let tokenizer = token._tokenizer;
  if (!tokenizer) {
    tokenizer = context.parser[token.contentType](token.start);
    if (token._contentTypeTextTrailing) {
      tokenizer._contentTypeTextTrailing = true;
    }
  }
  const childEvents = tokenizer.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous4;
  let index4 = -1;
  let current = token;
  let adjust = 0;
  let start2 = 0;
  const breaks = [start2];
  while (current) {
    while (events.get(++startPosition)[1] !== current) {
    }
    ok(
      !previous4 || current.previous === previous4,
      "expected previous to match"
    );
    ok(!previous4 || previous4.next === current, "expected next to match");
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(codes.eof);
      }
      if (previous4) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous4 = current;
    current = current.next;
  }
  current = token;
  while (++index4 < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index4][0] === "exit" && childEvents[index4 - 1][0] === "enter" && childEvents[index4][1].type === childEvents[index4 - 1][1].type && childEvents[index4][1].start.line !== childEvents[index4][1].end.line
    ) {
      ok(current, "expected a current token");
      start2 = index4 + 1;
      breaks.push(start2);
      current._tokenizer = void 0;
      current.previous = void 0;
      current = current.next;
    }
  }
  tokenizer.events = [];
  if (current) {
    current._tokenizer = void 0;
    current.previous = void 0;
    ok(!current.next, "expected no next token");
  } else {
    breaks.pop();
  }
  index4 = breaks.length;
  while (index4--) {
    const slice = childEvents.slice(breaks[index4], breaks[index4 + 1]);
    const start3 = startPositions.pop();
    ok(start3 !== void 0, "expected a start position when splicing");
    jumps.push([start3, start3 + slice.length - 1]);
    events.splice(start3, 2, slice);
  }
  jumps.reverse();
  index4 = -1;
  while (++index4 < jumps.length) {
    gaps[adjust + jumps[index4][0]] = adjust + jumps[index4][1];
    adjust += jumps[index4][1] - jumps[index4][0] - 1;
  }
  return gaps;
}

// node_modules/micromark-core-commonmark/dev/lib/content.js
var content2 = { resolve: resolveContent, tokenize: tokenizeContent };
var continuationConstruct = { partial: true, tokenize: tokenizeContinuation };
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok3) {
  let previous4;
  return chunkStart;
  function chunkStart(code4) {
    ok(
      code4 !== codes.eof && !markdownLineEnding(code4),
      "expected no eof or eol"
    );
    effects.enter(types.content);
    previous4 = effects.enter(types.chunkContent, {
      contentType: constants.contentTypeContent
    });
    return chunkInside(code4);
  }
  function chunkInside(code4) {
    if (code4 === codes.eof) {
      return contentEnd(code4);
    }
    if (markdownLineEnding(code4)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code4);
    }
    effects.consume(code4);
    return chunkInside;
  }
  function contentEnd(code4) {
    effects.exit(types.chunkContent);
    effects.exit(types.content);
    return ok3(code4);
  }
  function contentContinue(code4) {
    ok(markdownLineEnding(code4), "expected eol");
    effects.consume(code4);
    effects.exit(types.chunkContent);
    ok(previous4, "expected previous token");
    previous4.next = effects.enter(types.chunkContent, {
      contentType: constants.contentTypeContent,
      previous: previous4
    });
    previous4 = previous4.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok3, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code4) {
    ok(markdownLineEnding(code4), "expected a line ending");
    effects.exit(types.chunkContent);
    effects.enter(types.lineEnding);
    effects.consume(code4);
    effects.exit(types.lineEnding);
    return factorySpace(effects, prefixed, types.linePrefix);
  }
  function prefixed(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      return nok(code4);
    }
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize) {
      return ok3(code4);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok3)(code4);
  }
}

// node_modules/micromark-factory-destination/dev/index.js
function factoryDestination(effects, ok3, nok, type, literalType, literalMarkerType, rawType, stringType, max2) {
  const limit = max2 || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start2;
  function start2(code4) {
    if (code4 === codes.lessThan) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code4);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code4 === codes.eof || code4 === codes.space || code4 === codes.rightParenthesis || asciiControl(code4)) {
      return nok(code4);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return raw2(code4);
  }
  function enclosedBefore(code4) {
    if (code4 === codes.greaterThan) {
      effects.enter(literalMarkerType);
      effects.consume(code4);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return enclosed(code4);
  }
  function enclosed(code4) {
    if (code4 === codes.greaterThan) {
      effects.exit(types.chunkString);
      effects.exit(stringType);
      return enclosedBefore(code4);
    }
    if (code4 === codes.eof || code4 === codes.lessThan || markdownLineEnding(code4)) {
      return nok(code4);
    }
    effects.consume(code4);
    return code4 === codes.backslash ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code4) {
    if (code4 === codes.lessThan || code4 === codes.greaterThan || code4 === codes.backslash) {
      effects.consume(code4);
      return enclosed;
    }
    return enclosed(code4);
  }
  function raw2(code4) {
    if (!balance && (code4 === codes.eof || code4 === codes.rightParenthesis || markdownLineEndingOrSpace(code4))) {
      effects.exit(types.chunkString);
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok3(code4);
    }
    if (balance < limit && code4 === codes.leftParenthesis) {
      effects.consume(code4);
      balance++;
      return raw2;
    }
    if (code4 === codes.rightParenthesis) {
      effects.consume(code4);
      balance--;
      return raw2;
    }
    if (code4 === codes.eof || code4 === codes.space || code4 === codes.leftParenthesis || asciiControl(code4)) {
      return nok(code4);
    }
    effects.consume(code4);
    return code4 === codes.backslash ? rawEscape : raw2;
  }
  function rawEscape(code4) {
    if (code4 === codes.leftParenthesis || code4 === codes.rightParenthesis || code4 === codes.backslash) {
      effects.consume(code4);
      return raw2;
    }
    return raw2(code4);
  }
}

// node_modules/micromark-factory-label/dev/index.js
function factoryLabel(effects, ok3, nok, type, markerType, stringType) {
  const self2 = this;
  let size4 = 0;
  let seen;
  return start2;
  function start2(code4) {
    ok(code4 === codes.leftSquareBracket, "expected `[`");
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code4);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code4) {
    if (size4 > constants.linkReferenceSizeMax || code4 === codes.eof || code4 === codes.leftSquareBracket || code4 === codes.rightSquareBracket && !seen || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code4 === codes.caret && !size4 && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code4);
    }
    if (code4 === codes.rightSquareBracket) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code4);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    if (markdownLineEnding(code4)) {
      effects.enter(types.lineEnding);
      effects.consume(code4);
      effects.exit(types.lineEnding);
      return atBreak;
    }
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return labelInside(code4);
  }
  function labelInside(code4) {
    if (code4 === codes.eof || code4 === codes.leftSquareBracket || code4 === codes.rightSquareBracket || markdownLineEnding(code4) || size4++ > constants.linkReferenceSizeMax) {
      effects.exit(types.chunkString);
      return atBreak(code4);
    }
    effects.consume(code4);
    if (!seen) seen = !markdownSpace(code4);
    return code4 === codes.backslash ? labelEscape : labelInside;
  }
  function labelEscape(code4) {
    if (code4 === codes.leftSquareBracket || code4 === codes.backslash || code4 === codes.rightSquareBracket) {
      effects.consume(code4);
      size4++;
      return labelInside;
    }
    return labelInside(code4);
  }
}

// node_modules/micromark-factory-title/dev/index.js
function factoryTitle(effects, ok3, nok, type, markerType, stringType) {
  let marker;
  return start2;
  function start2(code4) {
    if (code4 === codes.quotationMark || code4 === codes.apostrophe || code4 === codes.leftParenthesis) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code4);
      effects.exit(markerType);
      marker = code4 === codes.leftParenthesis ? codes.rightParenthesis : code4;
      return begin;
    }
    return nok(code4);
  }
  function begin(code4) {
    if (code4 === marker) {
      effects.enter(markerType);
      effects.consume(code4);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    return atBreak(code4);
  }
  function atBreak(code4) {
    if (code4 === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code4 === codes.eof) {
      return nok(code4);
    }
    if (markdownLineEnding(code4)) {
      effects.enter(types.lineEnding);
      effects.consume(code4);
      effects.exit(types.lineEnding);
      return factorySpace(effects, atBreak, types.linePrefix);
    }
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return inside(code4);
  }
  function inside(code4) {
    if (code4 === marker || code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types.chunkString);
      return atBreak(code4);
    }
    effects.consume(code4);
    return code4 === codes.backslash ? escape2 : inside;
  }
  function escape2(code4) {
    if (code4 === marker || code4 === codes.backslash) {
      effects.consume(code4);
      return inside;
    }
    return inside(code4);
  }
}

// node_modules/micromark-factory-whitespace/dev/index.js
function factoryWhitespace(effects, ok3) {
  let seen;
  return start2;
  function start2(code4) {
    if (markdownLineEnding(code4)) {
      effects.enter(types.lineEnding);
      effects.consume(code4);
      effects.exit(types.lineEnding);
      seen = true;
      return start2;
    }
    if (markdownSpace(code4)) {
      return factorySpace(
        effects,
        start2,
        seen ? types.linePrefix : types.lineSuffix
      )(code4);
    }
    return ok3(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/definition.js
var definition = { name: "definition", tokenize: tokenizeDefinition };
var titleBefore = { partial: true, tokenize: tokenizeTitleBefore };
function tokenizeDefinition(effects, ok3, nok) {
  const self2 = this;
  let identifier;
  return start2;
  function start2(code4) {
    effects.enter(types.definition);
    return before(code4);
  }
  function before(code4) {
    ok(code4 === codes.leftSquareBracket, "expected `[`");
    return factoryLabel.call(
      self2,
      effects,
      labelAfter,
      // Note: we dont need to reset the way `markdown-rs` does.
      nok,
      types.definitionLabel,
      types.definitionLabelMarker,
      types.definitionLabelString
    )(code4);
  }
  function labelAfter(code4) {
    identifier = normalizeIdentifier(
      self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
    );
    if (code4 === codes.colon) {
      effects.enter(types.definitionMarker);
      effects.consume(code4);
      effects.exit(types.definitionMarker);
      return markerAfter;
    }
    return nok(code4);
  }
  function markerAfter(code4) {
    return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, destinationBefore)(code4) : destinationBefore(code4);
  }
  function destinationBefore(code4) {
    return factoryDestination(
      effects,
      destinationAfter,
      // Note: we dont need to reset the way `markdown-rs` does.
      nok,
      types.definitionDestination,
      types.definitionDestinationLiteral,
      types.definitionDestinationLiteralMarker,
      types.definitionDestinationRaw,
      types.definitionDestinationString
    )(code4);
  }
  function destinationAfter(code4) {
    return effects.attempt(titleBefore, after, after)(code4);
  }
  function after(code4) {
    return markdownSpace(code4) ? factorySpace(effects, afterWhitespace, types.whitespace)(code4) : afterWhitespace(code4);
  }
  function afterWhitespace(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types.definition);
      self2.parser.defined.push(identifier);
      return ok3(code4);
    }
    return nok(code4);
  }
}
function tokenizeTitleBefore(effects, ok3, nok) {
  return titleBefore2;
  function titleBefore2(code4) {
    return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, beforeMarker)(code4) : nok(code4);
  }
  function beforeMarker(code4) {
    return factoryTitle(
      effects,
      titleAfter,
      nok,
      types.definitionTitle,
      types.definitionTitleMarker,
      types.definitionTitleString
    )(code4);
  }
  function titleAfter(code4) {
    return markdownSpace(code4) ? factorySpace(
      effects,
      titleAfterOptionalWhitespace,
      types.whitespace
    )(code4) : titleAfterOptionalWhitespace(code4);
  }
  function titleAfterOptionalWhitespace(code4) {
    return code4 === codes.eof || markdownLineEnding(code4) ? ok3(code4) : nok(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/hard-break-escape.js
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok3, nok) {
  return start2;
  function start2(code4) {
    ok(code4 === codes.backslash, "expected `\\`");
    effects.enter(types.hardBreakEscape);
    effects.consume(code4);
    return after;
  }
  function after(code4) {
    if (markdownLineEnding(code4)) {
      effects.exit(types.hardBreakEscape);
      return ok3(code4);
    }
    return nok(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/heading-atx.js
var headingAtx = {
  name: "headingAtx",
  resolve: resolveHeadingAtx,
  tokenize: tokenizeHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content3;
  let text10;
  if (events[contentStart][1].type === types.whitespace) {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === types.whitespace) {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === types.atxHeadingSequence && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === types.whitespace)) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: types.atxHeadingText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text10 = {
      type: types.chunkText,
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: constants.contentTypeText
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content3, context],
      ["enter", text10, context],
      ["exit", text10, context],
      ["exit", content3, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok3, nok) {
  let size4 = 0;
  return start2;
  function start2(code4) {
    effects.enter(types.atxHeading);
    return before(code4);
  }
  function before(code4) {
    ok(code4 === codes.numberSign, "expected `#`");
    effects.enter(types.atxHeadingSequence);
    return sequenceOpen(code4);
  }
  function sequenceOpen(code4) {
    if (code4 === codes.numberSign && size4++ < constants.atxHeadingOpeningFenceSizeMax) {
      effects.consume(code4);
      return sequenceOpen;
    }
    if (code4 === codes.eof || markdownLineEndingOrSpace(code4)) {
      effects.exit(types.atxHeadingSequence);
      return atBreak(code4);
    }
    return nok(code4);
  }
  function atBreak(code4) {
    if (code4 === codes.numberSign) {
      effects.enter(types.atxHeadingSequence);
      return sequenceFurther(code4);
    }
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types.atxHeading);
      return ok3(code4);
    }
    if (markdownSpace(code4)) {
      return factorySpace(effects, atBreak, types.whitespace)(code4);
    }
    effects.enter(types.atxHeadingText);
    return data(code4);
  }
  function sequenceFurther(code4) {
    if (code4 === codes.numberSign) {
      effects.consume(code4);
      return sequenceFurther;
    }
    effects.exit(types.atxHeadingSequence);
    return atBreak(code4);
  }
  function data(code4) {
    if (code4 === codes.eof || code4 === codes.numberSign || markdownLineEndingOrSpace(code4)) {
      effects.exit(types.atxHeadingText);
      return atBreak(code4);
    }
    effects.consume(code4);
    return data;
  }
}

// node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// node_modules/micromark-core-commonmark/dev/lib/html-flow.js
var htmlFlow = {
  concrete: true,
  name: "htmlFlow",
  resolveTo: resolveToHtmlFlow,
  tokenize: tokenizeHtmlFlow
};
var blankLineBefore = { partial: true, tokenize: tokenizeBlankLineBefore };
var nonLazyContinuationStart = {
  partial: true,
  tokenize: tokenizeNonLazyContinuationStart
};
function resolveToHtmlFlow(events) {
  let index4 = events.length;
  while (index4--) {
    if (events[index4][0] === "enter" && events[index4][1].type === types.htmlFlow) {
      break;
    }
  }
  if (index4 > 1 && events[index4 - 2][1].type === types.linePrefix) {
    events[index4][1].start = events[index4 - 2][1].start;
    events[index4 + 1][1].start = events[index4 - 2][1].start;
    events.splice(index4 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let closingTag;
  let buffer;
  let index4;
  let markerB;
  return start2;
  function start2(code4) {
    return before(code4);
  }
  function before(code4) {
    ok(code4 === codes.lessThan, "expected `<`");
    effects.enter(types.htmlFlow);
    effects.enter(types.htmlFlowData);
    effects.consume(code4);
    return open2;
  }
  function open2(code4) {
    if (code4 === codes.exclamationMark) {
      effects.consume(code4);
      return declarationOpen;
    }
    if (code4 === codes.slash) {
      effects.consume(code4);
      closingTag = true;
      return tagCloseStart;
    }
    if (code4 === codes.questionMark) {
      effects.consume(code4);
      marker = constants.htmlInstruction;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    if (asciiAlpha(code4)) {
      ok(code4 !== null);
      effects.consume(code4);
      buffer = String.fromCharCode(code4);
      return tagName;
    }
    return nok(code4);
  }
  function declarationOpen(code4) {
    if (code4 === codes.dash) {
      effects.consume(code4);
      marker = constants.htmlComment;
      return commentOpenInside;
    }
    if (code4 === codes.leftSquareBracket) {
      effects.consume(code4);
      marker = constants.htmlCdata;
      index4 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      marker = constants.htmlDeclaration;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code4);
  }
  function commentOpenInside(code4) {
    if (code4 === codes.dash) {
      effects.consume(code4);
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code4);
  }
  function cdataOpenInside(code4) {
    const value = constants.cdataOpeningString;
    if (code4 === value.charCodeAt(index4++)) {
      effects.consume(code4);
      if (index4 === value.length) {
        return self2.interrupt ? ok3 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code4);
  }
  function tagCloseStart(code4) {
    if (asciiAlpha(code4)) {
      ok(code4 !== null);
      effects.consume(code4);
      buffer = String.fromCharCode(code4);
      return tagName;
    }
    return nok(code4);
  }
  function tagName(code4) {
    if (code4 === codes.eof || code4 === codes.slash || code4 === codes.greaterThan || markdownLineEndingOrSpace(code4)) {
      const slash = code4 === codes.slash;
      const name2 = buffer.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name2)) {
        marker = constants.htmlRaw;
        return self2.interrupt ? ok3(code4) : continuation(code4);
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        marker = constants.htmlBasic;
        if (slash) {
          effects.consume(code4);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok3(code4) : continuation(code4);
      }
      marker = constants.htmlComplete;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code4) : closingTag ? completeClosingTagAfter(code4) : completeAttributeNameBefore(code4);
    }
    if (code4 === codes.dash || asciiAlphanumeric(code4)) {
      effects.consume(code4);
      buffer += String.fromCharCode(code4);
      return tagName;
    }
    return nok(code4);
  }
  function basicSelfClosing(code4) {
    if (code4 === codes.greaterThan) {
      effects.consume(code4);
      return self2.interrupt ? ok3 : continuation;
    }
    return nok(code4);
  }
  function completeClosingTagAfter(code4) {
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return completeClosingTagAfter;
    }
    return completeEnd(code4);
  }
  function completeAttributeNameBefore(code4) {
    if (code4 === codes.slash) {
      effects.consume(code4);
      return completeEnd;
    }
    if (code4 === codes.colon || code4 === codes.underscore || asciiAlpha(code4)) {
      effects.consume(code4);
      return completeAttributeName;
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return completeAttributeNameBefore;
    }
    return completeEnd(code4);
  }
  function completeAttributeName(code4) {
    if (code4 === codes.dash || code4 === codes.dot || code4 === codes.colon || code4 === codes.underscore || asciiAlphanumeric(code4)) {
      effects.consume(code4);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code4);
  }
  function completeAttributeNameAfter(code4) {
    if (code4 === codes.equalsTo) {
      effects.consume(code4);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code4);
  }
  function completeAttributeValueBefore(code4) {
    if (code4 === codes.eof || code4 === codes.lessThan || code4 === codes.equalsTo || code4 === codes.greaterThan || code4 === codes.graveAccent) {
      return nok(code4);
    }
    if (code4 === codes.quotationMark || code4 === codes.apostrophe) {
      effects.consume(code4);
      markerB = code4;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code4);
  }
  function completeAttributeValueQuoted(code4) {
    if (code4 === markerB) {
      effects.consume(code4);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      return nok(code4);
    }
    effects.consume(code4);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code4) {
    if (code4 === codes.eof || code4 === codes.quotationMark || code4 === codes.apostrophe || code4 === codes.slash || code4 === codes.lessThan || code4 === codes.equalsTo || code4 === codes.greaterThan || code4 === codes.graveAccent || markdownLineEndingOrSpace(code4)) {
      return completeAttributeNameAfter(code4);
    }
    effects.consume(code4);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code4) {
    if (code4 === codes.slash || code4 === codes.greaterThan || markdownSpace(code4)) {
      return completeAttributeNameBefore(code4);
    }
    return nok(code4);
  }
  function completeEnd(code4) {
    if (code4 === codes.greaterThan) {
      effects.consume(code4);
      return completeAfter;
    }
    return nok(code4);
  }
  function completeAfter(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      return continuation(code4);
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return completeAfter;
    }
    return nok(code4);
  }
  function continuation(code4) {
    if (code4 === codes.dash && marker === constants.htmlComment) {
      effects.consume(code4);
      return continuationCommentInside;
    }
    if (code4 === codes.lessThan && marker === constants.htmlRaw) {
      effects.consume(code4);
      return continuationRawTagOpen;
    }
    if (code4 === codes.greaterThan && marker === constants.htmlDeclaration) {
      effects.consume(code4);
      return continuationClose;
    }
    if (code4 === codes.questionMark && marker === constants.htmlInstruction) {
      effects.consume(code4);
      return continuationDeclarationInside;
    }
    if (code4 === codes.rightSquareBracket && marker === constants.htmlCdata) {
      effects.consume(code4);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code4) && (marker === constants.htmlBasic || marker === constants.htmlComplete)) {
      effects.exit(types.htmlFlowData);
      return effects.check(
        blankLineBefore,
        continuationAfter,
        continuationStart
      )(code4);
    }
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types.htmlFlowData);
      return continuationStart(code4);
    }
    effects.consume(code4);
    return continuation;
  }
  function continuationStart(code4) {
    return effects.check(
      nonLazyContinuationStart,
      continuationStartNonLazy,
      continuationAfter
    )(code4);
  }
  function continuationStartNonLazy(code4) {
    ok(markdownLineEnding(code4));
    effects.enter(types.lineEnding);
    effects.consume(code4);
    effects.exit(types.lineEnding);
    return continuationBefore;
  }
  function continuationBefore(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      return continuationStart(code4);
    }
    effects.enter(types.htmlFlowData);
    return continuation(code4);
  }
  function continuationCommentInside(code4) {
    if (code4 === codes.dash) {
      effects.consume(code4);
      return continuationDeclarationInside;
    }
    return continuation(code4);
  }
  function continuationRawTagOpen(code4) {
    if (code4 === codes.slash) {
      effects.consume(code4);
      buffer = "";
      return continuationRawEndTag;
    }
    return continuation(code4);
  }
  function continuationRawEndTag(code4) {
    if (code4 === codes.greaterThan) {
      const name2 = buffer.toLowerCase();
      if (htmlRawNames.includes(name2)) {
        effects.consume(code4);
        return continuationClose;
      }
      return continuation(code4);
    }
    if (asciiAlpha(code4) && buffer.length < constants.htmlRawSizeMax) {
      ok(code4 !== null);
      effects.consume(code4);
      buffer += String.fromCharCode(code4);
      return continuationRawEndTag;
    }
    return continuation(code4);
  }
  function continuationCdataInside(code4) {
    if (code4 === codes.rightSquareBracket) {
      effects.consume(code4);
      return continuationDeclarationInside;
    }
    return continuation(code4);
  }
  function continuationDeclarationInside(code4) {
    if (code4 === codes.greaterThan) {
      effects.consume(code4);
      return continuationClose;
    }
    if (code4 === codes.dash && marker === constants.htmlComment) {
      effects.consume(code4);
      return continuationDeclarationInside;
    }
    return continuation(code4);
  }
  function continuationClose(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types.htmlFlowData);
      return continuationAfter(code4);
    }
    effects.consume(code4);
    return continuationClose;
  }
  function continuationAfter(code4) {
    effects.exit(types.htmlFlow);
    return ok3(code4);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code4) {
    if (markdownLineEnding(code4)) {
      effects.enter(types.lineEnding);
      effects.consume(code4);
      effects.exit(types.lineEnding);
      return after;
    }
    return nok(code4);
  }
  function after(code4) {
    return self2.parser.lazy[self2.now().line] ? nok(code4) : ok3(code4);
  }
}
function tokenizeBlankLineBefore(effects, ok3, nok) {
  return start2;
  function start2(code4) {
    ok(markdownLineEnding(code4), "expected a line ending");
    effects.enter(types.lineEnding);
    effects.consume(code4);
    effects.exit(types.lineEnding);
    return effects.attempt(blankLine, ok3, nok);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/html-text.js
var htmlText = { name: "htmlText", tokenize: tokenizeHtmlText };
function tokenizeHtmlText(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let index4;
  let returnState;
  return start2;
  function start2(code4) {
    ok(code4 === codes.lessThan, "expected `<`");
    effects.enter(types.htmlText);
    effects.enter(types.htmlTextData);
    effects.consume(code4);
    return open2;
  }
  function open2(code4) {
    if (code4 === codes.exclamationMark) {
      effects.consume(code4);
      return declarationOpen;
    }
    if (code4 === codes.slash) {
      effects.consume(code4);
      return tagCloseStart;
    }
    if (code4 === codes.questionMark) {
      effects.consume(code4);
      return instruction;
    }
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      return tagOpen;
    }
    return nok(code4);
  }
  function declarationOpen(code4) {
    if (code4 === codes.dash) {
      effects.consume(code4);
      return commentOpenInside;
    }
    if (code4 === codes.leftSquareBracket) {
      effects.consume(code4);
      index4 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      return declaration;
    }
    return nok(code4);
  }
  function commentOpenInside(code4) {
    if (code4 === codes.dash) {
      effects.consume(code4);
      return commentEnd;
    }
    return nok(code4);
  }
  function comment3(code4) {
    if (code4 === codes.eof) {
      return nok(code4);
    }
    if (code4 === codes.dash) {
      effects.consume(code4);
      return commentClose;
    }
    if (markdownLineEnding(code4)) {
      returnState = comment3;
      return lineEndingBefore(code4);
    }
    effects.consume(code4);
    return comment3;
  }
  function commentClose(code4) {
    if (code4 === codes.dash) {
      effects.consume(code4);
      return commentEnd;
    }
    return comment3(code4);
  }
  function commentEnd(code4) {
    return code4 === codes.greaterThan ? end(code4) : code4 === codes.dash ? commentClose(code4) : comment3(code4);
  }
  function cdataOpenInside(code4) {
    const value = constants.cdataOpeningString;
    if (code4 === value.charCodeAt(index4++)) {
      effects.consume(code4);
      return index4 === value.length ? cdata : cdataOpenInside;
    }
    return nok(code4);
  }
  function cdata(code4) {
    if (code4 === codes.eof) {
      return nok(code4);
    }
    if (code4 === codes.rightSquareBracket) {
      effects.consume(code4);
      return cdataClose;
    }
    if (markdownLineEnding(code4)) {
      returnState = cdata;
      return lineEndingBefore(code4);
    }
    effects.consume(code4);
    return cdata;
  }
  function cdataClose(code4) {
    if (code4 === codes.rightSquareBracket) {
      effects.consume(code4);
      return cdataEnd;
    }
    return cdata(code4);
  }
  function cdataEnd(code4) {
    if (code4 === codes.greaterThan) {
      return end(code4);
    }
    if (code4 === codes.rightSquareBracket) {
      effects.consume(code4);
      return cdataEnd;
    }
    return cdata(code4);
  }
  function declaration(code4) {
    if (code4 === codes.eof || code4 === codes.greaterThan) {
      return end(code4);
    }
    if (markdownLineEnding(code4)) {
      returnState = declaration;
      return lineEndingBefore(code4);
    }
    effects.consume(code4);
    return declaration;
  }
  function instruction(code4) {
    if (code4 === codes.eof) {
      return nok(code4);
    }
    if (code4 === codes.questionMark) {
      effects.consume(code4);
      return instructionClose;
    }
    if (markdownLineEnding(code4)) {
      returnState = instruction;
      return lineEndingBefore(code4);
    }
    effects.consume(code4);
    return instruction;
  }
  function instructionClose(code4) {
    return code4 === codes.greaterThan ? end(code4) : instruction(code4);
  }
  function tagCloseStart(code4) {
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      return tagClose;
    }
    return nok(code4);
  }
  function tagClose(code4) {
    if (code4 === codes.dash || asciiAlphanumeric(code4)) {
      effects.consume(code4);
      return tagClose;
    }
    return tagCloseBetween(code4);
  }
  function tagCloseBetween(code4) {
    if (markdownLineEnding(code4)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code4);
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return tagCloseBetween;
    }
    return end(code4);
  }
  function tagOpen(code4) {
    if (code4 === codes.dash || asciiAlphanumeric(code4)) {
      effects.consume(code4);
      return tagOpen;
    }
    if (code4 === codes.slash || code4 === codes.greaterThan || markdownLineEndingOrSpace(code4)) {
      return tagOpenBetween(code4);
    }
    return nok(code4);
  }
  function tagOpenBetween(code4) {
    if (code4 === codes.slash) {
      effects.consume(code4);
      return end;
    }
    if (code4 === codes.colon || code4 === codes.underscore || asciiAlpha(code4)) {
      effects.consume(code4);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code4)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code4);
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return tagOpenBetween;
    }
    return end(code4);
  }
  function tagOpenAttributeName(code4) {
    if (code4 === codes.dash || code4 === codes.dot || code4 === codes.colon || code4 === codes.underscore || asciiAlphanumeric(code4)) {
      effects.consume(code4);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code4);
  }
  function tagOpenAttributeNameAfter(code4) {
    if (code4 === codes.equalsTo) {
      effects.consume(code4);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code4)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code4);
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code4);
  }
  function tagOpenAttributeValueBefore(code4) {
    if (code4 === codes.eof || code4 === codes.lessThan || code4 === codes.equalsTo || code4 === codes.greaterThan || code4 === codes.graveAccent) {
      return nok(code4);
    }
    if (code4 === codes.quotationMark || code4 === codes.apostrophe) {
      effects.consume(code4);
      marker = code4;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code4)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code4);
    }
    if (markdownSpace(code4)) {
      effects.consume(code4);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code4);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code4) {
    if (code4 === marker) {
      effects.consume(code4);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code4 === codes.eof) {
      return nok(code4);
    }
    if (markdownLineEnding(code4)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code4);
    }
    effects.consume(code4);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code4) {
    if (code4 === codes.eof || code4 === codes.quotationMark || code4 === codes.apostrophe || code4 === codes.lessThan || code4 === codes.equalsTo || code4 === codes.graveAccent) {
      return nok(code4);
    }
    if (code4 === codes.slash || code4 === codes.greaterThan || markdownLineEndingOrSpace(code4)) {
      return tagOpenBetween(code4);
    }
    effects.consume(code4);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code4) {
    if (code4 === codes.slash || code4 === codes.greaterThan || markdownLineEndingOrSpace(code4)) {
      return tagOpenBetween(code4);
    }
    return nok(code4);
  }
  function end(code4) {
    if (code4 === codes.greaterThan) {
      effects.consume(code4);
      effects.exit(types.htmlTextData);
      effects.exit(types.htmlText);
      return ok3;
    }
    return nok(code4);
  }
  function lineEndingBefore(code4) {
    ok(returnState, "expected return state");
    ok(markdownLineEnding(code4), "expected eol");
    effects.exit(types.htmlTextData);
    effects.enter(types.lineEnding);
    effects.consume(code4);
    effects.exit(types.lineEnding);
    return lineEndingAfter;
  }
  function lineEndingAfter(code4) {
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return markdownSpace(code4) ? factorySpace(
      effects,
      lineEndingAfterPrefix,
      types.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code4) : lineEndingAfterPrefix(code4);
  }
  function lineEndingAfterPrefix(code4) {
    effects.enter(types.htmlTextData);
    return returnState(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-end.js
var labelEnd = {
  name: "labelEnd",
  resolveAll: resolveAllLabelEnd,
  resolveTo: resolveToLabelEnd,
  tokenize: tokenizeLabelEnd
};
var resourceConstruct = { tokenize: tokenizeResource };
var referenceFullConstruct = { tokenize: tokenizeReferenceFull };
var referenceCollapsedConstruct = { tokenize: tokenizeReferenceCollapsed };
function resolveAllLabelEnd(events) {
  let index4 = -1;
  const newEvents = [];
  while (++index4 < events.length) {
    const token = events[index4][1];
    newEvents.push(events[index4]);
    if (token.type === types.labelImage || token.type === types.labelLink || token.type === types.labelEnd) {
      const offset4 = token.type === types.labelImage ? 4 : 2;
      token.type = types.data;
      index4 += offset4;
    }
  }
  if (events.length !== newEvents.length) {
    splice(events, 0, events.length, newEvents);
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index4 = events.length;
  let offset4 = 0;
  let token;
  let open2;
  let close2;
  let media;
  while (index4--) {
    token = events[index4][1];
    if (open2) {
      if (token.type === types.link || token.type === types.labelLink && token._inactive) {
        break;
      }
      if (events[index4][0] === "enter" && token.type === types.labelLink) {
        token._inactive = true;
      }
    } else if (close2) {
      if (events[index4][0] === "enter" && (token.type === types.labelImage || token.type === types.labelLink) && !token._balanced) {
        open2 = index4;
        if (token.type !== types.labelLink) {
          offset4 = 2;
          break;
        }
      }
    } else if (token.type === types.labelEnd) {
      close2 = index4;
    }
  }
  ok(open2 !== void 0, "`open` is supposed to be found");
  ok(close2 !== void 0, "`close` is supposed to be found");
  const group = {
    type: events[open2][1].type === types.labelLink ? types.link : types.image,
    start: { ...events[open2][1].start },
    end: { ...events[events.length - 1][1].end }
  };
  const label = {
    type: types.label,
    start: { ...events[open2][1].start },
    end: { ...events[close2][1].end }
  };
  const text10 = {
    type: types.labelText,
    start: { ...events[open2 + offset4 + 2][1].end },
    end: { ...events[close2 - 2][1].start }
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push(media, events.slice(open2 + 1, open2 + offset4 + 3));
  media = push(media, [["enter", text10, context]]);
  ok(
    context.parser.constructs.insideSpan.null,
    "expected `insideSpan.null` to be populated"
  );
  media = push(
    media,
    resolveAll(
      context.parser.constructs.insideSpan.null,
      events.slice(open2 + offset4 + 4, close2 - 3),
      context
    )
  );
  media = push(media, [
    ["exit", text10, context],
    events[close2 - 2],
    events[close2 - 1],
    ["exit", label, context]
  ]);
  media = push(media, events.slice(close2 + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open2, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok3, nok) {
  const self2 = this;
  let index4 = self2.events.length;
  let labelStart;
  let defined;
  while (index4--) {
    if ((self2.events[index4][1].type === types.labelImage || self2.events[index4][1].type === types.labelLink) && !self2.events[index4][1]._balanced) {
      labelStart = self2.events[index4][1];
      break;
    }
  }
  return start2;
  function start2(code4) {
    ok(code4 === codes.rightSquareBracket, "expected `]`");
    if (!labelStart) {
      return nok(code4);
    }
    if (labelStart._inactive) {
      return labelEndNok(code4);
    }
    defined = self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize({ start: labelStart.end, end: self2.now() })
      )
    );
    effects.enter(types.labelEnd);
    effects.enter(types.labelMarker);
    effects.consume(code4);
    effects.exit(types.labelMarker);
    effects.exit(types.labelEnd);
    return after;
  }
  function after(code4) {
    if (code4 === codes.leftParenthesis) {
      return effects.attempt(
        resourceConstruct,
        labelEndOk,
        defined ? labelEndOk : labelEndNok
      )(code4);
    }
    if (code4 === codes.leftSquareBracket) {
      return effects.attempt(
        referenceFullConstruct,
        labelEndOk,
        defined ? referenceNotFull : labelEndNok
      )(code4);
    }
    return defined ? labelEndOk(code4) : labelEndNok(code4);
  }
  function referenceNotFull(code4) {
    return effects.attempt(
      referenceCollapsedConstruct,
      labelEndOk,
      labelEndNok
    )(code4);
  }
  function labelEndOk(code4) {
    return ok3(code4);
  }
  function labelEndNok(code4) {
    labelStart._balanced = true;
    return nok(code4);
  }
}
function tokenizeResource(effects, ok3, nok) {
  return resourceStart;
  function resourceStart(code4) {
    ok(code4 === codes.leftParenthesis, "expected left paren");
    effects.enter(types.resource);
    effects.enter(types.resourceMarker);
    effects.consume(code4);
    effects.exit(types.resourceMarker);
    return resourceBefore;
  }
  function resourceBefore(code4) {
    return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, resourceOpen)(code4) : resourceOpen(code4);
  }
  function resourceOpen(code4) {
    if (code4 === codes.rightParenthesis) {
      return resourceEnd(code4);
    }
    return factoryDestination(
      effects,
      resourceDestinationAfter,
      resourceDestinationMissing,
      types.resourceDestination,
      types.resourceDestinationLiteral,
      types.resourceDestinationLiteralMarker,
      types.resourceDestinationRaw,
      types.resourceDestinationString,
      constants.linkResourceDestinationBalanceMax
    )(code4);
  }
  function resourceDestinationAfter(code4) {
    return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, resourceBetween)(code4) : resourceEnd(code4);
  }
  function resourceDestinationMissing(code4) {
    return nok(code4);
  }
  function resourceBetween(code4) {
    if (code4 === codes.quotationMark || code4 === codes.apostrophe || code4 === codes.leftParenthesis) {
      return factoryTitle(
        effects,
        resourceTitleAfter,
        nok,
        types.resourceTitle,
        types.resourceTitleMarker,
        types.resourceTitleString
      )(code4);
    }
    return resourceEnd(code4);
  }
  function resourceTitleAfter(code4) {
    return markdownLineEndingOrSpace(code4) ? factoryWhitespace(effects, resourceEnd)(code4) : resourceEnd(code4);
  }
  function resourceEnd(code4) {
    if (code4 === codes.rightParenthesis) {
      effects.enter(types.resourceMarker);
      effects.consume(code4);
      effects.exit(types.resourceMarker);
      effects.exit(types.resource);
      return ok3;
    }
    return nok(code4);
  }
}
function tokenizeReferenceFull(effects, ok3, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code4) {
    ok(code4 === codes.leftSquareBracket, "expected left bracket");
    return factoryLabel.call(
      self2,
      effects,
      referenceFullAfter,
      referenceFullMissing,
      types.reference,
      types.referenceMarker,
      types.referenceString
    )(code4);
  }
  function referenceFullAfter(code4) {
    return self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
      )
    ) ? ok3(code4) : nok(code4);
  }
  function referenceFullMissing(code4) {
    return nok(code4);
  }
}
function tokenizeReferenceCollapsed(effects, ok3, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code4) {
    ok(code4 === codes.leftSquareBracket, "expected left bracket");
    effects.enter(types.reference);
    effects.enter(types.referenceMarker);
    effects.consume(code4);
    effects.exit(types.referenceMarker);
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code4) {
    if (code4 === codes.rightSquareBracket) {
      effects.enter(types.referenceMarker);
      effects.consume(code4);
      effects.exit(types.referenceMarker);
      effects.exit(types.reference);
      return ok3;
    }
    return nok(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-start-image.js
var labelStartImage = {
  name: "labelStartImage",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartImage
};
function tokenizeLabelStartImage(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code4) {
    ok(code4 === codes.exclamationMark, "expected `!`");
    effects.enter(types.labelImage);
    effects.enter(types.labelImageMarker);
    effects.consume(code4);
    effects.exit(types.labelImageMarker);
    return open2;
  }
  function open2(code4) {
    if (code4 === codes.leftSquareBracket) {
      effects.enter(types.labelMarker);
      effects.consume(code4);
      effects.exit(types.labelMarker);
      effects.exit(types.labelImage);
      return after;
    }
    return nok(code4);
  }
  function after(code4) {
    return code4 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code4) : ok3(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/label-start-link.js
var labelStartLink = {
  name: "labelStartLink",
  resolveAll: labelEnd.resolveAll,
  tokenize: tokenizeLabelStartLink
};
function tokenizeLabelStartLink(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code4) {
    ok(code4 === codes.leftSquareBracket, "expected `[`");
    effects.enter(types.labelLink);
    effects.enter(types.labelMarker);
    effects.consume(code4);
    effects.exit(types.labelMarker);
    effects.exit(types.labelLink);
    return after;
  }
  function after(code4) {
    return code4 === codes.caret && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code4) : ok3(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/line-ending.js
var lineEnding = { name: "lineEnding", tokenize: tokenizeLineEnding };
function tokenizeLineEnding(effects, ok3) {
  return start2;
  function start2(code4) {
    ok(markdownLineEnding(code4), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code4);
    effects.exit(types.lineEnding);
    return factorySpace(effects, ok3, types.linePrefix);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/thematic-break.js
var thematicBreak = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok3, nok) {
  let size4 = 0;
  let marker;
  return start2;
  function start2(code4) {
    effects.enter(types.thematicBreak);
    return before(code4);
  }
  function before(code4) {
    ok(
      code4 === codes.asterisk || code4 === codes.dash || code4 === codes.underscore,
      "expected `*`, `-`, or `_`"
    );
    marker = code4;
    return atBreak(code4);
  }
  function atBreak(code4) {
    if (code4 === marker) {
      effects.enter(types.thematicBreakSequence);
      return sequence(code4);
    }
    if (size4 >= constants.thematicBreakMarkerCountMin && (code4 === codes.eof || markdownLineEnding(code4))) {
      effects.exit(types.thematicBreak);
      return ok3(code4);
    }
    return nok(code4);
  }
  function sequence(code4) {
    if (code4 === marker) {
      effects.consume(code4);
      size4++;
      return sequence;
    }
    effects.exit(types.thematicBreakSequence);
    return markdownSpace(code4) ? factorySpace(effects, atBreak, types.whitespace)(code4) : atBreak(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/list.js
var list = {
  continuation: { tokenize: tokenizeListContinuation },
  exit: tokenizeListEnd,
  name: "list",
  tokenize: tokenizeListStart
};
var listItemPrefixWhitespaceConstruct = {
  partial: true,
  tokenize: tokenizeListItemPrefixWhitespace
};
var indentConstruct = { partial: true, tokenize: tokenizeIndent };
function tokenizeListStart(effects, ok3, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size4 = 0;
  return start2;
  function start2(code4) {
    ok(self2.containerState, "expected state");
    const kind = self2.containerState.type || (code4 === codes.asterisk || code4 === codes.plusSign || code4 === codes.dash ? types.listUnordered : types.listOrdered);
    if (kind === types.listUnordered ? !self2.containerState.marker || code4 === self2.containerState.marker : asciiDigit(code4)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, { _container: true });
      }
      if (kind === types.listUnordered) {
        effects.enter(types.listItemPrefix);
        return code4 === codes.asterisk || code4 === codes.dash ? effects.check(thematicBreak, nok, atMarker)(code4) : atMarker(code4);
      }
      if (!self2.interrupt || code4 === codes.digit1) {
        effects.enter(types.listItemPrefix);
        effects.enter(types.listItemValue);
        return inside(code4);
      }
    }
    return nok(code4);
  }
  function inside(code4) {
    ok(self2.containerState, "expected state");
    if (asciiDigit(code4) && ++size4 < constants.listItemValueSizeMax) {
      effects.consume(code4);
      return inside;
    }
    if ((!self2.interrupt || size4 < 2) && (self2.containerState.marker ? code4 === self2.containerState.marker : code4 === codes.rightParenthesis || code4 === codes.dot)) {
      effects.exit(types.listItemValue);
      return atMarker(code4);
    }
    return nok(code4);
  }
  function atMarker(code4) {
    ok(self2.containerState, "expected state");
    ok(code4 !== codes.eof, "eof (`null`) is not a marker");
    effects.enter(types.listItemMarker);
    effects.consume(code4);
    effects.exit(types.listItemMarker);
    self2.containerState.marker = self2.containerState.marker || code4;
    return effects.check(
      blankLine,
      // Cant be empty when interrupting.
      self2.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    );
  }
  function onBlank(code4) {
    ok(self2.containerState, "expected state");
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code4);
  }
  function otherPrefix(code4) {
    if (markdownSpace(code4)) {
      effects.enter(types.listItemPrefixWhitespace);
      effects.consume(code4);
      effects.exit(types.listItemPrefixWhitespace);
      return endOfPrefix;
    }
    return nok(code4);
  }
  function endOfPrefix(code4) {
    ok(self2.containerState, "expected state");
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit(types.listItemPrefix), true).length;
    return ok3(code4);
  }
}
function tokenizeListContinuation(effects, ok3, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code4) {
    ok(self2.containerState, "expected state");
    ok(typeof self2.containerState.size === "number", "expected size");
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(
      effects,
      ok3,
      types.listItemIndent,
      self2.containerState.size + 1
    )(code4);
  }
  function notBlank(code4) {
    ok(self2.containerState, "expected state");
    if (self2.containerState.furtherBlankLines || !markdownSpace(code4)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code4);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok3, notInCurrentItem)(code4);
  }
  function notInCurrentItem(code4) {
    ok(self2.containerState, "expected state");
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    ok(
      self2.parser.constructs.disable.null,
      "expected `disable.null` to be populated"
    );
    return factorySpace(
      effects,
      effects.attempt(list, ok3, nok),
      types.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    )(code4);
  }
}
function tokenizeIndent(effects, ok3, nok) {
  const self2 = this;
  ok(self2.containerState, "expected state");
  ok(typeof self2.containerState.size === "number", "expected size");
  return factorySpace(
    effects,
    afterPrefix,
    types.listItemIndent,
    self2.containerState.size + 1
  );
  function afterPrefix(code4) {
    ok(self2.containerState, "expected state");
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === types.listItemIndent && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok3(code4) : nok(code4);
  }
}
function tokenizeListEnd(effects) {
  ok(this.containerState, "expected state");
  ok(typeof this.containerState.type === "string", "expected type");
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok3, nok) {
  const self2 = this;
  ok(
    self2.parser.constructs.disable.null,
    "expected `disable.null` to be populated"
  );
  return factorySpace(
    effects,
    afterPrefix,
    types.listItemPrefixWhitespace,
    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize + 1
  );
  function afterPrefix(code4) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code4) && tail && tail[1].type === types.listItemPrefixWhitespace ? ok3(code4) : nok(code4);
  }
}

// node_modules/micromark-core-commonmark/dev/lib/setext-underline.js
var setextUnderline = {
  name: "setextUnderline",
  resolveTo: resolveToSetextUnderline,
  tokenize: tokenizeSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index4 = events.length;
  let content3;
  let text10;
  let definition3;
  while (index4--) {
    if (events[index4][0] === "enter") {
      if (events[index4][1].type === types.content) {
        content3 = index4;
        break;
      }
      if (events[index4][1].type === types.paragraph) {
        text10 = index4;
      }
    } else {
      if (events[index4][1].type === types.content) {
        events.splice(index4, 1);
      }
      if (!definition3 && events[index4][1].type === types.definition) {
        definition3 = index4;
      }
    }
  }
  ok(text10 !== void 0, "expected a `text` index to be found");
  ok(content3 !== void 0, "expected a `text` index to be found");
  ok(events[content3][2] === context, "enter context should be same");
  ok(
    events[events.length - 1][2] === context,
    "enter context should be same"
  );
  const heading3 = {
    type: types.setextHeading,
    start: { ...events[content3][1].start },
    end: { ...events[events.length - 1][1].end }
  };
  events[text10][1].type = types.setextHeadingText;
  if (definition3) {
    events.splice(text10, 0, ["enter", heading3, context]);
    events.splice(definition3 + 1, 0, ["exit", events[content3][1], context]);
    events[content3][1].end = { ...events[definition3][1].end };
  } else {
    events[content3][1] = heading3;
  }
  events.push(["exit", heading3, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok3, nok) {
  const self2 = this;
  let marker;
  return start2;
  function start2(code4) {
    let index4 = self2.events.length;
    let paragraph3;
    ok(
      code4 === codes.dash || code4 === codes.equalsTo,
      "expected `=` or `-`"
    );
    while (index4--) {
      if (self2.events[index4][1].type !== types.lineEnding && self2.events[index4][1].type !== types.linePrefix && self2.events[index4][1].type !== types.content) {
        paragraph3 = self2.events[index4][1].type === types.paragraph;
        break;
      }
    }
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph3)) {
      effects.enter(types.setextHeadingLine);
      marker = code4;
      return before(code4);
    }
    return nok(code4);
  }
  function before(code4) {
    effects.enter(types.setextHeadingLineSequence);
    return inside(code4);
  }
  function inside(code4) {
    if (code4 === marker) {
      effects.consume(code4);
      return inside;
    }
    effects.exit(types.setextHeadingLineSequence);
    return markdownSpace(code4) ? factorySpace(effects, after, types.lineSuffix)(code4) : after(code4);
  }
  function after(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types.setextHeadingLine);
      return ok3(code4);
    }
    return nok(code4);
  }
}

// node_modules/micromark/dev/lib/initialize/flow.js
var flow = { tokenize: initializeFlow };
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content2, afterConstruct)
        ),
        types.linePrefix
      )
    )
  );
  return initial;
  function atBlankEnding(code4) {
    ok(
      code4 === codes.eof || markdownLineEnding(code4),
      "expected eol or eof"
    );
    if (code4 === codes.eof) {
      effects.consume(code4);
      return;
    }
    effects.enter(types.lineEndingBlank);
    effects.consume(code4);
    effects.exit(types.lineEndingBlank);
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code4) {
    ok(
      code4 === codes.eof || markdownLineEnding(code4),
      "expected eol or eof"
    );
    if (code4 === codes.eof) {
      effects.consume(code4);
      return;
    }
    effects.enter(types.lineEnding);
    effects.consume(code4);
    effects.exit(types.lineEnding);
    self2.currentConstruct = void 0;
    return initial;
  }
}

// node_modules/micromark/dev/lib/initialize/text.js
var resolver = { resolveAll: createResolver() };
var string = initializeFactory("string");
var text2 = initializeFactory("text");
function initializeFactory(field) {
  return {
    resolveAll: createResolver(
      field === "text" ? resolveAllLineSuffixes : void 0
    ),
    tokenize: initializeText
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text10 = effects.attempt(constructs2, start2, notText);
    return start2;
    function start2(code4) {
      return atBreak(code4) ? text10(code4) : notText(code4);
    }
    function notText(code4) {
      if (code4 === codes.eof) {
        effects.consume(code4);
        return;
      }
      effects.enter(types.data);
      effects.consume(code4);
      return data;
    }
    function data(code4) {
      if (atBreak(code4)) {
        effects.exit(types.data);
        return text10(code4);
      }
      effects.consume(code4);
      return data;
    }
    function atBreak(code4) {
      if (code4 === codes.eof) {
        return true;
      }
      const list4 = constructs2[code4];
      let index4 = -1;
      if (list4) {
        ok(Array.isArray(list4), "expected `disable.null` to be populated");
        while (++index4 < list4.length) {
          const item = list4[index4];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index4 = -1;
    let enter;
    while (++index4 <= events.length) {
      if (enter === void 0) {
        if (events[index4] && events[index4][1].type === types.data) {
          enter = index4;
          index4++;
        }
      } else if (!events[index4] || events[index4][1].type !== types.data) {
        if (index4 !== enter + 2) {
          events[enter][1].end = events[index4 - 1][1].end;
          events.splice(enter + 2, index4 - enter - 2);
          index4 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === types.lineEnding) && events[eventIndex - 1][1].type === types.data) {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index4 = chunks.length;
      let bufferIndex = -1;
      let size4 = 0;
      let tabs;
      while (index4--) {
        const chunk = chunks[index4];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === codes.space) {
            size4++;
            bufferIndex--;
          }
          if (bufferIndex) break;
          bufferIndex = -1;
        } else if (chunk === codes.horizontalTab) {
          tabs = true;
          size4++;
        } else if (chunk === codes.virtualSpace) {
        } else {
          index4++;
          break;
        }
      }
      if (context._contentTypeTextTrailing && eventIndex === events.length) {
        size4 = 0;
      }
      if (size4) {
        const token = {
          type: eventIndex === events.length || tabs || size4 < constants.hardBreakPrefixSizeMin ? types.lineSuffix : types.hardBreakTrailing,
          start: {
            _bufferIndex: index4 ? bufferIndex : data.start._bufferIndex + bufferIndex,
            _index: data.start._index + index4,
            line: data.end.line,
            column: data.end.column - size4,
            offset: data.end.offset - size4
          },
          end: { ...data.end }
        };
        data.end = { ...token.start };
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(
            eventIndex,
            0,
            ["enter", token, context],
            ["exit", token, context]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}

// node_modules/micromark/dev/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document3,
  flow: () => flow2,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string2,
  text: () => text3
});
var document3 = {
  [codes.asterisk]: list,
  [codes.plusSign]: list,
  [codes.dash]: list,
  [codes.digit0]: list,
  [codes.digit1]: list,
  [codes.digit2]: list,
  [codes.digit3]: list,
  [codes.digit4]: list,
  [codes.digit5]: list,
  [codes.digit6]: list,
  [codes.digit7]: list,
  [codes.digit8]: list,
  [codes.digit9]: list,
  [codes.greaterThan]: blockQuote
};
var contentInitial = {
  [codes.leftSquareBracket]: definition
};
var flowInitial = {
  [codes.horizontalTab]: codeIndented,
  [codes.virtualSpace]: codeIndented,
  [codes.space]: codeIndented
};
var flow2 = {
  [codes.numberSign]: headingAtx,
  [codes.asterisk]: thematicBreak,
  [codes.dash]: [setextUnderline, thematicBreak],
  [codes.lessThan]: htmlFlow,
  [codes.equalsTo]: setextUnderline,
  [codes.underscore]: thematicBreak,
  [codes.graveAccent]: codeFenced,
  [codes.tilde]: codeFenced
};
var string2 = {
  [codes.ampersand]: characterReference,
  [codes.backslash]: characterEscape
};
var text3 = {
  [codes.carriageReturn]: lineEnding,
  [codes.lineFeed]: lineEnding,
  [codes.carriageReturnLineFeed]: lineEnding,
  [codes.exclamationMark]: labelStartImage,
  [codes.ampersand]: characterReference,
  [codes.asterisk]: attention,
  [codes.lessThan]: [autolink, htmlText],
  [codes.leftSquareBracket]: labelStartLink,
  [codes.backslash]: [hardBreakEscape, characterEscape],
  [codes.rightSquareBracket]: labelEnd,
  [codes.underscore]: attention,
  [codes.graveAccent]: codeText
};
var insideSpan = { null: [attention, resolver] };
var attentionMarkers = { null: [codes.asterisk, codes.underscore] };
var disable = { null: [] };

// node_modules/micromark/dev/lib/create-tokenizer.js
var import_debug = __toESM(require_browser(), 1);
var debug = (0, import_debug.default)("micromark");
function createTokenizer(parser, initialize, from) {
  let point5 = {
    _bufferIndex: -1,
    _index: 0,
    line: from && from.line || 1,
    column: from && from.column || 1,
    offset: from && from.offset || 0
  };
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    consume,
    enter,
    exit: exit3,
    interrupt: constructFactory(onsuccessfulcheck, { interrupt: true })
  };
  const context = {
    code: codes.eof,
    containerState: {},
    defineSkip,
    events: [],
    now,
    parser,
    previous: codes.eof,
    sliceSerialize,
    sliceStream,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice) {
    chunks = push(chunks, slice);
    main2();
    if (chunks[chunks.length - 1] !== codes.eof) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    const { _bufferIndex, _index, line, column, offset: offset4 } = point5;
    return { _bufferIndex, _index, line, column, offset: offset4 };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
    debug("position: define skip: `%j`", point5);
  }
  function main2() {
    let chunkIndex;
    while (point5._index < chunks.length) {
      const chunk = chunks[point5._index];
      if (typeof chunk === "string") {
        chunkIndex = point5._index;
        if (point5._bufferIndex < 0) {
          point5._bufferIndex = 0;
        }
        while (point5._index === chunkIndex && point5._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point5._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code4) {
    ok(consumed === true, "expected character to be consumed");
    consumed = void 0;
    debug("main: passing `%s` to %s", code4, state && state.name);
    expectedCode = code4;
    ok(typeof state === "function", "expected state");
    state = state(code4);
  }
  function consume(code4) {
    ok(code4 === expectedCode, "expected given code to equal expected code");
    debug("consume: `%s`", code4);
    ok(
      consumed === void 0,
      "expected code to not have been consumed: this might be because `return x(code)` instead of `return x` was used"
    );
    ok(
      code4 === null ? context.events.length === 0 || context.events[context.events.length - 1][0] === "exit" : context.events[context.events.length - 1][0] === "enter",
      "expected last token to be open"
    );
    if (markdownLineEnding(code4)) {
      point5.line++;
      point5.column = 1;
      point5.offset += code4 === codes.carriageReturnLineFeed ? 2 : 1;
      accountForPotentialSkip();
      debug("position: after eol: `%j`", point5);
    } else if (code4 !== codes.virtualSpace) {
      point5.column++;
      point5.offset++;
    }
    if (point5._bufferIndex < 0) {
      point5._index++;
    } else {
      point5._bufferIndex++;
      if (point5._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
      // strings.
      /** @type {string} */
      chunks[point5._index].length) {
        point5._bufferIndex = -1;
        point5._index++;
      }
    }
    context.previous = code4;
    consumed = true;
  }
  function enter(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now();
    ok(typeof type === "string", "expected string type");
    ok(type.length > 0, "expected non-empty string");
    debug("enter: `%s`", type);
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit3(type) {
    ok(typeof type === "string", "expected string type");
    ok(type.length > 0, "expected non-empty string");
    const token = stack.pop();
    ok(token, "cannot close w/o open tokens");
    token.end = now();
    ok(type === token.type, "expected exit token to match current token");
    ok(
      !(token.start._index === token.end._index && token.start._bufferIndex === token.end._bufferIndex),
      "expected non-empty token (`" + type + "`)"
    );
    debug("exit: `%s`", token.type);
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_10, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? (
        /* c8 ignore next 1 */
        handleListOfConstructs(constructs2)
      ) : "tokenize" in constructs2 ? (
        // Looks like a construct.
        handleListOfConstructs([
          /** @type {Construct} */
          constructs2
        ])
      ) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map3) {
        return start2;
        function start2(code4) {
          const left = code4 !== null && map3[code4];
          const all5 = code4 !== null && map3.null;
          const list4 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(left) ? left : left ? [left] : [],
            ...Array.isArray(all5) ? all5 : all5 ? [all5] : []
          ];
          return handleListOfConstructs(list4)(code4);
        }
      }
      function handleListOfConstructs(list4) {
        listOfConstructs = list4;
        constructIndex = 0;
        if (list4.length === 0) {
          ok(bogusState, "expected `bogusState` to be given");
          return bogusState;
        }
        return handleConstruct(list4[constructIndex]);
      }
      function handleConstruct(construct) {
        return start2;
        function start2(code4) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          ok(
            context.parser.constructs.disable.null,
            "expected `disable.null` to be populated"
          );
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code4);
          }
          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok3,
            nok
          )(code4);
        }
      }
      function ok3(code4) {
        ok(code4 === expectedCode, "expected code");
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code4) {
        ok(code4 === expectedCode, "expected code");
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(
        context.events,
        from2,
        context.events.length - from2,
        construct.resolve(context.events.slice(from2), context)
      );
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
    ok(
      construct.partial || context.events.length === 0 || context.events[context.events.length - 1][0] === "exit",
      "expected last token to end"
    );
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return { from: startEventsIndex, restore };
    function restore() {
      point5 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
      debug("position: restore: `%j`", point5);
    }
  }
  function accountForPotentialSkip() {
    if (point5.line in columnStart && point5.column < 2) {
      point5.column = columnStart[point5.line];
      point5.offset += columnStart[point5.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    ok(endBufferIndex > -1, "expected non-negative end buffer index");
    ok(startBufferIndex > -1, "expected non-negative start buffer index");
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head = view[0];
      if (typeof head === "string") {
        view[0] = head.slice(startBufferIndex);
      } else {
        ok(startBufferIndex === 0, "expected `startBufferIndex` to be `0`");
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index4 = -1;
  const result = [];
  let atTab;
  while (++index4 < chunks.length) {
    const chunk = chunks[index4];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case codes.carriageReturn: {
          value = values.cr;
          break;
        }
        case codes.lineFeed: {
          value = values.lf;
          break;
        }
        case codes.carriageReturnLineFeed: {
          value = values.cr + values.lf;
          break;
        }
        case codes.horizontalTab: {
          value = expandTabs ? values.space : values.ht;
          break;
        }
        case codes.virtualSpace: {
          if (!expandTabs && atTab) continue;
          value = values.space;
          break;
        }
        default: {
          ok(typeof chunk === "number", "expected number");
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === codes.horizontalTab;
    result.push(value);
  }
  return result.join("");
}

// node_modules/micromark/dev/lib/parse.js
function parse3(options) {
  const settings = options || {};
  const constructs2 = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([constructs_exports, ...settings.extensions || []])
  );
  const parser = {
    constructs: constructs2,
    content: create3(content),
    defined: [],
    document: create3(document2),
    flow: create3(flow),
    lazy: {},
    string: create3(string),
    text: create3(text2)
  };
  return parser;
  function create3(initial) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial, from);
    }
  }
}

// node_modules/micromark/dev/lib/postprocess.js
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}

// node_modules/micromark/dev/lib/preprocess.js
var search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer = "";
  let start2 = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match;
    let next2;
    let startPosition;
    let endPosition;
    let code4;
    value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
    startPosition = 0;
    buffer = "";
    if (start2) {
      if (value.charCodeAt(0) === codes.byteOrderMarker) {
        startPosition++;
      }
      start2 = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match = search.exec(value);
      endPosition = match && match.index !== void 0 ? match.index : value.length;
      code4 = value.charCodeAt(endPosition);
      if (!match) {
        buffer = value.slice(startPosition);
        break;
      }
      if (code4 === codes.lf && startPosition === endPosition && atCarriageReturn) {
        chunks.push(codes.carriageReturnLineFeed);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(codes.carriageReturn);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code4) {
          case codes.nul: {
            chunks.push(codes.replacementCharacter);
            column++;
            break;
          }
          case codes.ht: {
            next2 = Math.ceil(column / constants.tabSize) * constants.tabSize;
            chunks.push(codes.horizontalTab);
            while (column++ < next2) chunks.push(codes.virtualSpace);
            break;
          }
          case codes.lf: {
            chunks.push(codes.lineFeed);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn) chunks.push(codes.carriageReturn);
      if (buffer) chunks.push(buffer);
      chunks.push(codes.eof);
    }
    return chunks;
  }
}

// node_modules/micromark-util-decode-string/dev/index.js
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $22) {
  if ($1) {
    return $1;
  }
  const head = $22.charCodeAt(0);
  if (head === codes.numberSign) {
    const head2 = $22.charCodeAt(1);
    const hex = head2 === codes.lowercaseX || head2 === codes.uppercaseX;
    return decodeNumericCharacterReference(
      $22.slice(hex ? 2 : 1),
      hex ? constants.numericBaseHexadecimal : constants.numericBaseDecimal
    );
  }
  return decodeNamedCharacterReference($22) || $0;
}

// node_modules/mdast-util-from-markdown/dev/lib/index.js
var own2 = {}.hasOwnProperty;
function fromMarkdown(value, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(
    postprocess(
      parse3(options).document().write(preprocess()(value, encoding, true))
    )
  );
}
function compiler(options) {
  const config = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link3),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading3),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener(codeFlow, buffer),
      codeText: opener(codeText2, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition3),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener(emphasis3),
      hardBreakEscape: opener(hardBreak3),
      hardBreakTrailing: opener(hardBreak3),
      htmlFlow: opener(html8, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener(html8, buffer),
      htmlTextData: onenterdata,
      image: opener(image3),
      label: buffer,
      link: opener(link3),
      listItem: opener(listItem3),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list4, onenterlistordered),
      listUnordered: opener(list4),
      paragraph: opener(paragraph3),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener(heading3),
      strong: opener(strong3),
      thematicBreak: opener(thematicBreak4)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      characterReference: onexitcharacterreference,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config, (options || {}).mdastExtensions || []);
  const data = {};
  return compile2;
  function compile2(events) {
    let tree = { type: "root", children: [] };
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter,
      exit: exit3,
      buffer,
      resume,
      data
    };
    const listStack = [];
    let index4 = -1;
    while (++index4 < events.length) {
      if (events[index4][1].type === types.listOrdered || events[index4][1].type === types.listUnordered) {
        if (events[index4][0] === "enter") {
          listStack.push(index4);
        } else {
          const tail = listStack.pop();
          ok(typeof tail === "number", "expected list ot be open");
          index4 = prepareList(events, tail, index4);
        }
      }
    }
    index4 = -1;
    while (++index4 < events.length) {
      const handler = config[events[index4][0]];
      if (own2.call(handler, events[index4][1].type)) {
        handler[events[index4][1].type].call(
          Object.assign(
            { sliceSerialize: events[index4][2].sliceSerialize },
            context
          ),
          events[index4][1]
        );
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point3(
        events.length > 0 ? events[0][1].start : { line: 1, column: 1, offset: 0 }
      ),
      end: point3(
        events.length > 0 ? events[events.length - 2][1].end : { line: 1, column: 1, offset: 0 }
      )
    };
    index4 = -1;
    while (++index4 < config.transforms.length) {
      tree = config.transforms[index4](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start2, length) {
    let index4 = start2 - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem4;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index4 <= length) {
      const event = events[index4];
      switch (event[1].type) {
        case types.listUnordered:
        case types.listOrdered:
        case types.blockQuote: {
          if (event[0] === "enter") {
            containerBalance++;
          } else {
            containerBalance--;
          }
          atMarker = void 0;
          break;
        }
        case types.lineEndingBlank: {
          if (event[0] === "enter") {
            if (listItem4 && !atMarker && !containerBalance && !firstBlankLineIndex) {
              firstBlankLineIndex = index4;
            }
            atMarker = void 0;
          }
          break;
        }
        case types.linePrefix:
        case types.listItemValue:
        case types.listItemMarker:
        case types.listItemPrefix:
        case types.listItemPrefixWhitespace: {
          break;
        }
        default: {
          atMarker = void 0;
        }
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === types.listItemPrefix || containerBalance === -1 && event[0] === "exit" && (event[1].type === types.listUnordered || event[1].type === types.listOrdered)) {
        if (listItem4) {
          let tailIndex = index4;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === types.lineEnding || tailEvent[1].type === types.lineEndingBlank) {
              if (tailEvent[0] === "exit") continue;
              if (lineIndex) {
                events[lineIndex][1].type = types.lineEndingBlank;
                listSpread = true;
              }
              tailEvent[1].type = types.lineEnding;
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === types.linePrefix || tailEvent[1].type === types.blockQuotePrefix || tailEvent[1].type === types.blockQuotePrefixWhitespace || tailEvent[1].type === types.blockQuoteMarker || tailEvent[1].type === types.listItemIndent) {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem4._spread = true;
          }
          listItem4.end = Object.assign(
            {},
            lineIndex ? events[lineIndex][1].start : event[1].end
          );
          events.splice(lineIndex || index4, 0, ["exit", listItem4, event[2]]);
          index4++;
          length++;
        }
        if (event[1].type === types.listItemPrefix) {
          const item = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          listItem4 = item;
          events.splice(index4, 0, ["enter", item, event[2]]);
          index4++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start2][1]._spread = listSpread;
    return length;
  }
  function opener(create3, and) {
    return open2;
    function open2(token) {
      enter.call(this, create3(token), token);
      if (and) and.call(this, token);
    }
  }
  function buffer() {
    this.stack.push({ type: "fragment", children: [] });
  }
  function enter(node2, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    ok(parent, "expected `parent`");
    ok("children" in parent, "expected `parent`");
    const siblings = parent.children;
    siblings.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token, errorHandler || void 0]);
    node2.position = {
      start: point3(token.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function closer(and) {
    return close2;
    function close2(token) {
      if (and) and.call(this, token);
      exit3.call(this, token);
    }
  }
  function exit3(token, onExitError) {
    const node2 = this.stack.pop();
    ok(node2, "expected `node`");
    const open2 = this.tokenStack.pop();
    if (!open2) {
      throw new Error(
        "Cannot close `" + token.type + "` (" + stringifyPosition({ start: token.start, end: token.end }) + "): its not open"
      );
    } else if (open2[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open2[0]);
      } else {
        const handler = open2[1] || defaultOnError;
        handler.call(this, token, open2[0]);
      }
    }
    ok(node2.type !== "fragment", "unexpected fragment `exit`ed");
    ok(node2.position, "expected `position` to be defined");
    node2.position.end = point3(token.end);
  }
  function resume() {
    return toString(this.stack.pop());
  }
  function onenterlistordered() {
    this.data.expectingFirstListItemValue = true;
  }
  function onenterlistitemvalue(token) {
    if (this.data.expectingFirstListItemValue) {
      const ancestor = this.stack[this.stack.length - 2];
      ok(ancestor, "expected nodes on stack");
      ok(ancestor.type === "list", "expected list on stack");
      ancestor.start = Number.parseInt(
        this.sliceSerialize(token),
        constants.numericBaseDecimal
      );
      this.data.expectingFirstListItemValue = void 0;
    }
  }
  function onexitcodefencedfenceinfo() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.lang = data2;
  }
  function onexitcodefencedfencemeta() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.meta = data2;
  }
  function onexitcodefencedfence() {
    if (this.data.flowCodeInside) return;
    this.buffer();
    this.data.flowCodeInside = true;
  }
  function onexitcodefenced() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    this.data.flowCodeInside = void 0;
  }
  function onexitcodeindented() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "code", "expected code on stack");
    node2.value = data2.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.title = data2;
  }
  function onexitdefinitiondestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "definition", "expected definition on stack");
    node2.url = data2;
  }
  function onexitatxheadingsequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "heading", "expected heading on stack");
    if (!node2.depth) {
      const depth = this.sliceSerialize(token).length;
      ok(
        depth === 1 || depth === 2 || depth === 3 || depth === 4 || depth === 5 || depth === 6,
        "expected `depth` between `1` and `6`"
      );
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    this.data.setextHeadingSlurpLineEnding = true;
  }
  function onexitsetextheadinglinesequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "heading", "expected heading on stack");
    node2.depth = this.sliceSerialize(token).codePointAt(0) === codes.equalsTo ? 1 : 2;
  }
  function onexitsetextheading() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function onenterdata(token) {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok("children" in node2, "expected parent on stack");
    const siblings = node2.children;
    let tail = siblings[siblings.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text10();
      tail.position = {
        start: point3(token.start),
        // @ts-expect-error: well add `end` later.
        end: void 0
      };
      siblings.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    ok(tail, "expected a `node` to be on the stack");
    ok("value" in tail, "expected a `literal` to be on the stack");
    ok(tail.position, "expected `node` to have an open position");
    tail.value += this.sliceSerialize(token);
    tail.position.end = point3(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    ok(context, "expected `node`");
    if (this.data.atHardBreak) {
      ok("children" in context, "expected `parent`");
      const tail = context.children[context.children.length - 1];
      ok(tail.position, "expected tail to have a starting position");
      tail.position.end = point3(token.end);
      this.data.atHardBreak = void 0;
      return;
    }
    if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    this.data.atHardBreak = true;
  }
  function onexithtmlflow() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "html", "expected html on stack");
    node2.value = data2;
  }
  function onexithtmltext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "html", "expected html on stack");
    node2.value = data2;
  }
  function onexitcodetext() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "inlineCode", "expected inline code on stack");
    node2.value = data2;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "image", "expected image on stack");
    if (this.data.inReference) {
      const referenceType = this.data.referenceType || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    this.data.referenceType = void 0;
  }
  function onexitlabeltext(token) {
    const string3 = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    ok(ancestor, "expected ancestor on stack");
    ok(
      ancestor.type === "image" || ancestor.type === "link",
      "expected image or link on stack"
    );
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment2 = this.stack[this.stack.length - 1];
    ok(fragment2, "expected node on stack");
    ok(fragment2.type === "fragment", "expected fragment on stack");
    const value = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    this.data.inReference = true;
    if (node2.type === "link") {
      const children = fragment2.children;
      node2.children = children;
    } else {
      node2.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    node2.url = data2;
  }
  function onexitresourcetitlestring() {
    const data2 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image or link on stack"
    );
    node2.title = data2;
  }
  function onexitresource() {
    this.data.inReference = void 0;
  }
  function onenterreference() {
    this.data.referenceType = "collapsed";
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(
      node2.type === "image" || node2.type === "link",
      "expected image reference or link reference on stack"
    );
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
    this.data.referenceType = "full";
  }
  function onexitcharacterreferencemarker(token) {
    ok(
      token.type === "characterReferenceMarkerNumeric" || token.type === "characterReferenceMarkerHexadecimal"
    );
    this.data.characterReferenceType = token.type;
  }
  function onexitcharacterreferencevalue(token) {
    const data2 = this.sliceSerialize(token);
    const type = this.data.characterReferenceType;
    let value;
    if (type) {
      value = decodeNumericCharacterReference(
        data2,
        type === types.characterReferenceMarkerNumeric ? constants.numericBaseDecimal : constants.numericBaseHexadecimal
      );
      this.data.characterReferenceType = void 0;
    } else {
      const result = decodeNamedCharacterReference(data2);
      ok(result !== false, "expected reference to decode");
      value = result;
    }
    const tail = this.stack[this.stack.length - 1];
    ok(tail, "expected `node`");
    ok("value" in tail, "expected `node.value`");
    tail.value += value;
  }
  function onexitcharacterreference(token) {
    const tail = this.stack.pop();
    ok(tail, "expected `node`");
    ok(tail.position, "expected `node.position`");
    tail.position.end = point3(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    node2.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2, "expected node on stack");
    ok(node2.type === "link", "expected link on stack");
    node2.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return { type: "blockquote", children: [] };
  }
  function codeFlow() {
    return { type: "code", lang: null, meta: null, value: "" };
  }
  function codeText2() {
    return { type: "inlineCode", value: "" };
  }
  function definition3() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis3() {
    return { type: "emphasis", children: [] };
  }
  function heading3() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function hardBreak3() {
    return { type: "break" };
  }
  function html8() {
    return { type: "html", value: "" };
  }
  function image3() {
    return { type: "image", title: null, url: "", alt: null };
  }
  function link3() {
    return { type: "link", title: null, url: "", children: [] };
  }
  function list4(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem3(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph3() {
    return { type: "paragraph", children: [] };
  }
  function strong3() {
    return { type: "strong", children: [] };
  }
  function text10() {
    return { type: "text", value: "" };
  }
  function thematicBreak4() {
    return { type: "thematicBreak" };
  }
}
function point3(d14) {
  return { line: d14.line, column: d14.column, offset: d14.offset };
}
function configure(combined, extensions) {
  let index4 = -1;
  while (++index4 < extensions.length) {
    const value = extensions[index4];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own2.call(extension2, key)) {
      switch (key) {
        case "canContainEols": {
          const right = extension2[key];
          if (right) {
            combined[key].push(...right);
          }
          break;
        }
        case "transforms": {
          const right = extension2[key];
          if (right) {
            combined[key].push(...right);
          }
          break;
        }
        case "enter":
        case "exit": {
          const right = extension2[key];
          if (right) {
            Object.assign(combined[key], right);
          }
          break;
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error(
      "Cannot close `" + left.type + "` (" + stringifyPosition({ start: left.start, end: left.end }) + "): a different token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is open"
    );
  } else {
    throw new Error(
      "Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({ start: right.start, end: right.end }) + ") is still open"
    );
  }
}

// node_modules/@copilotkit/react-ui/node_modules/remark-parse/lib/index.js
function remarkParse(options) {
  const self2 = this;
  self2.parser = parser;
  function parser(doc) {
    return fromMarkdown(doc, {
      ...self2.data("settings"),
      ...options,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: self2.data("micromarkExtensions") || [],
      mdastExtensions: self2.data("fromMarkdownExtensions") || []
    });
  }
}

// node_modules/mdast-util-to-hast/lib/handlers/blockquote.js
function blockquote(state, node2) {
  const result = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: state.wrap(state.all(node2), true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/break.js
function hardBreak(state, node2) {
  const result = { type: "element", tagName: "br", properties: {}, children: [] };
  state.patch(node2, result);
  return [state.applyData(node2, result), { type: "text", value: "\n" }];
}

// node_modules/mdast-util-to-hast/lib/handlers/code.js
function code(state, node2) {
  const value = node2.value ? node2.value + "\n" : "";
  const properties = {};
  if (node2.lang) {
    properties.className = ["language-" + node2.lang];
  }
  let result = {
    type: "element",
    tagName: "code",
    properties,
    children: [{ type: "text", value }]
  };
  if (node2.meta) {
    result.data = { meta: node2.meta };
  }
  state.patch(node2, result);
  result = state.applyData(node2, result);
  result = { type: "element", tagName: "pre", properties: {}, children: [result] };
  state.patch(node2, result);
  return result;
}

// node_modules/mdast-util-to-hast/lib/handlers/delete.js
function strikethrough(state, node2) {
  const result = {
    type: "element",
    tagName: "del",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/emphasis.js
function emphasis(state, node2) {
  const result = {
    type: "element",
    tagName: "em",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js
function footnoteReference(state, node2) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const id = String(node2.identifier).toUpperCase();
  const safeId = normalizeUri(id.toLowerCase());
  const index4 = state.footnoteOrder.indexOf(id);
  let counter;
  let reuseCounter = state.footnoteCounts.get(id);
  if (reuseCounter === void 0) {
    reuseCounter = 0;
    state.footnoteOrder.push(id);
    counter = state.footnoteOrder.length;
  } else {
    counter = index4 + 1;
  }
  reuseCounter += 1;
  state.footnoteCounts.set(id, reuseCounter);
  const link3 = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + clobberPrefix + "fn-" + safeId,
      id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
      dataFootnoteRef: true,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(counter) }]
  };
  state.patch(node2, link3);
  const sup2 = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [link3]
  };
  state.patch(node2, sup2);
  return state.applyData(node2, sup2);
}

// node_modules/mdast-util-to-hast/lib/handlers/heading.js
function heading(state, node2) {
  const result = {
    type: "element",
    tagName: "h" + node2.depth,
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/html.js
function html4(state, node2) {
  if (state.options.allowDangerousHtml) {
    const result = { type: "raw", value: node2.value };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  return void 0;
}

// node_modules/mdast-util-to-hast/lib/revert.js
function revert(state, node2) {
  const subtype = node2.referenceType;
  let suffix = "]";
  if (subtype === "collapsed") {
    suffix += "[]";
  } else if (subtype === "full") {
    suffix += "[" + (node2.label || node2.identifier) + "]";
  }
  if (node2.type === "imageReference") {
    return [{ type: "text", value: "![" + node2.alt + suffix }];
  }
  const contents = state.all(node2);
  const head = contents[0];
  if (head && head.type === "text") {
    head.value = "[" + head.value;
  } else {
    contents.unshift({ type: "text", value: "[" });
  }
  const tail = contents[contents.length - 1];
  if (tail && tail.type === "text") {
    tail.value += suffix;
  } else {
    contents.push({ type: "text", value: suffix });
  }
  return contents;
}

// node_modules/mdast-util-to-hast/lib/handlers/image-reference.js
function imageReference(state, node2) {
  const id = String(node2.identifier).toUpperCase();
  const definition3 = state.definitionById.get(id);
  if (!definition3) {
    return revert(state, node2);
  }
  const properties = { src: normalizeUri(definition3.url || ""), alt: node2.alt };
  if (definition3.title !== null && definition3.title !== void 0) {
    properties.title = definition3.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/image.js
function image(state, node2) {
  const properties = { src: normalizeUri(node2.url) };
  if (node2.alt !== null && node2.alt !== void 0) {
    properties.alt = node2.alt;
  }
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = { type: "element", tagName: "img", properties, children: [] };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/inline-code.js
function inlineCode(state, node2) {
  const text10 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
  state.patch(node2, text10);
  const result = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [text10]
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/link-reference.js
function linkReference(state, node2) {
  const id = String(node2.identifier).toUpperCase();
  const definition3 = state.definitionById.get(id);
  if (!definition3) {
    return revert(state, node2);
  }
  const properties = { href: normalizeUri(definition3.url || "") };
  if (definition3.title !== null && definition3.title !== void 0) {
    properties.title = definition3.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/link.js
function link(state, node2) {
  const properties = { href: normalizeUri(node2.url) };
  if (node2.title !== null && node2.title !== void 0) {
    properties.title = node2.title;
  }
  const result = {
    type: "element",
    tagName: "a",
    properties,
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/list-item.js
function listItem(state, node2, parent) {
  const results = state.all(node2);
  const loose = parent ? listLoose(parent) : listItemLoose(node2);
  const properties = {};
  const children = [];
  if (typeof node2.checked === "boolean") {
    const head = results[0];
    let paragraph3;
    if (head && head.type === "element" && head.tagName === "p") {
      paragraph3 = head;
    } else {
      paragraph3 = { type: "element", tagName: "p", properties: {}, children: [] };
      results.unshift(paragraph3);
    }
    if (paragraph3.children.length > 0) {
      paragraph3.children.unshift({ type: "text", value: " " });
    }
    paragraph3.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: node2.checked, disabled: true },
      children: []
    });
    properties.className = ["task-list-item"];
  }
  let index4 = -1;
  while (++index4 < results.length) {
    const child = results[index4];
    if (loose || index4 !== 0 || child.type !== "element" || child.tagName !== "p") {
      children.push({ type: "text", value: "\n" });
    }
    if (child.type === "element" && child.tagName === "p" && !loose) {
      children.push(...child.children);
    } else {
      children.push(child);
    }
  }
  const tail = results[results.length - 1];
  if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
    children.push({ type: "text", value: "\n" });
  }
  const result = { type: "element", tagName: "li", properties, children };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function listLoose(node2) {
  let loose = false;
  if (node2.type === "list") {
    loose = node2.spread || false;
    const children = node2.children;
    let index4 = -1;
    while (!loose && ++index4 < children.length) {
      loose = listItemLoose(children[index4]);
    }
  }
  return loose;
}
function listItemLoose(node2) {
  const spread = node2.spread;
  return spread === null || spread === void 0 ? node2.children.length > 1 : spread;
}

// node_modules/mdast-util-to-hast/lib/handlers/list.js
function list2(state, node2) {
  const properties = {};
  const results = state.all(node2);
  let index4 = -1;
  if (typeof node2.start === "number" && node2.start !== 1) {
    properties.start = node2.start;
  }
  while (++index4 < results.length) {
    const child = results[index4];
    if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
      properties.className = ["contains-task-list"];
      break;
    }
  }
  const result = {
    type: "element",
    tagName: node2.ordered ? "ol" : "ul",
    properties,
    children: state.wrap(results, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/paragraph.js
function paragraph(state, node2) {
  const result = {
    type: "element",
    tagName: "p",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/root.js
function root2(state, node2) {
  const result = { type: "root", children: state.wrap(state.all(node2)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/strong.js
function strong(state, node2) {
  const result = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/table.js
function table(state, node2) {
  const rows = state.all(node2);
  const firstRow = rows.shift();
  const tableContent = [];
  if (firstRow) {
    const head = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: state.wrap([firstRow], true)
    };
    state.patch(node2.children[0], head);
    tableContent.push(head);
  }
  if (rows.length > 0) {
    const body = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: state.wrap(rows, true)
    };
    const start2 = pointStart(node2.children[1]);
    const end = pointEnd(node2.children[node2.children.length - 1]);
    if (start2 && end) body.position = { start: start2, end };
    tableContent.push(body);
  }
  const result = {
    type: "element",
    tagName: "table",
    properties: {},
    children: state.wrap(tableContent, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/table-row.js
function tableRow(state, node2, parent) {
  const siblings = parent ? parent.children : void 0;
  const rowIndex = siblings ? siblings.indexOf(node2) : 1;
  const tagName = rowIndex === 0 ? "th" : "td";
  const align = parent && parent.type === "table" ? parent.align : void 0;
  const length = align ? align.length : node2.children.length;
  let cellIndex = -1;
  const cells = [];
  while (++cellIndex < length) {
    const cell = node2.children[cellIndex];
    const properties = {};
    const alignValue = align ? align[cellIndex] : void 0;
    if (alignValue) {
      properties.align = alignValue;
    }
    let result2 = { type: "element", tagName, properties, children: [] };
    if (cell) {
      result2.children = state.all(cell);
      state.patch(cell, result2);
      result2 = state.applyData(cell, result2);
    }
    cells.push(result2);
  }
  const result = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: state.wrap(cells, true)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/table-cell.js
function tableCell(state, node2) {
  const result = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/text.js
function text4(state, node2) {
  const result = { type: "text", value: trimLines(String(node2.value)) };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js
function thematicBreak2(state, node2) {
  const result = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}

// node_modules/mdast-util-to-hast/lib/handlers/index.js
var handlers = {
  blockquote,
  break: hardBreak,
  code,
  delete: strikethrough,
  emphasis,
  footnoteReference,
  heading,
  html: html4,
  imageReference,
  image,
  inlineCode,
  linkReference,
  link,
  listItem,
  list: list2,
  paragraph,
  // @ts-expect-error: root is different, but hard to type.
  root: root2,
  strong,
  table,
  tableCell,
  tableRow,
  text: text4,
  thematicBreak: thematicBreak2,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};
function ignore() {
  return void 0;
}

// node_modules/@ungap/structured-clone/esm/types.js
var VOID = -1;
var PRIMITIVE = 0;
var ARRAY = 1;
var OBJECT = 2;
var DATE = 3;
var REGEXP = 4;
var MAP = 5;
var SET = 6;
var ERROR = 7;
var BIGINT = 8;

// node_modules/@ungap/structured-clone/esm/deserialize.js
var env = typeof self === "object" ? self : globalThis;
var deserializer = ($7, _10) => {
  const as = (out, index4) => {
    $7.set(index4, out);
    return out;
  };
  const unpair = (index4) => {
    if ($7.has(index4))
      return $7.get(index4);
    const [type, value] = _10[index4];
    switch (type) {
      case PRIMITIVE:
      case VOID:
        return as(value, index4);
      case ARRAY: {
        const arr = as([], index4);
        for (const index5 of value)
          arr.push(unpair(index5));
        return arr;
      }
      case OBJECT: {
        const object = as({}, index4);
        for (const [key, index5] of value)
          object[unpair(key)] = unpair(index5);
        return object;
      }
      case DATE:
        return as(new Date(value), index4);
      case REGEXP: {
        const { source, flags } = value;
        return as(new RegExp(source, flags), index4);
      }
      case MAP: {
        const map3 = as(/* @__PURE__ */ new Map(), index4);
        for (const [key, index5] of value)
          map3.set(unpair(key), unpair(index5));
        return map3;
      }
      case SET: {
        const set = as(/* @__PURE__ */ new Set(), index4);
        for (const index5 of value)
          set.add(unpair(index5));
        return set;
      }
      case ERROR: {
        const { name: name2, message } = value;
        return as(new env[name2](message), index4);
      }
      case BIGINT:
        return as(BigInt(value), index4);
      case "BigInt":
        return as(Object(BigInt(value)), index4);
      case "ArrayBuffer":
        return as(new Uint8Array(value).buffer, value);
      case "DataView": {
        const { buffer } = new Uint8Array(value);
        return as(new DataView(buffer), value);
      }
    }
    return as(new env[type](value), index4);
  };
  return unpair;
};
var deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);

// node_modules/@ungap/structured-clone/esm/serialize.js
var EMPTY = "";
var { toString: toString2 } = {};
var { keys } = Object;
var typeOf = (value) => {
  const type = typeof value;
  if (type !== "object" || !value)
    return [PRIMITIVE, type];
  const asString = toString2.call(value).slice(8, -1);
  switch (asString) {
    case "Array":
      return [ARRAY, EMPTY];
    case "Object":
      return [OBJECT, EMPTY];
    case "Date":
      return [DATE, EMPTY];
    case "RegExp":
      return [REGEXP, EMPTY];
    case "Map":
      return [MAP, EMPTY];
    case "Set":
      return [SET, EMPTY];
    case "DataView":
      return [ARRAY, asString];
  }
  if (asString.includes("Array"))
    return [ARRAY, asString];
  if (asString.includes("Error"))
    return [ERROR, asString];
  return [OBJECT, asString];
};
var shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
var serializer = (strict, json, $7, _10) => {
  const as = (out, value) => {
    const index4 = _10.push(out) - 1;
    $7.set(value, index4);
    return index4;
  };
  const pair = (value) => {
    if ($7.has(value))
      return $7.get(value);
    let [TYPE, type] = typeOf(value);
    switch (TYPE) {
      case PRIMITIVE: {
        let entry = value;
        switch (type) {
          case "bigint":
            TYPE = BIGINT;
            entry = value.toString();
            break;
          case "function":
          case "symbol":
            if (strict)
              throw new TypeError("unable to serialize " + type);
            entry = null;
            break;
          case "undefined":
            return as([VOID], value);
        }
        return as([TYPE, entry], value);
      }
      case ARRAY: {
        if (type) {
          let spread = value;
          if (type === "DataView") {
            spread = new Uint8Array(value.buffer);
          } else if (type === "ArrayBuffer") {
            spread = new Uint8Array(value);
          }
          return as([type, [...spread]], value);
        }
        const arr = [];
        const index4 = as([TYPE, arr], value);
        for (const entry of value)
          arr.push(pair(entry));
        return index4;
      }
      case OBJECT: {
        if (type) {
          switch (type) {
            case "BigInt":
              return as([type, value.toString()], value);
            case "Boolean":
            case "Number":
            case "String":
              return as([type, value.valueOf()], value);
          }
        }
        if (json && "toJSON" in value)
          return pair(value.toJSON());
        const entries = [];
        const index4 = as([TYPE, entries], value);
        for (const key of keys(value)) {
          if (strict || !shouldSkip(typeOf(value[key])))
            entries.push([pair(key), pair(value[key])]);
        }
        return index4;
      }
      case DATE:
        return as([TYPE, value.toISOString()], value);
      case REGEXP: {
        const { source, flags } = value;
        return as([TYPE, { source, flags }], value);
      }
      case MAP: {
        const entries = [];
        const index4 = as([TYPE, entries], value);
        for (const [key, entry] of value) {
          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))
            entries.push([pair(key), pair(entry)]);
        }
        return index4;
      }
      case SET: {
        const entries = [];
        const index4 = as([TYPE, entries], value);
        for (const entry of value) {
          if (strict || !shouldSkip(typeOf(entry)))
            entries.push(pair(entry));
        }
        return index4;
      }
    }
    const { message } = value;
    return as([TYPE, { name: type, message }], value);
  };
  return pair;
};
var serialize = (value, { json, lossy } = {}) => {
  const _10 = [];
  return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _10)(value), _10;
};

// node_modules/@ungap/structured-clone/esm/index.js
var esm_default = typeof structuredClone === "function" ? (
  /* c8 ignore start */
  (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize(any, options)) : structuredClone(any)
) : (any, options) => deserialize(serialize(any, options));

// node_modules/mdast-util-to-hast/lib/footer.js
function defaultFootnoteBackContent(_10, rereferenceIndex) {
  const result = [{ type: "text", value: "" }];
  if (rereferenceIndex > 1) {
    result.push({
      type: "element",
      tagName: "sup",
      properties: {},
      children: [{ type: "text", value: String(rereferenceIndex) }]
    });
  }
  return result;
}
function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
  return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
}
function footer(state) {
  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
  const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
  const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
  const footnoteLabel = state.options.footnoteLabel || "Footnotes";
  const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
  const footnoteLabelProperties = state.options.footnoteLabelProperties || {
    className: ["sr-only"]
  };
  const listItems = [];
  let referenceIndex = -1;
  while (++referenceIndex < state.footnoteOrder.length) {
    const definition3 = state.footnoteById.get(
      state.footnoteOrder[referenceIndex]
    );
    if (!definition3) {
      continue;
    }
    const content3 = state.all(definition3);
    const id = String(definition3.identifier).toUpperCase();
    const safeId = normalizeUri(id.toLowerCase());
    let rereferenceIndex = 0;
    const backReferences = [];
    const counts = state.footnoteCounts.get(id);
    while (counts !== void 0 && ++rereferenceIndex <= counts) {
      if (backReferences.length > 0) {
        backReferences.push({ type: "text", value: " " });
      }
      let children = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
      if (typeof children === "string") {
        children = { type: "text", value: children };
      }
      backReferences.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(children) ? children : [children]
      });
    }
    const tail = content3[content3.length - 1];
    if (tail && tail.type === "element" && tail.tagName === "p") {
      const tailTail = tail.children[tail.children.length - 1];
      if (tailTail && tailTail.type === "text") {
        tailTail.value += " ";
      } else {
        tail.children.push({ type: "text", value: " " });
      }
      tail.children.push(...backReferences);
    } else {
      content3.push(...backReferences);
    }
    const listItem3 = {
      type: "element",
      tagName: "li",
      properties: { id: clobberPrefix + "fn-" + safeId },
      children: state.wrap(content3, true)
    };
    state.patch(definition3, listItem3);
    listItems.push(listItem3);
  }
  if (listItems.length === 0) {
    return;
  }
  return {
    type: "element",
    tagName: "section",
    properties: { dataFootnotes: true, className: ["footnotes"] },
    children: [
      {
        type: "element",
        tagName: footnoteLabelTagName,
        properties: {
          ...esm_default(footnoteLabelProperties),
          id: "footnote-label"
        },
        children: [{ type: "text", value: footnoteLabel }]
      },
      { type: "text", value: "\n" },
      {
        type: "element",
        tagName: "ol",
        properties: {},
        children: state.wrap(listItems, true)
      },
      { type: "text", value: "\n" }
    ]
  };
}

// node_modules/unist-util-is/lib/index.js
var convert = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return ok2;
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : (
        // Cast because `ReadonlyArray` goes into the above but `isArray`
        // narrows to `Array`.
        propertiesFactory(
          /** @type {Props} */
          test
        )
      );
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks3 = [];
  let index4 = -1;
  while (++index4 < tests.length) {
    checks3[index4] = convert(tests[index4]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index5 = -1;
    while (++index5 < checks3.length) {
      if (checks3[index5].apply(this, parameters)) return true;
    }
    return false;
  }
}
function propertiesFactory(check) {
  const checkAsRecord = (
    /** @type {Record<string, unknown>} */
    check
  );
  return castFactory(all5);
  function all5(node2) {
    const nodeAsRecord = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      node2
    );
    let key;
    for (key in check) {
      if (nodeAsRecord[key] !== checkAsRecord[key]) return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index4, parent) {
    return Boolean(
      looksLikeANode(value) && testFunction.call(
        this,
        value,
        typeof index4 === "number" ? index4 : void 0,
        parent || void 0
      )
    );
  }
}
function ok2() {
  return true;
}
function looksLikeANode(value) {
  return value !== null && typeof value === "object" && "type" in value;
}

// node_modules/unist-util-visit-parents/lib/color.js
function color(d14) {
  return d14;
}

// node_modules/unist-util-visit-parents/lib/index.js
var empty2 = [];
var CONTINUE = true;
var EXIT = false;
var SKIP = "skip";
function visitParents(tree, test, visitor, reverse) {
  let check;
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
  } else {
    check = test;
  }
  const is2 = convert(check);
  const step = reverse ? -1 : 1;
  factory(tree, void 0, [])();
  function factory(node2, index4, parents) {
    const value = (
      /** @type {Record<string, unknown>} */
      node2 && typeof node2 === "object" ? node2 : {}
    );
    if (typeof value.type === "string") {
      const name2 = (
        // `hast`
        typeof value.tagName === "string" ? value.tagName : (
          // `xast`
          typeof value.name === "string" ? value.name : void 0
        )
      );
      Object.defineProperty(visit5, "name", {
        value: "node (" + color(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
      });
    }
    return visit5;
    function visit5() {
      let result = empty2;
      let subresult;
      let offset4;
      let grandparents;
      if (!test || is2(node2, index4, parents[parents.length - 1] || void 0)) {
        result = toResult(visitor(node2, parents));
        if (result[0] === EXIT) {
          return result;
        }
      }
      if ("children" in node2 && node2.children) {
        const nodeAsParent = (
          /** @type {UnistParent} */
          node2
        );
        if (nodeAsParent.children && result[0] !== SKIP) {
          offset4 = (reverse ? nodeAsParent.children.length : -1) + step;
          grandparents = parents.concat(nodeAsParent);
          while (offset4 > -1 && offset4 < nodeAsParent.children.length) {
            const child = nodeAsParent.children[offset4];
            subresult = factory(child, offset4, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset4 = typeof subresult[1] === "number" ? subresult[1] : offset4 + step;
          }
        }
      }
      return result;
    }
  }
}
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return value === null || value === void 0 ? empty2 : [value];
}

// node_modules/mdast-util-to-hast/node_modules/unist-util-visit/lib/index.js
function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse;
  let test;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test = void 0;
    visitor = testOrVisitor;
    reverse = visitorOrReverse;
  } else {
    test = testOrVisitor;
    visitor = visitorOrReverse;
    reverse = maybeReverse;
  }
  visitParents(tree, test, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    const index4 = parent ? parent.children.indexOf(node2) : void 0;
    return visitor(node2, index4, parent);
  }
}

// node_modules/mdast-util-to-hast/lib/state.js
var own3 = {}.hasOwnProperty;
var emptyOptions3 = {};
function createState(tree, options) {
  const settings = options || emptyOptions3;
  const definitionById = /* @__PURE__ */ new Map();
  const footnoteById = /* @__PURE__ */ new Map();
  const footnoteCounts = /* @__PURE__ */ new Map();
  const handlers2 = { ...handlers, ...settings.handlers };
  const state = {
    all: all5,
    applyData,
    definitionById,
    footnoteById,
    footnoteCounts,
    footnoteOrder: [],
    handlers: handlers2,
    one: one5,
    options: settings,
    patch,
    wrap
  };
  visit(tree, function(node2) {
    if (node2.type === "definition" || node2.type === "footnoteDefinition") {
      const map3 = node2.type === "definition" ? definitionById : footnoteById;
      const id = String(node2.identifier).toUpperCase();
      if (!map3.has(id)) {
        map3.set(id, node2);
      }
    }
  });
  return state;
  function one5(node2, parent) {
    const type = node2.type;
    const handle2 = state.handlers[type];
    if (own3.call(state.handlers, type) && handle2) {
      return handle2(state, node2, parent);
    }
    if (state.options.passThrough && state.options.passThrough.includes(type)) {
      if ("children" in node2) {
        const { children, ...shallow } = node2;
        const result = esm_default(shallow);
        result.children = state.all(node2);
        return result;
      }
      return esm_default(node2);
    }
    const unknown2 = state.options.unknownHandler || defaultUnknownHandler;
    return unknown2(state, node2, parent);
  }
  function all5(parent) {
    const values2 = [];
    if ("children" in parent) {
      const nodes = parent.children;
      let index4 = -1;
      while (++index4 < nodes.length) {
        const result = state.one(nodes[index4], parent);
        if (result) {
          if (index4 && nodes[index4 - 1].type === "break") {
            if (!Array.isArray(result) && result.type === "text") {
              result.value = trimMarkdownSpaceStart(result.value);
            }
            if (!Array.isArray(result) && result.type === "element") {
              const head = result.children[0];
              if (head && head.type === "text") {
                head.value = trimMarkdownSpaceStart(head.value);
              }
            }
          }
          if (Array.isArray(result)) {
            values2.push(...result);
          } else {
            values2.push(result);
          }
        }
      }
    }
    return values2;
  }
}
function patch(from, to) {
  if (from.position) to.position = position(from);
}
function applyData(from, to) {
  let result = to;
  if (from && from.data) {
    const hName = from.data.hName;
    const hChildren = from.data.hChildren;
    const hProperties = from.data.hProperties;
    if (typeof hName === "string") {
      if (result.type === "element") {
        result.tagName = hName;
      } else {
        const children = "children" in result ? result.children : [result];
        result = { type: "element", tagName: hName, properties: {}, children };
      }
    }
    if (result.type === "element" && hProperties) {
      Object.assign(result.properties, esm_default(hProperties));
    }
    if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
      result.children = hChildren;
    }
  }
  return result;
}
function defaultUnknownHandler(state, node2) {
  const data = node2.data || {};
  const result = "value" in node2 && !(own3.call(data, "hProperties") || own3.call(data, "hChildren")) ? { type: "text", value: node2.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: state.all(node2)
  };
  state.patch(node2, result);
  return state.applyData(node2, result);
}
function wrap(nodes, loose) {
  const result = [];
  let index4 = -1;
  if (loose) {
    result.push({ type: "text", value: "\n" });
  }
  while (++index4 < nodes.length) {
    if (index4) result.push({ type: "text", value: "\n" });
    result.push(nodes[index4]);
  }
  if (loose && nodes.length > 0) {
    result.push({ type: "text", value: "\n" });
  }
  return result;
}
function trimMarkdownSpaceStart(value) {
  let index4 = 0;
  let code4 = value.charCodeAt(index4);
  while (code4 === 9 || code4 === 32) {
    index4++;
    code4 = value.charCodeAt(index4);
  }
  return value.slice(index4);
}

// node_modules/mdast-util-to-hast/lib/index.js
function toHast(tree, options) {
  const state = createState(tree, options);
  const node2 = state.one(tree, void 0);
  const foot = footer(state);
  const result = Array.isArray(node2) ? { type: "root", children: node2 } : node2 || { type: "root", children: [] };
  if (foot) {
    ok("children" in result);
    result.children.push({ type: "text", value: "\n" }, foot);
  }
  return result;
}

// node_modules/@copilotkit/react-ui/node_modules/remark-rehype/lib/index.js
function remarkRehype(destination, options) {
  if (destination && "run" in destination) {
    return async function(tree, file) {
      const hastTree = (
        /** @type {HastRoot} */
        toHast(tree, { file, ...options })
      );
      await destination.run(hastTree, file);
    };
  }
  return function(tree, file) {
    return (
      /** @type {HastRoot} */
      toHast(tree, { file, ...destination || options })
    );
  };
}

// node_modules/@copilotkit/react-ui/node_modules/unified/lib/index.js
var import_extend = __toESM(require_extend(), 1);

// node_modules/@copilotkit/react-ui/node_modules/vfile-message/lib/index.js
var VFileMessage2 = class extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(causeOrReason, optionsOrParentOrPlace, origin) {
    super();
    if (typeof optionsOrParentOrPlace === "string") {
      origin = optionsOrParentOrPlace;
      optionsOrParentOrPlace = void 0;
    }
    let reason = "";
    let options = {};
    let legacyCause = false;
    if (optionsOrParentOrPlace) {
      if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
        options = { place: optionsOrParentOrPlace };
      } else if ("type" in optionsOrParentOrPlace) {
        options = {
          ancestors: [optionsOrParentOrPlace],
          place: optionsOrParentOrPlace.position
        };
      } else {
        options = { ...optionsOrParentOrPlace };
      }
    }
    if (typeof causeOrReason === "string") {
      reason = causeOrReason;
    } else if (!options.cause && causeOrReason) {
      legacyCause = true;
      reason = causeOrReason.message;
      options.cause = causeOrReason;
    }
    if (!options.ruleId && !options.source && typeof origin === "string") {
      const index4 = origin.indexOf(":");
      if (index4 === -1) {
        options.ruleId = origin;
      } else {
        options.source = origin.slice(0, index4);
        options.ruleId = origin.slice(index4 + 1);
      }
    }
    if (!options.place && options.ancestors && options.ancestors) {
      const parent = options.ancestors[options.ancestors.length - 1];
      if (parent) {
        options.place = parent.position;
      }
    }
    const start2 = options.place && "start" in options.place ? options.place.start : options.place;
    this.ancestors = options.ancestors || void 0;
    this.cause = options.cause || void 0;
    this.column = start2 ? start2.column : void 0;
    this.fatal = void 0;
    this.file = "";
    this.message = reason;
    this.line = start2 ? start2.line : void 0;
    this.name = stringifyPosition(options.place) || "1:1";
    this.place = options.place || void 0;
    this.reason = this.message;
    this.ruleId = options.ruleId || void 0;
    this.source = options.source || void 0;
    this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
    this.actual = void 0;
    this.expected = void 0;
    this.note = void 0;
    this.url = void 0;
  }
};
VFileMessage2.prototype.file = "";
VFileMessage2.prototype.name = "";
VFileMessage2.prototype.reason = "";
VFileMessage2.prototype.message = "";
VFileMessage2.prototype.stack = "";
VFileMessage2.prototype.column = void 0;
VFileMessage2.prototype.line = void 0;
VFileMessage2.prototype.ancestors = void 0;
VFileMessage2.prototype.cause = void 0;
VFileMessage2.prototype.fatal = void 0;
VFileMessage2.prototype.place = void 0;
VFileMessage2.prototype.ruleId = void 0;
VFileMessage2.prototype.source = void 0;

// node_modules/@copilotkit/react-ui/node_modules/vfile/lib/minpath.browser.js
var minpath = { basename, dirname, extname, join, sep: "/" };
function basename(path3, extname2) {
  if (extname2 !== void 0 && typeof extname2 !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path3);
  let start2 = 0;
  let end = -1;
  let index4 = path3.length;
  let seenNonSlash;
  if (extname2 === void 0 || extname2.length === 0 || extname2.length > path3.length) {
    while (index4--) {
      if (path3.codePointAt(index4) === 47) {
        if (seenNonSlash) {
          start2 = index4 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index4 + 1;
      }
    }
    return end < 0 ? "" : path3.slice(start2, end);
  }
  if (extname2 === path3) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extnameIndex = extname2.length - 1;
  while (index4--) {
    if (path3.codePointAt(index4) === 47) {
      if (seenNonSlash) {
        start2 = index4 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index4 + 1;
      }
      if (extnameIndex > -1) {
        if (path3.codePointAt(index4) === extname2.codePointAt(extnameIndex--)) {
          if (extnameIndex < 0) {
            end = index4;
          }
        } else {
          extnameIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start2 === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path3.length;
  }
  return path3.slice(start2, end);
}
function dirname(path3) {
  assertPath(path3);
  if (path3.length === 0) {
    return ".";
  }
  let end = -1;
  let index4 = path3.length;
  let unmatchedSlash;
  while (--index4) {
    if (path3.codePointAt(index4) === 47) {
      if (unmatchedSlash) {
        end = index4;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path3.codePointAt(0) === 47 ? "/" : "." : end === 1 && path3.codePointAt(0) === 47 ? "//" : path3.slice(0, end);
}
function extname(path3) {
  assertPath(path3);
  let index4 = path3.length;
  let end = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index4--) {
    const code4 = path3.codePointAt(index4);
    if (code4 === 47) {
      if (unmatchedSlash) {
        startPart = index4 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index4 + 1;
    }
    if (code4 === 46) {
      if (startDot < 0) {
        startDot = index4;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path3.slice(startDot, end);
}
function join(...segments) {
  let index4 = -1;
  let joined;
  while (++index4 < segments.length) {
    assertPath(segments[index4]);
    if (segments[index4]) {
      joined = joined === void 0 ? segments[index4] : joined + "/" + segments[index4];
    }
  }
  return joined === void 0 ? "." : normalize2(joined);
}
function normalize2(path3) {
  assertPath(path3);
  const absolute = path3.codePointAt(0) === 47;
  let value = normalizeString(path3, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path3.codePointAt(path3.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path3, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index4 = -1;
  let code4;
  let lastSlashIndex;
  while (++index4 <= path3.length) {
    if (index4 < path3.length) {
      code4 = path3.codePointAt(index4);
    } else if (code4 === 47) {
      break;
    } else {
      code4 = 47;
    }
    if (code4 === 47) {
      if (lastSlash === index4 - 1 || dots === 1) {
      } else if (lastSlash !== index4 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index4;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index4;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path3.slice(lastSlash + 1, index4);
        } else {
          result = path3.slice(lastSlash + 1, index4);
        }
        lastSegmentLength = index4 - lastSlash - 1;
      }
      lastSlash = index4;
      dots = 0;
    } else if (code4 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath(path3) {
  if (typeof path3 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path3)
    );
  }
}

// node_modules/@copilotkit/react-ui/node_modules/vfile/lib/minproc.browser.js
var minproc = { cwd };
function cwd() {
  return "/";
}

// node_modules/@copilotkit/react-ui/node_modules/vfile/lib/minurl.shared.js
function isUrl(fileUrlOrPath) {
  return Boolean(
    fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
    fileUrlOrPath.auth === void 0
  );
}

// node_modules/@copilotkit/react-ui/node_modules/vfile/lib/minurl.browser.js
function urlToPath(path3) {
  if (typeof path3 === "string") {
    path3 = new URL(path3);
  } else if (!isUrl(path3)) {
    const error2 = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path3 + "`"
    );
    error2.code = "ERR_INVALID_ARG_TYPE";
    throw error2;
  }
  if (path3.protocol !== "file:") {
    const error2 = new TypeError("The URL must be of scheme file");
    error2.code = "ERR_INVALID_URL_SCHEME";
    throw error2;
  }
  return getPathFromURLPosix(path3);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error2 = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error2.code = "ERR_INVALID_FILE_URL_HOST";
    throw error2;
  }
  const pathname = url.pathname;
  let index4 = -1;
  while (++index4 < pathname.length) {
    if (pathname.codePointAt(index4) === 37 && pathname.codePointAt(index4 + 1) === 50) {
      const third = pathname.codePointAt(index4 + 2);
      if (third === 70 || third === 102) {
        const error2 = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error2.code = "ERR_INVALID_FILE_URL_PATH";
        throw error2;
      }
    }
  }
  return decodeURIComponent(pathname);
}

// node_modules/@copilotkit/react-ui/node_modules/vfile/lib/index.js
var order = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
var VFile = class {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (isUrl(value)) {
      options = { path: value };
    } else if (typeof value === "string" || isUint8Array(value)) {
      options = { value };
    } else {
      options = value;
    }
    this.cwd = "cwd" in options ? "" : minproc.cwd();
    this.data = {};
    this.history = [];
    this.messages = [];
    this.value;
    this.map;
    this.result;
    this.stored;
    let index4 = -1;
    while (++index4 < order.length) {
      const field2 = order[index4];
      if (field2 in options && options[field2] !== void 0 && options[field2] !== null) {
        this[field2] = field2 === "history" ? [...options[field2]] : options[field2];
      }
    }
    let field;
    for (field in options) {
      if (!order.includes(field)) {
        this[field] = options[field];
      }
    }
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path === "string" ? minpath.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = minpath.join(this.dirname || "", basename2);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path === "string" ? minpath.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(dirname2) {
    assertPath2(this.basename, "dirname");
    this.path = minpath.join(dirname2 || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path === "string" ? minpath.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath2(this.dirname, "extname");
    if (extname2) {
      if (extname2.codePointAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = minpath.join(this.dirname, this.stem + (extname2 || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(path3) {
    if (isUrl(path3)) {
      path3 = urlToPath(path3);
    }
    assertNonEmpty(path3, "path");
    if (this.path !== path3) {
      this.history.push(path3);
    }
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path === "string" ? minpath.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = minpath.join(this.dirname || "", stem + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = true;
    throw message;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
    message.fatal = void 0;
    return message;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(causeOrReason, optionsOrParentOrPlace, origin) {
    const message = new VFileMessage2(
      // @ts-expect-error: the overloads are fine.
      causeOrReason,
      optionsOrParentOrPlace,
      origin
    );
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    if (this.value === void 0) {
      return "";
    }
    if (typeof this.value === "string") {
      return this.value;
    }
    const decoder = new TextDecoder(encoding || void 0);
    return decoder.decode(this.value);
  }
};
function assertPart(part, name2) {
  if (part && part.includes(minpath.sep)) {
    throw new Error(
      "`" + name2 + "` cannot be a path: did not expect `" + minpath.sep + "`"
    );
  }
}
function assertNonEmpty(part, name2) {
  if (!part) {
    throw new Error("`" + name2 + "` cannot be empty");
  }
}
function assertPath2(path3, name2) {
  if (!path3) {
    throw new Error("Setting `" + name2 + "` requires `path` to be set too");
  }
}
function isUint8Array(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}

// node_modules/@copilotkit/react-ui/node_modules/unified/lib/callable-instance.js
var CallableInstance = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(property) {
    const self2 = this;
    const constr = self2.constructor;
    const proto2 = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      constr.prototype
    );
    const value = proto2[property];
    const apply = function() {
      return value.apply(apply, arguments);
    };
    Object.setPrototypeOf(apply, proto2);
    return apply;
  }
);

// node_modules/@copilotkit/react-ui/node_modules/unified/lib/index.js
var own4 = {}.hasOwnProperty;
var Processor = class _Processor extends CallableInstance {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy");
    this.Compiler = void 0;
    this.Parser = void 0;
    this.attachers = [];
    this.compiler = void 0;
    this.freezeIndex = -1;
    this.frozen = void 0;
    this.namespace = {};
    this.parser = void 0;
    this.transformers = trough();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const destination = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new _Processor()
    );
    let index4 = -1;
    while (++index4 < this.attachers.length) {
      const attacher = this.attachers[index4];
      destination.use(...attacher);
    }
    destination.data((0, import_extend.default)(true, {}, this.namespace));
    return destination;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", this.frozen);
        this.namespace[key] = value;
        return this;
      }
      return own4.call(this.namespace, key) && this.namespace[key] || void 0;
    }
    if (key) {
      assertUnfrozen("data", this.frozen);
      this.namespace = key;
      return this;
    }
    return this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen) {
      return this;
    }
    const self2 = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    while (++this.freezeIndex < this.attachers.length) {
      const [attacher, ...options] = this.attachers[this.freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(self2, ...options);
      if (typeof transformer === "function") {
        this.transformers.use(transformer);
      }
    }
    this.frozen = true;
    this.freezeIndex = Number.POSITIVE_INFINITY;
    return this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(file) {
    this.freeze();
    const realFile = vfile(file);
    const parser = this.parser || this.Parser;
    assertParser("parse", parser);
    return parser(String(realFile), realFile);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(file, done) {
    const self2 = this;
    this.freeze();
    assertParser("process", this.parser || this.Parser);
    assertCompiler("process", this.compiler || this.Compiler);
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      const realFile = vfile(file);
      const parseTree3 = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        self2.parse(realFile)
      );
      self2.run(parseTree3, realFile, function(error2, tree, file2) {
        if (error2 || !tree || !file2) {
          return realDone(error2);
        }
        const compileTree = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          tree
        );
        const compileResult = self2.stringify(compileTree, file2);
        if (looksLikeAValue(compileResult)) {
          file2.value = compileResult;
        } else {
          file2.result = compileResult;
        }
        realDone(
          error2,
          /** @type {VFileWithOutput<CompileResult>} */
          file2
        );
      });
      function realDone(error2, file2) {
        if (error2 || !file2) {
          reject(error2);
        } else if (resolve) {
          resolve(file2);
        } else {
          ok(done, "`done` is defined if `resolve` is not");
          done(void 0, file2);
        }
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(file) {
    let complete = false;
    let result;
    this.freeze();
    assertParser("processSync", this.parser || this.Parser);
    assertCompiler("processSync", this.compiler || this.Compiler);
    this.process(file, realDone);
    assertDone("processSync", "process", complete);
    ok(result, "we either bailed on an error or have a tree");
    return result;
    function realDone(error2, file2) {
      complete = true;
      bail(error2);
      result = file2;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(tree, file, done) {
    assertNode(tree);
    this.freeze();
    const transformers = this.transformers;
    if (!done && typeof file === "function") {
      done = file;
      file = void 0;
    }
    return done ? executor(void 0, done) : new Promise(executor);
    function executor(resolve, reject) {
      ok(
        typeof file !== "function",
        "`file` cant be a `done` anymore, we checked"
      );
      const realFile = vfile(file);
      transformers.run(tree, realFile, realDone);
      function realDone(error2, outputTree, file2) {
        const resultingTree = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          outputTree || tree
        );
        if (error2) {
          reject(error2);
        } else if (resolve) {
          resolve(resultingTree);
        } else {
          ok(done, "`done` is defined if `resolve` is not");
          done(void 0, resultingTree, file2);
        }
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(tree, file) {
    let complete = false;
    let result;
    this.run(tree, file, realDone);
    assertDone("runSync", "run", complete);
    ok(result, "we either bailed on an error or have a tree");
    return result;
    function realDone(error2, tree2) {
      bail(error2);
      result = tree2;
      complete = true;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(tree, file) {
    this.freeze();
    const realFile = vfile(file);
    const compiler2 = this.compiler || this.Compiler;
    assertCompiler("stringify", compiler2);
    assertNode(tree);
    return compiler2(tree, realFile);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(value, ...parameters) {
    const attachers = this.attachers;
    const namespace = this.namespace;
    assertUnfrozen("use", this.frozen);
    if (value === null || value === void 0) {
    } else if (typeof value === "function") {
      addPlugin(value, parameters);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    return this;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2, []);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...parameters2] = (
            /** @type {PluginTuple<Array<unknown>>} */
            value2
          );
          addPlugin(plugin, parameters2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      if (!("plugins" in result) && !("settings" in result)) {
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      }
      addList(result.plugins);
      if (result.settings) {
        namespace.settings = (0, import_extend.default)(true, namespace.settings, result.settings);
      }
    }
    function addList(plugins) {
      let index4 = -1;
      if (plugins === null || plugins === void 0) {
      } else if (Array.isArray(plugins)) {
        while (++index4 < plugins.length) {
          const thing = plugins[index4];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, parameters2) {
      let index4 = -1;
      let entryIndex = -1;
      while (++index4 < attachers.length) {
        if (attachers[index4][0] === plugin) {
          entryIndex = index4;
          break;
        }
      }
      if (entryIndex === -1) {
        attachers.push([plugin, ...parameters2]);
      } else if (parameters2.length > 0) {
        let [primary, ...rest] = parameters2;
        const currentPrimary = attachers[entryIndex][1];
        if (isPlainObject(currentPrimary) && isPlainObject(primary)) {
          primary = (0, import_extend.default)(true, currentPrimary, primary);
        }
        attachers[entryIndex] = [plugin, primary, ...rest];
      }
    }
  }
};
var unified = new Processor().freeze();
function assertParser(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `parser`");
  }
}
function assertCompiler(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `compiler`");
  }
}
function assertUnfrozen(name2, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node2) {
  if (!isPlainObject(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name2, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAValue(value) {
  return typeof value === "string" || isUint8Array2(value);
}
function isUint8Array2(value) {
  return Boolean(
    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
  );
}

// node_modules/@copilotkit/react-ui/node_modules/unist-util-visit/lib/index.js
function visit2(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse;
  let test;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test = void 0;
    visitor = testOrVisitor;
    reverse = visitorOrReverse;
  } else {
    test = testOrVisitor;
    visitor = visitorOrReverse;
    reverse = maybeReverse;
  }
  visitParents(tree, test, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    const index4 = parent ? parent.children.indexOf(node2) : void 0;
    return visitor(node2, index4, parent);
  }
}

// node_modules/@copilotkit/react-ui/node_modules/react-markdown/lib/index.js
var changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md";
var emptyPlugins = [];
var emptyRemarkRehypeOptions = { allowDangerousHtml: true };
var safeProtocol = /^(https?|ircs?|mailto|xmpp)$/i;
var deprecations = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  { from: "className", id: "remove-classname" },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function Markdown(options) {
  const processor = createProcessor(options);
  const file = createFile(options);
  return post(processor.runSync(processor.parse(file), file), options);
}
function createProcessor(options) {
  const rehypePlugins = options.rehypePlugins || emptyPlugins;
  const remarkPlugins = options.remarkPlugins || emptyPlugins;
  const remarkRehypeOptions = options.remarkRehypeOptions ? { ...options.remarkRehypeOptions, ...emptyRemarkRehypeOptions } : emptyRemarkRehypeOptions;
  const processor = unified().use(remarkParse).use(remarkPlugins).use(remarkRehype, remarkRehypeOptions).use(rehypePlugins);
  return processor;
}
function createFile(options) {
  const children = options.children || "";
  const file = new VFile();
  if (typeof children === "string") {
    file.value = children;
  } else {
    unreachable(
      "Unexpected value `" + children + "` for `children` prop, expected `string`"
    );
  }
  return file;
}
function post(tree, options) {
  const allowedElements = options.allowedElements;
  const allowElement = options.allowElement;
  const components = options.components;
  const disallowedElements = options.disallowedElements;
  const skipHtml = options.skipHtml;
  const unwrapDisallowed = options.unwrapDisallowed;
  const urlTransform = options.urlTransform || defaultUrlTransform;
  for (const deprecation of deprecations) {
    if (Object.hasOwn(options, deprecation.from)) {
      unreachable(
        "Unexpected `" + deprecation.from + "` prop, " + (deprecation.to ? "use `" + deprecation.to + "` instead" : "remove it") + " (see <" + changelog + "#" + deprecation.id + "> for more info)"
      );
    }
  }
  if (allowedElements && disallowedElements) {
    unreachable(
      "Unexpected combined `allowedElements` and `disallowedElements`, expected one or the other"
    );
  }
  visit2(tree, transform);
  return toJsxRuntime(tree, {
    Fragment: import_jsx_runtime17.Fragment,
    components,
    ignoreInvalidStyle: true,
    jsx: import_jsx_runtime17.jsx,
    jsxs: import_jsx_runtime17.jsxs,
    passKeys: true,
    passNode: true
  });
  function transform(node2, index4, parent) {
    if (node2.type === "raw" && parent && typeof index4 === "number") {
      if (skipHtml) {
        parent.children.splice(index4, 1);
      } else {
        parent.children[index4] = { type: "text", value: node2.value };
      }
      return index4;
    }
    if (node2.type === "element") {
      let key;
      for (key in urlAttributes) {
        if (Object.hasOwn(urlAttributes, key) && Object.hasOwn(node2.properties, key)) {
          const value = node2.properties[key];
          const test = urlAttributes[key];
          if (test === null || test.includes(node2.tagName)) {
            node2.properties[key] = urlTransform(String(value || ""), key, node2);
          }
        }
      }
    }
    if (node2.type === "element") {
      let remove = allowedElements ? !allowedElements.includes(node2.tagName) : disallowedElements ? disallowedElements.includes(node2.tagName) : false;
      if (!remove && allowElement && typeof index4 === "number") {
        remove = !allowElement(node2, index4, parent);
      }
      if (remove && parent && typeof index4 === "number") {
        if (unwrapDisallowed && node2.children) {
          parent.children.splice(index4, 1, ...node2.children);
        } else {
          parent.children.splice(index4, 1);
        }
        return index4;
      }
    }
  }
}
function defaultUrlTransform(value) {
  const colon = value.indexOf(":");
  const questionMark = value.indexOf("?");
  const numberSign = value.indexOf("#");
  const slash = value.indexOf("/");
  if (
    // If there is no protocol, its relative.
    colon === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    slash !== -1 && colon > slash || questionMark !== -1 && colon > questionMark || numberSign !== -1 && colon > numberSign || // It is a protocol, it should be allowed.
    safeProtocol.test(value.slice(0, colon))
  ) {
    return value;
  }
  return "";
}

// node_modules/ccount/index.js
function ccount(value, character) {
  const source = String(value);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count2 = 0;
  let index4 = source.indexOf(character);
  while (index4 !== -1) {
    count2++;
    index4 = source.indexOf(character, index4 + character.length);
  }
  return count2;
}

// node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string3) {
  if (typeof string3 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// node_modules/mdast-util-find-and-replace/lib/index.js
function findAndReplace(tree, list4, options) {
  const settings = options || {};
  const ignored = convert(settings.ignore || []);
  const pairs = toPairs(list4);
  let pairIndex = -1;
  while (++pairIndex < pairs.length) {
    visitParents(tree, "text", visitor);
  }
  function visitor(node2, parents) {
    let index4 = -1;
    let grandparent;
    while (++index4 < parents.length) {
      const parent = parents[index4];
      const siblings = grandparent ? grandparent.children : void 0;
      if (ignored(
        parent,
        siblings ? siblings.indexOf(parent) : void 0,
        grandparent
      )) {
        return;
      }
      grandparent = parent;
    }
    if (grandparent) {
      return handler(node2, parents);
    }
  }
  function handler(node2, parents) {
    const parent = parents[parents.length - 1];
    const find4 = pairs[pairIndex][0];
    const replace2 = pairs[pairIndex][1];
    let start2 = 0;
    const siblings = parent.children;
    const index4 = siblings.indexOf(node2);
    let change = false;
    let nodes = [];
    find4.lastIndex = 0;
    let match = find4.exec(node2.value);
    while (match) {
      const position4 = match.index;
      const matchObject = {
        index: match.index,
        input: match.input,
        stack: [...parents, node2]
      };
      let value = replace2(...match, matchObject);
      if (typeof value === "string") {
        value = value.length > 0 ? { type: "text", value } : void 0;
      }
      if (value === false) {
        find4.lastIndex = position4 + 1;
      } else {
        if (start2 !== position4) {
          nodes.push({
            type: "text",
            value: node2.value.slice(start2, position4)
          });
        }
        if (Array.isArray(value)) {
          nodes.push(...value);
        } else if (value) {
          nodes.push(value);
        }
        start2 = position4 + match[0].length;
        change = true;
      }
      if (!find4.global) {
        break;
      }
      match = find4.exec(node2.value);
    }
    if (change) {
      if (start2 < node2.value.length) {
        nodes.push({ type: "text", value: node2.value.slice(start2) });
      }
      parent.children.splice(index4, 1, ...nodes);
    } else {
      nodes = [node2];
    }
    return index4 + nodes.length;
  }
}
function toPairs(tupleOrList) {
  const result = [];
  if (!Array.isArray(tupleOrList)) {
    throw new TypeError("Expected find and replace tuple or list of tuples");
  }
  const list4 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
  let index4 = -1;
  while (++index4 < list4.length) {
    const tuple = list4[index4];
    result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
  }
  return result;
}
function toExpression(find4) {
  return typeof find4 === "string" ? new RegExp(escapeStringRegexp(find4), "g") : find4;
}
function toFunction(replace2) {
  return typeof replace2 === "function" ? replace2 : function() {
    return replace2;
  };
}

// node_modules/mdast-util-gfm-autolink-literal/lib/index.js
var inConstruct = "phrasing";
var notInConstruct = ["autolink", "link", "image", "label"];
function gfmAutolinkLiteralFromMarkdown() {
  return {
    transforms: [transformGfmAutolinkLiterals],
    enter: {
      literalAutolink: enterLiteralAutolink,
      literalAutolinkEmail: enterLiteralAutolinkValue,
      literalAutolinkHttp: enterLiteralAutolinkValue,
      literalAutolinkWww: enterLiteralAutolinkValue
    },
    exit: {
      literalAutolink: exitLiteralAutolink,
      literalAutolinkEmail: exitLiteralAutolinkEmail,
      literalAutolinkHttp: exitLiteralAutolinkHttp,
      literalAutolinkWww: exitLiteralAutolinkWww
    }
  };
}
function gfmAutolinkLiteralToMarkdown() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct,
        notInConstruct
      }
    ]
  };
}
function enterLiteralAutolink(token) {
  this.enter({ type: "link", title: null, url: "", children: [] }, token);
}
function enterLiteralAutolinkValue(token) {
  this.config.enter.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkHttp(token) {
  this.config.exit.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkWww(token) {
  this.config.exit.data.call(this, token);
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "link");
  node2.url = "http://" + this.sliceSerialize(token);
}
function exitLiteralAutolinkEmail(token) {
  this.config.exit.autolinkEmail.call(this, token);
}
function exitLiteralAutolink(token) {
  this.exit(token);
}
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(
    tree,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), findEmail]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function findUrl(_10, protocol, domain2, path3, match) {
  let prefix = "";
  if (!previous2(match)) {
    return false;
  }
  if (/^w/i.test(protocol)) {
    domain2 = protocol + domain2;
    protocol = "";
    prefix = "http://";
  }
  if (!isCorrectDomain(domain2)) {
    return false;
  }
  const parts = splitUrl(domain2 + path3);
  if (!parts[0]) return false;
  const result = {
    type: "link",
    title: null,
    url: prefix + protocol + parts[0],
    children: [{ type: "text", value: protocol + parts[0] }]
  };
  if (parts[1]) {
    return [result, { type: "text", value: parts[1] }];
  }
  return result;
}
function findEmail(_10, atext, label, match) {
  if (
    // Not an expected previous character.
    !previous2(match, true) || // Label ends in not allowed character.
    /[-\d_]$/.test(label)
  ) {
    return false;
  }
  return {
    type: "link",
    title: null,
    url: "mailto:" + atext + "@" + label,
    children: [{ type: "text", value: atext + "@" + label }]
  };
}
function isCorrectDomain(domain2) {
  const parts = domain2.split(".");
  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
    return false;
  }
  return true;
}
function splitUrl(url) {
  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
  if (!trailExec) {
    return [url, void 0];
  }
  url = url.slice(0, trailExec.index);
  let trail2 = trailExec[0];
  let closingParenIndex = trail2.indexOf(")");
  const openingParens = ccount(url, "(");
  let closingParens = ccount(url, ")");
  while (closingParenIndex !== -1 && openingParens > closingParens) {
    url += trail2.slice(0, closingParenIndex + 1);
    trail2 = trail2.slice(closingParenIndex + 1);
    closingParenIndex = trail2.indexOf(")");
    closingParens++;
  }
  return [url, trail2];
}
function previous2(match, email) {
  const code4 = match.input.charCodeAt(match.index - 1);
  return (match.index === 0 || unicodeWhitespace(code4) || unicodePunctuation(code4)) && // If its an email, the previous character should not be a slash.
  (!email || code4 !== 47);
}

// node_modules/mdast-util-gfm-footnote/lib/index.js
footnoteReference2.peek = footnoteReferencePeek;
function enterFootnoteCallString() {
  this.buffer();
}
function enterFootnoteCall(token) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, token);
}
function enterFootnoteDefinitionLabelString() {
  this.buffer();
}
function enterFootnoteDefinition(token) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    token
  );
}
function exitFootnoteCallString(token) {
  const label = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "footnoteReference");
  node2.identifier = normalizeIdentifier(
    this.sliceSerialize(token)
  ).toLowerCase();
  node2.label = label;
}
function exitFootnoteCall(token) {
  this.exit(token);
}
function exitFootnoteDefinitionLabelString(token) {
  const label = this.resume();
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "footnoteDefinition");
  node2.identifier = normalizeIdentifier(
    this.sliceSerialize(token)
  ).toLowerCase();
  node2.label = label;
}
function exitFootnoteDefinition(token) {
  this.exit(token);
}
function footnoteReferencePeek() {
  return "[";
}
function footnoteReference2(node2, _10, state, info) {
  const tracker = state.createTracker(info);
  let value = tracker.move("[^");
  const exit3 = state.enter("footnoteReference");
  const subexit = state.enter("reference");
  value += tracker.move(
    state.safe(state.associationId(node2), { after: "]", before: value })
  );
  subexit();
  exit3();
  value += tracker.move("]");
  return value;
}
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteCallString: enterFootnoteCallString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteDefinition: enterFootnoteDefinition
    },
    exit: {
      gfmFootnoteCallString: exitFootnoteCallString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteDefinition: exitFootnoteDefinition
    }
  };
}
function gfmFootnoteToMarkdown(options) {
  let firstLineBlank = false;
  if (options && options.firstLineBlank) {
    firstLineBlank = true;
  }
  return {
    handlers: { footnoteDefinition, footnoteReference: footnoteReference2 },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function footnoteDefinition(node2, _10, state, info) {
    const tracker = state.createTracker(info);
    let value = tracker.move("[^");
    const exit3 = state.enter("footnoteDefinition");
    const subexit = state.enter("label");
    value += tracker.move(
      state.safe(state.associationId(node2), { before: value, after: "]" })
    );
    subexit();
    value += tracker.move("]:");
    if (node2.children && node2.children.length > 0) {
      tracker.shift(4);
      value += tracker.move(
        (firstLineBlank ? "\n" : " ") + state.indentLines(
          state.containerFlow(node2, tracker.current()),
          firstLineBlank ? mapAll : mapExceptFirst
        )
      );
    }
    exit3();
    return value;
  }
}
function mapExceptFirst(line, index4, blank) {
  return index4 === 0 ? line : mapAll(line, index4, blank);
}
function mapAll(line, index4, blank) {
  return (blank ? "" : "    ") + line;
}

// node_modules/mdast-util-gfm-strikethrough/lib/index.js
var constructsWithoutStrikethrough = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
handleDelete.peek = peekDelete;
function gfmStrikethroughFromMarkdown() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: enterStrikethrough },
    exit: { strikethrough: exitStrikethrough }
  };
}
function gfmStrikethroughToMarkdown() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: constructsWithoutStrikethrough
      }
    ],
    handlers: { delete: handleDelete }
  };
}
function enterStrikethrough(token) {
  this.enter({ type: "delete", children: [] }, token);
}
function exitStrikethrough(token) {
  this.exit(token);
}
function handleDelete(node2, _10, state, info) {
  const tracker = state.createTracker(info);
  const exit3 = state.enter("strikethrough");
  let value = tracker.move("~~");
  value += state.containerPhrasing(node2, {
    ...tracker.current(),
    before: value,
    after: "~"
  });
  value += tracker.move("~~");
  exit3();
  return value;
}
function peekDelete() {
  return "~";
}

// node_modules/markdown-table/index.js
function defaultStringLength(value) {
  return value.length;
}
function markdownTable(table2, options) {
  const settings = options || {};
  const align = (settings.align || []).concat();
  const stringLength = settings.stringLength || defaultStringLength;
  const alignments2 = [];
  const cellMatrix = [];
  const sizeMatrix = [];
  const longestCellByColumn = [];
  let mostCellsPerRow = 0;
  let rowIndex = -1;
  while (++rowIndex < table2.length) {
    const row2 = [];
    const sizes2 = [];
    let columnIndex2 = -1;
    if (table2[rowIndex].length > mostCellsPerRow) {
      mostCellsPerRow = table2[rowIndex].length;
    }
    while (++columnIndex2 < table2[rowIndex].length) {
      const cell = serialize2(table2[rowIndex][columnIndex2]);
      if (settings.alignDelimiters !== false) {
        const size4 = stringLength(cell);
        sizes2[columnIndex2] = size4;
        if (longestCellByColumn[columnIndex2] === void 0 || size4 > longestCellByColumn[columnIndex2]) {
          longestCellByColumn[columnIndex2] = size4;
        }
      }
      row2.push(cell);
    }
    cellMatrix[rowIndex] = row2;
    sizeMatrix[rowIndex] = sizes2;
  }
  let columnIndex = -1;
  if (typeof align === "object" && "length" in align) {
    while (++columnIndex < mostCellsPerRow) {
      alignments2[columnIndex] = toAlignment(align[columnIndex]);
    }
  } else {
    const code4 = toAlignment(align);
    while (++columnIndex < mostCellsPerRow) {
      alignments2[columnIndex] = code4;
    }
  }
  columnIndex = -1;
  const row = [];
  const sizes = [];
  while (++columnIndex < mostCellsPerRow) {
    const code4 = alignments2[columnIndex];
    let before = "";
    let after = "";
    if (code4 === 99) {
      before = ":";
      after = ":";
    } else if (code4 === 108) {
      before = ":";
    } else if (code4 === 114) {
      after = ":";
    }
    let size4 = settings.alignDelimiters === false ? 1 : Math.max(
      1,
      longestCellByColumn[columnIndex] - before.length - after.length
    );
    const cell = before + "-".repeat(size4) + after;
    if (settings.alignDelimiters !== false) {
      size4 = before.length + size4 + after.length;
      if (size4 > longestCellByColumn[columnIndex]) {
        longestCellByColumn[columnIndex] = size4;
      }
      sizes[columnIndex] = size4;
    }
    row[columnIndex] = cell;
  }
  cellMatrix.splice(1, 0, row);
  sizeMatrix.splice(1, 0, sizes);
  rowIndex = -1;
  const lines = [];
  while (++rowIndex < cellMatrix.length) {
    const row2 = cellMatrix[rowIndex];
    const sizes2 = sizeMatrix[rowIndex];
    columnIndex = -1;
    const line = [];
    while (++columnIndex < mostCellsPerRow) {
      const cell = row2[columnIndex] || "";
      let before = "";
      let after = "";
      if (settings.alignDelimiters !== false) {
        const size4 = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
        const code4 = alignments2[columnIndex];
        if (code4 === 114) {
          before = " ".repeat(size4);
        } else if (code4 === 99) {
          if (size4 % 2) {
            before = " ".repeat(size4 / 2 + 0.5);
            after = " ".repeat(size4 / 2 - 0.5);
          } else {
            before = " ".repeat(size4 / 2);
            after = before;
          }
        } else {
          after = " ".repeat(size4);
        }
      }
      if (settings.delimiterStart !== false && !columnIndex) {
        line.push("|");
      }
      if (settings.padding !== false && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(settings.alignDelimiters === false && cell === "") && (settings.delimiterStart !== false || columnIndex)) {
        line.push(" ");
      }
      if (settings.alignDelimiters !== false) {
        line.push(before);
      }
      line.push(cell);
      if (settings.alignDelimiters !== false) {
        line.push(after);
      }
      if (settings.padding !== false) {
        line.push(" ");
      }
      if (settings.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
        line.push("|");
      }
    }
    lines.push(
      settings.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join("")
    );
  }
  return lines.join("\n");
}
function serialize2(value) {
  return value === null || value === void 0 ? "" : String(value);
}
function toAlignment(value) {
  const code4 = typeof value === "string" ? value.codePointAt(0) : 0;
  return code4 === 67 || code4 === 99 ? 99 : code4 === 76 || code4 === 108 ? 108 : code4 === 82 || code4 === 114 ? 114 : 0;
}

// node_modules/zwitch/index.js
var own5 = {}.hasOwnProperty;
function zwitch(key, options) {
  const settings = options || {};
  function one5(value, ...parameters) {
    let fn = one5.invalid;
    const handlers2 = one5.handlers;
    if (value && own5.call(value, key)) {
      const id = String(value[key]);
      fn = own5.call(handlers2, id) ? handlers2[id] : one5.unknown;
    }
    if (fn) {
      return fn.call(this, value, ...parameters);
    }
  }
  one5.handlers = settings.handlers || {};
  one5.invalid = settings.invalid;
  one5.unknown = settings.unknown;
  return one5;
}

// node_modules/mdast-util-to-markdown/lib/configure.js
var own6 = {}.hasOwnProperty;

// node_modules/mdast-util-to-markdown/lib/handle/blockquote.js
function blockquote2(node2, _10, state, info) {
  const exit3 = state.enter("blockquote");
  const tracker = state.createTracker(info);
  tracker.move("> ");
  tracker.shift(2);
  const value = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map
  );
  exit3();
  return value;
}
function map(line, _10, blank) {
  return ">" + (blank ? "" : " ") + line;
}

// node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
function patternInScope(stack, pattern) {
  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
}
function listInScope(stack, list4, none) {
  if (typeof list4 === "string") {
    list4 = [list4];
  }
  if (!list4 || list4.length === 0) {
    return none;
  }
  let index4 = -1;
  while (++index4 < list4.length) {
    if (stack.includes(list4[index4])) {
      return true;
    }
  }
  return false;
}

// node_modules/mdast-util-to-markdown/lib/handle/break.js
function hardBreak2(_10, _1, state, info) {
  let index4 = -1;
  while (++index4 < state.unsafe.length) {
    if (state.unsafe[index4].character === "\n" && patternInScope(state.stack, state.unsafe[index4])) {
      return /[ \t]/.test(info.before) ? "" : " ";
    }
  }
  return "\\\n";
}

// node_modules/longest-streak/index.js
function longestStreak(value, substring) {
  const source = String(value);
  let index4 = source.indexOf(substring);
  let expected = index4;
  let count2 = 0;
  let max2 = 0;
  if (typeof substring !== "string") {
    throw new TypeError("Expected substring");
  }
  while (index4 !== -1) {
    if (index4 === expected) {
      if (++count2 > max2) {
        max2 = count2;
      }
    } else {
      count2 = 1;
    }
    expected = index4 + substring.length;
    index4 = source.indexOf(substring, expected);
  }
  return max2;
}

// node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js
function formatCodeAsIndented(node2, state) {
  return Boolean(
    state.options.fences === false && node2.value && // If theres no info
    !node2.lang && // And theres a non-whitespace character
    /[^ \r\n]/.test(node2.value) && // And the value doesnt start or end in a blank
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
  );
}

// node_modules/mdast-util-to-markdown/lib/util/check-fence.js
function checkFence(state) {
  const marker = state.options.fence || "`";
  if (marker !== "`" && marker !== "~") {
    throw new Error(
      "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/code.js
function code2(node2, _10, state, info) {
  const marker = checkFence(state);
  const raw2 = node2.value || "";
  const suffix = marker === "`" ? "GraveAccent" : "Tilde";
  if (formatCodeAsIndented(node2, state)) {
    const exit4 = state.enter("codeIndented");
    const value2 = state.indentLines(raw2, map2);
    exit4();
    return value2;
  }
  const tracker = state.createTracker(info);
  const sequence = marker.repeat(Math.max(longestStreak(raw2, marker) + 1, 3));
  const exit3 = state.enter("codeFenced");
  let value = tracker.move(sequence);
  if (node2.lang) {
    const subexit = state.enter(`codeFencedLang${suffix}`);
    value += tracker.move(
      state.safe(node2.lang, {
        before: value,
        after: " ",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  if (node2.lang && node2.meta) {
    const subexit = state.enter(`codeFencedMeta${suffix}`);
    value += tracker.move(" ");
    value += tracker.move(
      state.safe(node2.meta, {
        before: value,
        after: "\n",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  value += tracker.move("\n");
  if (raw2) {
    value += tracker.move(raw2 + "\n");
  }
  value += tracker.move(sequence);
  exit3();
  return value;
}
function map2(line, _10, blank) {
  return (blank ? "" : "    ") + line;
}

// node_modules/mdast-util-to-markdown/lib/util/check-quote.js
function checkQuote(state) {
  const marker = state.options.quote || '"';
  if (marker !== '"' && marker !== "'") {
    throw new Error(
      "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/definition.js
function definition2(node2, _10, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit3 = state.enter("definition");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  value += tracker.move(
    state.safe(state.associationId(node2), {
      before: value,
      after: "]",
      ...tracker.current()
    })
  );
  value += tracker.move("]: ");
  subexit();
  if (
    // If theres no url, or
    !node2.url || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : "\n",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  exit3();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js
function checkEmphasis(state) {
  const marker = state.options.emphasis || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js
function encodeCharacterReference(code4) {
  return "&#x" + code4.toString(16).toUpperCase() + ";";
}

// node_modules/mdast-util-to-markdown/lib/util/encode-info.js
function encodeInfo(outside, inside, marker) {
  const outsideKind = classifyCharacter(outside);
  const insideKind = classifyCharacter(inside);
  if (outsideKind === void 0) {
    return insideKind === void 0 ? (
      // Letter inside:
      // we have to encode *both* letters for `_` as it is looser.
      // it already forms for `*` (and GFMs `~`).
      marker === "_" ? { inside: true, outside: true } : { inside: false, outside: false }
    ) : insideKind === 1 ? (
      // Whitespace inside: encode both (letter, whitespace).
      { inside: true, outside: true }
    ) : (
      // Punctuation inside: encode outer (letter)
      { inside: false, outside: true }
    );
  }
  if (outsideKind === 1) {
    return insideKind === void 0 ? (
      // Letter inside: already forms.
      { inside: false, outside: false }
    ) : insideKind === 1 ? (
      // Whitespace inside: encode both (whitespace).
      { inside: true, outside: true }
    ) : (
      // Punctuation inside: already forms.
      { inside: false, outside: false }
    );
  }
  return insideKind === void 0 ? (
    // Letter inside: already forms.
    { inside: false, outside: false }
  ) : insideKind === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: true, outside: false }
  ) : (
    // Punctuation inside: already forms.
    { inside: false, outside: false }
  );
}

// node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
emphasis2.peek = emphasisPeek;
function emphasis2(node2, _10, state, info) {
  const marker = checkEmphasis(state);
  const exit3 = state.enter("emphasis");
  const tracker = state.createTracker(info);
  const before = tracker.move(marker);
  let between = tracker.move(
    state.containerPhrasing(node2, {
      after: marker,
      before,
      ...tracker.current()
    })
  );
  const betweenHead = between.charCodeAt(0);
  const open2 = encodeInfo(
    info.before.charCodeAt(info.before.length - 1),
    betweenHead,
    marker
  );
  if (open2.inside) {
    between = encodeCharacterReference(betweenHead) + between.slice(1);
  }
  const betweenTail = between.charCodeAt(between.length - 1);
  const close2 = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
  if (close2.inside) {
    between = between.slice(0, -1) + encodeCharacterReference(betweenTail);
  }
  const after = tracker.move(marker);
  exit3();
  state.attentionEncodeSurroundingInfo = {
    after: close2.outside,
    before: open2.outside
  };
  return before + between + after;
}
function emphasisPeek(_10, _1, state) {
  return state.options.emphasis || "*";
}

// node_modules/mdast-util-to-markdown/node_modules/unist-util-visit/lib/index.js
function visit3(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse;
  let test;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test = void 0;
    visitor = testOrVisitor;
    reverse = visitorOrReverse;
  } else {
    test = testOrVisitor;
    visitor = visitorOrReverse;
    reverse = maybeReverse;
  }
  visitParents(tree, test, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    const index4 = parent ? parent.children.indexOf(node2) : void 0;
    return visitor(node2, index4, parent);
  }
}

// node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js
function formatHeadingAsSetext(node2, state) {
  let literalWithBreak = false;
  visit3(node2, function(node3) {
    if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
      literalWithBreak = true;
      return EXIT;
    }
  });
  return Boolean(
    (!node2.depth || node2.depth < 3) && toString(node2) && (state.options.setext || literalWithBreak)
  );
}

// node_modules/mdast-util-to-markdown/lib/handle/heading.js
function heading2(node2, _10, state, info) {
  const rank = Math.max(Math.min(6, node2.depth || 1), 1);
  const tracker = state.createTracker(info);
  if (formatHeadingAsSetext(node2, state)) {
    const exit4 = state.enter("headingSetext");
    const subexit2 = state.enter("phrasing");
    const value2 = state.containerPhrasing(node2, {
      ...tracker.current(),
      before: "\n",
      after: "\n"
    });
    subexit2();
    exit4();
    return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
      // The whole size
      value2.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
    );
  }
  const sequence = "#".repeat(rank);
  const exit3 = state.enter("headingAtx");
  const subexit = state.enter("phrasing");
  tracker.move(sequence + " ");
  let value = state.containerPhrasing(node2, {
    before: "# ",
    after: "\n",
    ...tracker.current()
  });
  if (/^[\t ]/.test(value)) {
    value = encodeCharacterReference(value.charCodeAt(0)) + value.slice(1);
  }
  value = value ? sequence + " " + value : sequence;
  if (state.options.closeAtx) {
    value += " " + sequence;
  }
  subexit();
  exit3();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/handle/html.js
html5.peek = htmlPeek;
function html5(node2) {
  return node2.value || "";
}
function htmlPeek() {
  return "<";
}

// node_modules/mdast-util-to-markdown/lib/handle/image.js
image2.peek = imagePeek;
function image2(node2, _10, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit3 = state.enter("image");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  value += tracker.move(
    state.safe(node2.alt, { before: value, after: "]", ...tracker.current() })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If theres no url but there is a title
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit3();
  return value;
}
function imagePeek() {
  return "!";
}

// node_modules/mdast-util-to-markdown/lib/handle/image-reference.js
imageReference2.peek = imageReferencePeek;
function imageReference2(node2, _10, state, info) {
  const type = node2.referenceType;
  const exit3 = state.enter("imageReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  const alt = state.safe(node2.alt, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(alt + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit3();
  if (type === "full" || !alt || alt !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function imageReferencePeek() {
  return "!";
}

// node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
inlineCode2.peek = inlineCodePeek;
function inlineCode2(node2, _10, state) {
  let value = node2.value || "";
  let sequence = "`";
  let index4 = -1;
  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
    sequence += "`";
  }
  if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
    value = " " + value + " ";
  }
  while (++index4 < state.unsafe.length) {
    const pattern = state.unsafe[index4];
    const expression = state.compilePattern(pattern);
    let match;
    if (!pattern.atBreak) continue;
    while (match = expression.exec(value)) {
      let position4 = match.index;
      if (value.charCodeAt(position4) === 10 && value.charCodeAt(position4 - 1) === 13) {
        position4--;
      }
      value = value.slice(0, position4) + " " + value.slice(match.index + 1);
    }
  }
  return sequence + value + sequence;
}
function inlineCodePeek() {
  return "`";
}

// node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js
function formatLinkAsAutolink(node2, state) {
  const raw2 = toString(node2);
  return Boolean(
    !state.options.resourceLink && // If theres a url
    node2.url && // And theres a no title
    !node2.title && // And the content of `node` is a single text node
    node2.children && node2.children.length === 1 && node2.children[0].type === "text" && // And if the url is the same as the content
    (raw2 === node2.url || "mailto:" + raw2 === node2.url) && // And that starts w/ a protocol
    /^[a-z][a-z+.-]+:/i.test(node2.url) && // And that doesnt contain ASCII control codes (character escapes and
    // references dont work), space, or angle brackets
    !/[\0- <>\u007F]/.test(node2.url)
  );
}

// node_modules/mdast-util-to-markdown/lib/handle/link.js
link2.peek = linkPeek;
function link2(node2, _10, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const tracker = state.createTracker(info);
  let exit3;
  let subexit;
  if (formatLinkAsAutolink(node2, state)) {
    const stack = state.stack;
    state.stack = [];
    exit3 = state.enter("autolink");
    let value2 = tracker.move("<");
    value2 += tracker.move(
      state.containerPhrasing(node2, {
        before: value2,
        after: ">",
        ...tracker.current()
      })
    );
    value2 += tracker.move(">");
    exit3();
    state.stack = stack;
    return value2;
  }
  exit3 = state.enter("link");
  subexit = state.enter("label");
  let value = tracker.move("[");
  value += tracker.move(
    state.containerPhrasing(node2, {
      before: value,
      after: "](",
      ...tracker.current()
    })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If theres no url but there is a title
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit3();
  return value;
}
function linkPeek(node2, _10, state) {
  return formatLinkAsAutolink(node2, state) ? "<" : "[";
}

// node_modules/mdast-util-to-markdown/lib/handle/link-reference.js
linkReference2.peek = linkReferencePeek;
function linkReference2(node2, _10, state, info) {
  const type = node2.referenceType;
  const exit3 = state.enter("linkReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  const text10 = state.containerPhrasing(node2, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(text10 + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit3();
  if (type === "full" || !text10 || text10 !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function linkReferencePeek() {
  return "[";
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
function checkBullet(state) {
  const marker = state.options.bullet || "*";
  if (marker !== "*" && marker !== "+" && marker !== "-") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js
function checkBulletOther(state) {
  const bullet = checkBullet(state);
  const bulletOther = state.options.bulletOther;
  if (!bulletOther) {
    return bullet === "*" ? "-" : "*";
  }
  if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
    throw new Error(
      "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  }
  if (bulletOther === bullet) {
    throw new Error(
      "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
    );
  }
  return bulletOther;
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js
function checkBulletOrdered(state) {
  const marker = state.options.bulletOrdered || ".";
  if (marker !== "." && marker !== ")") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/check-rule.js
function checkRule(state) {
  const marker = state.options.rule || "*";
  if (marker !== "*" && marker !== "-" && marker !== "_") {
    throw new Error(
      "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/list.js
function list3(node2, parent, state, info) {
  const exit3 = state.enter("list");
  const bulletCurrent = state.bulletCurrent;
  let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
  const bulletOther = node2.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
  let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
  if (!node2.ordered) {
    const firstListItem = node2.children ? node2.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (bullet === "*" || bullet === "-") && // Empty first list item:
      firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
      state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
      state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
    ) {
      useDifferentMarker = true;
    }
    if (checkRule(state) === bullet && firstListItem) {
      let index4 = -1;
      while (++index4 < node2.children.length) {
        const item = node2.children[index4];
        if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
          useDifferentMarker = true;
          break;
        }
      }
    }
  }
  if (useDifferentMarker) {
    bullet = bulletOther;
  }
  state.bulletCurrent = bullet;
  const value = state.containerFlow(node2, info);
  state.bulletLastUsed = bullet;
  state.bulletCurrent = bulletCurrent;
  exit3();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
function checkListItemIndent(state) {
  const style2 = state.options.listItemIndent || "one";
  if (style2 !== "tab" && style2 !== "one" && style2 !== "mixed") {
    throw new Error(
      "Cannot serialize items with `" + style2 + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  }
  return style2;
}

// node_modules/mdast-util-to-markdown/lib/handle/list-item.js
function listItem2(node2, parent, state, info) {
  const listItemIndent = checkListItemIndent(state);
  let bullet = state.bulletCurrent || checkBullet(state);
  if (parent && parent.type === "list" && parent.ordered) {
    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
  }
  let size4 = bullet.length + 1;
  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
    size4 = Math.ceil(size4 / 4) * 4;
  }
  const tracker = state.createTracker(info);
  tracker.move(bullet + " ".repeat(size4 - bullet.length));
  tracker.shift(size4);
  const exit3 = state.enter("listItem");
  const value = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map3
  );
  exit3();
  return value;
  function map3(line, index4, blank) {
    if (index4) {
      return (blank ? "" : " ".repeat(size4)) + line;
    }
    return (blank ? bullet : bullet + " ".repeat(size4 - bullet.length)) + line;
  }
}

// node_modules/mdast-util-to-markdown/lib/handle/paragraph.js
function paragraph2(node2, _10, state, info) {
  const exit3 = state.enter("paragraph");
  const subexit = state.enter("phrasing");
  const value = state.containerPhrasing(node2, info);
  subexit();
  exit3();
  return value;
}

// node_modules/mdast-util-phrasing/lib/index.js
var phrasing = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  convert([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);

// node_modules/mdast-util-to-markdown/lib/handle/root.js
function root3(node2, _10, state, info) {
  const hasPhrasing = node2.children.some(function(d14) {
    return phrasing(d14);
  });
  const container = hasPhrasing ? state.containerPhrasing : state.containerFlow;
  return container.call(state, node2, info);
}

// node_modules/mdast-util-to-markdown/lib/util/check-strong.js
function checkStrong(state) {
  const marker = state.options.strong || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/strong.js
strong2.peek = strongPeek;
function strong2(node2, _10, state, info) {
  const marker = checkStrong(state);
  const exit3 = state.enter("strong");
  const tracker = state.createTracker(info);
  const before = tracker.move(marker + marker);
  let between = tracker.move(
    state.containerPhrasing(node2, {
      after: marker,
      before,
      ...tracker.current()
    })
  );
  const betweenHead = between.charCodeAt(0);
  const open2 = encodeInfo(
    info.before.charCodeAt(info.before.length - 1),
    betweenHead,
    marker
  );
  if (open2.inside) {
    between = encodeCharacterReference(betweenHead) + between.slice(1);
  }
  const betweenTail = between.charCodeAt(between.length - 1);
  const close2 = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
  if (close2.inside) {
    between = between.slice(0, -1) + encodeCharacterReference(betweenTail);
  }
  const after = tracker.move(marker + marker);
  exit3();
  state.attentionEncodeSurroundingInfo = {
    after: close2.outside,
    before: open2.outside
  };
  return before + between + after;
}
function strongPeek(_10, _1, state) {
  return state.options.strong || "*";
}

// node_modules/mdast-util-to-markdown/lib/handle/text.js
function text5(node2, _10, state, info) {
  return state.safe(node2.value, info);
}

// node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js
function checkRuleRepetition(state) {
  const repetition = state.options.ruleRepetition || 3;
  if (repetition < 3) {
    throw new Error(
      "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
    );
  }
  return repetition;
}

// node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
function thematicBreak3(_10, _1, state) {
  const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
  return state.options.ruleSpaces ? value.slice(0, -1) : value;
}

// node_modules/mdast-util-to-markdown/lib/handle/index.js
var handle = {
  blockquote: blockquote2,
  break: hardBreak2,
  code: code2,
  definition: definition2,
  emphasis: emphasis2,
  hardBreak: hardBreak2,
  heading: heading2,
  html: html5,
  image: image2,
  imageReference: imageReference2,
  inlineCode: inlineCode2,
  link: link2,
  linkReference: linkReference2,
  list: list3,
  listItem: listItem2,
  paragraph: paragraph2,
  root: root3,
  strong: strong2,
  text: text5,
  thematicBreak: thematicBreak3
};

// node_modules/mdast-util-gfm-table/lib/index.js
function gfmTableFromMarkdown() {
  return {
    enter: {
      table: enterTable,
      tableData: enterCell,
      tableHeader: enterCell,
      tableRow: enterRow
    },
    exit: {
      codeText: exitCodeText,
      table: exitTable,
      tableData: exit2,
      tableHeader: exit2,
      tableRow: exit2
    }
  };
}
function enterTable(token) {
  const align = token._align;
  ok(align, "expected `_align` on table");
  this.enter(
    {
      type: "table",
      align: align.map(function(d14) {
        return d14 === "none" ? null : d14;
      }),
      children: []
    },
    token
  );
  this.data.inTable = true;
}
function exitTable(token) {
  this.exit(token);
  this.data.inTable = void 0;
}
function enterRow(token) {
  this.enter({ type: "tableRow", children: [] }, token);
}
function exit2(token) {
  this.exit(token);
}
function enterCell(token) {
  this.enter({ type: "tableCell", children: [] }, token);
}
function exitCodeText(token) {
  let value = this.resume();
  if (this.data.inTable) {
    value = value.replace(/\\([\\|])/g, replace);
  }
  const node2 = this.stack[this.stack.length - 1];
  ok(node2.type === "inlineCode");
  node2.value = value;
  this.exit(token);
}
function replace($0, $1) {
  return $1 === "|" ? $1 : $0;
}
function gfmTableToMarkdown(options) {
  const settings = options || {};
  const padding = settings.tableCellPadding;
  const alignDelimiters = settings.tablePipeAlign;
  const stringLength = settings.stringLength;
  const around = padding ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: "\n", inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: true, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: true, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: true, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: inlineCodeWithTable,
      table: handleTable,
      tableCell: handleTableCell,
      tableRow: handleTableRow
    }
  };
  function handleTable(node2, _10, state, info) {
    return serializeData(handleTableAsData(node2, state, info), node2.align);
  }
  function handleTableRow(node2, _10, state, info) {
    const row = handleTableRowAsData(node2, state, info);
    const value = serializeData([row]);
    return value.slice(0, value.indexOf("\n"));
  }
  function handleTableCell(node2, _10, state, info) {
    const exit3 = state.enter("tableCell");
    const subexit = state.enter("phrasing");
    const value = state.containerPhrasing(node2, {
      ...info,
      before: around,
      after: around
    });
    subexit();
    exit3();
    return value;
  }
  function serializeData(matrix, align) {
    return markdownTable(matrix, {
      align,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength
    });
  }
  function handleTableAsData(node2, state, info) {
    const children = node2.children;
    let index4 = -1;
    const result = [];
    const subexit = state.enter("table");
    while (++index4 < children.length) {
      result[index4] = handleTableRowAsData(children[index4], state, info);
    }
    subexit();
    return result;
  }
  function handleTableRowAsData(node2, state, info) {
    const children = node2.children;
    let index4 = -1;
    const result = [];
    const subexit = state.enter("tableRow");
    while (++index4 < children.length) {
      result[index4] = handleTableCell(children[index4], node2, state, info);
    }
    subexit();
    return result;
  }
  function inlineCodeWithTable(node2, parent, state) {
    let value = handle.inlineCode(node2, parent, state);
    if (state.stack.includes("tableCell")) {
      value = value.replace(/\|/g, "\\$&");
    }
    return value;
  }
}

// node_modules/mdast-util-gfm-task-list-item/lib/index.js
function gfmTaskListItemFromMarkdown() {
  return {
    exit: {
      taskListCheckValueChecked: exitCheck,
      taskListCheckValueUnchecked: exitCheck,
      paragraph: exitParagraphWithTaskListItem
    }
  };
}
function gfmTaskListItemToMarkdown() {
  return {
    unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
    handlers: { listItem: listItemWithTaskListItem }
  };
}
function exitCheck(token) {
  const node2 = this.stack[this.stack.length - 2];
  ok(node2.type === "listItem");
  node2.checked = token.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token) {
  const parent = this.stack[this.stack.length - 2];
  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
    const node2 = this.stack[this.stack.length - 1];
    ok(node2.type === "paragraph");
    const head = node2.children[0];
    if (head && head.type === "text") {
      const siblings = parent.children;
      let index4 = -1;
      let firstParaghraph;
      while (++index4 < siblings.length) {
        const sibling = siblings[index4];
        if (sibling.type === "paragraph") {
          firstParaghraph = sibling;
          break;
        }
      }
      if (firstParaghraph === node2) {
        head.value = head.value.slice(1);
        if (head.value.length === 0) {
          node2.children.shift();
        } else if (node2.position && head.position && typeof head.position.start.offset === "number") {
          head.position.start.column++;
          head.position.start.offset++;
          node2.position.start = Object.assign({}, head.position.start);
        }
      }
    }
  }
  this.exit(token);
}
function listItemWithTaskListItem(node2, parent, state, info) {
  const head = node2.children[0];
  const checkable = typeof node2.checked === "boolean" && head && head.type === "paragraph";
  const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
  const tracker = state.createTracker(info);
  if (checkable) {
    tracker.move(checkbox);
  }
  let value = handle.listItem(node2, parent, state, {
    ...info,
    ...tracker.current()
  });
  if (checkable) {
    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
  }
  return value;
  function check($0) {
    return $0 + checkbox;
  }
}

// node_modules/mdast-util-gfm/lib/index.js
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown(),
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown(),
    gfmTableFromMarkdown(),
    gfmTaskListItemFromMarkdown()
  ];
}
function gfmToMarkdown(options) {
  return {
    extensions: [
      gfmAutolinkLiteralToMarkdown(),
      gfmFootnoteToMarkdown(options),
      gfmStrikethroughToMarkdown(),
      gfmTableToMarkdown(options),
      gfmTaskListItemToMarkdown()
    ]
  };
}

// node_modules/micromark-extension-gfm-autolink-literal/dev/lib/syntax.js
var wwwPrefix = { tokenize: tokenizeWwwPrefix, partial: true };
var domain = { tokenize: tokenizeDomain, partial: true };
var path = { tokenize: tokenizePath, partial: true };
var trail = { tokenize: tokenizeTrail, partial: true };
var emailDomainDotTrail = {
  tokenize: tokenizeEmailDomainDotTrail,
  partial: true
};
var wwwAutolink = {
  name: "wwwAutolink",
  tokenize: tokenizeWwwAutolink,
  previous: previousWww
};
var protocolAutolink = {
  name: "protocolAutolink",
  tokenize: tokenizeProtocolAutolink,
  previous: previousProtocol
};
var emailAutolink = {
  name: "emailAutolink",
  tokenize: tokenizeEmailAutolink,
  previous: previousEmail
};
var text6 = {};
function gfmAutolinkLiteral() {
  return { text: text6 };
}
var code3 = codes.digit0;
while (code3 < codes.leftCurlyBrace) {
  text6[code3] = emailAutolink;
  code3++;
  if (code3 === codes.colon) code3 = codes.uppercaseA;
  else if (code3 === codes.leftSquareBracket) code3 = codes.lowercaseA;
}
text6[codes.plusSign] = emailAutolink;
text6[codes.dash] = emailAutolink;
text6[codes.dot] = emailAutolink;
text6[codes.underscore] = emailAutolink;
text6[codes.uppercaseH] = [emailAutolink, protocolAutolink];
text6[codes.lowercaseH] = [emailAutolink, protocolAutolink];
text6[codes.uppercaseW] = [emailAutolink, wwwAutolink];
text6[codes.lowercaseW] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(effects, ok3, nok) {
  const self2 = this;
  let dot;
  let data;
  return start2;
  function start2(code4) {
    if (!gfmAtext(code4) || !previousEmail.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code4);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkEmail");
    return atext(code4);
  }
  function atext(code4) {
    if (gfmAtext(code4)) {
      effects.consume(code4);
      return atext;
    }
    if (code4 === codes.atSign) {
      effects.consume(code4);
      return emailDomain;
    }
    return nok(code4);
  }
  function emailDomain(code4) {
    if (code4 === codes.dot) {
      return effects.check(
        emailDomainDotTrail,
        emailDomainAfter,
        emailDomainDot
      )(code4);
    }
    if (code4 === codes.dash || code4 === codes.underscore || asciiAlphanumeric(code4)) {
      data = true;
      effects.consume(code4);
      return emailDomain;
    }
    return emailDomainAfter(code4);
  }
  function emailDomainDot(code4) {
    effects.consume(code4);
    dot = true;
    return emailDomain;
  }
  function emailDomainAfter(code4) {
    if (data && dot && asciiAlpha(self2.previous)) {
      effects.exit("literalAutolinkEmail");
      effects.exit("literalAutolink");
      return ok3(code4);
    }
    return nok(code4);
  }
}
function tokenizeWwwAutolink(effects, ok3, nok) {
  const self2 = this;
  return wwwStart;
  function wwwStart(code4) {
    if (code4 !== codes.uppercaseW && code4 !== codes.lowercaseW || !previousWww.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code4);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkWww");
    return effects.check(
      wwwPrefix,
      effects.attempt(domain, effects.attempt(path, wwwAfter), nok),
      nok
    )(code4);
  }
  function wwwAfter(code4) {
    effects.exit("literalAutolinkWww");
    effects.exit("literalAutolink");
    return ok3(code4);
  }
}
function tokenizeProtocolAutolink(effects, ok3, nok) {
  const self2 = this;
  let buffer = "";
  let seen = false;
  return protocolStart;
  function protocolStart(code4) {
    if ((code4 === codes.uppercaseH || code4 === codes.lowercaseH) && previousProtocol.call(self2, self2.previous) && !previousUnbalanced(self2.events)) {
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkHttp");
      buffer += String.fromCodePoint(code4);
      effects.consume(code4);
      return protocolPrefixInside;
    }
    return nok(code4);
  }
  function protocolPrefixInside(code4) {
    if (asciiAlpha(code4) && buffer.length < 5) {
      buffer += String.fromCodePoint(code4);
      effects.consume(code4);
      return protocolPrefixInside;
    }
    if (code4 === codes.colon) {
      const protocol = buffer.toLowerCase();
      if (protocol === "http" || protocol === "https") {
        effects.consume(code4);
        return protocolSlashesInside;
      }
    }
    return nok(code4);
  }
  function protocolSlashesInside(code4) {
    if (code4 === codes.slash) {
      effects.consume(code4);
      if (seen) {
        return afterProtocol;
      }
      seen = true;
      return protocolSlashesInside;
    }
    return nok(code4);
  }
  function afterProtocol(code4) {
    return code4 === codes.eof || asciiControl(code4) || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4) || unicodePunctuation(code4) ? nok(code4) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code4);
  }
  function protocolAfter(code4) {
    effects.exit("literalAutolinkHttp");
    effects.exit("literalAutolink");
    return ok3(code4);
  }
}
function tokenizeWwwPrefix(effects, ok3, nok) {
  let size4 = 0;
  return wwwPrefixInside;
  function wwwPrefixInside(code4) {
    if ((code4 === codes.uppercaseW || code4 === codes.lowercaseW) && size4 < 3) {
      size4++;
      effects.consume(code4);
      return wwwPrefixInside;
    }
    if (code4 === codes.dot && size4 === 3) {
      effects.consume(code4);
      return wwwPrefixAfter;
    }
    return nok(code4);
  }
  function wwwPrefixAfter(code4) {
    return code4 === codes.eof ? nok(code4) : ok3(code4);
  }
}
function tokenizeDomain(effects, ok3, nok) {
  let underscoreInLastSegment;
  let underscoreInLastLastSegment;
  let seen;
  return domainInside;
  function domainInside(code4) {
    if (code4 === codes.dot || code4 === codes.underscore) {
      return effects.check(trail, domainAfter, domainAtPunctuation)(code4);
    }
    if (code4 === codes.eof || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4) || code4 !== codes.dash && unicodePunctuation(code4)) {
      return domainAfter(code4);
    }
    seen = true;
    effects.consume(code4);
    return domainInside;
  }
  function domainAtPunctuation(code4) {
    if (code4 === codes.underscore) {
      underscoreInLastSegment = true;
    } else {
      underscoreInLastLastSegment = underscoreInLastSegment;
      underscoreInLastSegment = void 0;
    }
    effects.consume(code4);
    return domainInside;
  }
  function domainAfter(code4) {
    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
      return nok(code4);
    }
    return ok3(code4);
  }
}
function tokenizePath(effects, ok3) {
  let sizeOpen = 0;
  let sizeClose = 0;
  return pathInside;
  function pathInside(code4) {
    if (code4 === codes.leftParenthesis) {
      sizeOpen++;
      effects.consume(code4);
      return pathInside;
    }
    if (code4 === codes.rightParenthesis && sizeClose < sizeOpen) {
      return pathAtPunctuation(code4);
    }
    if (code4 === codes.exclamationMark || code4 === codes.quotationMark || code4 === codes.ampersand || code4 === codes.apostrophe || code4 === codes.rightParenthesis || code4 === codes.asterisk || code4 === codes.comma || code4 === codes.dot || code4 === codes.colon || code4 === codes.semicolon || code4 === codes.lessThan || code4 === codes.questionMark || code4 === codes.rightSquareBracket || code4 === codes.underscore || code4 === codes.tilde) {
      return effects.check(trail, ok3, pathAtPunctuation)(code4);
    }
    if (code4 === codes.eof || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)) {
      return ok3(code4);
    }
    effects.consume(code4);
    return pathInside;
  }
  function pathAtPunctuation(code4) {
    if (code4 === codes.rightParenthesis) {
      sizeClose++;
    }
    effects.consume(code4);
    return pathInside;
  }
}
function tokenizeTrail(effects, ok3, nok) {
  return trail2;
  function trail2(code4) {
    if (code4 === codes.exclamationMark || code4 === codes.quotationMark || code4 === codes.apostrophe || code4 === codes.rightParenthesis || code4 === codes.asterisk || code4 === codes.comma || code4 === codes.dot || code4 === codes.colon || code4 === codes.semicolon || code4 === codes.questionMark || code4 === codes.underscore || code4 === codes.tilde) {
      effects.consume(code4);
      return trail2;
    }
    if (code4 === codes.ampersand) {
      effects.consume(code4);
      return trailCharacterReferenceStart;
    }
    if (code4 === codes.rightSquareBracket) {
      effects.consume(code4);
      return trailBracketAfter;
    }
    if (
      // `<` is an end.
      code4 === codes.lessThan || // So is whitespace.
      code4 === codes.eof || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)
    ) {
      return ok3(code4);
    }
    return nok(code4);
  }
  function trailBracketAfter(code4) {
    if (code4 === codes.eof || code4 === codes.leftParenthesis || code4 === codes.leftSquareBracket || markdownLineEndingOrSpace(code4) || unicodeWhitespace(code4)) {
      return ok3(code4);
    }
    return trail2(code4);
  }
  function trailCharacterReferenceStart(code4) {
    return asciiAlpha(code4) ? trailCharacterReferenceInside(code4) : nok(code4);
  }
  function trailCharacterReferenceInside(code4) {
    if (code4 === codes.semicolon) {
      effects.consume(code4);
      return trail2;
    }
    if (asciiAlpha(code4)) {
      effects.consume(code4);
      return trailCharacterReferenceInside;
    }
    return nok(code4);
  }
}
function tokenizeEmailDomainDotTrail(effects, ok3, nok) {
  return start2;
  function start2(code4) {
    effects.consume(code4);
    return after;
  }
  function after(code4) {
    return asciiAlphanumeric(code4) ? nok(code4) : ok3(code4);
  }
}
function previousWww(code4) {
  return code4 === codes.eof || code4 === codes.leftParenthesis || code4 === codes.asterisk || code4 === codes.underscore || code4 === codes.leftSquareBracket || code4 === codes.rightSquareBracket || code4 === codes.tilde || markdownLineEndingOrSpace(code4);
}
function previousProtocol(code4) {
  return !asciiAlpha(code4);
}
function previousEmail(code4) {
  return !(code4 === codes.slash || gfmAtext(code4));
}
function gfmAtext(code4) {
  return code4 === codes.plusSign || code4 === codes.dash || code4 === codes.dot || code4 === codes.underscore || asciiAlphanumeric(code4);
}
function previousUnbalanced(events) {
  let index4 = events.length;
  let result = false;
  while (index4--) {
    const token = events[index4][1];
    if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
      result = true;
      break;
    }
    if (token._gfmAutolinkLiteralWalkedInto) {
      result = false;
      break;
    }
  }
  if (events.length > 0 && !result) {
    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
  }
  return result;
}

// node_modules/micromark-extension-gfm-footnote/dev/lib/syntax.js
var indent = { tokenize: tokenizeIndent2, partial: true };
function gfmFootnote() {
  return {
    document: {
      [codes.leftSquareBracket]: {
        name: "gfmFootnoteDefinition",
        tokenize: tokenizeDefinitionStart,
        continuation: { tokenize: tokenizeDefinitionContinuation },
        exit: gfmFootnoteDefinitionEnd
      }
    },
    text: {
      [codes.leftSquareBracket]: {
        name: "gfmFootnoteCall",
        tokenize: tokenizeGfmFootnoteCall
      },
      [codes.rightSquareBracket]: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall
      }
    }
  };
}
function tokenizePotentialGfmFootnoteCall(effects, ok3, nok) {
  const self2 = this;
  let index4 = self2.events.length;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let labelStart;
  while (index4--) {
    const token = self2.events[index4][1];
    if (token.type === types.labelImage) {
      labelStart = token;
      break;
    }
    if (token.type === "gfmFootnoteCall" || token.type === types.labelLink || token.type === types.label || token.type === types.image || token.type === types.link) {
      break;
    }
  }
  return start2;
  function start2(code4) {
    ok(code4 === codes.rightSquareBracket, "expected `]`");
    if (!labelStart || !labelStart._balanced) {
      return nok(code4);
    }
    const id = normalizeIdentifier(
      self2.sliceSerialize({ start: labelStart.end, end: self2.now() })
    );
    if (id.codePointAt(0) !== codes.caret || !defined.includes(id.slice(1))) {
      return nok(code4);
    }
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code4);
    effects.exit("gfmFootnoteCallLabelMarker");
    return ok3(code4);
  }
}
function resolveToPotentialGfmFootnoteCall(events, context) {
  let index4 = events.length;
  let labelStart;
  while (index4--) {
    if (events[index4][1].type === types.labelImage && events[index4][0] === "enter") {
      labelStart = events[index4][1];
      break;
    }
  }
  ok(labelStart, "expected `labelStart` to resolve");
  events[index4 + 1][1].type = types.data;
  events[index4 + 3][1].type = "gfmFootnoteCallLabelMarker";
  const call = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, events[index4 + 3][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const marker = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, events[index4 + 3][1].end),
    end: Object.assign({}, events[index4 + 3][1].end)
  };
  marker.end.column++;
  marker.end.offset++;
  marker.end._bufferIndex++;
  const string3 = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, marker.end),
    end: Object.assign({}, events[events.length - 1][1].start)
  };
  const chunk = {
    type: types.chunkString,
    contentType: "string",
    start: Object.assign({}, string3.start),
    end: Object.assign({}, string3.end)
  };
  const replacement = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    events[index4 + 1],
    events[index4 + 2],
    ["enter", call, context],
    // The `[`
    events[index4 + 3],
    events[index4 + 4],
    // The `^`.
    ["enter", marker, context],
    ["exit", marker, context],
    // Everything in between.
    ["enter", string3, context],
    ["enter", chunk, context],
    ["exit", chunk, context],
    ["exit", string3, context],
    // The ending (`]`, properly parsed and labelled).
    events[events.length - 2],
    events[events.length - 1],
    ["exit", call, context]
  ];
  events.splice(index4, events.length - index4 + 1, ...replacement);
  return events;
}
function tokenizeGfmFootnoteCall(effects, ok3, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let size4 = 0;
  let data;
  return start2;
  function start2(code4) {
    ok(code4 === codes.leftSquareBracket, "expected `[`");
    effects.enter("gfmFootnoteCall");
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code4);
    effects.exit("gfmFootnoteCallLabelMarker");
    return callStart;
  }
  function callStart(code4) {
    if (code4 !== codes.caret) return nok(code4);
    effects.enter("gfmFootnoteCallMarker");
    effects.consume(code4);
    effects.exit("gfmFootnoteCallMarker");
    effects.enter("gfmFootnoteCallString");
    effects.enter("chunkString").contentType = "string";
    return callData;
  }
  function callData(code4) {
    if (
      // Too long.
      size4 > constants.linkReferenceSizeMax || // Closing brace with nothing.
      code4 === codes.rightSquareBracket && !data || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code4 === codes.eof || code4 === codes.leftSquareBracket || markdownLineEndingOrSpace(code4)
    ) {
      return nok(code4);
    }
    if (code4 === codes.rightSquareBracket) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteCallString");
      if (!defined.includes(normalizeIdentifier(self2.sliceSerialize(token)))) {
        return nok(code4);
      }
      effects.enter("gfmFootnoteCallLabelMarker");
      effects.consume(code4);
      effects.exit("gfmFootnoteCallLabelMarker");
      effects.exit("gfmFootnoteCall");
      return ok3;
    }
    if (!markdownLineEndingOrSpace(code4)) {
      data = true;
    }
    size4++;
    effects.consume(code4);
    return code4 === codes.backslash ? callEscape : callData;
  }
  function callEscape(code4) {
    if (code4 === codes.leftSquareBracket || code4 === codes.backslash || code4 === codes.rightSquareBracket) {
      effects.consume(code4);
      size4++;
      return callData;
    }
    return callData(code4);
  }
}
function tokenizeDefinitionStart(effects, ok3, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let identifier;
  let size4 = 0;
  let data;
  return start2;
  function start2(code4) {
    ok(code4 === codes.leftSquareBracket, "expected `[`");
    effects.enter("gfmFootnoteDefinition")._container = true;
    effects.enter("gfmFootnoteDefinitionLabel");
    effects.enter("gfmFootnoteDefinitionLabelMarker");
    effects.consume(code4);
    effects.exit("gfmFootnoteDefinitionLabelMarker");
    return labelAtMarker;
  }
  function labelAtMarker(code4) {
    if (code4 === codes.caret) {
      effects.enter("gfmFootnoteDefinitionMarker");
      effects.consume(code4);
      effects.exit("gfmFootnoteDefinitionMarker");
      effects.enter("gfmFootnoteDefinitionLabelString");
      effects.enter("chunkString").contentType = "string";
      return labelInside;
    }
    return nok(code4);
  }
  function labelInside(code4) {
    if (
      // Too long.
      size4 > constants.linkReferenceSizeMax || // Closing brace with nothing.
      code4 === codes.rightSquareBracket && !data || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code4 === codes.eof || code4 === codes.leftSquareBracket || markdownLineEndingOrSpace(code4)
    ) {
      return nok(code4);
    }
    if (code4 === codes.rightSquareBracket) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteDefinitionLabelString");
      identifier = normalizeIdentifier(self2.sliceSerialize(token));
      effects.enter("gfmFootnoteDefinitionLabelMarker");
      effects.consume(code4);
      effects.exit("gfmFootnoteDefinitionLabelMarker");
      effects.exit("gfmFootnoteDefinitionLabel");
      return labelAfter;
    }
    if (!markdownLineEndingOrSpace(code4)) {
      data = true;
    }
    size4++;
    effects.consume(code4);
    return code4 === codes.backslash ? labelEscape : labelInside;
  }
  function labelEscape(code4) {
    if (code4 === codes.leftSquareBracket || code4 === codes.backslash || code4 === codes.rightSquareBracket) {
      effects.consume(code4);
      size4++;
      return labelInside;
    }
    return labelInside(code4);
  }
  function labelAfter(code4) {
    if (code4 === codes.colon) {
      effects.enter("definitionMarker");
      effects.consume(code4);
      effects.exit("definitionMarker");
      if (!defined.includes(identifier)) {
        defined.push(identifier);
      }
      return factorySpace(
        effects,
        whitespaceAfter,
        "gfmFootnoteDefinitionWhitespace"
      );
    }
    return nok(code4);
  }
  function whitespaceAfter(code4) {
    return ok3(code4);
  }
}
function tokenizeDefinitionContinuation(effects, ok3, nok) {
  return effects.check(blankLine, ok3, effects.attempt(indent, ok3, nok));
}
function gfmFootnoteDefinitionEnd(effects) {
  effects.exit("gfmFootnoteDefinition");
}
function tokenizeIndent2(effects, ok3, nok) {
  const self2 = this;
  return factorySpace(
    effects,
    afterPrefix,
    "gfmFootnoteDefinitionIndent",
    constants.tabSize + 1
  );
  function afterPrefix(code4) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === constants.tabSize ? ok3(code4) : nok(code4);
  }
}

// node_modules/micromark-extension-gfm-footnote/dev/lib/html.js
var own7 = {}.hasOwnProperty;

// node_modules/micromark-extension-gfm-strikethrough/dev/lib/syntax.js
function gfmStrikethrough(options) {
  const options_ = options || {};
  let single = options_.singleTilde;
  const tokenizer = {
    name: "strikethrough",
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    text: { [codes.tilde]: tokenizer },
    insideSpan: { null: [tokenizer] },
    attentionMarkers: { null: [codes.tilde] }
  };
  function resolveAllStrikethrough(events, context) {
    let index4 = -1;
    while (++index4 < events.length) {
      if (events[index4][0] === "enter" && events[index4][1].type === "strikethroughSequenceTemporary" && events[index4][1]._close) {
        let open2 = index4;
        while (open2--) {
          if (events[open2][0] === "exit" && events[open2][1].type === "strikethroughSequenceTemporary" && events[open2][1]._open && // If the sizes are the same:
          events[index4][1].end.offset - events[index4][1].start.offset === events[open2][1].end.offset - events[open2][1].start.offset) {
            events[index4][1].type = "strikethroughSequence";
            events[open2][1].type = "strikethroughSequence";
            const strikethrough2 = {
              type: "strikethrough",
              start: Object.assign({}, events[open2][1].start),
              end: Object.assign({}, events[index4][1].end)
            };
            const text10 = {
              type: "strikethroughText",
              start: Object.assign({}, events[open2][1].end),
              end: Object.assign({}, events[index4][1].start)
            };
            const nextEvents = [
              ["enter", strikethrough2, context],
              ["enter", events[open2][1], context],
              ["exit", events[open2][1], context],
              ["enter", text10, context]
            ];
            const insideSpan2 = context.parser.constructs.insideSpan.null;
            if (insideSpan2) {
              splice(
                nextEvents,
                nextEvents.length,
                0,
                resolveAll(insideSpan2, events.slice(open2 + 1, index4), context)
              );
            }
            splice(nextEvents, nextEvents.length, 0, [
              ["exit", text10, context],
              ["enter", events[index4][1], context],
              ["exit", events[index4][1], context],
              ["exit", strikethrough2, context]
            ]);
            splice(events, open2 - 1, index4 - open2 + 3, nextEvents);
            index4 = open2 + nextEvents.length - 2;
            break;
          }
        }
      }
    }
    index4 = -1;
    while (++index4 < events.length) {
      if (events[index4][1].type === "strikethroughSequenceTemporary") {
        events[index4][1].type = types.data;
      }
    }
    return events;
  }
  function tokenizeStrikethrough(effects, ok3, nok) {
    const previous4 = this.previous;
    const events = this.events;
    let size4 = 0;
    return start2;
    function start2(code4) {
      ok(code4 === codes.tilde, "expected `~`");
      if (previous4 === codes.tilde && events[events.length - 1][1].type !== types.characterEscape) {
        return nok(code4);
      }
      effects.enter("strikethroughSequenceTemporary");
      return more(code4);
    }
    function more(code4) {
      const before = classifyCharacter(previous4);
      if (code4 === codes.tilde) {
        if (size4 > 1) return nok(code4);
        effects.consume(code4);
        size4++;
        return more;
      }
      if (size4 < 2 && !single) return nok(code4);
      const token = effects.exit("strikethroughSequenceTemporary");
      const after = classifyCharacter(code4);
      token._open = !after || after === constants.attentionSideAfter && Boolean(before);
      token._close = !before || before === constants.attentionSideAfter && Boolean(after);
      return ok3(code4);
    }
  }
}

// node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js
var EditMap = class {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(index4, remove, add) {
    addImplementation(this, index4, remove, add);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(events) {
    this.map.sort(function(a28, b14) {
      return a28[0] - b14[0];
    });
    if (this.map.length === 0) {
      return;
    }
    let index4 = this.map.length;
    const vecs = [];
    while (index4 > 0) {
      index4 -= 1;
      vecs.push(
        events.slice(this.map[index4][0] + this.map[index4][1]),
        this.map[index4][2]
      );
      events.length = this.map[index4][0];
    }
    vecs.push(events.slice());
    events.length = 0;
    let slice = vecs.pop();
    while (slice) {
      for (const element5 of slice) {
        events.push(element5);
      }
      slice = vecs.pop();
    }
    this.map.length = 0;
  }
};
function addImplementation(editMap, at2, remove, add) {
  let index4 = 0;
  if (remove === 0 && add.length === 0) {
    return;
  }
  while (index4 < editMap.map.length) {
    if (editMap.map[index4][0] === at2) {
      editMap.map[index4][1] += remove;
      editMap.map[index4][2].push(...add);
      return;
    }
    index4 += 1;
  }
  editMap.map.push([at2, remove, add]);
}

// node_modules/micromark-extension-gfm-table/dev/lib/infer.js
function gfmTableAlign(events, index4) {
  ok(events[index4][1].type === "table", "expected table");
  let inDelimiterRow = false;
  const align = [];
  while (index4 < events.length) {
    const event = events[index4];
    if (inDelimiterRow) {
      if (event[0] === "enter") {
        if (event[1].type === "tableContent") {
          align.push(
            events[index4 + 1][1].type === "tableDelimiterMarker" ? "left" : "none"
          );
        }
      } else if (event[1].type === "tableContent") {
        if (events[index4 - 1][1].type === "tableDelimiterMarker") {
          const alignIndex = align.length - 1;
          align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
        }
      } else if (event[1].type === "tableDelimiterRow") {
        break;
      }
    } else if (event[0] === "enter" && event[1].type === "tableDelimiterRow") {
      inDelimiterRow = true;
    }
    index4 += 1;
  }
  return align;
}

// node_modules/micromark-extension-gfm-table/dev/lib/syntax.js
function gfmTable() {
  return {
    flow: {
      null: { name: "table", tokenize: tokenizeTable, resolveAll: resolveTable }
    }
  };
}
function tokenizeTable(effects, ok3, nok) {
  const self2 = this;
  let size4 = 0;
  let sizeB = 0;
  let seen;
  return start2;
  function start2(code4) {
    let index4 = self2.events.length - 1;
    while (index4 > -1) {
      const type = self2.events[index4][1].type;
      if (type === types.lineEnding || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      type === types.linePrefix)
        index4--;
      else break;
    }
    const tail = index4 > -1 ? self2.events[index4][1].type : null;
    const next2 = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
    if (next2 === bodyRowStart && self2.parser.lazy[self2.now().line]) {
      return nok(code4);
    }
    return next2(code4);
  }
  function headRowBefore(code4) {
    effects.enter("tableHead");
    effects.enter("tableRow");
    return headRowStart(code4);
  }
  function headRowStart(code4) {
    if (code4 === codes.verticalBar) {
      return headRowBreak(code4);
    }
    seen = true;
    sizeB += 1;
    return headRowBreak(code4);
  }
  function headRowBreak(code4) {
    if (code4 === codes.eof) {
      return nok(code4);
    }
    if (markdownLineEnding(code4)) {
      if (sizeB > 1) {
        sizeB = 0;
        self2.interrupt = true;
        effects.exit("tableRow");
        effects.enter(types.lineEnding);
        effects.consume(code4);
        effects.exit(types.lineEnding);
        return headDelimiterStart;
      }
      return nok(code4);
    }
    if (markdownSpace(code4)) {
      return factorySpace(effects, headRowBreak, types.whitespace)(code4);
    }
    sizeB += 1;
    if (seen) {
      seen = false;
      size4 += 1;
    }
    if (code4 === codes.verticalBar) {
      effects.enter("tableCellDivider");
      effects.consume(code4);
      effects.exit("tableCellDivider");
      seen = true;
      return headRowBreak;
    }
    effects.enter(types.data);
    return headRowData(code4);
  }
  function headRowData(code4) {
    if (code4 === codes.eof || code4 === codes.verticalBar || markdownLineEndingOrSpace(code4)) {
      effects.exit(types.data);
      return headRowBreak(code4);
    }
    effects.consume(code4);
    return code4 === codes.backslash ? headRowEscape : headRowData;
  }
  function headRowEscape(code4) {
    if (code4 === codes.backslash || code4 === codes.verticalBar) {
      effects.consume(code4);
      return headRowData;
    }
    return headRowData(code4);
  }
  function headDelimiterStart(code4) {
    self2.interrupt = false;
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code4);
    }
    effects.enter("tableDelimiterRow");
    seen = false;
    if (markdownSpace(code4)) {
      ok(self2.parser.constructs.disable.null, "expected `disabled.null`");
      return factorySpace(
        effects,
        headDelimiterBefore,
        types.linePrefix,
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
      )(code4);
    }
    return headDelimiterBefore(code4);
  }
  function headDelimiterBefore(code4) {
    if (code4 === codes.dash || code4 === codes.colon) {
      return headDelimiterValueBefore(code4);
    }
    if (code4 === codes.verticalBar) {
      seen = true;
      effects.enter("tableCellDivider");
      effects.consume(code4);
      effects.exit("tableCellDivider");
      return headDelimiterCellBefore;
    }
    return headDelimiterNok(code4);
  }
  function headDelimiterCellBefore(code4) {
    if (markdownSpace(code4)) {
      return factorySpace(
        effects,
        headDelimiterValueBefore,
        types.whitespace
      )(code4);
    }
    return headDelimiterValueBefore(code4);
  }
  function headDelimiterValueBefore(code4) {
    if (code4 === codes.colon) {
      sizeB += 1;
      seen = true;
      effects.enter("tableDelimiterMarker");
      effects.consume(code4);
      effects.exit("tableDelimiterMarker");
      return headDelimiterLeftAlignmentAfter;
    }
    if (code4 === codes.dash) {
      sizeB += 1;
      return headDelimiterLeftAlignmentAfter(code4);
    }
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      return headDelimiterCellAfter(code4);
    }
    return headDelimiterNok(code4);
  }
  function headDelimiterLeftAlignmentAfter(code4) {
    if (code4 === codes.dash) {
      effects.enter("tableDelimiterFiller");
      return headDelimiterFiller(code4);
    }
    return headDelimiterNok(code4);
  }
  function headDelimiterFiller(code4) {
    if (code4 === codes.dash) {
      effects.consume(code4);
      return headDelimiterFiller;
    }
    if (code4 === codes.colon) {
      seen = true;
      effects.exit("tableDelimiterFiller");
      effects.enter("tableDelimiterMarker");
      effects.consume(code4);
      effects.exit("tableDelimiterMarker");
      return headDelimiterRightAlignmentAfter;
    }
    effects.exit("tableDelimiterFiller");
    return headDelimiterRightAlignmentAfter(code4);
  }
  function headDelimiterRightAlignmentAfter(code4) {
    if (markdownSpace(code4)) {
      return factorySpace(
        effects,
        headDelimiterCellAfter,
        types.whitespace
      )(code4);
    }
    return headDelimiterCellAfter(code4);
  }
  function headDelimiterCellAfter(code4) {
    if (code4 === codes.verticalBar) {
      return headDelimiterBefore(code4);
    }
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      if (!seen || size4 !== sizeB) {
        return headDelimiterNok(code4);
      }
      effects.exit("tableDelimiterRow");
      effects.exit("tableHead");
      return ok3(code4);
    }
    return headDelimiterNok(code4);
  }
  function headDelimiterNok(code4) {
    return nok(code4);
  }
  function bodyRowStart(code4) {
    effects.enter("tableRow");
    return bodyRowBreak(code4);
  }
  function bodyRowBreak(code4) {
    if (code4 === codes.verticalBar) {
      effects.enter("tableCellDivider");
      effects.consume(code4);
      effects.exit("tableCellDivider");
      return bodyRowBreak;
    }
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit("tableRow");
      return ok3(code4);
    }
    if (markdownSpace(code4)) {
      return factorySpace(effects, bodyRowBreak, types.whitespace)(code4);
    }
    effects.enter(types.data);
    return bodyRowData(code4);
  }
  function bodyRowData(code4) {
    if (code4 === codes.eof || code4 === codes.verticalBar || markdownLineEndingOrSpace(code4)) {
      effects.exit(types.data);
      return bodyRowBreak(code4);
    }
    effects.consume(code4);
    return code4 === codes.backslash ? bodyRowEscape : bodyRowData;
  }
  function bodyRowEscape(code4) {
    if (code4 === codes.backslash || code4 === codes.verticalBar) {
      effects.consume(code4);
      return bodyRowData;
    }
    return bodyRowData(code4);
  }
}
function resolveTable(events, context) {
  let index4 = -1;
  let inFirstCellAwaitingPipe = true;
  let rowKind = 0;
  let lastCell = [0, 0, 0, 0];
  let cell = [0, 0, 0, 0];
  let afterHeadAwaitingFirstBodyRow = false;
  let lastTableEnd = 0;
  let currentTable;
  let currentBody;
  let currentCell;
  const map3 = new EditMap();
  while (++index4 < events.length) {
    const event = events[index4];
    const token = event[1];
    if (event[0] === "enter") {
      if (token.type === "tableHead") {
        afterHeadAwaitingFirstBodyRow = false;
        if (lastTableEnd !== 0) {
          ok(currentTable, "there should be a table opening");
          flushTableEnd(map3, context, lastTableEnd, currentTable, currentBody);
          currentBody = void 0;
          lastTableEnd = 0;
        }
        currentTable = {
          type: "table",
          start: Object.assign({}, token.start),
          // Note: correct end is set later.
          end: Object.assign({}, token.end)
        };
        map3.add(index4, 0, [["enter", currentTable, context]]);
      } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
        inFirstCellAwaitingPipe = true;
        currentCell = void 0;
        lastCell = [0, 0, 0, 0];
        cell = [0, index4 + 1, 0, 0];
        if (afterHeadAwaitingFirstBodyRow) {
          afterHeadAwaitingFirstBodyRow = false;
          currentBody = {
            type: "tableBody",
            start: Object.assign({}, token.start),
            // Note: correct end is set later.
            end: Object.assign({}, token.end)
          };
          map3.add(index4, 0, [["enter", currentBody, context]]);
        }
        rowKind = token.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
      } else if (rowKind && (token.type === types.data || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
        inFirstCellAwaitingPipe = false;
        if (cell[2] === 0) {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(
              map3,
              context,
              lastCell,
              rowKind,
              void 0,
              currentCell
            );
            lastCell = [0, 0, 0, 0];
          }
          cell[2] = index4;
        }
      } else if (token.type === "tableCellDivider") {
        if (inFirstCellAwaitingPipe) {
          inFirstCellAwaitingPipe = false;
        } else {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(
              map3,
              context,
              lastCell,
              rowKind,
              void 0,
              currentCell
            );
          }
          lastCell = cell;
          cell = [lastCell[1], index4, 0, 0];
        }
      }
    } else if (token.type === "tableHead") {
      afterHeadAwaitingFirstBodyRow = true;
      lastTableEnd = index4;
    } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
      lastTableEnd = index4;
      if (lastCell[1] !== 0) {
        cell[0] = cell[1];
        currentCell = flushCell(
          map3,
          context,
          lastCell,
          rowKind,
          index4,
          currentCell
        );
      } else if (cell[1] !== 0) {
        currentCell = flushCell(map3, context, cell, rowKind, index4, currentCell);
      }
      rowKind = 0;
    } else if (rowKind && (token.type === types.data || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
      cell[3] = index4;
    }
  }
  if (lastTableEnd !== 0) {
    ok(currentTable, "expected table opening");
    flushTableEnd(map3, context, lastTableEnd, currentTable, currentBody);
  }
  map3.consume(context.events);
  index4 = -1;
  while (++index4 < context.events.length) {
    const event = context.events[index4];
    if (event[0] === "enter" && event[1].type === "table") {
      event[1]._align = gfmTableAlign(context.events, index4);
    }
  }
  return events;
}
function flushCell(map3, context, range, rowKind, rowEnd, previousCell) {
  const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
  const valueName = "tableContent";
  if (range[0] !== 0) {
    ok(previousCell, "expected previous cell enter");
    previousCell.end = Object.assign({}, getPoint(context.events, range[0]));
    map3.add(range[0], 0, [["exit", previousCell, context]]);
  }
  const now = getPoint(context.events, range[1]);
  previousCell = {
    type: groupName,
    start: Object.assign({}, now),
    // Note: correct end is set later.
    end: Object.assign({}, now)
  };
  map3.add(range[1], 0, [["enter", previousCell, context]]);
  if (range[2] !== 0) {
    const relatedStart = getPoint(context.events, range[2]);
    const relatedEnd = getPoint(context.events, range[3]);
    const valueToken = {
      type: valueName,
      start: Object.assign({}, relatedStart),
      end: Object.assign({}, relatedEnd)
    };
    map3.add(range[2], 0, [["enter", valueToken, context]]);
    ok(range[3] !== 0);
    if (rowKind !== 2) {
      const start2 = context.events[range[2]];
      const end = context.events[range[3]];
      start2[1].end = Object.assign({}, end[1].end);
      start2[1].type = types.chunkText;
      start2[1].contentType = constants.contentTypeText;
      if (range[3] > range[2] + 1) {
        const a28 = range[2] + 1;
        const b14 = range[3] - range[2] - 1;
        map3.add(a28, b14, []);
      }
    }
    map3.add(range[3] + 1, 0, [["exit", valueToken, context]]);
  }
  if (rowEnd !== void 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
    map3.add(rowEnd, 0, [["exit", previousCell, context]]);
    previousCell = void 0;
  }
  return previousCell;
}
function flushTableEnd(map3, context, index4, table2, tableBody) {
  const exits = [];
  const related = getPoint(context.events, index4);
  if (tableBody) {
    tableBody.end = Object.assign({}, related);
    exits.push(["exit", tableBody, context]);
  }
  table2.end = Object.assign({}, related);
  exits.push(["exit", table2, context]);
  map3.add(index4 + 1, 0, exits);
}
function getPoint(events, index4) {
  const event = events[index4];
  const side = event[0] === "enter" ? "start" : "end";
  return event[1][side];
}

// node_modules/micromark-extension-gfm-tagfilter/lib/index.js
var reFlow = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|title|textarea|xmp)(?=[\t\n\f\r />])/gi;
var reText = new RegExp("^" + reFlow.source, "i");

// node_modules/micromark-extension-gfm-task-list-item/dev/lib/syntax.js
var tasklistCheck = { name: "tasklistCheck", tokenize: tokenizeTasklistCheck };
function gfmTaskListItem() {
  return {
    text: { [codes.leftSquareBracket]: tasklistCheck }
  };
}
function tokenizeTasklistCheck(effects, ok3, nok) {
  const self2 = this;
  return open2;
  function open2(code4) {
    ok(code4 === codes.leftSquareBracket, "expected `[`");
    if (
      // Exit if theres stuff before.
      self2.previous !== codes.eof || // Exit if not in the first content that is the first child of a list
      // item.
      !self2._gfmTasklistFirstContentOfListItem
    ) {
      return nok(code4);
    }
    effects.enter("taskListCheck");
    effects.enter("taskListCheckMarker");
    effects.consume(code4);
    effects.exit("taskListCheckMarker");
    return inside;
  }
  function inside(code4) {
    if (markdownLineEndingOrSpace(code4)) {
      effects.enter("taskListCheckValueUnchecked");
      effects.consume(code4);
      effects.exit("taskListCheckValueUnchecked");
      return close2;
    }
    if (code4 === codes.uppercaseX || code4 === codes.lowercaseX) {
      effects.enter("taskListCheckValueChecked");
      effects.consume(code4);
      effects.exit("taskListCheckValueChecked");
      return close2;
    }
    return nok(code4);
  }
  function close2(code4) {
    if (code4 === codes.rightSquareBracket) {
      effects.enter("taskListCheckMarker");
      effects.consume(code4);
      effects.exit("taskListCheckMarker");
      effects.exit("taskListCheck");
      return after;
    }
    return nok(code4);
  }
  function after(code4) {
    if (markdownLineEnding(code4)) {
      return ok3(code4);
    }
    if (markdownSpace(code4)) {
      return effects.check({ tokenize: spaceThenNonSpace }, ok3, nok)(code4);
    }
    return nok(code4);
  }
}
function spaceThenNonSpace(effects, ok3, nok) {
  return factorySpace(effects, after, types.whitespace);
  function after(code4) {
    return code4 === codes.eof ? nok(code4) : ok3(code4);
  }
}

// node_modules/micromark-extension-gfm/index.js
function gfm(options) {
  return combineExtensions([
    gfmAutolinkLiteral(),
    gfmFootnote(),
    gfmStrikethrough(options),
    gfmTable(),
    gfmTaskListItem()
  ]);
}

// node_modules/remark-gfm/lib/index.js
var emptyOptions4 = {};
function remarkGfm(options) {
  const self2 = (
    /** @type {Processor<Root>} */
    this
  );
  const settings = options || emptyOptions4;
  const data = self2.data();
  const micromarkExtensions = data.micromarkExtensions || (data.micromarkExtensions = []);
  const fromMarkdownExtensions = data.fromMarkdownExtensions || (data.fromMarkdownExtensions = []);
  const toMarkdownExtensions = data.toMarkdownExtensions || (data.toMarkdownExtensions = []);
  micromarkExtensions.push(gfm(settings));
  fromMarkdownExtensions.push(gfmFromMarkdown());
  toMarkdownExtensions.push(gfmToMarkdown(settings));
}

// node_modules/mdast-util-math/lib/index.js
function mathFromMarkdown() {
  return {
    enter: {
      mathFlow: enterMathFlow,
      mathFlowFenceMeta: enterMathFlowMeta,
      mathText: enterMathText
    },
    exit: {
      mathFlow: exitMathFlow,
      mathFlowFence: exitMathFlowFence,
      mathFlowFenceMeta: exitMathFlowMeta,
      mathFlowValue: exitMathData,
      mathText: exitMathText,
      mathTextData: exitMathData
    }
  };
  function enterMathFlow(token) {
    const code4 = {
      type: "element",
      tagName: "code",
      properties: { className: ["language-math", "math-display"] },
      children: []
    };
    this.enter(
      {
        type: "math",
        meta: null,
        value: "",
        data: { hName: "pre", hChildren: [code4] }
      },
      token
    );
  }
  function enterMathFlowMeta() {
    this.buffer();
  }
  function exitMathFlowMeta() {
    const data = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2.type === "math");
    node2.meta = data;
  }
  function exitMathFlowFence() {
    if (this.data.mathFlowInside) return;
    this.buffer();
    this.data.mathFlowInside = true;
  }
  function exitMathFlow(token) {
    const data = this.resume().replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    const node2 = this.stack[this.stack.length - 1];
    ok(node2.type === "math");
    this.exit(token);
    node2.value = data;
    const code4 = (
      /** @type {HastElement} */
      node2.data.hChildren[0]
    );
    ok(code4.type === "element");
    ok(code4.tagName === "code");
    code4.children.push({ type: "text", value: data });
    this.data.mathFlowInside = void 0;
  }
  function enterMathText(token) {
    this.enter(
      {
        type: "inlineMath",
        value: "",
        data: {
          hName: "code",
          hProperties: { className: ["language-math", "math-inline"] },
          hChildren: []
        }
      },
      token
    );
    this.buffer();
  }
  function exitMathText(token) {
    const data = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2.type === "inlineMath");
    this.exit(token);
    node2.value = data;
    const children = (
      /** @type {Array<HastElementContent>} */
      // @ts-expect-error: we defined it in `enterMathFlow`.
      node2.data.hChildren
    );
    children.push({ type: "text", value: data });
  }
  function exitMathData(token) {
    this.config.enter.data.call(this, token);
    this.config.exit.data.call(this, token);
  }
}
function mathToMarkdown(options) {
  let single = (options || {}).singleDollarTextMath;
  if (single === null || single === void 0) {
    single = true;
  }
  inlineMath.peek = inlineMathPeek;
  return {
    unsafe: [
      { character: "\r", inConstruct: "mathFlowMeta" },
      { character: "\n", inConstruct: "mathFlowMeta" },
      {
        character: "$",
        after: single ? void 0 : "\\$",
        inConstruct: "phrasing"
      },
      { character: "$", inConstruct: "mathFlowMeta" },
      { atBreak: true, character: "$", after: "\\$" }
    ],
    handlers: { math: math3, inlineMath }
  };
  function math3(node2, _10, state, info) {
    const raw2 = node2.value || "";
    const tracker = state.createTracker(info);
    const sequence = "$".repeat(Math.max(longestStreak(raw2, "$") + 1, 2));
    const exit3 = state.enter("mathFlow");
    let value = tracker.move(sequence);
    if (node2.meta) {
      const subexit = state.enter("mathFlowMeta");
      value += tracker.move(
        state.safe(node2.meta, {
          after: "\n",
          before: value,
          encode: ["$"],
          ...tracker.current()
        })
      );
      subexit();
    }
    value += tracker.move("\n");
    if (raw2) {
      value += tracker.move(raw2 + "\n");
    }
    value += tracker.move(sequence);
    exit3();
    return value;
  }
  function inlineMath(node2, _10, state) {
    let value = node2.value || "";
    let size4 = 1;
    if (!single) size4++;
    while (new RegExp("(^|[^$])" + "\\$".repeat(size4) + "([^$]|$)").test(value)) {
      size4++;
    }
    const sequence = "$".repeat(size4);
    if (
      // Contains non-space.
      /[^ \r\n]/.test(value) && // Starts with space and ends with space.
      (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || // Starts or ends with dollar.
      /^\$|\$$/.test(value))
    ) {
      value = " " + value + " ";
    }
    let index4 = -1;
    while (++index4 < state.unsafe.length) {
      const pattern = state.unsafe[index4];
      if (!pattern.atBreak) continue;
      const expression = state.compilePattern(pattern);
      let match;
      while (match = expression.exec(value)) {
        let position4 = match.index;
        if (value.codePointAt(position4) === 10 && value.codePointAt(position4 - 1) === 13) {
          position4--;
        }
        value = value.slice(0, position4) + " " + value.slice(match.index + 1);
      }
    }
    return sequence + value + sequence;
  }
  function inlineMathPeek() {
    return "$";
  }
}

// node_modules/micromark-extension-math/dev/lib/math-flow.js
var mathFlow = {
  tokenize: tokenizeMathFenced,
  concrete: true,
  name: "mathFlow"
};
var nonLazyContinuation2 = {
  tokenize: tokenizeNonLazyContinuation2,
  partial: true
};
function tokenizeMathFenced(effects, ok3, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  const initialSize = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let sizeOpen = 0;
  return start2;
  function start2(code4) {
    ok(code4 === codes.dollarSign, "expected `$`");
    effects.enter("mathFlow");
    effects.enter("mathFlowFence");
    effects.enter("mathFlowFenceSequence");
    return sequenceOpen(code4);
  }
  function sequenceOpen(code4) {
    if (code4 === codes.dollarSign) {
      effects.consume(code4);
      sizeOpen++;
      return sequenceOpen;
    }
    if (sizeOpen < 2) {
      return nok(code4);
    }
    effects.exit("mathFlowFenceSequence");
    return factorySpace(effects, metaBefore, types.whitespace)(code4);
  }
  function metaBefore(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      return metaAfter(code4);
    }
    effects.enter("mathFlowFenceMeta");
    effects.enter(types.chunkString, { contentType: constants.contentTypeString });
    return meta(code4);
  }
  function meta(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit(types.chunkString);
      effects.exit("mathFlowFenceMeta");
      return metaAfter(code4);
    }
    if (code4 === codes.dollarSign) {
      return nok(code4);
    }
    effects.consume(code4);
    return meta;
  }
  function metaAfter(code4) {
    effects.exit("mathFlowFence");
    if (self2.interrupt) {
      return ok3(code4);
    }
    return effects.attempt(
      nonLazyContinuation2,
      beforeNonLazyContinuation,
      after
    )(code4);
  }
  function beforeNonLazyContinuation(code4) {
    return effects.attempt(
      { tokenize: tokenizeClosingFence, partial: true },
      after,
      contentStart
    )(code4);
  }
  function contentStart(code4) {
    return (initialSize ? factorySpace(
      effects,
      beforeContentChunk,
      types.linePrefix,
      initialSize + 1
    ) : beforeContentChunk)(code4);
  }
  function beforeContentChunk(code4) {
    if (code4 === codes.eof) {
      return after(code4);
    }
    if (markdownLineEnding(code4)) {
      return effects.attempt(
        nonLazyContinuation2,
        beforeNonLazyContinuation,
        after
      )(code4);
    }
    effects.enter("mathFlowValue");
    return contentChunk(code4);
  }
  function contentChunk(code4) {
    if (code4 === codes.eof || markdownLineEnding(code4)) {
      effects.exit("mathFlowValue");
      return beforeContentChunk(code4);
    }
    effects.consume(code4);
    return contentChunk;
  }
  function after(code4) {
    effects.exit("mathFlow");
    return ok3(code4);
  }
  function tokenizeClosingFence(effects2, ok4, nok2) {
    let size4 = 0;
    ok(self2.parser.constructs.disable.null, "expected `disable.null`");
    return factorySpace(
      effects2,
      beforeSequenceClose,
      types.linePrefix,
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : constants.tabSize
    );
    function beforeSequenceClose(code4) {
      effects2.enter("mathFlowFence");
      effects2.enter("mathFlowFenceSequence");
      return sequenceClose(code4);
    }
    function sequenceClose(code4) {
      if (code4 === codes.dollarSign) {
        size4++;
        effects2.consume(code4);
        return sequenceClose;
      }
      if (size4 < sizeOpen) {
        return nok2(code4);
      }
      effects2.exit("mathFlowFenceSequence");
      return factorySpace(effects2, afterSequenceClose, types.whitespace)(code4);
    }
    function afterSequenceClose(code4) {
      if (code4 === codes.eof || markdownLineEnding(code4)) {
        effects2.exit("mathFlowFence");
        return ok4(code4);
      }
      return nok2(code4);
    }
  }
}
function tokenizeNonLazyContinuation2(effects, ok3, nok) {
  const self2 = this;
  return start2;
  function start2(code4) {
    if (code4 === null) {
      return ok3(code4);
    }
    ok(markdownLineEnding(code4), "expected eol");
    effects.enter(types.lineEnding);
    effects.consume(code4);
    effects.exit(types.lineEnding);
    return lineStart;
  }
  function lineStart(code4) {
    return self2.parser.lazy[self2.now().line] ? nok(code4) : ok3(code4);
  }
}

// node_modules/micromark-extension-math/dev/lib/math-text.js
function mathText(options) {
  const options_ = options || {};
  let single = options_.singleDollarTextMath;
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    tokenize: tokenizeMathText,
    resolve: resolveMathText,
    previous: previous3,
    name: "mathText"
  };
  function tokenizeMathText(effects, ok3, nok) {
    const self2 = this;
    let sizeOpen = 0;
    let size4;
    let token;
    return start2;
    function start2(code4) {
      ok(code4 === codes.dollarSign, "expected `$`");
      ok(previous3.call(self2, self2.previous), "expected correct previous");
      effects.enter("mathText");
      effects.enter("mathTextSequence");
      return sequenceOpen(code4);
    }
    function sequenceOpen(code4) {
      if (code4 === codes.dollarSign) {
        effects.consume(code4);
        sizeOpen++;
        return sequenceOpen;
      }
      if (sizeOpen < 2 && !single) {
        return nok(code4);
      }
      effects.exit("mathTextSequence");
      return between(code4);
    }
    function between(code4) {
      if (code4 === codes.eof) {
        return nok(code4);
      }
      if (code4 === codes.dollarSign) {
        token = effects.enter("mathTextSequence");
        size4 = 0;
        return sequenceClose(code4);
      }
      if (code4 === codes.space) {
        effects.enter("space");
        effects.consume(code4);
        effects.exit("space");
        return between;
      }
      if (markdownLineEnding(code4)) {
        effects.enter(types.lineEnding);
        effects.consume(code4);
        effects.exit(types.lineEnding);
        return between;
      }
      effects.enter("mathTextData");
      return data(code4);
    }
    function data(code4) {
      if (code4 === codes.eof || code4 === codes.space || code4 === codes.dollarSign || markdownLineEnding(code4)) {
        effects.exit("mathTextData");
        return between(code4);
      }
      effects.consume(code4);
      return data;
    }
    function sequenceClose(code4) {
      if (code4 === codes.dollarSign) {
        effects.consume(code4);
        size4++;
        return sequenceClose;
      }
      if (size4 === sizeOpen) {
        effects.exit("mathTextSequence");
        effects.exit("mathText");
        return ok3(code4);
      }
      token.type = "mathTextData";
      return data(code4);
    }
  }
}
function resolveMathText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index4;
  let enter;
  if ((events[headEnterIndex][1].type === types.lineEnding || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === types.lineEnding || events[tailExitIndex][1].type === "space")) {
    index4 = headEnterIndex;
    while (++index4 < tailExitIndex) {
      if (events[index4][1].type === "mathTextData") {
        events[tailExitIndex][1].type = "mathTextPadding";
        events[headEnterIndex][1].type = "mathTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index4 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index4 <= tailExitIndex) {
    if (enter === void 0) {
      if (index4 !== tailExitIndex && events[index4][1].type !== types.lineEnding) {
        enter = index4;
      }
    } else if (index4 === tailExitIndex || events[index4][1].type === types.lineEnding) {
      events[enter][1].type = "mathTextData";
      if (index4 !== enter + 2) {
        events[enter][1].end = events[index4 - 1][1].end;
        events.splice(enter + 2, index4 - enter - 2);
        tailExitIndex -= index4 - enter - 2;
        index4 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous3(code4) {
  return code4 !== codes.dollarSign || this.events[this.events.length - 1][1].type === types.characterEscape;
}

// node_modules/micromark-extension-math/dev/lib/syntax.js
function math(options) {
  return {
    flow: { [codes.dollarSign]: mathFlow },
    text: { [codes.dollarSign]: mathText(options) }
  };
}

// node_modules/katex/dist/katex.mjs
var SourceLocation = class _SourceLocation {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(lexer, start2, end) {
    this.lexer = void 0;
    this.start = void 0;
    this.end = void 0;
    this.lexer = lexer;
    this.start = start2;
    this.end = end;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(first, second) {
    if (!second) {
      return first && first.loc;
    } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
      return null;
    } else {
      return new _SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
    }
  }
};
var Token = class _Token {
  // don't expand the token
  // used in \noexpand
  constructor(text10, loc) {
    this.text = void 0;
    this.loc = void 0;
    this.noexpand = void 0;
    this.treatAsRelax = void 0;
    this.text = text10;
    this.loc = loc;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(endToken, text10) {
    return new _Token(text10, SourceLocation.range(this, endToken));
  }
};
var ParseError = class _ParseError {
  // Error start position based on passed-in Token or ParseNode.
  // Length of affected text based on passed-in Token or ParseNode.
  // The underlying error message without any context added.
  constructor(message, token) {
    this.name = void 0;
    this.position = void 0;
    this.length = void 0;
    this.rawMessage = void 0;
    var error2 = "KaTeX parse error: " + message;
    var start2;
    var end;
    var loc = token && token.loc;
    if (loc && loc.start <= loc.end) {
      var input = loc.lexer.input;
      start2 = loc.start;
      end = loc.end;
      if (start2 === input.length) {
        error2 += " at end of input: ";
      } else {
        error2 += " at position " + (start2 + 1) + ": ";
      }
      var underlined = input.slice(start2, end).replace(/[^]/g, "$&");
      var left;
      if (start2 > 15) {
        left = "" + input.slice(start2 - 15, start2);
      } else {
        left = input.slice(0, start2);
      }
      var right;
      if (end + 15 < input.length) {
        right = input.slice(end, end + 15) + "";
      } else {
        right = input.slice(end);
      }
      error2 += left + underlined + right;
    }
    var self2 = new Error(error2);
    self2.name = "ParseError";
    self2.__proto__ = _ParseError.prototype;
    self2.position = start2;
    if (start2 != null && end != null) {
      self2.length = end - start2;
    }
    self2.rawMessage = message;
    return self2;
  }
};
ParseError.prototype.__proto__ = Error.prototype;
var deflt = function deflt2(setting, defaultIfUndefined) {
  return setting === void 0 ? defaultIfUndefined : setting;
};
var uppercase = /([A-Z])/g;
var hyphenate = function hyphenate2(str) {
  return str.replace(uppercase, "-$1").toLowerCase();
};
var ESCAPE_LOOKUP = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
};
var ESCAPE_REGEX = /[&><"']/g;
function escape(text10) {
  return String(text10).replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
}
var getBaseElem = function getBaseElem2(group) {
  if (group.type === "ordgroup") {
    if (group.body.length === 1) {
      return getBaseElem2(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "color") {
    if (group.body.length === 1) {
      return getBaseElem2(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "font") {
    return getBaseElem2(group.body);
  } else {
    return group;
  }
};
var isCharacterBox = function isCharacterBox2(group) {
  var baseElem = getBaseElem(group);
  return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
};
var assert2 = function assert3(value) {
  if (!value) {
    throw new Error("Expected non-null, but got " + String(value));
  }
  return value;
};
var protocolFromUrl = function protocolFromUrl2(url) {
  var protocol = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);
  if (!protocol) {
    return "_relative";
  }
  if (protocol[2] !== ":") {
    return null;
  }
  if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(protocol[1])) {
    return null;
  }
  return protocol[1].toLowerCase();
};
var utils = {
  deflt,
  escape,
  hyphenate,
  getBaseElem,
  isCharacterBox,
  protocolFromUrl
};
var SETTINGS_SCHEMA = {
  displayMode: {
    type: "boolean",
    description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
    cli: "-d, --display-mode"
  },
  output: {
    type: {
      enum: ["htmlAndMathml", "html", "mathml"]
    },
    description: "Determines the markup language of the output.",
    cli: "-F, --format <type>"
  },
  leqno: {
    type: "boolean",
    description: "Render display math in leqno style (left-justified tags)."
  },
  fleqn: {
    type: "boolean",
    description: "Render display math flush left."
  },
  throwOnError: {
    type: "boolean",
    default: true,
    cli: "-t, --no-throw-on-error",
    cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
  },
  errorColor: {
    type: "string",
    default: "#cc0000",
    cli: "-c, --error-color <color>",
    cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
    cliProcessor: (color2) => "#" + color2
  },
  macros: {
    type: "object",
    cli: "-m, --macro <def>",
    cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
    cliDefault: [],
    cliProcessor: (def, defs) => {
      defs.push(def);
      return defs;
    }
  },
  minRuleThickness: {
    type: "number",
    description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
    processor: (t14) => Math.max(0, t14),
    cli: "--min-rule-thickness <size>",
    cliProcessor: parseFloat
  },
  colorIsTextColor: {
    type: "boolean",
    description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
    cli: "-b, --color-is-text-color"
  },
  strict: {
    type: [{
      enum: ["warn", "ignore", "error"]
    }, "boolean", "function"],
    description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
    cli: "-S, --strict",
    cliDefault: false
  },
  trust: {
    type: ["boolean", "function"],
    description: "Trust the input, enabling all HTML features such as \\url.",
    cli: "-T, --trust"
  },
  maxSize: {
    type: "number",
    default: Infinity,
    description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
    processor: (s21) => Math.max(0, s21),
    cli: "-s, --max-size <n>",
    cliProcessor: parseInt
  },
  maxExpand: {
    type: "number",
    default: 1e3,
    description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
    processor: (n17) => Math.max(0, n17),
    cli: "-e, --max-expand <n>",
    cliProcessor: (n17) => n17 === "Infinity" ? Infinity : parseInt(n17)
  },
  globalGroup: {
    type: "boolean",
    cli: false
  }
};
function getDefaultValue(schema) {
  if (schema.default) {
    return schema.default;
  }
  var type = schema.type;
  var defaultType = Array.isArray(type) ? type[0] : type;
  if (typeof defaultType !== "string") {
    return defaultType.enum[0];
  }
  switch (defaultType) {
    case "boolean":
      return false;
    case "string":
      return "";
    case "number":
      return 0;
    case "object":
      return {};
  }
}
var Settings = class {
  constructor(options) {
    this.displayMode = void 0;
    this.output = void 0;
    this.leqno = void 0;
    this.fleqn = void 0;
    this.throwOnError = void 0;
    this.errorColor = void 0;
    this.macros = void 0;
    this.minRuleThickness = void 0;
    this.colorIsTextColor = void 0;
    this.strict = void 0;
    this.trust = void 0;
    this.maxSize = void 0;
    this.maxExpand = void 0;
    this.globalGroup = void 0;
    options = options || {};
    for (var prop in SETTINGS_SCHEMA) {
      if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {
        var schema = SETTINGS_SCHEMA[prop];
        this[prop] = options[prop] !== void 0 ? schema.processor ? schema.processor(options[prop]) : options[prop] : getDefaultValue(schema);
      }
    }
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */
  reportNonstrict(errorCode, errorMsg, token) {
    var strict = this.strict;
    if (typeof strict === "function") {
      strict = strict(errorCode, errorMsg, token);
    }
    if (!strict || strict === "ignore") {
      return;
    } else if (strict === true || strict === "error") {
      throw new ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
    } else if (strict === "warn") {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
    } else {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */
  useStrictBehavior(errorCode, errorMsg, token) {
    var strict = this.strict;
    if (typeof strict === "function") {
      try {
        strict = strict(errorCode, errorMsg, token);
      } catch (error2) {
        strict = "error";
      }
    }
    if (!strict || strict === "ignore") {
      return false;
    } else if (strict === true || strict === "error") {
      return true;
    } else if (strict === "warn") {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
      return false;
    } else {
      typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
      return false;
    }
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(context) {
    if (context.url && !context.protocol) {
      var protocol = utils.protocolFromUrl(context.url);
      if (protocol == null) {
        return false;
      }
      context.protocol = protocol;
    }
    var trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
    return Boolean(trust);
  }
};
var Style = class {
  constructor(id, size4, cramped) {
    this.id = void 0;
    this.size = void 0;
    this.cramped = void 0;
    this.id = id;
    this.size = size4;
    this.cramped = cramped;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */
  sup() {
    return styles[sup[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */
  sub() {
    return styles[sub[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */
  fracNum() {
    return styles[fracNum[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */
  fracDen() {
    return styles[fracDen[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */
  cramp() {
    return styles[cramp[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */
  text() {
    return styles[text$1[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */
  isTight() {
    return this.size >= 2;
  }
};
var D12 = 0;
var Dc = 1;
var T10 = 2;
var Tc = 3;
var S10 = 4;
var Sc = 5;
var SS = 6;
var SSc = 7;
var styles = [new Style(D12, 0, false), new Style(Dc, 0, true), new Style(T10, 1, false), new Style(Tc, 1, true), new Style(S10, 2, false), new Style(Sc, 2, true), new Style(SS, 3, false), new Style(SSc, 3, true)];
var sup = [S10, Sc, S10, Sc, SS, SSc, SS, SSc];
var sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
var fracNum = [T10, Tc, S10, Sc, SS, SSc, SS, SSc];
var fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
var cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
var text$1 = [D12, Dc, T10, Tc, T10, Tc, T10, Tc];
var Style$1 = {
  DISPLAY: styles[D12],
  TEXT: styles[T10],
  SCRIPT: styles[S10],
  SCRIPTSCRIPT: styles[SS]
};
var scriptData = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: "latin",
  blocks: [
    [256, 591],
    // Latin Extended-A and Latin Extended-B
    [768, 879]
    // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: "cyrillic",
  blocks: [[1024, 1279]]
}, {
  // Armenian
  name: "armenian",
  blocks: [[1328, 1423]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900097F)
  // Bengali (098009FF)
  // Gurmukhi (0A000A7F)
  // Gujarati (0A800AFF)
  // Oriya (0B000B7F)
  // Tamil (0B800BFF)
  // Telugu (0C000C7F)
  // Kannada (0C800CFF)
  // Malayalam (0D000D7F)
  // Sinhala (0D800DFF)
  // Thai (0E000E7F)
  // Lao (0E800EFF)
  // Tibetan (0F000FFF)
  // Myanmar (1000109F)
  name: "brahmic",
  blocks: [[2304, 4255]]
}, {
  name: "georgian",
  blocks: [[4256, 4351]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [
    [12288, 12543],
    // CJK symbols and punctuation, Hiragana, Katakana
    [19968, 40879],
    // CJK ideograms
    [65280, 65376]
    // Fullwidth punctuation
    // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: "hangul",
  blocks: [[44032, 55215]]
}];
function scriptFromCodepoint(codepoint) {
  for (var i16 = 0; i16 < scriptData.length; i16++) {
    var script = scriptData[i16];
    for (var _i = 0; _i < script.blocks.length; _i++) {
      var block = script.blocks[_i];
      if (codepoint >= block[0] && codepoint <= block[1]) {
        return script.name;
      }
    }
  }
  return null;
}
var allBlocks = [];
scriptData.forEach((s21) => s21.blocks.forEach((b14) => allBlocks.push(...b14)));
function supportedCodepoint(codepoint) {
  for (var i16 = 0; i16 < allBlocks.length; i16 += 2) {
    if (codepoint >= allBlocks[i16] && codepoint <= allBlocks[i16 + 1]) {
      return true;
    }
  }
  return false;
}
var hLinePad = 80;
var sqrtMain = function sqrtMain2(extraVinculum, hLinePad2) {
  return "M95," + (622 + extraVinculum + hLinePad2) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraVinculum / 2.075 + " -" + extraVinculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraVinculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize1 = function sqrtSize12(extraVinculum, hLinePad2) {
  return "M263," + (601 + extraVinculum + hLinePad2) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraVinculum / 2.084 + " -" + extraVinculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraVinculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize2 = function sqrtSize22(extraVinculum, hLinePad2) {
  return "M983 " + (10 + extraVinculum + hLinePad2) + "\nl" + extraVinculum / 3.13 + " -" + extraVinculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraVinculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize3 = function sqrtSize32(extraVinculum, hLinePad2) {
  return "M424," + (2398 + extraVinculum + hLinePad2) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraVinculum / 4.223 + " -" + extraVinculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraVinculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraVinculum) + " " + hLinePad2 + "\nh400000v" + (40 + extraVinculum) + "h-400000z";
};
var sqrtSize4 = function sqrtSize42(extraVinculum, hLinePad2) {
  return "M473," + (2713 + extraVinculum + hLinePad2) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraVinculum / 5.298 + " -" + extraVinculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraVinculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "H1017.7z";
};
var phasePath = function phasePath2(y10) {
  var x10 = y10 / 2;
  return "M400000 " + y10 + " H0 L" + x10 + " 0 l65 45 L145 " + (y10 - 80) + " H400000z";
};
var sqrtTall = function sqrtTall2(extraVinculum, hLinePad2, viewBoxHeight) {
  var vertSegment = viewBoxHeight - 54 - hLinePad2 - extraVinculum;
  return "M702 " + (extraVinculum + hLinePad2) + "H400000" + (40 + extraVinculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad2 + "H400000v" + (40 + extraVinculum) + "H742z";
};
var sqrtPath = function sqrtPath2(size4, extraVinculum, viewBoxHeight) {
  extraVinculum = 1e3 * extraVinculum;
  var path3 = "";
  switch (size4) {
    case "sqrtMain":
      path3 = sqrtMain(extraVinculum, hLinePad);
      break;
    case "sqrtSize1":
      path3 = sqrtSize1(extraVinculum, hLinePad);
      break;
    case "sqrtSize2":
      path3 = sqrtSize2(extraVinculum, hLinePad);
      break;
    case "sqrtSize3":
      path3 = sqrtSize3(extraVinculum, hLinePad);
      break;
    case "sqrtSize4":
      path3 = sqrtSize4(extraVinculum, hLinePad);
      break;
    case "sqrtTall":
      path3 = sqrtTall(extraVinculum, hLinePad, viewBoxHeight);
  }
  return path3;
};
var innerPath = function innerPath2(name2, height) {
  switch (name2) {
    case "":
      return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";
    case "":
      return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";
    case "":
      return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");
    case "":
      return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";
    case "":
      return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";
    case "":
      return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";
    case "":
      return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";
    case "":
      return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";
    case "":
      return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");
    default:
      return "";
  }
};
var path2 = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
  leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
  leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
  leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
  leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
  leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
  leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
  leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
  longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
  midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
  midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
  oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
  oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
  oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
  oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
  rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
  rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
  rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
  rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
  rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
  rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
  rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
  rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
  rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
  righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
  rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
  rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
  twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
  // ditto tilde2, tilde3, & tilde4
  tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
  tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
  tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
  // ditto widehat2, widehat3, & widehat4
  widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
  // widecheck paths are all inverted versions of widehat
  widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
  widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
  rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
  shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
  shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
};
var tallDelim = function tallDelim2(label, midHeight) {
  switch (label) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v" + midHeight + " v1759 h84z";
    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v" + midHeight + " v1759 h84z";
    case "vert":
      return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z";
    case "doublevert":
      return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z\nM367 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v" + midHeight + " v585 h43z";
    case "lfloor":
      return "M319 602 V0 H403 V602 v" + midHeight + " v1715 h263 v84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
    case "rfloor":
      return "M319 602 V0 H403 V602 v" + midHeight + " v1799 H0 v-84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v602 h84z\nM403 1759 V0 H319 V1759 v" + midHeight + " v602 h84z";
    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v602 h84z\nM347 1759 V0 h-84 V1759 v" + midHeight + " v602 h84z";
    case "lparen":
      return "M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0," + (midHeight + 84) + "c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-" + (midHeight + 92) + "c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z";
    case "rparen":
      return "M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0," + (midHeight + 9) + "\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-" + (midHeight + 144) + "c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z";
    default:
      throw new Error("Unknown stretchy delimiter.");
  }
};
var DocumentFragment = class {
  // Never used; needed for satisfying interface.
  constructor(children) {
    this.children = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    this.children = children;
    this.classes = [];
    this.height = 0;
    this.depth = 0;
    this.maxFontSize = 0;
    this.style = {};
  }
  hasClass(className) {
    return this.classes.includes(className);
  }
  /** Convert the fragment into a node. */
  toNode() {
    var frag = document.createDocumentFragment();
    for (var i16 = 0; i16 < this.children.length; i16++) {
      frag.appendChild(this.children[i16].toNode());
    }
    return frag;
  }
  /** Convert the fragment into HTML markup. */
  toMarkup() {
    var markup = "";
    for (var i16 = 0; i16 < this.children.length; i16++) {
      markup += this.children[i16].toMarkup();
    }
    return markup;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    var toText = (child) => child.toText();
    return this.children.map(toText).join("");
  }
};
var fontMetricsData = {
  "AMS-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.68889, 0, 0, 0.72222],
    "66": [0, 0.68889, 0, 0, 0.66667],
    "67": [0, 0.68889, 0, 0, 0.72222],
    "68": [0, 0.68889, 0, 0, 0.72222],
    "69": [0, 0.68889, 0, 0, 0.66667],
    "70": [0, 0.68889, 0, 0, 0.61111],
    "71": [0, 0.68889, 0, 0, 0.77778],
    "72": [0, 0.68889, 0, 0, 0.77778],
    "73": [0, 0.68889, 0, 0, 0.38889],
    "74": [0.16667, 0.68889, 0, 0, 0.5],
    "75": [0, 0.68889, 0, 0, 0.77778],
    "76": [0, 0.68889, 0, 0, 0.66667],
    "77": [0, 0.68889, 0, 0, 0.94445],
    "78": [0, 0.68889, 0, 0, 0.72222],
    "79": [0.16667, 0.68889, 0, 0, 0.77778],
    "80": [0, 0.68889, 0, 0, 0.61111],
    "81": [0.16667, 0.68889, 0, 0, 0.77778],
    "82": [0, 0.68889, 0, 0, 0.72222],
    "83": [0, 0.68889, 0, 0, 0.55556],
    "84": [0, 0.68889, 0, 0, 0.66667],
    "85": [0, 0.68889, 0, 0, 0.72222],
    "86": [0, 0.68889, 0, 0, 0.72222],
    "87": [0, 0.68889, 0, 0, 1],
    "88": [0, 0.68889, 0, 0, 0.72222],
    "89": [0, 0.68889, 0, 0, 0.72222],
    "90": [0, 0.68889, 0, 0, 0.66667],
    "107": [0, 0.68889, 0, 0, 0.55556],
    "160": [0, 0, 0, 0, 0.25],
    "165": [0, 0.675, 0.025, 0, 0.75],
    "174": [0.15559, 0.69224, 0, 0, 0.94666],
    "240": [0, 0.68889, 0, 0, 0.55556],
    "295": [0, 0.68889, 0, 0, 0.54028],
    "710": [0, 0.825, 0, 0, 2.33334],
    "732": [0, 0.9, 0, 0, 2.33334],
    "770": [0, 0.825, 0, 0, 2.33334],
    "771": [0, 0.9, 0, 0, 2.33334],
    "989": [0.08167, 0.58167, 0, 0, 0.77778],
    "1008": [0, 0.43056, 0.04028, 0, 0.66667],
    "8245": [0, 0.54986, 0, 0, 0.275],
    "8463": [0, 0.68889, 0, 0, 0.54028],
    "8487": [0, 0.68889, 0, 0, 0.72222],
    "8498": [0, 0.68889, 0, 0, 0.55556],
    "8502": [0, 0.68889, 0, 0, 0.66667],
    "8503": [0, 0.68889, 0, 0, 0.44445],
    "8504": [0, 0.68889, 0, 0, 0.66667],
    "8513": [0, 0.68889, 0, 0, 0.63889],
    "8592": [-0.03598, 0.46402, 0, 0, 0.5],
    "8594": [-0.03598, 0.46402, 0, 0, 0.5],
    "8602": [-0.13313, 0.36687, 0, 0, 1],
    "8603": [-0.13313, 0.36687, 0, 0, 1],
    "8606": [0.01354, 0.52239, 0, 0, 1],
    "8608": [0.01354, 0.52239, 0, 0, 1],
    "8610": [0.01354, 0.52239, 0, 0, 1.11111],
    "8611": [0.01354, 0.52239, 0, 0, 1.11111],
    "8619": [0, 0.54986, 0, 0, 1],
    "8620": [0, 0.54986, 0, 0, 1],
    "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
    "8622": [-0.13313, 0.36687, 0, 0, 1],
    "8624": [0, 0.69224, 0, 0, 0.5],
    "8625": [0, 0.69224, 0, 0, 0.5],
    "8630": [0, 0.43056, 0, 0, 1],
    "8631": [0, 0.43056, 0, 0, 1],
    "8634": [0.08198, 0.58198, 0, 0, 0.77778],
    "8635": [0.08198, 0.58198, 0, 0, 0.77778],
    "8638": [0.19444, 0.69224, 0, 0, 0.41667],
    "8639": [0.19444, 0.69224, 0, 0, 0.41667],
    "8642": [0.19444, 0.69224, 0, 0, 0.41667],
    "8643": [0.19444, 0.69224, 0, 0, 0.41667],
    "8644": [0.1808, 0.675, 0, 0, 1],
    "8646": [0.1808, 0.675, 0, 0, 1],
    "8647": [0.1808, 0.675, 0, 0, 1],
    "8648": [0.19444, 0.69224, 0, 0, 0.83334],
    "8649": [0.1808, 0.675, 0, 0, 1],
    "8650": [0.19444, 0.69224, 0, 0, 0.83334],
    "8651": [0.01354, 0.52239, 0, 0, 1],
    "8652": [0.01354, 0.52239, 0, 0, 1],
    "8653": [-0.13313, 0.36687, 0, 0, 1],
    "8654": [-0.13313, 0.36687, 0, 0, 1],
    "8655": [-0.13313, 0.36687, 0, 0, 1],
    "8666": [0.13667, 0.63667, 0, 0, 1],
    "8667": [0.13667, 0.63667, 0, 0, 1],
    "8669": [-0.13313, 0.37788, 0, 0, 1],
    "8672": [-0.064, 0.437, 0, 0, 1.334],
    "8674": [-0.064, 0.437, 0, 0, 1.334],
    "8705": [0, 0.825, 0, 0, 0.5],
    "8708": [0, 0.68889, 0, 0, 0.55556],
    "8709": [0.08167, 0.58167, 0, 0, 0.77778],
    "8717": [0, 0.43056, 0, 0, 0.42917],
    "8722": [-0.03598, 0.46402, 0, 0, 0.5],
    "8724": [0.08198, 0.69224, 0, 0, 0.77778],
    "8726": [0.08167, 0.58167, 0, 0, 0.77778],
    "8733": [0, 0.69224, 0, 0, 0.77778],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8737": [0, 0.69224, 0, 0, 0.72222],
    "8738": [0.03517, 0.52239, 0, 0, 0.72222],
    "8739": [0.08167, 0.58167, 0, 0, 0.22222],
    "8740": [0.25142, 0.74111, 0, 0, 0.27778],
    "8741": [0.08167, 0.58167, 0, 0, 0.38889],
    "8742": [0.25142, 0.74111, 0, 0, 0.5],
    "8756": [0, 0.69224, 0, 0, 0.66667],
    "8757": [0, 0.69224, 0, 0, 0.66667],
    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
    "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8774": [0.30274, 0.79383, 0, 0, 0.77778],
    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
    "8778": [0.08167, 0.58167, 0, 0, 0.77778],
    "8782": [0.06062, 0.54986, 0, 0, 0.77778],
    "8783": [0.06062, 0.54986, 0, 0, 0.77778],
    "8785": [0.08198, 0.58198, 0, 0, 0.77778],
    "8786": [0.08198, 0.58198, 0, 0, 0.77778],
    "8787": [0.08198, 0.58198, 0, 0, 0.77778],
    "8790": [0, 0.69224, 0, 0, 0.77778],
    "8791": [0.22958, 0.72958, 0, 0, 0.77778],
    "8796": [0.08198, 0.91667, 0, 0, 0.77778],
    "8806": [0.25583, 0.75583, 0, 0, 0.77778],
    "8807": [0.25583, 0.75583, 0, 0, 0.77778],
    "8808": [0.25142, 0.75726, 0, 0, 0.77778],
    "8809": [0.25142, 0.75726, 0, 0, 0.77778],
    "8812": [0.25583, 0.75583, 0, 0, 0.5],
    "8814": [0.20576, 0.70576, 0, 0, 0.77778],
    "8815": [0.20576, 0.70576, 0, 0, 0.77778],
    "8816": [0.30274, 0.79383, 0, 0, 0.77778],
    "8817": [0.30274, 0.79383, 0, 0, 0.77778],
    "8818": [0.22958, 0.72958, 0, 0, 0.77778],
    "8819": [0.22958, 0.72958, 0, 0, 0.77778],
    "8822": [0.1808, 0.675, 0, 0, 0.77778],
    "8823": [0.1808, 0.675, 0, 0, 0.77778],
    "8828": [0.13667, 0.63667, 0, 0, 0.77778],
    "8829": [0.13667, 0.63667, 0, 0, 0.77778],
    "8830": [0.22958, 0.72958, 0, 0, 0.77778],
    "8831": [0.22958, 0.72958, 0, 0, 0.77778],
    "8832": [0.20576, 0.70576, 0, 0, 0.77778],
    "8833": [0.20576, 0.70576, 0, 0, 0.77778],
    "8840": [0.30274, 0.79383, 0, 0, 0.77778],
    "8841": [0.30274, 0.79383, 0, 0, 0.77778],
    "8842": [0.13597, 0.63597, 0, 0, 0.77778],
    "8843": [0.13597, 0.63597, 0, 0, 0.77778],
    "8847": [0.03517, 0.54986, 0, 0, 0.77778],
    "8848": [0.03517, 0.54986, 0, 0, 0.77778],
    "8858": [0.08198, 0.58198, 0, 0, 0.77778],
    "8859": [0.08198, 0.58198, 0, 0, 0.77778],
    "8861": [0.08198, 0.58198, 0, 0, 0.77778],
    "8862": [0, 0.675, 0, 0, 0.77778],
    "8863": [0, 0.675, 0, 0, 0.77778],
    "8864": [0, 0.675, 0, 0, 0.77778],
    "8865": [0, 0.675, 0, 0, 0.77778],
    "8872": [0, 0.69224, 0, 0, 0.61111],
    "8873": [0, 0.69224, 0, 0, 0.72222],
    "8874": [0, 0.69224, 0, 0, 0.88889],
    "8876": [0, 0.68889, 0, 0, 0.61111],
    "8877": [0, 0.68889, 0, 0, 0.61111],
    "8878": [0, 0.68889, 0, 0, 0.72222],
    "8879": [0, 0.68889, 0, 0, 0.72222],
    "8882": [0.03517, 0.54986, 0, 0, 0.77778],
    "8883": [0.03517, 0.54986, 0, 0, 0.77778],
    "8884": [0.13667, 0.63667, 0, 0, 0.77778],
    "8885": [0.13667, 0.63667, 0, 0, 0.77778],
    "8888": [0, 0.54986, 0, 0, 1.11111],
    "8890": [0.19444, 0.43056, 0, 0, 0.55556],
    "8891": [0.19444, 0.69224, 0, 0, 0.61111],
    "8892": [0.19444, 0.69224, 0, 0, 0.61111],
    "8901": [0, 0.54986, 0, 0, 0.27778],
    "8903": [0.08167, 0.58167, 0, 0, 0.77778],
    "8905": [0.08167, 0.58167, 0, 0, 0.77778],
    "8906": [0.08167, 0.58167, 0, 0, 0.77778],
    "8907": [0, 0.69224, 0, 0, 0.77778],
    "8908": [0, 0.69224, 0, 0, 0.77778],
    "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
    "8910": [0, 0.54986, 0, 0, 0.76042],
    "8911": [0, 0.54986, 0, 0, 0.76042],
    "8912": [0.03517, 0.54986, 0, 0, 0.77778],
    "8913": [0.03517, 0.54986, 0, 0, 0.77778],
    "8914": [0, 0.54986, 0, 0, 0.66667],
    "8915": [0, 0.54986, 0, 0, 0.66667],
    "8916": [0, 0.69224, 0, 0, 0.66667],
    "8918": [0.0391, 0.5391, 0, 0, 0.77778],
    "8919": [0.0391, 0.5391, 0, 0, 0.77778],
    "8920": [0.03517, 0.54986, 0, 0, 1.33334],
    "8921": [0.03517, 0.54986, 0, 0, 1.33334],
    "8922": [0.38569, 0.88569, 0, 0, 0.77778],
    "8923": [0.38569, 0.88569, 0, 0, 0.77778],
    "8926": [0.13667, 0.63667, 0, 0, 0.77778],
    "8927": [0.13667, 0.63667, 0, 0, 0.77778],
    "8928": [0.30274, 0.79383, 0, 0, 0.77778],
    "8929": [0.30274, 0.79383, 0, 0, 0.77778],
    "8934": [0.23222, 0.74111, 0, 0, 0.77778],
    "8935": [0.23222, 0.74111, 0, 0, 0.77778],
    "8936": [0.23222, 0.74111, 0, 0, 0.77778],
    "8937": [0.23222, 0.74111, 0, 0, 0.77778],
    "8938": [0.20576, 0.70576, 0, 0, 0.77778],
    "8939": [0.20576, 0.70576, 0, 0, 0.77778],
    "8940": [0.30274, 0.79383, 0, 0, 0.77778],
    "8941": [0.30274, 0.79383, 0, 0, 0.77778],
    "8994": [0.19444, 0.69224, 0, 0, 0.77778],
    "8995": [0.19444, 0.69224, 0, 0, 0.77778],
    "9416": [0.15559, 0.69224, 0, 0, 0.90222],
    "9484": [0, 0.69224, 0, 0, 0.5],
    "9488": [0, 0.69224, 0, 0, 0.5],
    "9492": [0, 0.37788, 0, 0, 0.5],
    "9496": [0, 0.37788, 0, 0, 0.5],
    "9585": [0.19444, 0.68889, 0, 0, 0.88889],
    "9586": [0.19444, 0.74111, 0, 0, 0.88889],
    "9632": [0, 0.675, 0, 0, 0.77778],
    "9633": [0, 0.675, 0, 0, 0.77778],
    "9650": [0, 0.54986, 0, 0, 0.72222],
    "9651": [0, 0.54986, 0, 0, 0.72222],
    "9654": [0.03517, 0.54986, 0, 0, 0.77778],
    "9660": [0, 0.54986, 0, 0, 0.72222],
    "9661": [0, 0.54986, 0, 0, 0.72222],
    "9664": [0.03517, 0.54986, 0, 0, 0.77778],
    "9674": [0.11111, 0.69224, 0, 0, 0.66667],
    "9733": [0.19444, 0.69224, 0, 0, 0.94445],
    "10003": [0, 0.69224, 0, 0, 0.83334],
    "10016": [0, 0.69224, 0, 0, 0.83334],
    "10731": [0.11111, 0.69224, 0, 0, 0.66667],
    "10846": [0.19444, 0.75583, 0, 0, 0.61111],
    "10877": [0.13667, 0.63667, 0, 0, 0.77778],
    "10878": [0.13667, 0.63667, 0, 0, 0.77778],
    "10885": [0.25583, 0.75583, 0, 0, 0.77778],
    "10886": [0.25583, 0.75583, 0, 0, 0.77778],
    "10887": [0.13597, 0.63597, 0, 0, 0.77778],
    "10888": [0.13597, 0.63597, 0, 0, 0.77778],
    "10889": [0.26167, 0.75726, 0, 0, 0.77778],
    "10890": [0.26167, 0.75726, 0, 0, 0.77778],
    "10891": [0.48256, 0.98256, 0, 0, 0.77778],
    "10892": [0.48256, 0.98256, 0, 0, 0.77778],
    "10901": [0.13667, 0.63667, 0, 0, 0.77778],
    "10902": [0.13667, 0.63667, 0, 0, 0.77778],
    "10933": [0.25142, 0.75726, 0, 0, 0.77778],
    "10934": [0.25142, 0.75726, 0, 0, 0.77778],
    "10935": [0.26167, 0.75726, 0, 0, 0.77778],
    "10936": [0.26167, 0.75726, 0, 0, 0.77778],
    "10937": [0.26167, 0.75726, 0, 0, 0.77778],
    "10938": [0.26167, 0.75726, 0, 0, 0.77778],
    "10949": [0.25583, 0.75583, 0, 0, 0.77778],
    "10950": [0.25583, 0.75583, 0, 0, 0.77778],
    "10955": [0.28481, 0.79383, 0, 0, 0.77778],
    "10956": [0.28481, 0.79383, 0, 0, 0.77778],
    "57350": [0.08167, 0.58167, 0, 0, 0.22222],
    "57351": [0.08167, 0.58167, 0, 0, 0.38889],
    "57352": [0.08167, 0.58167, 0, 0, 0.77778],
    "57353": [0, 0.43056, 0.04028, 0, 0.66667],
    "57356": [0.25142, 0.75726, 0, 0, 0.77778],
    "57357": [0.25142, 0.75726, 0, 0, 0.77778],
    "57358": [0.41951, 0.91951, 0, 0, 0.77778],
    "57359": [0.30274, 0.79383, 0, 0, 0.77778],
    "57360": [0.30274, 0.79383, 0, 0, 0.77778],
    "57361": [0.41951, 0.91951, 0, 0, 0.77778],
    "57366": [0.25142, 0.75726, 0, 0, 0.77778],
    "57367": [0.25142, 0.75726, 0, 0, 0.77778],
    "57368": [0.25142, 0.75726, 0, 0, 0.77778],
    "57369": [0.25142, 0.75726, 0, 0, 0.77778],
    "57370": [0.13597, 0.63597, 0, 0, 0.77778],
    "57371": [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.68333, 0, 0.19445, 0.79847],
    "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
    "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
    "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
    "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
    "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
    "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
    "73": [0, 0.68333, 0.07382, 0, 0.54452],
    "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
    "76": [0, 0.68333, 0, 0.13889, 0.68972],
    "77": [0, 0.68333, 0, 0.13889, 1.2009],
    "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
    "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
    "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
    "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
    "82": [0, 0.68333, 0, 0.08334, 0.8475],
    "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
    "84": [0, 0.68333, 0.25417, 0, 0.54464],
    "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
    "86": [0, 0.68333, 0.08222, 0, 0.61278],
    "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
    "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
    "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
    "160": [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69141, 0, 0, 0.29574],
    "34": [0, 0.69141, 0, 0, 0.21471],
    "38": [0, 0.69141, 0, 0, 0.73786],
    "39": [0, 0.69141, 0, 0, 0.21201],
    "40": [0.24982, 0.74947, 0, 0, 0.38865],
    "41": [0.24982, 0.74947, 0, 0, 0.38865],
    "42": [0, 0.62119, 0, 0, 0.27764],
    "43": [0.08319, 0.58283, 0, 0, 0.75623],
    "44": [0, 0.10803, 0, 0, 0.27764],
    "45": [0.08319, 0.58283, 0, 0, 0.75623],
    "46": [0, 0.10803, 0, 0, 0.27764],
    "47": [0.24982, 0.74947, 0, 0, 0.50181],
    "48": [0, 0.47534, 0, 0, 0.50181],
    "49": [0, 0.47534, 0, 0, 0.50181],
    "50": [0, 0.47534, 0, 0, 0.50181],
    "51": [0.18906, 0.47534, 0, 0, 0.50181],
    "52": [0.18906, 0.47534, 0, 0, 0.50181],
    "53": [0.18906, 0.47534, 0, 0, 0.50181],
    "54": [0, 0.69141, 0, 0, 0.50181],
    "55": [0.18906, 0.47534, 0, 0, 0.50181],
    "56": [0, 0.69141, 0, 0, 0.50181],
    "57": [0.18906, 0.47534, 0, 0, 0.50181],
    "58": [0, 0.47534, 0, 0, 0.21606],
    "59": [0.12604, 0.47534, 0, 0, 0.21606],
    "61": [-0.13099, 0.36866, 0, 0, 0.75623],
    "63": [0, 0.69141, 0, 0, 0.36245],
    "65": [0, 0.69141, 0, 0, 0.7176],
    "66": [0, 0.69141, 0, 0, 0.88397],
    "67": [0, 0.69141, 0, 0, 0.61254],
    "68": [0, 0.69141, 0, 0, 0.83158],
    "69": [0, 0.69141, 0, 0, 0.66278],
    "70": [0.12604, 0.69141, 0, 0, 0.61119],
    "71": [0, 0.69141, 0, 0, 0.78539],
    "72": [0.06302, 0.69141, 0, 0, 0.7203],
    "73": [0, 0.69141, 0, 0, 0.55448],
    "74": [0.12604, 0.69141, 0, 0, 0.55231],
    "75": [0, 0.69141, 0, 0, 0.66845],
    "76": [0, 0.69141, 0, 0, 0.66602],
    "77": [0, 0.69141, 0, 0, 1.04953],
    "78": [0, 0.69141, 0, 0, 0.83212],
    "79": [0, 0.69141, 0, 0, 0.82699],
    "80": [0.18906, 0.69141, 0, 0, 0.82753],
    "81": [0.03781, 0.69141, 0, 0, 0.82699],
    "82": [0, 0.69141, 0, 0, 0.82807],
    "83": [0, 0.69141, 0, 0, 0.82861],
    "84": [0, 0.69141, 0, 0, 0.66899],
    "85": [0, 0.69141, 0, 0, 0.64576],
    "86": [0, 0.69141, 0, 0, 0.83131],
    "87": [0, 0.69141, 0, 0, 1.04602],
    "88": [0, 0.69141, 0, 0, 0.71922],
    "89": [0.18906, 0.69141, 0, 0, 0.83293],
    "90": [0.12604, 0.69141, 0, 0, 0.60201],
    "91": [0.24982, 0.74947, 0, 0, 0.27764],
    "93": [0.24982, 0.74947, 0, 0, 0.27764],
    "94": [0, 0.69141, 0, 0, 0.49965],
    "97": [0, 0.47534, 0, 0, 0.50046],
    "98": [0, 0.69141, 0, 0, 0.51315],
    "99": [0, 0.47534, 0, 0, 0.38946],
    "100": [0, 0.62119, 0, 0, 0.49857],
    "101": [0, 0.47534, 0, 0, 0.40053],
    "102": [0.18906, 0.69141, 0, 0, 0.32626],
    "103": [0.18906, 0.47534, 0, 0, 0.5037],
    "104": [0.18906, 0.69141, 0, 0, 0.52126],
    "105": [0, 0.69141, 0, 0, 0.27899],
    "106": [0, 0.69141, 0, 0, 0.28088],
    "107": [0, 0.69141, 0, 0, 0.38946],
    "108": [0, 0.69141, 0, 0, 0.27953],
    "109": [0, 0.47534, 0, 0, 0.76676],
    "110": [0, 0.47534, 0, 0, 0.52666],
    "111": [0, 0.47534, 0, 0, 0.48885],
    "112": [0.18906, 0.52396, 0, 0, 0.50046],
    "113": [0.18906, 0.47534, 0, 0, 0.48912],
    "114": [0, 0.47534, 0, 0, 0.38919],
    "115": [0, 0.47534, 0, 0, 0.44266],
    "116": [0, 0.62119, 0, 0, 0.33301],
    "117": [0, 0.47534, 0, 0, 0.5172],
    "118": [0, 0.52396, 0, 0, 0.5118],
    "119": [0, 0.52396, 0, 0, 0.77351],
    "120": [0.18906, 0.47534, 0, 0, 0.38865],
    "121": [0.18906, 0.47534, 0, 0, 0.49884],
    "122": [0.18906, 0.47534, 0, 0, 0.39054],
    "160": [0, 0, 0, 0, 0.25],
    "8216": [0, 0.69141, 0, 0, 0.21471],
    "8217": [0, 0.69141, 0, 0, 0.21471],
    "58112": [0, 0.62119, 0, 0, 0.49749],
    "58113": [0, 0.62119, 0, 0, 0.4983],
    "58114": [0.18906, 0.69141, 0, 0, 0.33328],
    "58115": [0.18906, 0.69141, 0, 0, 0.32923],
    "58116": [0.18906, 0.47534, 0, 0, 0.50343],
    "58117": [0, 0.69141, 0, 0, 0.33301],
    "58118": [0, 0.62119, 0, 0, 0.33409],
    "58119": [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.35],
    "34": [0, 0.69444, 0, 0, 0.60278],
    "35": [0.19444, 0.69444, 0, 0, 0.95833],
    "36": [0.05556, 0.75, 0, 0, 0.575],
    "37": [0.05556, 0.75, 0, 0, 0.95833],
    "38": [0, 0.69444, 0, 0, 0.89444],
    "39": [0, 0.69444, 0, 0, 0.31944],
    "40": [0.25, 0.75, 0, 0, 0.44722],
    "41": [0.25, 0.75, 0, 0, 0.44722],
    "42": [0, 0.75, 0, 0, 0.575],
    "43": [0.13333, 0.63333, 0, 0, 0.89444],
    "44": [0.19444, 0.15556, 0, 0, 0.31944],
    "45": [0, 0.44444, 0, 0, 0.38333],
    "46": [0, 0.15556, 0, 0, 0.31944],
    "47": [0.25, 0.75, 0, 0, 0.575],
    "48": [0, 0.64444, 0, 0, 0.575],
    "49": [0, 0.64444, 0, 0, 0.575],
    "50": [0, 0.64444, 0, 0, 0.575],
    "51": [0, 0.64444, 0, 0, 0.575],
    "52": [0, 0.64444, 0, 0, 0.575],
    "53": [0, 0.64444, 0, 0, 0.575],
    "54": [0, 0.64444, 0, 0, 0.575],
    "55": [0, 0.64444, 0, 0, 0.575],
    "56": [0, 0.64444, 0, 0, 0.575],
    "57": [0, 0.64444, 0, 0, 0.575],
    "58": [0, 0.44444, 0, 0, 0.31944],
    "59": [0.19444, 0.44444, 0, 0, 0.31944],
    "60": [0.08556, 0.58556, 0, 0, 0.89444],
    "61": [-0.10889, 0.39111, 0, 0, 0.89444],
    "62": [0.08556, 0.58556, 0, 0, 0.89444],
    "63": [0, 0.69444, 0, 0, 0.54305],
    "64": [0, 0.69444, 0, 0, 0.89444],
    "65": [0, 0.68611, 0, 0, 0.86944],
    "66": [0, 0.68611, 0, 0, 0.81805],
    "67": [0, 0.68611, 0, 0, 0.83055],
    "68": [0, 0.68611, 0, 0, 0.88194],
    "69": [0, 0.68611, 0, 0, 0.75555],
    "70": [0, 0.68611, 0, 0, 0.72361],
    "71": [0, 0.68611, 0, 0, 0.90416],
    "72": [0, 0.68611, 0, 0, 0.9],
    "73": [0, 0.68611, 0, 0, 0.43611],
    "74": [0, 0.68611, 0, 0, 0.59444],
    "75": [0, 0.68611, 0, 0, 0.90138],
    "76": [0, 0.68611, 0, 0, 0.69166],
    "77": [0, 0.68611, 0, 0, 1.09166],
    "78": [0, 0.68611, 0, 0, 0.9],
    "79": [0, 0.68611, 0, 0, 0.86388],
    "80": [0, 0.68611, 0, 0, 0.78611],
    "81": [0.19444, 0.68611, 0, 0, 0.86388],
    "82": [0, 0.68611, 0, 0, 0.8625],
    "83": [0, 0.68611, 0, 0, 0.63889],
    "84": [0, 0.68611, 0, 0, 0.8],
    "85": [0, 0.68611, 0, 0, 0.88472],
    "86": [0, 0.68611, 0.01597, 0, 0.86944],
    "87": [0, 0.68611, 0.01597, 0, 1.18888],
    "88": [0, 0.68611, 0, 0, 0.86944],
    "89": [0, 0.68611, 0.02875, 0, 0.86944],
    "90": [0, 0.68611, 0, 0, 0.70277],
    "91": [0.25, 0.75, 0, 0, 0.31944],
    "92": [0.25, 0.75, 0, 0, 0.575],
    "93": [0.25, 0.75, 0, 0, 0.31944],
    "94": [0, 0.69444, 0, 0, 0.575],
    "95": [0.31, 0.13444, 0.03194, 0, 0.575],
    "97": [0, 0.44444, 0, 0, 0.55902],
    "98": [0, 0.69444, 0, 0, 0.63889],
    "99": [0, 0.44444, 0, 0, 0.51111],
    "100": [0, 0.69444, 0, 0, 0.63889],
    "101": [0, 0.44444, 0, 0, 0.52708],
    "102": [0, 0.69444, 0.10903, 0, 0.35139],
    "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
    "104": [0, 0.69444, 0, 0, 0.63889],
    "105": [0, 0.69444, 0, 0, 0.31944],
    "106": [0.19444, 0.69444, 0, 0, 0.35139],
    "107": [0, 0.69444, 0, 0, 0.60694],
    "108": [0, 0.69444, 0, 0, 0.31944],
    "109": [0, 0.44444, 0, 0, 0.95833],
    "110": [0, 0.44444, 0, 0, 0.63889],
    "111": [0, 0.44444, 0, 0, 0.575],
    "112": [0.19444, 0.44444, 0, 0, 0.63889],
    "113": [0.19444, 0.44444, 0, 0, 0.60694],
    "114": [0, 0.44444, 0, 0, 0.47361],
    "115": [0, 0.44444, 0, 0, 0.45361],
    "116": [0, 0.63492, 0, 0, 0.44722],
    "117": [0, 0.44444, 0, 0, 0.63889],
    "118": [0, 0.44444, 0.01597, 0, 0.60694],
    "119": [0, 0.44444, 0.01597, 0, 0.83055],
    "120": [0, 0.44444, 0, 0, 0.60694],
    "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
    "122": [0, 0.44444, 0, 0, 0.51111],
    "123": [0.25, 0.75, 0, 0, 0.575],
    "124": [0.25, 0.75, 0, 0, 0.31944],
    "125": [0.25, 0.75, 0, 0, 0.575],
    "126": [0.35, 0.34444, 0, 0, 0.575],
    "160": [0, 0, 0, 0, 0.25],
    "163": [0, 0.69444, 0, 0, 0.86853],
    "168": [0, 0.69444, 0, 0, 0.575],
    "172": [0, 0.44444, 0, 0, 0.76666],
    "176": [0, 0.69444, 0, 0, 0.86944],
    "177": [0.13333, 0.63333, 0, 0, 0.89444],
    "184": [0.17014, 0, 0, 0, 0.51111],
    "198": [0, 0.68611, 0, 0, 1.04166],
    "215": [0.13333, 0.63333, 0, 0, 0.89444],
    "216": [0.04861, 0.73472, 0, 0, 0.89444],
    "223": [0, 0.69444, 0, 0, 0.59722],
    "230": [0, 0.44444, 0, 0, 0.83055],
    "247": [0.13333, 0.63333, 0, 0, 0.89444],
    "248": [0.09722, 0.54167, 0, 0, 0.575],
    "305": [0, 0.44444, 0, 0, 0.31944],
    "338": [0, 0.68611, 0, 0, 1.16944],
    "339": [0, 0.44444, 0, 0, 0.89444],
    "567": [0.19444, 0.44444, 0, 0, 0.35139],
    "710": [0, 0.69444, 0, 0, 0.575],
    "711": [0, 0.63194, 0, 0, 0.575],
    "713": [0, 0.59611, 0, 0, 0.575],
    "714": [0, 0.69444, 0, 0, 0.575],
    "715": [0, 0.69444, 0, 0, 0.575],
    "728": [0, 0.69444, 0, 0, 0.575],
    "729": [0, 0.69444, 0, 0, 0.31944],
    "730": [0, 0.69444, 0, 0, 0.86944],
    "732": [0, 0.69444, 0, 0, 0.575],
    "733": [0, 0.69444, 0, 0, 0.575],
    "915": [0, 0.68611, 0, 0, 0.69166],
    "916": [0, 0.68611, 0, 0, 0.95833],
    "920": [0, 0.68611, 0, 0, 0.89444],
    "923": [0, 0.68611, 0, 0, 0.80555],
    "926": [0, 0.68611, 0, 0, 0.76666],
    "928": [0, 0.68611, 0, 0, 0.9],
    "931": [0, 0.68611, 0, 0, 0.83055],
    "933": [0, 0.68611, 0, 0, 0.89444],
    "934": [0, 0.68611, 0, 0, 0.83055],
    "936": [0, 0.68611, 0, 0, 0.89444],
    "937": [0, 0.68611, 0, 0, 0.83055],
    "8211": [0, 0.44444, 0.03194, 0, 0.575],
    "8212": [0, 0.44444, 0.03194, 0, 1.14999],
    "8216": [0, 0.69444, 0, 0, 0.31944],
    "8217": [0, 0.69444, 0, 0, 0.31944],
    "8220": [0, 0.69444, 0, 0, 0.60278],
    "8221": [0, 0.69444, 0, 0, 0.60278],
    "8224": [0.19444, 0.69444, 0, 0, 0.51111],
    "8225": [0.19444, 0.69444, 0, 0, 0.51111],
    "8242": [0, 0.55556, 0, 0, 0.34444],
    "8407": [0, 0.72444, 0.15486, 0, 0.575],
    "8463": [0, 0.69444, 0, 0, 0.66759],
    "8465": [0, 0.69444, 0, 0, 0.83055],
    "8467": [0, 0.69444, 0, 0, 0.47361],
    "8472": [0.19444, 0.44444, 0, 0, 0.74027],
    "8476": [0, 0.69444, 0, 0, 0.83055],
    "8501": [0, 0.69444, 0, 0, 0.70277],
    "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8593": [0.19444, 0.69444, 0, 0, 0.575],
    "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8595": [0.19444, 0.69444, 0, 0, 0.575],
    "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8597": [0.25, 0.75, 0, 0, 0.575],
    "8598": [0.19444, 0.69444, 0, 0, 1.14999],
    "8599": [0.19444, 0.69444, 0, 0, 1.14999],
    "8600": [0.19444, 0.69444, 0, 0, 1.14999],
    "8601": [0.19444, 0.69444, 0, 0, 1.14999],
    "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8657": [0.19444, 0.69444, 0, 0, 0.70277],
    "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8659": [0.19444, 0.69444, 0, 0, 0.70277],
    "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
    "8661": [0.25, 0.75, 0, 0, 0.70277],
    "8704": [0, 0.69444, 0, 0, 0.63889],
    "8706": [0, 0.69444, 0.06389, 0, 0.62847],
    "8707": [0, 0.69444, 0, 0, 0.63889],
    "8709": [0.05556, 0.75, 0, 0, 0.575],
    "8711": [0, 0.68611, 0, 0, 0.95833],
    "8712": [0.08556, 0.58556, 0, 0, 0.76666],
    "8715": [0.08556, 0.58556, 0, 0, 0.76666],
    "8722": [0.13333, 0.63333, 0, 0, 0.89444],
    "8723": [0.13333, 0.63333, 0, 0, 0.89444],
    "8725": [0.25, 0.75, 0, 0, 0.575],
    "8726": [0.25, 0.75, 0, 0, 0.575],
    "8727": [-0.02778, 0.47222, 0, 0, 0.575],
    "8728": [-0.02639, 0.47361, 0, 0, 0.575],
    "8729": [-0.02639, 0.47361, 0, 0, 0.575],
    "8730": [0.18, 0.82, 0, 0, 0.95833],
    "8733": [0, 0.44444, 0, 0, 0.89444],
    "8734": [0, 0.44444, 0, 0, 1.14999],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8739": [0.25, 0.75, 0, 0, 0.31944],
    "8741": [0.25, 0.75, 0, 0, 0.575],
    "8743": [0, 0.55556, 0, 0, 0.76666],
    "8744": [0, 0.55556, 0, 0, 0.76666],
    "8745": [0, 0.55556, 0, 0, 0.76666],
    "8746": [0, 0.55556, 0, 0, 0.76666],
    "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
    "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
    "8768": [0.19444, 0.69444, 0, 0, 0.31944],
    "8771": [222e-5, 0.50222, 0, 0, 0.89444],
    "8773": [0.027, 0.638, 0, 0, 0.894],
    "8776": [0.02444, 0.52444, 0, 0, 0.89444],
    "8781": [222e-5, 0.50222, 0, 0, 0.89444],
    "8801": [222e-5, 0.50222, 0, 0, 0.89444],
    "8804": [0.19667, 0.69667, 0, 0, 0.89444],
    "8805": [0.19667, 0.69667, 0, 0, 0.89444],
    "8810": [0.08556, 0.58556, 0, 0, 1.14999],
    "8811": [0.08556, 0.58556, 0, 0, 1.14999],
    "8826": [0.08556, 0.58556, 0, 0, 0.89444],
    "8827": [0.08556, 0.58556, 0, 0, 0.89444],
    "8834": [0.08556, 0.58556, 0, 0, 0.89444],
    "8835": [0.08556, 0.58556, 0, 0, 0.89444],
    "8838": [0.19667, 0.69667, 0, 0, 0.89444],
    "8839": [0.19667, 0.69667, 0, 0, 0.89444],
    "8846": [0, 0.55556, 0, 0, 0.76666],
    "8849": [0.19667, 0.69667, 0, 0, 0.89444],
    "8850": [0.19667, 0.69667, 0, 0, 0.89444],
    "8851": [0, 0.55556, 0, 0, 0.76666],
    "8852": [0, 0.55556, 0, 0, 0.76666],
    "8853": [0.13333, 0.63333, 0, 0, 0.89444],
    "8854": [0.13333, 0.63333, 0, 0, 0.89444],
    "8855": [0.13333, 0.63333, 0, 0, 0.89444],
    "8856": [0.13333, 0.63333, 0, 0, 0.89444],
    "8857": [0.13333, 0.63333, 0, 0, 0.89444],
    "8866": [0, 0.69444, 0, 0, 0.70277],
    "8867": [0, 0.69444, 0, 0, 0.70277],
    "8868": [0, 0.69444, 0, 0, 0.89444],
    "8869": [0, 0.69444, 0, 0, 0.89444],
    "8900": [-0.02639, 0.47361, 0, 0, 0.575],
    "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
    "8902": [-0.02778, 0.47222, 0, 0, 0.575],
    "8968": [0.25, 0.75, 0, 0, 0.51111],
    "8969": [0.25, 0.75, 0, 0, 0.51111],
    "8970": [0.25, 0.75, 0, 0, 0.51111],
    "8971": [0.25, 0.75, 0, 0, 0.51111],
    "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
    "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
    "9651": [0.19444, 0.69444, 0, 0, 1.02222],
    "9657": [-0.02778, 0.47222, 0, 0, 0.575],
    "9661": [0.19444, 0.69444, 0, 0, 1.02222],
    "9667": [-0.02778, 0.47222, 0, 0, 0.575],
    "9711": [0.19444, 0.69444, 0, 0, 1.14999],
    "9824": [0.12963, 0.69444, 0, 0, 0.89444],
    "9825": [0.12963, 0.69444, 0, 0, 0.89444],
    "9826": [0.12963, 0.69444, 0, 0, 0.89444],
    "9827": [0.12963, 0.69444, 0, 0, 0.89444],
    "9837": [0, 0.75, 0, 0, 0.44722],
    "9838": [0.19444, 0.69444, 0, 0, 0.44722],
    "9839": [0.19444, 0.69444, 0, 0, 0.44722],
    "10216": [0.25, 0.75, 0, 0, 0.44722],
    "10217": [0.25, 0.75, 0, 0, 0.44722],
    "10815": [0, 0.68611, 0, 0, 0.9],
    "10927": [0.19667, 0.69667, 0, 0, 0.89444],
    "10928": [0.19667, 0.69667, 0, 0, 0.89444],
    "57376": [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.11417, 0, 0.38611],
    "34": [0, 0.69444, 0.07939, 0, 0.62055],
    "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
    "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
    "38": [0, 0.69444, 0.08528, 0, 0.88555],
    "39": [0, 0.69444, 0.12945, 0, 0.35555],
    "40": [0.25, 0.75, 0.15806, 0, 0.47333],
    "41": [0.25, 0.75, 0.03306, 0, 0.47333],
    "42": [0, 0.75, 0.14333, 0, 0.59111],
    "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
    "44": [0.19444, 0.14722, 0, 0, 0.35555],
    "45": [0, 0.44444, 0.02611, 0, 0.41444],
    "46": [0, 0.14722, 0, 0, 0.35555],
    "47": [0.25, 0.75, 0.15806, 0, 0.59111],
    "48": [0, 0.64444, 0.13167, 0, 0.59111],
    "49": [0, 0.64444, 0.13167, 0, 0.59111],
    "50": [0, 0.64444, 0.13167, 0, 0.59111],
    "51": [0, 0.64444, 0.13167, 0, 0.59111],
    "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
    "53": [0, 0.64444, 0.13167, 0, 0.59111],
    "54": [0, 0.64444, 0.13167, 0, 0.59111],
    "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
    "56": [0, 0.64444, 0.13167, 0, 0.59111],
    "57": [0, 0.64444, 0.13167, 0, 0.59111],
    "58": [0, 0.44444, 0.06695, 0, 0.35555],
    "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
    "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    "63": [0, 0.69444, 0.11472, 0, 0.59111],
    "64": [0, 0.69444, 0.09208, 0, 0.88555],
    "65": [0, 0.68611, 0, 0, 0.86555],
    "66": [0, 0.68611, 0.0992, 0, 0.81666],
    "67": [0, 0.68611, 0.14208, 0, 0.82666],
    "68": [0, 0.68611, 0.09062, 0, 0.87555],
    "69": [0, 0.68611, 0.11431, 0, 0.75666],
    "70": [0, 0.68611, 0.12903, 0, 0.72722],
    "71": [0, 0.68611, 0.07347, 0, 0.89527],
    "72": [0, 0.68611, 0.17208, 0, 0.8961],
    "73": [0, 0.68611, 0.15681, 0, 0.47166],
    "74": [0, 0.68611, 0.145, 0, 0.61055],
    "75": [0, 0.68611, 0.14208, 0, 0.89499],
    "76": [0, 0.68611, 0, 0, 0.69777],
    "77": [0, 0.68611, 0.17208, 0, 1.07277],
    "78": [0, 0.68611, 0.17208, 0, 0.8961],
    "79": [0, 0.68611, 0.09062, 0, 0.85499],
    "80": [0, 0.68611, 0.0992, 0, 0.78721],
    "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
    "82": [0, 0.68611, 0.02559, 0, 0.85944],
    "83": [0, 0.68611, 0.11264, 0, 0.64999],
    "84": [0, 0.68611, 0.12903, 0, 0.7961],
    "85": [0, 0.68611, 0.17208, 0, 0.88083],
    "86": [0, 0.68611, 0.18625, 0, 0.86555],
    "87": [0, 0.68611, 0.18625, 0, 1.15999],
    "88": [0, 0.68611, 0.15681, 0, 0.86555],
    "89": [0, 0.68611, 0.19803, 0, 0.86555],
    "90": [0, 0.68611, 0.14208, 0, 0.70888],
    "91": [0.25, 0.75, 0.1875, 0, 0.35611],
    "93": [0.25, 0.75, 0.09972, 0, 0.35611],
    "94": [0, 0.69444, 0.06709, 0, 0.59111],
    "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
    "97": [0, 0.44444, 0.09426, 0, 0.59111],
    "98": [0, 0.69444, 0.07861, 0, 0.53222],
    "99": [0, 0.44444, 0.05222, 0, 0.53222],
    "100": [0, 0.69444, 0.10861, 0, 0.59111],
    "101": [0, 0.44444, 0.085, 0, 0.53222],
    "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
    "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
    "104": [0, 0.69444, 0.09426, 0, 0.59111],
    "105": [0, 0.69326, 0.11387, 0, 0.35555],
    "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
    "107": [0, 0.69444, 0.11111, 0, 0.53222],
    "108": [0, 0.69444, 0.10861, 0, 0.29666],
    "109": [0, 0.44444, 0.09426, 0, 0.94444],
    "110": [0, 0.44444, 0.09426, 0, 0.64999],
    "111": [0, 0.44444, 0.07861, 0, 0.59111],
    "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
    "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
    "114": [0, 0.44444, 0.11111, 0, 0.50167],
    "115": [0, 0.44444, 0.08167, 0, 0.48694],
    "116": [0, 0.63492, 0.09639, 0, 0.385],
    "117": [0, 0.44444, 0.09426, 0, 0.62055],
    "118": [0, 0.44444, 0.11111, 0, 0.53222],
    "119": [0, 0.44444, 0.11111, 0, 0.76777],
    "120": [0, 0.44444, 0.12583, 0, 0.56055],
    "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
    "122": [0, 0.44444, 0.13889, 0, 0.49055],
    "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.69444, 0.11473, 0, 0.59111],
    "176": [0, 0.69444, 0, 0, 0.94888],
    "184": [0.17014, 0, 0, 0, 0.53222],
    "198": [0, 0.68611, 0.11431, 0, 1.02277],
    "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
    "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
    "230": [0, 0.44444, 0.085, 0, 0.82666],
    "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
    "305": [0, 0.44444, 0.09426, 0, 0.35555],
    "338": [0, 0.68611, 0.11431, 0, 1.14054],
    "339": [0, 0.44444, 0.085, 0, 0.82666],
    "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
    "710": [0, 0.69444, 0.06709, 0, 0.59111],
    "711": [0, 0.63194, 0.08271, 0, 0.59111],
    "713": [0, 0.59444, 0.10444, 0, 0.59111],
    "714": [0, 0.69444, 0.08528, 0, 0.59111],
    "715": [0, 0.69444, 0, 0, 0.59111],
    "728": [0, 0.69444, 0.10333, 0, 0.59111],
    "729": [0, 0.69444, 0.12945, 0, 0.35555],
    "730": [0, 0.69444, 0, 0, 0.94888],
    "732": [0, 0.69444, 0.11472, 0, 0.59111],
    "733": [0, 0.69444, 0.11472, 0, 0.59111],
    "915": [0, 0.68611, 0.12903, 0, 0.69777],
    "916": [0, 0.68611, 0, 0, 0.94444],
    "920": [0, 0.68611, 0.09062, 0, 0.88555],
    "923": [0, 0.68611, 0, 0, 0.80666],
    "926": [0, 0.68611, 0.15092, 0, 0.76777],
    "928": [0, 0.68611, 0.17208, 0, 0.8961],
    "931": [0, 0.68611, 0.11431, 0, 0.82666],
    "933": [0, 0.68611, 0.10778, 0, 0.88555],
    "934": [0, 0.68611, 0.05632, 0, 0.82666],
    "936": [0, 0.68611, 0.10778, 0, 0.88555],
    "937": [0, 0.68611, 0.0992, 0, 0.82666],
    "8211": [0, 0.44444, 0.09811, 0, 0.59111],
    "8212": [0, 0.44444, 0.09811, 0, 1.18221],
    "8216": [0, 0.69444, 0.12945, 0, 0.35555],
    "8217": [0, 0.69444, 0.12945, 0, 0.35555],
    "8220": [0, 0.69444, 0.16772, 0, 0.62055],
    "8221": [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.12417, 0, 0.30667],
    "34": [0, 0.69444, 0.06961, 0, 0.51444],
    "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
    "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
    "38": [0, 0.69444, 0.09694, 0, 0.76666],
    "39": [0, 0.69444, 0.12417, 0, 0.30667],
    "40": [0.25, 0.75, 0.16194, 0, 0.40889],
    "41": [0.25, 0.75, 0.03694, 0, 0.40889],
    "42": [0, 0.75, 0.14917, 0, 0.51111],
    "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
    "44": [0.19444, 0.10556, 0, 0, 0.30667],
    "45": [0, 0.43056, 0.02826, 0, 0.35778],
    "46": [0, 0.10556, 0, 0, 0.30667],
    "47": [0.25, 0.75, 0.16194, 0, 0.51111],
    "48": [0, 0.64444, 0.13556, 0, 0.51111],
    "49": [0, 0.64444, 0.13556, 0, 0.51111],
    "50": [0, 0.64444, 0.13556, 0, 0.51111],
    "51": [0, 0.64444, 0.13556, 0, 0.51111],
    "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
    "53": [0, 0.64444, 0.13556, 0, 0.51111],
    "54": [0, 0.64444, 0.13556, 0, 0.51111],
    "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
    "56": [0, 0.64444, 0.13556, 0, 0.51111],
    "57": [0, 0.64444, 0.13556, 0, 0.51111],
    "58": [0, 0.43056, 0.0582, 0, 0.30667],
    "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
    "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    "63": [0, 0.69444, 0.1225, 0, 0.51111],
    "64": [0, 0.69444, 0.09597, 0, 0.76666],
    "65": [0, 0.68333, 0, 0, 0.74333],
    "66": [0, 0.68333, 0.10257, 0, 0.70389],
    "67": [0, 0.68333, 0.14528, 0, 0.71555],
    "68": [0, 0.68333, 0.09403, 0, 0.755],
    "69": [0, 0.68333, 0.12028, 0, 0.67833],
    "70": [0, 0.68333, 0.13305, 0, 0.65277],
    "71": [0, 0.68333, 0.08722, 0, 0.77361],
    "72": [0, 0.68333, 0.16389, 0, 0.74333],
    "73": [0, 0.68333, 0.15806, 0, 0.38555],
    "74": [0, 0.68333, 0.14028, 0, 0.525],
    "75": [0, 0.68333, 0.14528, 0, 0.76888],
    "76": [0, 0.68333, 0, 0, 0.62722],
    "77": [0, 0.68333, 0.16389, 0, 0.89666],
    "78": [0, 0.68333, 0.16389, 0, 0.74333],
    "79": [0, 0.68333, 0.09403, 0, 0.76666],
    "80": [0, 0.68333, 0.10257, 0, 0.67833],
    "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
    "82": [0, 0.68333, 0.03868, 0, 0.72944],
    "83": [0, 0.68333, 0.11972, 0, 0.56222],
    "84": [0, 0.68333, 0.13305, 0, 0.71555],
    "85": [0, 0.68333, 0.16389, 0, 0.74333],
    "86": [0, 0.68333, 0.18361, 0, 0.74333],
    "87": [0, 0.68333, 0.18361, 0, 0.99888],
    "88": [0, 0.68333, 0.15806, 0, 0.74333],
    "89": [0, 0.68333, 0.19383, 0, 0.74333],
    "90": [0, 0.68333, 0.14528, 0, 0.61333],
    "91": [0.25, 0.75, 0.1875, 0, 0.30667],
    "93": [0.25, 0.75, 0.10528, 0, 0.30667],
    "94": [0, 0.69444, 0.06646, 0, 0.51111],
    "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
    "97": [0, 0.43056, 0.07671, 0, 0.51111],
    "98": [0, 0.69444, 0.06312, 0, 0.46],
    "99": [0, 0.43056, 0.05653, 0, 0.46],
    "100": [0, 0.69444, 0.10333, 0, 0.51111],
    "101": [0, 0.43056, 0.07514, 0, 0.46],
    "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
    "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
    "104": [0, 0.69444, 0.07671, 0, 0.51111],
    "105": [0, 0.65536, 0.1019, 0, 0.30667],
    "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
    "107": [0, 0.69444, 0.10764, 0, 0.46],
    "108": [0, 0.69444, 0.10333, 0, 0.25555],
    "109": [0, 0.43056, 0.07671, 0, 0.81777],
    "110": [0, 0.43056, 0.07671, 0, 0.56222],
    "111": [0, 0.43056, 0.06312, 0, 0.51111],
    "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
    "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
    "114": [0, 0.43056, 0.10764, 0, 0.42166],
    "115": [0, 0.43056, 0.08208, 0, 0.40889],
    "116": [0, 0.61508, 0.09486, 0, 0.33222],
    "117": [0, 0.43056, 0.07671, 0, 0.53666],
    "118": [0, 0.43056, 0.10764, 0, 0.46],
    "119": [0, 0.43056, 0.10764, 0, 0.66444],
    "120": [0, 0.43056, 0.12042, 0, 0.46389],
    "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
    "122": [0, 0.43056, 0.12292, 0, 0.40889],
    "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.66786, 0.10474, 0, 0.51111],
    "176": [0, 0.69444, 0, 0, 0.83129],
    "184": [0.17014, 0, 0, 0, 0.46],
    "198": [0, 0.68333, 0.12028, 0, 0.88277],
    "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
    "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
    "230": [0, 0.43056, 0.07514, 0, 0.71555],
    "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
    "338": [0, 0.68333, 0.12028, 0, 0.98499],
    "339": [0, 0.43056, 0.07514, 0, 0.71555],
    "710": [0, 0.69444, 0.06646, 0, 0.51111],
    "711": [0, 0.62847, 0.08295, 0, 0.51111],
    "713": [0, 0.56167, 0.10333, 0, 0.51111],
    "714": [0, 0.69444, 0.09694, 0, 0.51111],
    "715": [0, 0.69444, 0, 0, 0.51111],
    "728": [0, 0.69444, 0.10806, 0, 0.51111],
    "729": [0, 0.66786, 0.11752, 0, 0.30667],
    "730": [0, 0.69444, 0, 0, 0.83129],
    "732": [0, 0.66786, 0.11585, 0, 0.51111],
    "733": [0, 0.69444, 0.1225, 0, 0.51111],
    "915": [0, 0.68333, 0.13305, 0, 0.62722],
    "916": [0, 0.68333, 0, 0, 0.81777],
    "920": [0, 0.68333, 0.09403, 0, 0.76666],
    "923": [0, 0.68333, 0, 0, 0.69222],
    "926": [0, 0.68333, 0.15294, 0, 0.66444],
    "928": [0, 0.68333, 0.16389, 0, 0.74333],
    "931": [0, 0.68333, 0.12028, 0, 0.71555],
    "933": [0, 0.68333, 0.11111, 0, 0.76666],
    "934": [0, 0.68333, 0.05986, 0, 0.71555],
    "936": [0, 0.68333, 0.11111, 0, 0.76666],
    "937": [0, 0.68333, 0.10257, 0, 0.71555],
    "8211": [0, 0.43056, 0.09208, 0, 0.51111],
    "8212": [0, 0.43056, 0.09208, 0, 1.02222],
    "8216": [0, 0.69444, 0.12417, 0, 0.30667],
    "8217": [0, 0.69444, 0.12417, 0, 0.30667],
    "8220": [0, 0.69444, 0.1685, 0, 0.51444],
    "8221": [0, 0.69444, 0.06961, 0, 0.51444],
    "8463": [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.27778],
    "34": [0, 0.69444, 0, 0, 0.5],
    "35": [0.19444, 0.69444, 0, 0, 0.83334],
    "36": [0.05556, 0.75, 0, 0, 0.5],
    "37": [0.05556, 0.75, 0, 0, 0.83334],
    "38": [0, 0.69444, 0, 0, 0.77778],
    "39": [0, 0.69444, 0, 0, 0.27778],
    "40": [0.25, 0.75, 0, 0, 0.38889],
    "41": [0.25, 0.75, 0, 0, 0.38889],
    "42": [0, 0.75, 0, 0, 0.5],
    "43": [0.08333, 0.58333, 0, 0, 0.77778],
    "44": [0.19444, 0.10556, 0, 0, 0.27778],
    "45": [0, 0.43056, 0, 0, 0.33333],
    "46": [0, 0.10556, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0, 0, 0.5],
    "48": [0, 0.64444, 0, 0, 0.5],
    "49": [0, 0.64444, 0, 0, 0.5],
    "50": [0, 0.64444, 0, 0, 0.5],
    "51": [0, 0.64444, 0, 0, 0.5],
    "52": [0, 0.64444, 0, 0, 0.5],
    "53": [0, 0.64444, 0, 0, 0.5],
    "54": [0, 0.64444, 0, 0, 0.5],
    "55": [0, 0.64444, 0, 0, 0.5],
    "56": [0, 0.64444, 0, 0, 0.5],
    "57": [0, 0.64444, 0, 0, 0.5],
    "58": [0, 0.43056, 0, 0, 0.27778],
    "59": [0.19444, 0.43056, 0, 0, 0.27778],
    "60": [0.0391, 0.5391, 0, 0, 0.77778],
    "61": [-0.13313, 0.36687, 0, 0, 0.77778],
    "62": [0.0391, 0.5391, 0, 0, 0.77778],
    "63": [0, 0.69444, 0, 0, 0.47222],
    "64": [0, 0.69444, 0, 0, 0.77778],
    "65": [0, 0.68333, 0, 0, 0.75],
    "66": [0, 0.68333, 0, 0, 0.70834],
    "67": [0, 0.68333, 0, 0, 0.72222],
    "68": [0, 0.68333, 0, 0, 0.76389],
    "69": [0, 0.68333, 0, 0, 0.68056],
    "70": [0, 0.68333, 0, 0, 0.65278],
    "71": [0, 0.68333, 0, 0, 0.78472],
    "72": [0, 0.68333, 0, 0, 0.75],
    "73": [0, 0.68333, 0, 0, 0.36111],
    "74": [0, 0.68333, 0, 0, 0.51389],
    "75": [0, 0.68333, 0, 0, 0.77778],
    "76": [0, 0.68333, 0, 0, 0.625],
    "77": [0, 0.68333, 0, 0, 0.91667],
    "78": [0, 0.68333, 0, 0, 0.75],
    "79": [0, 0.68333, 0, 0, 0.77778],
    "80": [0, 0.68333, 0, 0, 0.68056],
    "81": [0.19444, 0.68333, 0, 0, 0.77778],
    "82": [0, 0.68333, 0, 0, 0.73611],
    "83": [0, 0.68333, 0, 0, 0.55556],
    "84": [0, 0.68333, 0, 0, 0.72222],
    "85": [0, 0.68333, 0, 0, 0.75],
    "86": [0, 0.68333, 0.01389, 0, 0.75],
    "87": [0, 0.68333, 0.01389, 0, 1.02778],
    "88": [0, 0.68333, 0, 0, 0.75],
    "89": [0, 0.68333, 0.025, 0, 0.75],
    "90": [0, 0.68333, 0, 0, 0.61111],
    "91": [0.25, 0.75, 0, 0, 0.27778],
    "92": [0.25, 0.75, 0, 0, 0.5],
    "93": [0.25, 0.75, 0, 0, 0.27778],
    "94": [0, 0.69444, 0, 0, 0.5],
    "95": [0.31, 0.12056, 0.02778, 0, 0.5],
    "97": [0, 0.43056, 0, 0, 0.5],
    "98": [0, 0.69444, 0, 0, 0.55556],
    "99": [0, 0.43056, 0, 0, 0.44445],
    "100": [0, 0.69444, 0, 0, 0.55556],
    "101": [0, 0.43056, 0, 0, 0.44445],
    "102": [0, 0.69444, 0.07778, 0, 0.30556],
    "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
    "104": [0, 0.69444, 0, 0, 0.55556],
    "105": [0, 0.66786, 0, 0, 0.27778],
    "106": [0.19444, 0.66786, 0, 0, 0.30556],
    "107": [0, 0.69444, 0, 0, 0.52778],
    "108": [0, 0.69444, 0, 0, 0.27778],
    "109": [0, 0.43056, 0, 0, 0.83334],
    "110": [0, 0.43056, 0, 0, 0.55556],
    "111": [0, 0.43056, 0, 0, 0.5],
    "112": [0.19444, 0.43056, 0, 0, 0.55556],
    "113": [0.19444, 0.43056, 0, 0, 0.52778],
    "114": [0, 0.43056, 0, 0, 0.39167],
    "115": [0, 0.43056, 0, 0, 0.39445],
    "116": [0, 0.61508, 0, 0, 0.38889],
    "117": [0, 0.43056, 0, 0, 0.55556],
    "118": [0, 0.43056, 0.01389, 0, 0.52778],
    "119": [0, 0.43056, 0.01389, 0, 0.72222],
    "120": [0, 0.43056, 0, 0, 0.52778],
    "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
    "122": [0, 0.43056, 0, 0, 0.44445],
    "123": [0.25, 0.75, 0, 0, 0.5],
    "124": [0.25, 0.75, 0, 0, 0.27778],
    "125": [0.25, 0.75, 0, 0, 0.5],
    "126": [0.35, 0.31786, 0, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "163": [0, 0.69444, 0, 0, 0.76909],
    "167": [0.19444, 0.69444, 0, 0, 0.44445],
    "168": [0, 0.66786, 0, 0, 0.5],
    "172": [0, 0.43056, 0, 0, 0.66667],
    "176": [0, 0.69444, 0, 0, 0.75],
    "177": [0.08333, 0.58333, 0, 0, 0.77778],
    "182": [0.19444, 0.69444, 0, 0, 0.61111],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "198": [0, 0.68333, 0, 0, 0.90278],
    "215": [0.08333, 0.58333, 0, 0, 0.77778],
    "216": [0.04861, 0.73194, 0, 0, 0.77778],
    "223": [0, 0.69444, 0, 0, 0.5],
    "230": [0, 0.43056, 0, 0, 0.72222],
    "247": [0.08333, 0.58333, 0, 0, 0.77778],
    "248": [0.09722, 0.52778, 0, 0, 0.5],
    "305": [0, 0.43056, 0, 0, 0.27778],
    "338": [0, 0.68333, 0, 0, 1.01389],
    "339": [0, 0.43056, 0, 0, 0.77778],
    "567": [0.19444, 0.43056, 0, 0, 0.30556],
    "710": [0, 0.69444, 0, 0, 0.5],
    "711": [0, 0.62847, 0, 0, 0.5],
    "713": [0, 0.56778, 0, 0, 0.5],
    "714": [0, 0.69444, 0, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0, 0, 0.5],
    "729": [0, 0.66786, 0, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.75],
    "732": [0, 0.66786, 0, 0, 0.5],
    "733": [0, 0.69444, 0, 0, 0.5],
    "915": [0, 0.68333, 0, 0, 0.625],
    "916": [0, 0.68333, 0, 0, 0.83334],
    "920": [0, 0.68333, 0, 0, 0.77778],
    "923": [0, 0.68333, 0, 0, 0.69445],
    "926": [0, 0.68333, 0, 0, 0.66667],
    "928": [0, 0.68333, 0, 0, 0.75],
    "931": [0, 0.68333, 0, 0, 0.72222],
    "933": [0, 0.68333, 0, 0, 0.77778],
    "934": [0, 0.68333, 0, 0, 0.72222],
    "936": [0, 0.68333, 0, 0, 0.77778],
    "937": [0, 0.68333, 0, 0, 0.72222],
    "8211": [0, 0.43056, 0.02778, 0, 0.5],
    "8212": [0, 0.43056, 0.02778, 0, 1],
    "8216": [0, 0.69444, 0, 0, 0.27778],
    "8217": [0, 0.69444, 0, 0, 0.27778],
    "8220": [0, 0.69444, 0, 0, 0.5],
    "8221": [0, 0.69444, 0, 0, 0.5],
    "8224": [0.19444, 0.69444, 0, 0, 0.44445],
    "8225": [0.19444, 0.69444, 0, 0, 0.44445],
    "8230": [0, 0.123, 0, 0, 1.172],
    "8242": [0, 0.55556, 0, 0, 0.275],
    "8407": [0, 0.71444, 0.15382, 0, 0.5],
    "8463": [0, 0.68889, 0, 0, 0.54028],
    "8465": [0, 0.69444, 0, 0, 0.72222],
    "8467": [0, 0.69444, 0, 0.11111, 0.41667],
    "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
    "8476": [0, 0.69444, 0, 0, 0.72222],
    "8501": [0, 0.69444, 0, 0, 0.61111],
    "8592": [-0.13313, 0.36687, 0, 0, 1],
    "8593": [0.19444, 0.69444, 0, 0, 0.5],
    "8594": [-0.13313, 0.36687, 0, 0, 1],
    "8595": [0.19444, 0.69444, 0, 0, 0.5],
    "8596": [-0.13313, 0.36687, 0, 0, 1],
    "8597": [0.25, 0.75, 0, 0, 0.5],
    "8598": [0.19444, 0.69444, 0, 0, 1],
    "8599": [0.19444, 0.69444, 0, 0, 1],
    "8600": [0.19444, 0.69444, 0, 0, 1],
    "8601": [0.19444, 0.69444, 0, 0, 1],
    "8614": [0.011, 0.511, 0, 0, 1],
    "8617": [0.011, 0.511, 0, 0, 1.126],
    "8618": [0.011, 0.511, 0, 0, 1.126],
    "8636": [-0.13313, 0.36687, 0, 0, 1],
    "8637": [-0.13313, 0.36687, 0, 0, 1],
    "8640": [-0.13313, 0.36687, 0, 0, 1],
    "8641": [-0.13313, 0.36687, 0, 0, 1],
    "8652": [0.011, 0.671, 0, 0, 1],
    "8656": [-0.13313, 0.36687, 0, 0, 1],
    "8657": [0.19444, 0.69444, 0, 0, 0.61111],
    "8658": [-0.13313, 0.36687, 0, 0, 1],
    "8659": [0.19444, 0.69444, 0, 0, 0.61111],
    "8660": [-0.13313, 0.36687, 0, 0, 1],
    "8661": [0.25, 0.75, 0, 0, 0.61111],
    "8704": [0, 0.69444, 0, 0, 0.55556],
    "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
    "8707": [0, 0.69444, 0, 0, 0.55556],
    "8709": [0.05556, 0.75, 0, 0, 0.5],
    "8711": [0, 0.68333, 0, 0, 0.83334],
    "8712": [0.0391, 0.5391, 0, 0, 0.66667],
    "8715": [0.0391, 0.5391, 0, 0, 0.66667],
    "8722": [0.08333, 0.58333, 0, 0, 0.77778],
    "8723": [0.08333, 0.58333, 0, 0, 0.77778],
    "8725": [0.25, 0.75, 0, 0, 0.5],
    "8726": [0.25, 0.75, 0, 0, 0.5],
    "8727": [-0.03472, 0.46528, 0, 0, 0.5],
    "8728": [-0.05555, 0.44445, 0, 0, 0.5],
    "8729": [-0.05555, 0.44445, 0, 0, 0.5],
    "8730": [0.2, 0.8, 0, 0, 0.83334],
    "8733": [0, 0.43056, 0, 0, 0.77778],
    "8734": [0, 0.43056, 0, 0, 1],
    "8736": [0, 0.69224, 0, 0, 0.72222],
    "8739": [0.25, 0.75, 0, 0, 0.27778],
    "8741": [0.25, 0.75, 0, 0, 0.5],
    "8743": [0, 0.55556, 0, 0, 0.66667],
    "8744": [0, 0.55556, 0, 0, 0.66667],
    "8745": [0, 0.55556, 0, 0, 0.66667],
    "8746": [0, 0.55556, 0, 0, 0.66667],
    "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
    "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
    "8768": [0.19444, 0.69444, 0, 0, 0.27778],
    "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8773": [-0.022, 0.589, 0, 0, 0.778],
    "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
    "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8784": [-0.133, 0.673, 0, 0, 0.778],
    "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
    "8804": [0.13597, 0.63597, 0, 0, 0.77778],
    "8805": [0.13597, 0.63597, 0, 0, 0.77778],
    "8810": [0.0391, 0.5391, 0, 0, 1],
    "8811": [0.0391, 0.5391, 0, 0, 1],
    "8826": [0.0391, 0.5391, 0, 0, 0.77778],
    "8827": [0.0391, 0.5391, 0, 0, 0.77778],
    "8834": [0.0391, 0.5391, 0, 0, 0.77778],
    "8835": [0.0391, 0.5391, 0, 0, 0.77778],
    "8838": [0.13597, 0.63597, 0, 0, 0.77778],
    "8839": [0.13597, 0.63597, 0, 0, 0.77778],
    "8846": [0, 0.55556, 0, 0, 0.66667],
    "8849": [0.13597, 0.63597, 0, 0, 0.77778],
    "8850": [0.13597, 0.63597, 0, 0, 0.77778],
    "8851": [0, 0.55556, 0, 0, 0.66667],
    "8852": [0, 0.55556, 0, 0, 0.66667],
    "8853": [0.08333, 0.58333, 0, 0, 0.77778],
    "8854": [0.08333, 0.58333, 0, 0, 0.77778],
    "8855": [0.08333, 0.58333, 0, 0, 0.77778],
    "8856": [0.08333, 0.58333, 0, 0, 0.77778],
    "8857": [0.08333, 0.58333, 0, 0, 0.77778],
    "8866": [0, 0.69444, 0, 0, 0.61111],
    "8867": [0, 0.69444, 0, 0, 0.61111],
    "8868": [0, 0.69444, 0, 0, 0.77778],
    "8869": [0, 0.69444, 0, 0, 0.77778],
    "8872": [0.249, 0.75, 0, 0, 0.867],
    "8900": [-0.05555, 0.44445, 0, 0, 0.5],
    "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
    "8902": [-0.03472, 0.46528, 0, 0, 0.5],
    "8904": [5e-3, 0.505, 0, 0, 0.9],
    "8942": [0.03, 0.903, 0, 0, 0.278],
    "8943": [-0.19, 0.313, 0, 0, 1.172],
    "8945": [-0.1, 0.823, 0, 0, 1.282],
    "8968": [0.25, 0.75, 0, 0, 0.44445],
    "8969": [0.25, 0.75, 0, 0, 0.44445],
    "8970": [0.25, 0.75, 0, 0, 0.44445],
    "8971": [0.25, 0.75, 0, 0, 0.44445],
    "8994": [-0.14236, 0.35764, 0, 0, 1],
    "8995": [-0.14236, 0.35764, 0, 0, 1],
    "9136": [0.244, 0.744, 0, 0, 0.412],
    "9137": [0.244, 0.745, 0, 0, 0.412],
    "9651": [0.19444, 0.69444, 0, 0, 0.88889],
    "9657": [-0.03472, 0.46528, 0, 0, 0.5],
    "9661": [0.19444, 0.69444, 0, 0, 0.88889],
    "9667": [-0.03472, 0.46528, 0, 0, 0.5],
    "9711": [0.19444, 0.69444, 0, 0, 1],
    "9824": [0.12963, 0.69444, 0, 0, 0.77778],
    "9825": [0.12963, 0.69444, 0, 0, 0.77778],
    "9826": [0.12963, 0.69444, 0, 0, 0.77778],
    "9827": [0.12963, 0.69444, 0, 0, 0.77778],
    "9837": [0, 0.75, 0, 0, 0.38889],
    "9838": [0.19444, 0.69444, 0, 0, 0.38889],
    "9839": [0.19444, 0.69444, 0, 0, 0.38889],
    "10216": [0.25, 0.75, 0, 0, 0.38889],
    "10217": [0.25, 0.75, 0, 0, 0.38889],
    "10222": [0.244, 0.744, 0, 0, 0.412],
    "10223": [0.244, 0.745, 0, 0, 0.412],
    "10229": [0.011, 0.511, 0, 0, 1.609],
    "10230": [0.011, 0.511, 0, 0, 1.638],
    "10231": [0.011, 0.511, 0, 0, 1.859],
    "10232": [0.024, 0.525, 0, 0, 1.609],
    "10233": [0.024, 0.525, 0, 0, 1.638],
    "10234": [0.024, 0.525, 0, 0, 1.858],
    "10236": [0.011, 0.511, 0, 0, 1.638],
    "10815": [0, 0.68333, 0, 0, 0.75],
    "10927": [0.13597, 0.63597, 0, 0, 0.77778],
    "10928": [0.13597, 0.63597, 0, 0, 0.77778],
    "57376": [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    "32": [0, 0, 0, 0, 0.25],
    "48": [0, 0.44444, 0, 0, 0.575],
    "49": [0, 0.44444, 0, 0, 0.575],
    "50": [0, 0.44444, 0, 0, 0.575],
    "51": [0.19444, 0.44444, 0, 0, 0.575],
    "52": [0.19444, 0.44444, 0, 0, 0.575],
    "53": [0.19444, 0.44444, 0, 0, 0.575],
    "54": [0, 0.64444, 0, 0, 0.575],
    "55": [0.19444, 0.44444, 0, 0, 0.575],
    "56": [0, 0.64444, 0, 0, 0.575],
    "57": [0.19444, 0.44444, 0, 0, 0.575],
    "65": [0, 0.68611, 0, 0, 0.86944],
    "66": [0, 0.68611, 0.04835, 0, 0.8664],
    "67": [0, 0.68611, 0.06979, 0, 0.81694],
    "68": [0, 0.68611, 0.03194, 0, 0.93812],
    "69": [0, 0.68611, 0.05451, 0, 0.81007],
    "70": [0, 0.68611, 0.15972, 0, 0.68889],
    "71": [0, 0.68611, 0, 0, 0.88673],
    "72": [0, 0.68611, 0.08229, 0, 0.98229],
    "73": [0, 0.68611, 0.07778, 0, 0.51111],
    "74": [0, 0.68611, 0.10069, 0, 0.63125],
    "75": [0, 0.68611, 0.06979, 0, 0.97118],
    "76": [0, 0.68611, 0, 0, 0.75555],
    "77": [0, 0.68611, 0.11424, 0, 1.14201],
    "78": [0, 0.68611, 0.11424, 0, 0.95034],
    "79": [0, 0.68611, 0.03194, 0, 0.83666],
    "80": [0, 0.68611, 0.15972, 0, 0.72309],
    "81": [0.19444, 0.68611, 0, 0, 0.86861],
    "82": [0, 0.68611, 421e-5, 0, 0.87235],
    "83": [0, 0.68611, 0.05382, 0, 0.69271],
    "84": [0, 0.68611, 0.15972, 0, 0.63663],
    "85": [0, 0.68611, 0.11424, 0, 0.80027],
    "86": [0, 0.68611, 0.25555, 0, 0.67778],
    "87": [0, 0.68611, 0.15972, 0, 1.09305],
    "88": [0, 0.68611, 0.07778, 0, 0.94722],
    "89": [0, 0.68611, 0.25555, 0, 0.67458],
    "90": [0, 0.68611, 0.06979, 0, 0.77257],
    "97": [0, 0.44444, 0, 0, 0.63287],
    "98": [0, 0.69444, 0, 0, 0.52083],
    "99": [0, 0.44444, 0, 0, 0.51342],
    "100": [0, 0.69444, 0, 0, 0.60972],
    "101": [0, 0.44444, 0, 0, 0.55361],
    "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
    "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
    "104": [0, 0.69444, 0, 0, 0.66759],
    "105": [0, 0.69326, 0, 0, 0.4048],
    "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
    "107": [0, 0.69444, 0.01852, 0, 0.6037],
    "108": [0, 0.69444, 88e-4, 0, 0.34815],
    "109": [0, 0.44444, 0, 0, 1.0324],
    "110": [0, 0.44444, 0, 0, 0.71296],
    "111": [0, 0.44444, 0, 0, 0.58472],
    "112": [0.19444, 0.44444, 0, 0, 0.60092],
    "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
    "114": [0, 0.44444, 0.03194, 0, 0.5287],
    "115": [0, 0.44444, 0, 0, 0.53125],
    "116": [0, 0.63492, 0, 0, 0.41528],
    "117": [0, 0.44444, 0, 0, 0.68102],
    "118": [0, 0.44444, 0.03704, 0, 0.56666],
    "119": [0, 0.44444, 0.02778, 0, 0.83148],
    "120": [0, 0.44444, 0, 0, 0.65903],
    "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
    "122": [0, 0.44444, 0.04213, 0, 0.55509],
    "160": [0, 0, 0, 0, 0.25],
    "915": [0, 0.68611, 0.15972, 0, 0.65694],
    "916": [0, 0.68611, 0, 0, 0.95833],
    "920": [0, 0.68611, 0.03194, 0, 0.86722],
    "923": [0, 0.68611, 0, 0, 0.80555],
    "926": [0, 0.68611, 0.07458, 0, 0.84125],
    "928": [0, 0.68611, 0.08229, 0, 0.98229],
    "931": [0, 0.68611, 0.05451, 0, 0.88507],
    "933": [0, 0.68611, 0.15972, 0, 0.67083],
    "934": [0, 0.68611, 0, 0, 0.76666],
    "936": [0, 0.68611, 0.11653, 0, 0.71402],
    "937": [0, 0.68611, 0.04835, 0, 0.8789],
    "945": [0, 0.44444, 0, 0, 0.76064],
    "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
    "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
    "948": [0, 0.69444, 0.03819, 0, 0.52222],
    "949": [0, 0.44444, 0, 0, 0.52882],
    "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
    "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
    "952": [0, 0.69444, 0.03194, 0, 0.5618],
    "953": [0, 0.44444, 0, 0, 0.41204],
    "954": [0, 0.44444, 0, 0, 0.66759],
    "955": [0, 0.69444, 0, 0, 0.67083],
    "956": [0.19444, 0.44444, 0, 0, 0.70787],
    "957": [0, 0.44444, 0.06898, 0, 0.57685],
    "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
    "959": [0, 0.44444, 0, 0, 0.58472],
    "960": [0, 0.44444, 0.03704, 0, 0.68241],
    "961": [0.19444, 0.44444, 0, 0, 0.6118],
    "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
    "963": [0, 0.44444, 0.03704, 0, 0.68588],
    "964": [0, 0.44444, 0.13472, 0, 0.52083],
    "965": [0, 0.44444, 0.03704, 0, 0.63055],
    "966": [0.19444, 0.44444, 0, 0, 0.74722],
    "967": [0.19444, 0.44444, 0, 0, 0.71805],
    "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
    "969": [0, 0.44444, 0.03704, 0, 0.71782],
    "977": [0, 0.69444, 0, 0, 0.69155],
    "981": [0.19444, 0.69444, 0, 0, 0.7125],
    "982": [0, 0.44444, 0.03194, 0, 0.975],
    "1009": [0.19444, 0.44444, 0, 0, 0.6118],
    "1013": [0, 0.44444, 0, 0, 0.48333],
    "57649": [0, 0.44444, 0, 0, 0.39352],
    "57911": [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "48": [0, 0.43056, 0, 0, 0.5],
    "49": [0, 0.43056, 0, 0, 0.5],
    "50": [0, 0.43056, 0, 0, 0.5],
    "51": [0.19444, 0.43056, 0, 0, 0.5],
    "52": [0.19444, 0.43056, 0, 0, 0.5],
    "53": [0.19444, 0.43056, 0, 0, 0.5],
    "54": [0, 0.64444, 0, 0, 0.5],
    "55": [0.19444, 0.43056, 0, 0, 0.5],
    "56": [0, 0.64444, 0, 0, 0.5],
    "57": [0.19444, 0.43056, 0, 0, 0.5],
    "65": [0, 0.68333, 0, 0.13889, 0.75],
    "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
    "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
    "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
    "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
    "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
    "71": [0, 0.68333, 0, 0.08334, 0.78625],
    "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
    "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
    "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
    "76": [0, 0.68333, 0, 0.02778, 0.68056],
    "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
    "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
    "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
    "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
    "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
    "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
    "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
    "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
    "86": [0, 0.68333, 0.22222, 0, 0.58333],
    "87": [0, 0.68333, 0.13889, 0, 0.94445],
    "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
    "89": [0, 0.68333, 0.22222, 0, 0.58056],
    "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
    "97": [0, 0.43056, 0, 0, 0.52859],
    "98": [0, 0.69444, 0, 0, 0.42917],
    "99": [0, 0.43056, 0, 0.05556, 0.43276],
    "100": [0, 0.69444, 0, 0.16667, 0.52049],
    "101": [0, 0.43056, 0, 0.05556, 0.46563],
    "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    "104": [0, 0.69444, 0, 0, 0.57616],
    "105": [0, 0.65952, 0, 0, 0.34451],
    "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
    "107": [0, 0.69444, 0.03148, 0, 0.5206],
    "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
    "109": [0, 0.43056, 0, 0, 0.87801],
    "110": [0, 0.43056, 0, 0, 0.60023],
    "111": [0, 0.43056, 0, 0.05556, 0.48472],
    "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
    "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
    "115": [0, 0.43056, 0, 0.05556, 0.46875],
    "116": [0, 0.61508, 0, 0.08334, 0.36111],
    "117": [0, 0.43056, 0, 0.02778, 0.57246],
    "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
    "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
    "120": [0, 0.43056, 0, 0.02778, 0.57153],
    "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
    "160": [0, 0, 0, 0, 0.25],
    "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
    "916": [0, 0.68333, 0, 0.16667, 0.83334],
    "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
    "923": [0, 0.68333, 0, 0.16667, 0.69445],
    "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
    "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
    "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
    "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
    "934": [0, 0.68333, 0, 0.08334, 0.66667],
    "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
    "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
    "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
    "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
    "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
    "949": [0, 0.43056, 0, 0.08334, 0.46632],
    "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
    "953": [0, 0.43056, 0, 0.05556, 0.35394],
    "954": [0, 0.43056, 0, 0, 0.57616],
    "955": [0, 0.69444, 0, 0, 0.58334],
    "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
    "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
    "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    "959": [0, 0.43056, 0, 0.05556, 0.48472],
    "960": [0, 0.43056, 0.03588, 0, 0.57003],
    "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    "963": [0, 0.43056, 0.03588, 0, 0.57141],
    "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
    "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
    "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
    "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
    "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    "969": [0, 0.43056, 0.03588, 0, 0.62245],
    "977": [0, 0.69444, 0, 0.08334, 0.59144],
    "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
    "982": [0, 0.43056, 0.02778, 0, 0.82813],
    "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
    "1013": [0, 0.43056, 0, 0.05556, 0.4059],
    "57649": [0, 0.43056, 0, 0.02778, 0.32246],
    "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.36667],
    "34": [0, 0.69444, 0, 0, 0.55834],
    "35": [0.19444, 0.69444, 0, 0, 0.91667],
    "36": [0.05556, 0.75, 0, 0, 0.55],
    "37": [0.05556, 0.75, 0, 0, 1.02912],
    "38": [0, 0.69444, 0, 0, 0.83056],
    "39": [0, 0.69444, 0, 0, 0.30556],
    "40": [0.25, 0.75, 0, 0, 0.42778],
    "41": [0.25, 0.75, 0, 0, 0.42778],
    "42": [0, 0.75, 0, 0, 0.55],
    "43": [0.11667, 0.61667, 0, 0, 0.85556],
    "44": [0.10556, 0.13056, 0, 0, 0.30556],
    "45": [0, 0.45833, 0, 0, 0.36667],
    "46": [0, 0.13056, 0, 0, 0.30556],
    "47": [0.25, 0.75, 0, 0, 0.55],
    "48": [0, 0.69444, 0, 0, 0.55],
    "49": [0, 0.69444, 0, 0, 0.55],
    "50": [0, 0.69444, 0, 0, 0.55],
    "51": [0, 0.69444, 0, 0, 0.55],
    "52": [0, 0.69444, 0, 0, 0.55],
    "53": [0, 0.69444, 0, 0, 0.55],
    "54": [0, 0.69444, 0, 0, 0.55],
    "55": [0, 0.69444, 0, 0, 0.55],
    "56": [0, 0.69444, 0, 0, 0.55],
    "57": [0, 0.69444, 0, 0, 0.55],
    "58": [0, 0.45833, 0, 0, 0.30556],
    "59": [0.10556, 0.45833, 0, 0, 0.30556],
    "61": [-0.09375, 0.40625, 0, 0, 0.85556],
    "63": [0, 0.69444, 0, 0, 0.51945],
    "64": [0, 0.69444, 0, 0, 0.73334],
    "65": [0, 0.69444, 0, 0, 0.73334],
    "66": [0, 0.69444, 0, 0, 0.73334],
    "67": [0, 0.69444, 0, 0, 0.70278],
    "68": [0, 0.69444, 0, 0, 0.79445],
    "69": [0, 0.69444, 0, 0, 0.64167],
    "70": [0, 0.69444, 0, 0, 0.61111],
    "71": [0, 0.69444, 0, 0, 0.73334],
    "72": [0, 0.69444, 0, 0, 0.79445],
    "73": [0, 0.69444, 0, 0, 0.33056],
    "74": [0, 0.69444, 0, 0, 0.51945],
    "75": [0, 0.69444, 0, 0, 0.76389],
    "76": [0, 0.69444, 0, 0, 0.58056],
    "77": [0, 0.69444, 0, 0, 0.97778],
    "78": [0, 0.69444, 0, 0, 0.79445],
    "79": [0, 0.69444, 0, 0, 0.79445],
    "80": [0, 0.69444, 0, 0, 0.70278],
    "81": [0.10556, 0.69444, 0, 0, 0.79445],
    "82": [0, 0.69444, 0, 0, 0.70278],
    "83": [0, 0.69444, 0, 0, 0.61111],
    "84": [0, 0.69444, 0, 0, 0.73334],
    "85": [0, 0.69444, 0, 0, 0.76389],
    "86": [0, 0.69444, 0.01528, 0, 0.73334],
    "87": [0, 0.69444, 0.01528, 0, 1.03889],
    "88": [0, 0.69444, 0, 0, 0.73334],
    "89": [0, 0.69444, 0.0275, 0, 0.73334],
    "90": [0, 0.69444, 0, 0, 0.67223],
    "91": [0.25, 0.75, 0, 0, 0.34306],
    "93": [0.25, 0.75, 0, 0, 0.34306],
    "94": [0, 0.69444, 0, 0, 0.55],
    "95": [0.35, 0.10833, 0.03056, 0, 0.55],
    "97": [0, 0.45833, 0, 0, 0.525],
    "98": [0, 0.69444, 0, 0, 0.56111],
    "99": [0, 0.45833, 0, 0, 0.48889],
    "100": [0, 0.69444, 0, 0, 0.56111],
    "101": [0, 0.45833, 0, 0, 0.51111],
    "102": [0, 0.69444, 0.07639, 0, 0.33611],
    "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
    "104": [0, 0.69444, 0, 0, 0.56111],
    "105": [0, 0.69444, 0, 0, 0.25556],
    "106": [0.19444, 0.69444, 0, 0, 0.28611],
    "107": [0, 0.69444, 0, 0, 0.53056],
    "108": [0, 0.69444, 0, 0, 0.25556],
    "109": [0, 0.45833, 0, 0, 0.86667],
    "110": [0, 0.45833, 0, 0, 0.56111],
    "111": [0, 0.45833, 0, 0, 0.55],
    "112": [0.19444, 0.45833, 0, 0, 0.56111],
    "113": [0.19444, 0.45833, 0, 0, 0.56111],
    "114": [0, 0.45833, 0.01528, 0, 0.37222],
    "115": [0, 0.45833, 0, 0, 0.42167],
    "116": [0, 0.58929, 0, 0, 0.40417],
    "117": [0, 0.45833, 0, 0, 0.56111],
    "118": [0, 0.45833, 0.01528, 0, 0.5],
    "119": [0, 0.45833, 0.01528, 0, 0.74445],
    "120": [0, 0.45833, 0, 0, 0.5],
    "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
    "122": [0, 0.45833, 0, 0, 0.47639],
    "126": [0.35, 0.34444, 0, 0, 0.55],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.69444, 0, 0, 0.55],
    "176": [0, 0.69444, 0, 0, 0.73334],
    "180": [0, 0.69444, 0, 0, 0.55],
    "184": [0.17014, 0, 0, 0, 0.48889],
    "305": [0, 0.45833, 0, 0, 0.25556],
    "567": [0.19444, 0.45833, 0, 0, 0.28611],
    "710": [0, 0.69444, 0, 0, 0.55],
    "711": [0, 0.63542, 0, 0, 0.55],
    "713": [0, 0.63778, 0, 0, 0.55],
    "728": [0, 0.69444, 0, 0, 0.55],
    "729": [0, 0.69444, 0, 0, 0.30556],
    "730": [0, 0.69444, 0, 0, 0.73334],
    "732": [0, 0.69444, 0, 0, 0.55],
    "733": [0, 0.69444, 0, 0, 0.55],
    "915": [0, 0.69444, 0, 0, 0.58056],
    "916": [0, 0.69444, 0, 0, 0.91667],
    "920": [0, 0.69444, 0, 0, 0.85556],
    "923": [0, 0.69444, 0, 0, 0.67223],
    "926": [0, 0.69444, 0, 0, 0.73334],
    "928": [0, 0.69444, 0, 0, 0.79445],
    "931": [0, 0.69444, 0, 0, 0.79445],
    "933": [0, 0.69444, 0, 0, 0.85556],
    "934": [0, 0.69444, 0, 0, 0.79445],
    "936": [0, 0.69444, 0, 0, 0.85556],
    "937": [0, 0.69444, 0, 0, 0.79445],
    "8211": [0, 0.45833, 0.03056, 0, 0.55],
    "8212": [0, 0.45833, 0.03056, 0, 1.10001],
    "8216": [0, 0.69444, 0, 0, 0.30556],
    "8217": [0, 0.69444, 0, 0, 0.30556],
    "8220": [0, 0.69444, 0, 0, 0.55834],
    "8221": [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0.05733, 0, 0.31945],
    "34": [0, 0.69444, 316e-5, 0, 0.5],
    "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
    "36": [0.05556, 0.75, 0.11156, 0, 0.5],
    "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
    "38": [0, 0.69444, 0.03058, 0, 0.75834],
    "39": [0, 0.69444, 0.07816, 0, 0.27778],
    "40": [0.25, 0.75, 0.13164, 0, 0.38889],
    "41": [0.25, 0.75, 0.02536, 0, 0.38889],
    "42": [0, 0.75, 0.11775, 0, 0.5],
    "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
    "44": [0.125, 0.08333, 0, 0, 0.27778],
    "45": [0, 0.44444, 0.01946, 0, 0.33333],
    "46": [0, 0.08333, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0.13164, 0, 0.5],
    "48": [0, 0.65556, 0.11156, 0, 0.5],
    "49": [0, 0.65556, 0.11156, 0, 0.5],
    "50": [0, 0.65556, 0.11156, 0, 0.5],
    "51": [0, 0.65556, 0.11156, 0, 0.5],
    "52": [0, 0.65556, 0.11156, 0, 0.5],
    "53": [0, 0.65556, 0.11156, 0, 0.5],
    "54": [0, 0.65556, 0.11156, 0, 0.5],
    "55": [0, 0.65556, 0.11156, 0, 0.5],
    "56": [0, 0.65556, 0.11156, 0, 0.5],
    "57": [0, 0.65556, 0.11156, 0, 0.5],
    "58": [0, 0.44444, 0.02502, 0, 0.27778],
    "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
    "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
    "63": [0, 0.69444, 0.11809, 0, 0.47222],
    "64": [0, 0.69444, 0.07555, 0, 0.66667],
    "65": [0, 0.69444, 0, 0, 0.66667],
    "66": [0, 0.69444, 0.08293, 0, 0.66667],
    "67": [0, 0.69444, 0.11983, 0, 0.63889],
    "68": [0, 0.69444, 0.07555, 0, 0.72223],
    "69": [0, 0.69444, 0.11983, 0, 0.59722],
    "70": [0, 0.69444, 0.13372, 0, 0.56945],
    "71": [0, 0.69444, 0.11983, 0, 0.66667],
    "72": [0, 0.69444, 0.08094, 0, 0.70834],
    "73": [0, 0.69444, 0.13372, 0, 0.27778],
    "74": [0, 0.69444, 0.08094, 0, 0.47222],
    "75": [0, 0.69444, 0.11983, 0, 0.69445],
    "76": [0, 0.69444, 0, 0, 0.54167],
    "77": [0, 0.69444, 0.08094, 0, 0.875],
    "78": [0, 0.69444, 0.08094, 0, 0.70834],
    "79": [0, 0.69444, 0.07555, 0, 0.73611],
    "80": [0, 0.69444, 0.08293, 0, 0.63889],
    "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
    "82": [0, 0.69444, 0.08293, 0, 0.64584],
    "83": [0, 0.69444, 0.09205, 0, 0.55556],
    "84": [0, 0.69444, 0.13372, 0, 0.68056],
    "85": [0, 0.69444, 0.08094, 0, 0.6875],
    "86": [0, 0.69444, 0.1615, 0, 0.66667],
    "87": [0, 0.69444, 0.1615, 0, 0.94445],
    "88": [0, 0.69444, 0.13372, 0, 0.66667],
    "89": [0, 0.69444, 0.17261, 0, 0.66667],
    "90": [0, 0.69444, 0.11983, 0, 0.61111],
    "91": [0.25, 0.75, 0.15942, 0, 0.28889],
    "93": [0.25, 0.75, 0.08719, 0, 0.28889],
    "94": [0, 0.69444, 0.0799, 0, 0.5],
    "95": [0.35, 0.09444, 0.08616, 0, 0.5],
    "97": [0, 0.44444, 981e-5, 0, 0.48056],
    "98": [0, 0.69444, 0.03057, 0, 0.51667],
    "99": [0, 0.44444, 0.08336, 0, 0.44445],
    "100": [0, 0.69444, 0.09483, 0, 0.51667],
    "101": [0, 0.44444, 0.06778, 0, 0.44445],
    "102": [0, 0.69444, 0.21705, 0, 0.30556],
    "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
    "104": [0, 0.69444, 0.01778, 0, 0.51667],
    "105": [0, 0.67937, 0.09718, 0, 0.23889],
    "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
    "107": [0, 0.69444, 0.08336, 0, 0.48889],
    "108": [0, 0.69444, 0.09483, 0, 0.23889],
    "109": [0, 0.44444, 0.01778, 0, 0.79445],
    "110": [0, 0.44444, 0.01778, 0, 0.51667],
    "111": [0, 0.44444, 0.06613, 0, 0.5],
    "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
    "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
    "114": [0, 0.44444, 0.10836, 0, 0.34167],
    "115": [0, 0.44444, 0.0778, 0, 0.38333],
    "116": [0, 0.57143, 0.07225, 0, 0.36111],
    "117": [0, 0.44444, 0.04169, 0, 0.51667],
    "118": [0, 0.44444, 0.10836, 0, 0.46111],
    "119": [0, 0.44444, 0.10836, 0, 0.68334],
    "120": [0, 0.44444, 0.09169, 0, 0.46111],
    "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
    "122": [0, 0.44444, 0.08752, 0, 0.43472],
    "126": [0.35, 0.32659, 0.08826, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.67937, 0.06385, 0, 0.5],
    "176": [0, 0.69444, 0, 0, 0.73752],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "305": [0, 0.44444, 0.04169, 0, 0.23889],
    "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
    "710": [0, 0.69444, 0.0799, 0, 0.5],
    "711": [0, 0.63194, 0.08432, 0, 0.5],
    "713": [0, 0.60889, 0.08776, 0, 0.5],
    "714": [0, 0.69444, 0.09205, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0.09483, 0, 0.5],
    "729": [0, 0.67937, 0.07774, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.73752],
    "732": [0, 0.67659, 0.08826, 0, 0.5],
    "733": [0, 0.69444, 0.09205, 0, 0.5],
    "915": [0, 0.69444, 0.13372, 0, 0.54167],
    "916": [0, 0.69444, 0, 0, 0.83334],
    "920": [0, 0.69444, 0.07555, 0, 0.77778],
    "923": [0, 0.69444, 0, 0, 0.61111],
    "926": [0, 0.69444, 0.12816, 0, 0.66667],
    "928": [0, 0.69444, 0.08094, 0, 0.70834],
    "931": [0, 0.69444, 0.11983, 0, 0.72222],
    "933": [0, 0.69444, 0.09031, 0, 0.77778],
    "934": [0, 0.69444, 0.04603, 0, 0.72222],
    "936": [0, 0.69444, 0.09031, 0, 0.77778],
    "937": [0, 0.69444, 0.08293, 0, 0.72222],
    "8211": [0, 0.44444, 0.08616, 0, 0.5],
    "8212": [0, 0.44444, 0.08616, 0, 1],
    "8216": [0, 0.69444, 0.07816, 0, 0.27778],
    "8217": [0, 0.69444, 0.07816, 0, 0.27778],
    "8220": [0, 0.69444, 0.14205, 0, 0.5],
    "8221": [0, 0.69444, 316e-5, 0, 0.5]
  },
  "SansSerif-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "33": [0, 0.69444, 0, 0, 0.31945],
    "34": [0, 0.69444, 0, 0, 0.5],
    "35": [0.19444, 0.69444, 0, 0, 0.83334],
    "36": [0.05556, 0.75, 0, 0, 0.5],
    "37": [0.05556, 0.75, 0, 0, 0.83334],
    "38": [0, 0.69444, 0, 0, 0.75834],
    "39": [0, 0.69444, 0, 0, 0.27778],
    "40": [0.25, 0.75, 0, 0, 0.38889],
    "41": [0.25, 0.75, 0, 0, 0.38889],
    "42": [0, 0.75, 0, 0, 0.5],
    "43": [0.08333, 0.58333, 0, 0, 0.77778],
    "44": [0.125, 0.08333, 0, 0, 0.27778],
    "45": [0, 0.44444, 0, 0, 0.33333],
    "46": [0, 0.08333, 0, 0, 0.27778],
    "47": [0.25, 0.75, 0, 0, 0.5],
    "48": [0, 0.65556, 0, 0, 0.5],
    "49": [0, 0.65556, 0, 0, 0.5],
    "50": [0, 0.65556, 0, 0, 0.5],
    "51": [0, 0.65556, 0, 0, 0.5],
    "52": [0, 0.65556, 0, 0, 0.5],
    "53": [0, 0.65556, 0, 0, 0.5],
    "54": [0, 0.65556, 0, 0, 0.5],
    "55": [0, 0.65556, 0, 0, 0.5],
    "56": [0, 0.65556, 0, 0, 0.5],
    "57": [0, 0.65556, 0, 0, 0.5],
    "58": [0, 0.44444, 0, 0, 0.27778],
    "59": [0.125, 0.44444, 0, 0, 0.27778],
    "61": [-0.13, 0.37, 0, 0, 0.77778],
    "63": [0, 0.69444, 0, 0, 0.47222],
    "64": [0, 0.69444, 0, 0, 0.66667],
    "65": [0, 0.69444, 0, 0, 0.66667],
    "66": [0, 0.69444, 0, 0, 0.66667],
    "67": [0, 0.69444, 0, 0, 0.63889],
    "68": [0, 0.69444, 0, 0, 0.72223],
    "69": [0, 0.69444, 0, 0, 0.59722],
    "70": [0, 0.69444, 0, 0, 0.56945],
    "71": [0, 0.69444, 0, 0, 0.66667],
    "72": [0, 0.69444, 0, 0, 0.70834],
    "73": [0, 0.69444, 0, 0, 0.27778],
    "74": [0, 0.69444, 0, 0, 0.47222],
    "75": [0, 0.69444, 0, 0, 0.69445],
    "76": [0, 0.69444, 0, 0, 0.54167],
    "77": [0, 0.69444, 0, 0, 0.875],
    "78": [0, 0.69444, 0, 0, 0.70834],
    "79": [0, 0.69444, 0, 0, 0.73611],
    "80": [0, 0.69444, 0, 0, 0.63889],
    "81": [0.125, 0.69444, 0, 0, 0.73611],
    "82": [0, 0.69444, 0, 0, 0.64584],
    "83": [0, 0.69444, 0, 0, 0.55556],
    "84": [0, 0.69444, 0, 0, 0.68056],
    "85": [0, 0.69444, 0, 0, 0.6875],
    "86": [0, 0.69444, 0.01389, 0, 0.66667],
    "87": [0, 0.69444, 0.01389, 0, 0.94445],
    "88": [0, 0.69444, 0, 0, 0.66667],
    "89": [0, 0.69444, 0.025, 0, 0.66667],
    "90": [0, 0.69444, 0, 0, 0.61111],
    "91": [0.25, 0.75, 0, 0, 0.28889],
    "93": [0.25, 0.75, 0, 0, 0.28889],
    "94": [0, 0.69444, 0, 0, 0.5],
    "95": [0.35, 0.09444, 0.02778, 0, 0.5],
    "97": [0, 0.44444, 0, 0, 0.48056],
    "98": [0, 0.69444, 0, 0, 0.51667],
    "99": [0, 0.44444, 0, 0, 0.44445],
    "100": [0, 0.69444, 0, 0, 0.51667],
    "101": [0, 0.44444, 0, 0, 0.44445],
    "102": [0, 0.69444, 0.06944, 0, 0.30556],
    "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
    "104": [0, 0.69444, 0, 0, 0.51667],
    "105": [0, 0.67937, 0, 0, 0.23889],
    "106": [0.19444, 0.67937, 0, 0, 0.26667],
    "107": [0, 0.69444, 0, 0, 0.48889],
    "108": [0, 0.69444, 0, 0, 0.23889],
    "109": [0, 0.44444, 0, 0, 0.79445],
    "110": [0, 0.44444, 0, 0, 0.51667],
    "111": [0, 0.44444, 0, 0, 0.5],
    "112": [0.19444, 0.44444, 0, 0, 0.51667],
    "113": [0.19444, 0.44444, 0, 0, 0.51667],
    "114": [0, 0.44444, 0.01389, 0, 0.34167],
    "115": [0, 0.44444, 0, 0, 0.38333],
    "116": [0, 0.57143, 0, 0, 0.36111],
    "117": [0, 0.44444, 0, 0, 0.51667],
    "118": [0, 0.44444, 0.01389, 0, 0.46111],
    "119": [0, 0.44444, 0.01389, 0, 0.68334],
    "120": [0, 0.44444, 0, 0, 0.46111],
    "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
    "122": [0, 0.44444, 0, 0, 0.43472],
    "126": [0.35, 0.32659, 0, 0, 0.5],
    "160": [0, 0, 0, 0, 0.25],
    "168": [0, 0.67937, 0, 0, 0.5],
    "176": [0, 0.69444, 0, 0, 0.66667],
    "184": [0.17014, 0, 0, 0, 0.44445],
    "305": [0, 0.44444, 0, 0, 0.23889],
    "567": [0.19444, 0.44444, 0, 0, 0.26667],
    "710": [0, 0.69444, 0, 0, 0.5],
    "711": [0, 0.63194, 0, 0, 0.5],
    "713": [0, 0.60889, 0, 0, 0.5],
    "714": [0, 0.69444, 0, 0, 0.5],
    "715": [0, 0.69444, 0, 0, 0.5],
    "728": [0, 0.69444, 0, 0, 0.5],
    "729": [0, 0.67937, 0, 0, 0.27778],
    "730": [0, 0.69444, 0, 0, 0.66667],
    "732": [0, 0.67659, 0, 0, 0.5],
    "733": [0, 0.69444, 0, 0, 0.5],
    "915": [0, 0.69444, 0, 0, 0.54167],
    "916": [0, 0.69444, 0, 0, 0.83334],
    "920": [0, 0.69444, 0, 0, 0.77778],
    "923": [0, 0.69444, 0, 0, 0.61111],
    "926": [0, 0.69444, 0, 0, 0.66667],
    "928": [0, 0.69444, 0, 0, 0.70834],
    "931": [0, 0.69444, 0, 0, 0.72222],
    "933": [0, 0.69444, 0, 0, 0.77778],
    "934": [0, 0.69444, 0, 0, 0.72222],
    "936": [0, 0.69444, 0, 0, 0.77778],
    "937": [0, 0.69444, 0, 0, 0.72222],
    "8211": [0, 0.44444, 0.02778, 0, 0.5],
    "8212": [0, 0.44444, 0.02778, 0, 1],
    "8216": [0, 0.69444, 0, 0, 0.27778],
    "8217": [0, 0.69444, 0, 0, 0.27778],
    "8220": [0, 0.69444, 0, 0, 0.5],
    "8221": [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "65": [0, 0.7, 0.22925, 0, 0.80253],
    "66": [0, 0.7, 0.04087, 0, 0.90757],
    "67": [0, 0.7, 0.1689, 0, 0.66619],
    "68": [0, 0.7, 0.09371, 0, 0.77443],
    "69": [0, 0.7, 0.18583, 0, 0.56162],
    "70": [0, 0.7, 0.13634, 0, 0.89544],
    "71": [0, 0.7, 0.17322, 0, 0.60961],
    "72": [0, 0.7, 0.29694, 0, 0.96919],
    "73": [0, 0.7, 0.19189, 0, 0.80907],
    "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
    "75": [0, 0.7, 0.31259, 0, 0.91364],
    "76": [0, 0.7, 0.19189, 0, 0.87373],
    "77": [0, 0.7, 0.15981, 0, 1.08031],
    "78": [0, 0.7, 0.3525, 0, 0.9015],
    "79": [0, 0.7, 0.08078, 0, 0.73787],
    "80": [0, 0.7, 0.08078, 0, 1.01262],
    "81": [0, 0.7, 0.03305, 0, 0.88282],
    "82": [0, 0.7, 0.06259, 0, 0.85],
    "83": [0, 0.7, 0.19189, 0, 0.86767],
    "84": [0, 0.7, 0.29087, 0, 0.74697],
    "85": [0, 0.7, 0.25815, 0, 0.79996],
    "86": [0, 0.7, 0.27523, 0, 0.62204],
    "87": [0, 0.7, 0.27523, 0, 0.80532],
    "88": [0, 0.7, 0.26006, 0, 0.94445],
    "89": [0, 0.7, 0.2939, 0, 0.70961],
    "90": [0, 0.7, 0.24037, 0, 0.8212],
    "160": [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.35001, 0.85, 0, 0, 0.45834],
    "41": [0.35001, 0.85, 0, 0, 0.45834],
    "47": [0.35001, 0.85, 0, 0, 0.57778],
    "91": [0.35001, 0.85, 0, 0, 0.41667],
    "92": [0.35001, 0.85, 0, 0, 0.57778],
    "93": [0.35001, 0.85, 0, 0, 0.41667],
    "123": [0.35001, 0.85, 0, 0, 0.58334],
    "125": [0.35001, 0.85, 0, 0, 0.58334],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.72222, 0, 0, 0.55556],
    "732": [0, 0.72222, 0, 0, 0.55556],
    "770": [0, 0.72222, 0, 0, 0.55556],
    "771": [0, 0.72222, 0, 0, 0.55556],
    "8214": [-99e-5, 0.601, 0, 0, 0.77778],
    "8593": [1e-5, 0.6, 0, 0, 0.66667],
    "8595": [1e-5, 0.6, 0, 0, 0.66667],
    "8657": [1e-5, 0.6, 0, 0, 0.77778],
    "8659": [1e-5, 0.6, 0, 0, 0.77778],
    "8719": [0.25001, 0.75, 0, 0, 0.94445],
    "8720": [0.25001, 0.75, 0, 0, 0.94445],
    "8721": [0.25001, 0.75, 0, 0, 1.05556],
    "8730": [0.35001, 0.85, 0, 0, 1],
    "8739": [-599e-5, 0.606, 0, 0, 0.33333],
    "8741": [-599e-5, 0.606, 0, 0, 0.55556],
    "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
    "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
    "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
    "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
    "8896": [0.25001, 0.75, 0, 0, 0.83334],
    "8897": [0.25001, 0.75, 0, 0, 0.83334],
    "8898": [0.25001, 0.75, 0, 0, 0.83334],
    "8899": [0.25001, 0.75, 0, 0, 0.83334],
    "8968": [0.35001, 0.85, 0, 0, 0.47222],
    "8969": [0.35001, 0.85, 0, 0, 0.47222],
    "8970": [0.35001, 0.85, 0, 0, 0.47222],
    "8971": [0.35001, 0.85, 0, 0, 0.47222],
    "9168": [-99e-5, 0.601, 0, 0, 0.66667],
    "10216": [0.35001, 0.85, 0, 0, 0.47222],
    "10217": [0.35001, 0.85, 0, 0, 0.47222],
    "10752": [0.25001, 0.75, 0, 0, 1.11111],
    "10753": [0.25001, 0.75, 0, 0, 1.11111],
    "10754": [0.25001, 0.75, 0, 0, 1.11111],
    "10756": [0.25001, 0.75, 0, 0, 0.83334],
    "10758": [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.65002, 1.15, 0, 0, 0.59722],
    "41": [0.65002, 1.15, 0, 0, 0.59722],
    "47": [0.65002, 1.15, 0, 0, 0.81111],
    "91": [0.65002, 1.15, 0, 0, 0.47222],
    "92": [0.65002, 1.15, 0, 0, 0.81111],
    "93": [0.65002, 1.15, 0, 0, 0.47222],
    "123": [0.65002, 1.15, 0, 0, 0.66667],
    "125": [0.65002, 1.15, 0, 0, 0.66667],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.75, 0, 0, 1],
    "732": [0, 0.75, 0, 0, 1],
    "770": [0, 0.75, 0, 0, 1],
    "771": [0, 0.75, 0, 0, 1],
    "8719": [0.55001, 1.05, 0, 0, 1.27778],
    "8720": [0.55001, 1.05, 0, 0, 1.27778],
    "8721": [0.55001, 1.05, 0, 0, 1.44445],
    "8730": [0.65002, 1.15, 0, 0, 1],
    "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
    "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
    "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
    "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
    "8896": [0.55001, 1.05, 0, 0, 1.11111],
    "8897": [0.55001, 1.05, 0, 0, 1.11111],
    "8898": [0.55001, 1.05, 0, 0, 1.11111],
    "8899": [0.55001, 1.05, 0, 0, 1.11111],
    "8968": [0.65002, 1.15, 0, 0, 0.52778],
    "8969": [0.65002, 1.15, 0, 0, 0.52778],
    "8970": [0.65002, 1.15, 0, 0, 0.52778],
    "8971": [0.65002, 1.15, 0, 0, 0.52778],
    "10216": [0.65002, 1.15, 0, 0, 0.61111],
    "10217": [0.65002, 1.15, 0, 0, 0.61111],
    "10752": [0.55001, 1.05, 0, 0, 1.51112],
    "10753": [0.55001, 1.05, 0, 0, 1.51112],
    "10754": [0.55001, 1.05, 0, 0, 1.51112],
    "10756": [0.55001, 1.05, 0, 0, 1.11111],
    "10758": [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [0.95003, 1.45, 0, 0, 0.73611],
    "41": [0.95003, 1.45, 0, 0, 0.73611],
    "47": [0.95003, 1.45, 0, 0, 1.04445],
    "91": [0.95003, 1.45, 0, 0, 0.52778],
    "92": [0.95003, 1.45, 0, 0, 1.04445],
    "93": [0.95003, 1.45, 0, 0, 0.52778],
    "123": [0.95003, 1.45, 0, 0, 0.75],
    "125": [0.95003, 1.45, 0, 0, 0.75],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.75, 0, 0, 1.44445],
    "732": [0, 0.75, 0, 0, 1.44445],
    "770": [0, 0.75, 0, 0, 1.44445],
    "771": [0, 0.75, 0, 0, 1.44445],
    "8730": [0.95003, 1.45, 0, 0, 1],
    "8968": [0.95003, 1.45, 0, 0, 0.58334],
    "8969": [0.95003, 1.45, 0, 0, 0.58334],
    "8970": [0.95003, 1.45, 0, 0, 0.58334],
    "8971": [0.95003, 1.45, 0, 0, 0.58334],
    "10216": [0.95003, 1.45, 0, 0, 0.75],
    "10217": [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    "32": [0, 0, 0, 0, 0.25],
    "40": [1.25003, 1.75, 0, 0, 0.79167],
    "41": [1.25003, 1.75, 0, 0, 0.79167],
    "47": [1.25003, 1.75, 0, 0, 1.27778],
    "91": [1.25003, 1.75, 0, 0, 0.58334],
    "92": [1.25003, 1.75, 0, 0, 1.27778],
    "93": [1.25003, 1.75, 0, 0, 0.58334],
    "123": [1.25003, 1.75, 0, 0, 0.80556],
    "125": [1.25003, 1.75, 0, 0, 0.80556],
    "160": [0, 0, 0, 0, 0.25],
    "710": [0, 0.825, 0, 0, 1.8889],
    "732": [0, 0.825, 0, 0, 1.8889],
    "770": [0, 0.825, 0, 0, 1.8889],
    "771": [0, 0.825, 0, 0, 1.8889],
    "8730": [1.25003, 1.75, 0, 0, 1],
    "8968": [1.25003, 1.75, 0, 0, 0.63889],
    "8969": [1.25003, 1.75, 0, 0, 0.63889],
    "8970": [1.25003, 1.75, 0, 0, 0.63889],
    "8971": [1.25003, 1.75, 0, 0, 0.63889],
    "9115": [0.64502, 1.155, 0, 0, 0.875],
    "9116": [1e-5, 0.6, 0, 0, 0.875],
    "9117": [0.64502, 1.155, 0, 0, 0.875],
    "9118": [0.64502, 1.155, 0, 0, 0.875],
    "9119": [1e-5, 0.6, 0, 0, 0.875],
    "9120": [0.64502, 1.155, 0, 0, 0.875],
    "9121": [0.64502, 1.155, 0, 0, 0.66667],
    "9122": [-99e-5, 0.601, 0, 0, 0.66667],
    "9123": [0.64502, 1.155, 0, 0, 0.66667],
    "9124": [0.64502, 1.155, 0, 0, 0.66667],
    "9125": [-99e-5, 0.601, 0, 0, 0.66667],
    "9126": [0.64502, 1.155, 0, 0, 0.66667],
    "9127": [1e-5, 0.9, 0, 0, 0.88889],
    "9128": [0.65002, 1.15, 0, 0, 0.88889],
    "9129": [0.90001, 0, 0, 0, 0.88889],
    "9130": [0, 0.3, 0, 0, 0.88889],
    "9131": [1e-5, 0.9, 0, 0, 0.88889],
    "9132": [0.65002, 1.15, 0, 0, 0.88889],
    "9133": [0.90001, 0, 0, 0, 0.88889],
    "9143": [0.88502, 0.915, 0, 0, 1.05556],
    "10216": [1.25003, 1.75, 0, 0, 0.80556],
    "10217": [1.25003, 1.75, 0, 0, 0.80556],
    "57344": [-499e-5, 0.605, 0, 0, 1.05556],
    "57345": [-499e-5, 0.605, 0, 0, 1.05556],
    "57680": [0, 0.12, 0, 0, 0.45],
    "57681": [0, 0.12, 0, 0, 0.45],
    "57682": [0, 0.12, 0, 0, 0.45],
    "57683": [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    "32": [0, 0, 0, 0, 0.525],
    "33": [0, 0.61111, 0, 0, 0.525],
    "34": [0, 0.61111, 0, 0, 0.525],
    "35": [0, 0.61111, 0, 0, 0.525],
    "36": [0.08333, 0.69444, 0, 0, 0.525],
    "37": [0.08333, 0.69444, 0, 0, 0.525],
    "38": [0, 0.61111, 0, 0, 0.525],
    "39": [0, 0.61111, 0, 0, 0.525],
    "40": [0.08333, 0.69444, 0, 0, 0.525],
    "41": [0.08333, 0.69444, 0, 0, 0.525],
    "42": [0, 0.52083, 0, 0, 0.525],
    "43": [-0.08056, 0.53055, 0, 0, 0.525],
    "44": [0.13889, 0.125, 0, 0, 0.525],
    "45": [-0.08056, 0.53055, 0, 0, 0.525],
    "46": [0, 0.125, 0, 0, 0.525],
    "47": [0.08333, 0.69444, 0, 0, 0.525],
    "48": [0, 0.61111, 0, 0, 0.525],
    "49": [0, 0.61111, 0, 0, 0.525],
    "50": [0, 0.61111, 0, 0, 0.525],
    "51": [0, 0.61111, 0, 0, 0.525],
    "52": [0, 0.61111, 0, 0, 0.525],
    "53": [0, 0.61111, 0, 0, 0.525],
    "54": [0, 0.61111, 0, 0, 0.525],
    "55": [0, 0.61111, 0, 0, 0.525],
    "56": [0, 0.61111, 0, 0, 0.525],
    "57": [0, 0.61111, 0, 0, 0.525],
    "58": [0, 0.43056, 0, 0, 0.525],
    "59": [0.13889, 0.43056, 0, 0, 0.525],
    "60": [-0.05556, 0.55556, 0, 0, 0.525],
    "61": [-0.19549, 0.41562, 0, 0, 0.525],
    "62": [-0.05556, 0.55556, 0, 0, 0.525],
    "63": [0, 0.61111, 0, 0, 0.525],
    "64": [0, 0.61111, 0, 0, 0.525],
    "65": [0, 0.61111, 0, 0, 0.525],
    "66": [0, 0.61111, 0, 0, 0.525],
    "67": [0, 0.61111, 0, 0, 0.525],
    "68": [0, 0.61111, 0, 0, 0.525],
    "69": [0, 0.61111, 0, 0, 0.525],
    "70": [0, 0.61111, 0, 0, 0.525],
    "71": [0, 0.61111, 0, 0, 0.525],
    "72": [0, 0.61111, 0, 0, 0.525],
    "73": [0, 0.61111, 0, 0, 0.525],
    "74": [0, 0.61111, 0, 0, 0.525],
    "75": [0, 0.61111, 0, 0, 0.525],
    "76": [0, 0.61111, 0, 0, 0.525],
    "77": [0, 0.61111, 0, 0, 0.525],
    "78": [0, 0.61111, 0, 0, 0.525],
    "79": [0, 0.61111, 0, 0, 0.525],
    "80": [0, 0.61111, 0, 0, 0.525],
    "81": [0.13889, 0.61111, 0, 0, 0.525],
    "82": [0, 0.61111, 0, 0, 0.525],
    "83": [0, 0.61111, 0, 0, 0.525],
    "84": [0, 0.61111, 0, 0, 0.525],
    "85": [0, 0.61111, 0, 0, 0.525],
    "86": [0, 0.61111, 0, 0, 0.525],
    "87": [0, 0.61111, 0, 0, 0.525],
    "88": [0, 0.61111, 0, 0, 0.525],
    "89": [0, 0.61111, 0, 0, 0.525],
    "90": [0, 0.61111, 0, 0, 0.525],
    "91": [0.08333, 0.69444, 0, 0, 0.525],
    "92": [0.08333, 0.69444, 0, 0, 0.525],
    "93": [0.08333, 0.69444, 0, 0, 0.525],
    "94": [0, 0.61111, 0, 0, 0.525],
    "95": [0.09514, 0, 0, 0, 0.525],
    "96": [0, 0.61111, 0, 0, 0.525],
    "97": [0, 0.43056, 0, 0, 0.525],
    "98": [0, 0.61111, 0, 0, 0.525],
    "99": [0, 0.43056, 0, 0, 0.525],
    "100": [0, 0.61111, 0, 0, 0.525],
    "101": [0, 0.43056, 0, 0, 0.525],
    "102": [0, 0.61111, 0, 0, 0.525],
    "103": [0.22222, 0.43056, 0, 0, 0.525],
    "104": [0, 0.61111, 0, 0, 0.525],
    "105": [0, 0.61111, 0, 0, 0.525],
    "106": [0.22222, 0.61111, 0, 0, 0.525],
    "107": [0, 0.61111, 0, 0, 0.525],
    "108": [0, 0.61111, 0, 0, 0.525],
    "109": [0, 0.43056, 0, 0, 0.525],
    "110": [0, 0.43056, 0, 0, 0.525],
    "111": [0, 0.43056, 0, 0, 0.525],
    "112": [0.22222, 0.43056, 0, 0, 0.525],
    "113": [0.22222, 0.43056, 0, 0, 0.525],
    "114": [0, 0.43056, 0, 0, 0.525],
    "115": [0, 0.43056, 0, 0, 0.525],
    "116": [0, 0.55358, 0, 0, 0.525],
    "117": [0, 0.43056, 0, 0, 0.525],
    "118": [0, 0.43056, 0, 0, 0.525],
    "119": [0, 0.43056, 0, 0, 0.525],
    "120": [0, 0.43056, 0, 0, 0.525],
    "121": [0.22222, 0.43056, 0, 0, 0.525],
    "122": [0, 0.43056, 0, 0, 0.525],
    "123": [0.08333, 0.69444, 0, 0, 0.525],
    "124": [0.08333, 0.69444, 0, 0, 0.525],
    "125": [0.08333, 0.69444, 0, 0, 0.525],
    "126": [0, 0.61111, 0, 0, 0.525],
    "127": [0, 0.61111, 0, 0, 0.525],
    "160": [0, 0, 0, 0, 0.525],
    "176": [0, 0.61111, 0, 0, 0.525],
    "184": [0.19445, 0, 0, 0, 0.525],
    "305": [0, 0.43056, 0, 0, 0.525],
    "567": [0.22222, 0.43056, 0, 0, 0.525],
    "711": [0, 0.56597, 0, 0, 0.525],
    "713": [0, 0.56555, 0, 0, 0.525],
    "714": [0, 0.61111, 0, 0, 0.525],
    "715": [0, 0.61111, 0, 0, 0.525],
    "728": [0, 0.61111, 0, 0, 0.525],
    "730": [0, 0.61111, 0, 0, 0.525],
    "770": [0, 0.61111, 0, 0, 0.525],
    "771": [0, 0.61111, 0, 0, 0.525],
    "776": [0, 0.61111, 0, 0, 0.525],
    "915": [0, 0.61111, 0, 0, 0.525],
    "916": [0, 0.61111, 0, 0, 0.525],
    "920": [0, 0.61111, 0, 0, 0.525],
    "923": [0, 0.61111, 0, 0, 0.525],
    "926": [0, 0.61111, 0, 0, 0.525],
    "928": [0, 0.61111, 0, 0, 0.525],
    "931": [0, 0.61111, 0, 0, 0.525],
    "933": [0, 0.61111, 0, 0, 0.525],
    "934": [0, 0.61111, 0, 0, 0.525],
    "936": [0, 0.61111, 0, 0, 0.525],
    "937": [0, 0.61111, 0, 0, 0.525],
    "8216": [0, 0.61111, 0, 0, 0.525],
    "8217": [0, 0.61111, 0, 0, 0.525],
    "8242": [0, 0.61111, 0, 0, 0.525],
    "9251": [0.11111, 0.21944, 0, 0, 0.525]
  }
};
var sigmasAndXis = {
  slant: [0.25, 0.25, 0.25],
  // sigma1
  space: [0, 0, 0],
  // sigma2
  stretch: [0, 0, 0],
  // sigma3
  shrink: [0, 0, 0],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1, 1.171, 1.472],
  // sigma6
  extraSpace: [0, 0, 0],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.15, 0.143, 0.2],
  // sigma16
  sub2: [0.247, 0.286, 0.4],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.05, 0.071, 0.1],
  // sigma19
  delim1: [2.39, 1.7, 1.98],
  // sigma20
  delim2: [1.01, 1.157, 1.42],
  // sigma21
  axisHeight: [0.25, 0.25, 0.25],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.scss; if you change it make sure the
  // values match.
  ptPerEm: [10, 10, 10],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2],
  // The width of separator lines in {array} environments. From
  // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
  arrayRuleWidth: [0.04, 0.04, 0.04],
  // Two values from LaTeX source2e:
  fboxsep: [0.3, 0.3, 0.3],
  //        3 pt / ptPerEm
  fboxrule: [0.04, 0.04, 0.04]
  // 0.4 pt / ptPerEm
};
var extraCharacterMap = {
  // Latin-1
  "": "A",
  "": "D",
  "": "o",
  "": "a",
  "": "d",
  "": "o",
  // Cyrillic
  "": "A",
  "": "B",
  "": "B",
  "": "F",
  "": "A",
  "": "E",
  "": "K",
  "": "3",
  "": "N",
  "": "N",
  "": "K",
  "": "N",
  "": "M",
  "": "H",
  "": "O",
  "": "N",
  "": "P",
  "": "C",
  "": "T",
  "": "y",
  "": "O",
  "": "X",
  "": "U",
  "": "h",
  "": "W",
  "": "W",
  "": "B",
  "": "X",
  "": "B",
  "": "3",
  "": "X",
  "": "R",
  "": "a",
  "": "b",
  "": "a",
  "": "r",
  "": "y",
  "": "e",
  "": "m",
  "": "e",
  "": "n",
  "": "n",
  "": "n",
  "": "n",
  "": "m",
  "": "n",
  "": "o",
  "": "n",
  "": "p",
  "": "c",
  "": "o",
  "": "y",
  "": "b",
  "": "x",
  "": "n",
  "": "n",
  "": "w",
  "": "w",
  "": "a",
  "": "m",
  "": "a",
  "": "e",
  "": "m",
  "": "r"
};
function setFontMetrics(fontName, metrics) {
  fontMetricsData[fontName] = metrics;
}
function getCharacterMetrics(character, font, mode) {
  if (!fontMetricsData[font]) {
    throw new Error("Font metrics not found for font: " + font + ".");
  }
  var ch = character.charCodeAt(0);
  var metrics = fontMetricsData[font][ch];
  if (!metrics && character[0] in extraCharacterMap) {
    ch = extraCharacterMap[character[0]].charCodeAt(0);
    metrics = fontMetricsData[font][ch];
  }
  if (!metrics && mode === "text") {
    if (supportedCodepoint(ch)) {
      metrics = fontMetricsData[font][77];
    }
  }
  if (metrics) {
    return {
      depth: metrics[0],
      height: metrics[1],
      italic: metrics[2],
      skew: metrics[3],
      width: metrics[4]
    };
  }
}
var fontMetricsBySizeIndex = {};
function getGlobalMetrics(size4) {
  var sizeIndex;
  if (size4 >= 5) {
    sizeIndex = 0;
  } else if (size4 >= 3) {
    sizeIndex = 1;
  } else {
    sizeIndex = 2;
  }
  if (!fontMetricsBySizeIndex[sizeIndex]) {
    var metrics = fontMetricsBySizeIndex[sizeIndex] = {
      cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
    };
    for (var key in sigmasAndXis) {
      if (sigmasAndXis.hasOwnProperty(key)) {
        metrics[key] = sigmasAndXis[key][sizeIndex];
      }
    }
  }
  return fontMetricsBySizeIndex[sizeIndex];
}
var sizeStyleMap = [
  // Each element contains [textsize, scriptsize, scriptscriptsize].
  // The size mappings are taken from TeX with \normalsize=10pt.
  [1, 1, 1],
  // size1: [5, 5, 5]              \tiny
  [2, 1, 1],
  // size2: [6, 5, 5]
  [3, 1, 1],
  // size3: [7, 5, 5]              \scriptsize
  [4, 2, 1],
  // size4: [8, 6, 5]              \footnotesize
  [5, 2, 1],
  // size5: [9, 6, 5]              \small
  [6, 3, 1],
  // size6: [10, 7, 5]             \normalsize
  [7, 4, 2],
  // size7: [12, 8, 6]             \large
  [8, 6, 3],
  // size8: [14.4, 10, 7]          \Large
  [9, 7, 6],
  // size9: [17.28, 12, 10]        \LARGE
  [10, 8, 7],
  // size10: [20.74, 14.4, 12]     \huge
  [11, 10, 9]
  // size11: [24.88, 20.74, 17.28] \HUGE
];
var sizeMultipliers = [
  // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
  // you change size indexes, change that function.
  0.5,
  0.6,
  0.7,
  0.8,
  0.9,
  1,
  1.2,
  1.44,
  1.728,
  2.074,
  2.488
];
var sizeAtStyle = function sizeAtStyle2(size4, style2) {
  return style2.size < 2 ? size4 : sizeStyleMap[size4 - 1][style2.size - 1];
};
var Options = class _Options {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
  /**
   * The base size index.
   */
  constructor(data) {
    this.style = void 0;
    this.color = void 0;
    this.size = void 0;
    this.textSize = void 0;
    this.phantom = void 0;
    this.font = void 0;
    this.fontFamily = void 0;
    this.fontWeight = void 0;
    this.fontShape = void 0;
    this.sizeMultiplier = void 0;
    this.maxSize = void 0;
    this.minRuleThickness = void 0;
    this._fontMetrics = void 0;
    this.style = data.style;
    this.color = data.color;
    this.size = data.size || _Options.BASESIZE;
    this.textSize = data.textSize || this.size;
    this.phantom = !!data.phantom;
    this.font = data.font || "";
    this.fontFamily = data.fontFamily || "";
    this.fontWeight = data.fontWeight || "";
    this.fontShape = data.fontShape || "";
    this.sizeMultiplier = sizeMultipliers[this.size - 1];
    this.maxSize = data.maxSize;
    this.minRuleThickness = data.minRuleThickness;
    this._fontMetrics = void 0;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */
  extend(extension2) {
    var data = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };
    for (var key in extension2) {
      if (extension2.hasOwnProperty(key)) {
        data[key] = extension2[key];
      }
    }
    return new _Options(data);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */
  havingStyle(style2) {
    if (this.style === style2) {
      return this;
    } else {
      return this.extend({
        style: style2,
        size: sizeAtStyle(this.textSize, style2)
      });
    }
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */
  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */
  havingSize(size4) {
    if (this.size === size4 && this.textSize === size4) {
      return this;
    } else {
      return this.extend({
        style: this.style.text(),
        size: size4,
        textSize: size4,
        sizeMultiplier: sizeMultipliers[size4 - 1]
      });
    }
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */
  havingBaseStyle(style2) {
    style2 = style2 || this.style.text();
    var wantSize = sizeAtStyle(_Options.BASESIZE, style2);
    if (this.size === wantSize && this.textSize === _Options.BASESIZE && this.style === style2) {
      return this;
    } else {
      return this.extend({
        style: style2,
        size: wantSize
      });
    }
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */
  havingBaseSizing() {
    var size4;
    switch (this.style.id) {
      case 4:
      case 5:
        size4 = 3;
        break;
      case 6:
      case 7:
        size4 = 1;
        break;
      default:
        size4 = 6;
    }
    return this.extend({
      style: this.style.text(),
      size: size4
    });
  }
  /**
   * Create a new options object with the given color.
   */
  withColor(color2) {
    return this.extend({
      color: color2
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */
  withPhantom() {
    return this.extend({
      phantom: true
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(font) {
    return this.extend({
      font
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */
  withTextFontFamily(fontFamily) {
    return this.extend({
      fontFamily,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontWeight(fontWeight) {
    return this.extend({
      fontWeight,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontShape(fontShape) {
    return this.extend({
      fontShape,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */
  sizingClasses(oldOptions) {
    if (oldOptions.size !== this.size) {
      return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
    } else {
      return [];
    }
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */
  baseSizingClasses() {
    if (this.size !== _Options.BASESIZE) {
      return ["sizing", "reset-size" + this.size, "size" + _Options.BASESIZE];
    } else {
      return [];
    }
  }
  /**
   * Return the font metrics for this size.
   */
  fontMetrics() {
    if (!this._fontMetrics) {
      this._fontMetrics = getGlobalMetrics(this.size);
    }
    return this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */
  getColor() {
    if (this.phantom) {
      return "transparent";
    } else {
      return this.color;
    }
  }
};
Options.BASESIZE = 6;
var ptPerUnit = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  "pt": 1,
  // TeX point
  "mm": 7227 / 2540,
  // millimeter
  "cm": 7227 / 254,
  // centimeter
  "in": 72.27,
  // inch
  "bp": 803 / 800,
  // big (PostScript) points
  "pc": 12,
  // pica
  "dd": 1238 / 1157,
  // didot
  "cc": 14856 / 1157,
  // cicero (12 didot)
  "nd": 685 / 642,
  // new didot
  "nc": 1370 / 107,
  // new cicero (12 new didot)
  "sp": 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  "px": 803 / 800
  // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
};
var relativeUnit = {
  "ex": true,
  "em": true,
  "mu": true
};
var validUnit = function validUnit2(unit) {
  if (typeof unit !== "string") {
    unit = unit.unit;
  }
  return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
};
var calculateSize = function calculateSize2(sizeValue, options) {
  var scale;
  if (sizeValue.unit in ptPerUnit) {
    scale = ptPerUnit[sizeValue.unit] / options.fontMetrics().ptPerEm / options.sizeMultiplier;
  } else if (sizeValue.unit === "mu") {
    scale = options.fontMetrics().cssEmPerMu;
  } else {
    var unitOptions;
    if (options.style.isTight()) {
      unitOptions = options.havingStyle(options.style.text());
    } else {
      unitOptions = options;
    }
    if (sizeValue.unit === "ex") {
      scale = unitOptions.fontMetrics().xHeight;
    } else if (sizeValue.unit === "em") {
      scale = unitOptions.fontMetrics().quad;
    } else {
      throw new ParseError("Invalid unit: '" + sizeValue.unit + "'");
    }
    if (unitOptions !== options) {
      scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
    }
  }
  return Math.min(sizeValue.number * scale, options.maxSize);
};
var makeEm = function makeEm2(n17) {
  return +n17.toFixed(4) + "em";
};
var createClass = function createClass2(classes) {
  return classes.filter((cls) => cls).join(" ");
};
var initNode = function initNode2(classes, options, style2) {
  this.classes = classes || [];
  this.attributes = {};
  this.height = 0;
  this.depth = 0;
  this.maxFontSize = 0;
  this.style = style2 || {};
  if (options) {
    if (options.style.isTight()) {
      this.classes.push("mtight");
    }
    var color2 = options.getColor();
    if (color2) {
      this.style.color = color2;
    }
  }
};
var toNode = function toNode2(tagName) {
  var node2 = document.createElement(tagName);
  node2.className = createClass(this.classes);
  for (var style2 in this.style) {
    if (this.style.hasOwnProperty(style2)) {
      node2.style[style2] = this.style[style2];
    }
  }
  for (var attr2 in this.attributes) {
    if (this.attributes.hasOwnProperty(attr2)) {
      node2.setAttribute(attr2, this.attributes[attr2]);
    }
  }
  for (var i16 = 0; i16 < this.children.length; i16++) {
    node2.appendChild(this.children[i16].toNode());
  }
  return node2;
};
var invalidAttributeNameRegex = /[\s"'>/=\x00-\x1f]/;
var toMarkup = function toMarkup2(tagName) {
  var markup = "<" + tagName;
  if (this.classes.length) {
    markup += ' class="' + utils.escape(createClass(this.classes)) + '"';
  }
  var styles2 = "";
  for (var style2 in this.style) {
    if (this.style.hasOwnProperty(style2)) {
      styles2 += utils.hyphenate(style2) + ":" + this.style[style2] + ";";
    }
  }
  if (styles2) {
    markup += ' style="' + utils.escape(styles2) + '"';
  }
  for (var attr2 in this.attributes) {
    if (this.attributes.hasOwnProperty(attr2)) {
      if (invalidAttributeNameRegex.test(attr2)) {
        throw new ParseError("Invalid attribute name '" + attr2 + "'");
      }
      markup += " " + attr2 + '="' + utils.escape(this.attributes[attr2]) + '"';
    }
  }
  markup += ">";
  for (var i16 = 0; i16 < this.children.length; i16++) {
    markup += this.children[i16].toMarkup();
  }
  markup += "</" + tagName + ">";
  return markup;
};
var Span = class {
  constructor(classes, children, options, style2) {
    this.children = void 0;
    this.attributes = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.width = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    initNode.call(this, classes, options, style2);
    this.children = children || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */
  setAttribute(attribute, value) {
    this.attributes[attribute] = value;
  }
  hasClass(className) {
    return this.classes.includes(className);
  }
  toNode() {
    return toNode.call(this, "span");
  }
  toMarkup() {
    return toMarkup.call(this, "span");
  }
};
var Anchor = class {
  constructor(href, classes, children, options) {
    this.children = void 0;
    this.attributes = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    initNode.call(this, classes, options);
    this.children = children || [];
    this.setAttribute("href", href);
  }
  setAttribute(attribute, value) {
    this.attributes[attribute] = value;
  }
  hasClass(className) {
    return this.classes.includes(className);
  }
  toNode() {
    return toNode.call(this, "a");
  }
  toMarkup() {
    return toMarkup.call(this, "a");
  }
};
var Img = class {
  constructor(src, alt, style2) {
    this.src = void 0;
    this.alt = void 0;
    this.classes = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.maxFontSize = void 0;
    this.style = void 0;
    this.alt = alt;
    this.src = src;
    this.classes = ["mord"];
    this.style = style2;
  }
  hasClass(className) {
    return this.classes.includes(className);
  }
  toNode() {
    var node2 = document.createElement("img");
    node2.src = this.src;
    node2.alt = this.alt;
    node2.className = "mord";
    for (var style2 in this.style) {
      if (this.style.hasOwnProperty(style2)) {
        node2.style[style2] = this.style[style2];
      }
    }
    return node2;
  }
  toMarkup() {
    var markup = '<img src="' + utils.escape(this.src) + '"' + (' alt="' + utils.escape(this.alt) + '"');
    var styles2 = "";
    for (var style2 in this.style) {
      if (this.style.hasOwnProperty(style2)) {
        styles2 += utils.hyphenate(style2) + ":" + this.style[style2] + ";";
      }
    }
    if (styles2) {
      markup += ' style="' + utils.escape(styles2) + '"';
    }
    markup += "'/>";
    return markup;
  }
};
var iCombinations = {
  "": "",
  "": "",
  "": "",
  // '': '\u0131\u0304', // enable when we add Extended Latin
  "": ""
};
var SymbolNode = class {
  constructor(text10, height, depth, italic, skew, width, classes, style2) {
    this.text = void 0;
    this.height = void 0;
    this.depth = void 0;
    this.italic = void 0;
    this.skew = void 0;
    this.width = void 0;
    this.maxFontSize = void 0;
    this.classes = void 0;
    this.style = void 0;
    this.text = text10;
    this.height = height || 0;
    this.depth = depth || 0;
    this.italic = italic || 0;
    this.skew = skew || 0;
    this.width = width || 0;
    this.classes = classes || [];
    this.style = style2 || {};
    this.maxFontSize = 0;
    var script = scriptFromCodepoint(this.text.charCodeAt(0));
    if (script) {
      this.classes.push(script + "_fallback");
    }
    if (/[]/.test(this.text)) {
      this.text = iCombinations[this.text];
    }
  }
  hasClass(className) {
    return this.classes.includes(className);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */
  toNode() {
    var node2 = document.createTextNode(this.text);
    var span = null;
    if (this.italic > 0) {
      span = document.createElement("span");
      span.style.marginRight = makeEm(this.italic);
    }
    if (this.classes.length > 0) {
      span = span || document.createElement("span");
      span.className = createClass(this.classes);
    }
    for (var style2 in this.style) {
      if (this.style.hasOwnProperty(style2)) {
        span = span || document.createElement("span");
        span.style[style2] = this.style[style2];
      }
    }
    if (span) {
      span.appendChild(node2);
      return span;
    } else {
      return node2;
    }
  }
  /**
   * Creates markup for a symbol node.
   */
  toMarkup() {
    var needsSpan = false;
    var markup = "<span";
    if (this.classes.length) {
      needsSpan = true;
      markup += ' class="';
      markup += utils.escape(createClass(this.classes));
      markup += '"';
    }
    var styles2 = "";
    if (this.italic > 0) {
      styles2 += "margin-right:" + this.italic + "em;";
    }
    for (var style2 in this.style) {
      if (this.style.hasOwnProperty(style2)) {
        styles2 += utils.hyphenate(style2) + ":" + this.style[style2] + ";";
      }
    }
    if (styles2) {
      needsSpan = true;
      markup += ' style="' + utils.escape(styles2) + '"';
    }
    var escaped = utils.escape(this.text);
    if (needsSpan) {
      markup += ">";
      markup += escaped;
      markup += "</span>";
      return markup;
    } else {
      return escaped;
    }
  }
};
var SvgNode = class {
  constructor(children, attributes) {
    this.children = void 0;
    this.attributes = void 0;
    this.children = children || [];
    this.attributes = attributes || {};
  }
  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node2 = document.createElementNS(svgNS, "svg");
    for (var attr2 in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
        node2.setAttribute(attr2, this.attributes[attr2]);
      }
    }
    for (var i16 = 0; i16 < this.children.length; i16++) {
      node2.appendChild(this.children[i16].toNode());
    }
    return node2;
  }
  toMarkup() {
    var markup = '<svg xmlns="http://www.w3.org/2000/svg"';
    for (var attr2 in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
        markup += " " + attr2 + '="' + utils.escape(this.attributes[attr2]) + '"';
      }
    }
    markup += ">";
    for (var i16 = 0; i16 < this.children.length; i16++) {
      markup += this.children[i16].toMarkup();
    }
    markup += "</svg>";
    return markup;
  }
};
var PathNode = class {
  constructor(pathName, alternate) {
    this.pathName = void 0;
    this.alternate = void 0;
    this.pathName = pathName;
    this.alternate = alternate;
  }
  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node2 = document.createElementNS(svgNS, "path");
    if (this.alternate) {
      node2.setAttribute("d", this.alternate);
    } else {
      node2.setAttribute("d", path2[this.pathName]);
    }
    return node2;
  }
  toMarkup() {
    if (this.alternate) {
      return '<path d="' + utils.escape(this.alternate) + '"/>';
    } else {
      return '<path d="' + utils.escape(path2[this.pathName]) + '"/>';
    }
  }
};
var LineNode = class {
  constructor(attributes) {
    this.attributes = void 0;
    this.attributes = attributes || {};
  }
  toNode() {
    var svgNS = "http://www.w3.org/2000/svg";
    var node2 = document.createElementNS(svgNS, "line");
    for (var attr2 in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
        node2.setAttribute(attr2, this.attributes[attr2]);
      }
    }
    return node2;
  }
  toMarkup() {
    var markup = "<line";
    for (var attr2 in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
        markup += " " + attr2 + '="' + utils.escape(this.attributes[attr2]) + '"';
      }
    }
    markup += "/>";
    return markup;
  }
};
function assertSymbolDomNode(group) {
  if (group instanceof SymbolNode) {
    return group;
  } else {
    throw new Error("Expected symbolNode but got " + String(group) + ".");
  }
}
function assertSpan(group) {
  if (group instanceof Span) {
    return group;
  } else {
    throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
  }
}
var ATOMS = {
  "bin": 1,
  "close": 1,
  "inner": 1,
  "open": 1,
  "punct": 1,
  "rel": 1
};
var NON_ATOMS = {
  "accent-token": 1,
  "mathord": 1,
  "op-token": 1,
  "spacing": 1,
  "textord": 1
};
var symbols = {
  "math": {},
  "text": {}
};
function defineSymbol(mode, font, group, replace2, name2, acceptUnicodeChar) {
  symbols[mode][name2] = {
    font,
    group,
    replace: replace2
  };
  if (acceptUnicodeChar && replace2) {
    symbols[mode][replace2] = symbols[mode][name2];
  }
}
var math2 = "math";
var text7 = "text";
var main = "main";
var ams = "ams";
var accent = "accent-token";
var bin = "bin";
var close = "close";
var inner2 = "inner";
var mathord = "mathord";
var op = "op-token";
var open = "open";
var punct = "punct";
var rel = "rel";
var spacing = "spacing";
var textord = "textord";
defineSymbol(math2, main, rel, "", "\\equiv", true);
defineSymbol(math2, main, rel, "", "\\prec", true);
defineSymbol(math2, main, rel, "", "\\succ", true);
defineSymbol(math2, main, rel, "", "\\sim", true);
defineSymbol(math2, main, rel, "", "\\perp");
defineSymbol(math2, main, rel, "", "\\preceq", true);
defineSymbol(math2, main, rel, "", "\\succeq", true);
defineSymbol(math2, main, rel, "", "\\simeq", true);
defineSymbol(math2, main, rel, "", "\\mid", true);
defineSymbol(math2, main, rel, "", "\\ll", true);
defineSymbol(math2, main, rel, "", "\\gg", true);
defineSymbol(math2, main, rel, "", "\\asymp", true);
defineSymbol(math2, main, rel, "", "\\parallel");
defineSymbol(math2, main, rel, "", "\\bowtie", true);
defineSymbol(math2, main, rel, "", "\\smile", true);
defineSymbol(math2, main, rel, "", "\\sqsubseteq", true);
defineSymbol(math2, main, rel, "", "\\sqsupseteq", true);
defineSymbol(math2, main, rel, "", "\\doteq", true);
defineSymbol(math2, main, rel, "", "\\frown", true);
defineSymbol(math2, main, rel, "", "\\ni", true);
defineSymbol(math2, main, rel, "", "\\propto", true);
defineSymbol(math2, main, rel, "", "\\vdash", true);
defineSymbol(math2, main, rel, "", "\\dashv", true);
defineSymbol(math2, main, rel, "", "\\owns");
defineSymbol(math2, main, punct, ".", "\\ldotp");
defineSymbol(math2, main, punct, "", "\\cdotp");
defineSymbol(math2, main, textord, "#", "\\#");
defineSymbol(text7, main, textord, "#", "\\#");
defineSymbol(math2, main, textord, "&", "\\&");
defineSymbol(text7, main, textord, "&", "\\&");
defineSymbol(math2, main, textord, "", "\\aleph", true);
defineSymbol(math2, main, textord, "", "\\forall", true);
defineSymbol(math2, main, textord, "", "\\hbar", true);
defineSymbol(math2, main, textord, "", "\\exists", true);
defineSymbol(math2, main, textord, "", "\\nabla", true);
defineSymbol(math2, main, textord, "", "\\flat", true);
defineSymbol(math2, main, textord, "", "\\ell", true);
defineSymbol(math2, main, textord, "", "\\natural", true);
defineSymbol(math2, main, textord, "", "\\clubsuit", true);
defineSymbol(math2, main, textord, "", "\\wp", true);
defineSymbol(math2, main, textord, "", "\\sharp", true);
defineSymbol(math2, main, textord, "", "\\diamondsuit", true);
defineSymbol(math2, main, textord, "", "\\Re", true);
defineSymbol(math2, main, textord, "", "\\heartsuit", true);
defineSymbol(math2, main, textord, "", "\\Im", true);
defineSymbol(math2, main, textord, "", "\\spadesuit", true);
defineSymbol(math2, main, textord, "", "\\S", true);
defineSymbol(text7, main, textord, "", "\\S");
defineSymbol(math2, main, textord, "", "\\P", true);
defineSymbol(text7, main, textord, "", "\\P");
defineSymbol(math2, main, textord, "", "\\dag");
defineSymbol(text7, main, textord, "", "\\dag");
defineSymbol(text7, main, textord, "", "\\textdagger");
defineSymbol(math2, main, textord, "", "\\ddag");
defineSymbol(text7, main, textord, "", "\\ddag");
defineSymbol(text7, main, textord, "", "\\textdaggerdbl");
defineSymbol(math2, main, close, "", "\\rmoustache", true);
defineSymbol(math2, main, open, "", "\\lmoustache", true);
defineSymbol(math2, main, close, "", "\\rgroup", true);
defineSymbol(math2, main, open, "", "\\lgroup", true);
defineSymbol(math2, main, bin, "", "\\mp", true);
defineSymbol(math2, main, bin, "", "\\ominus", true);
defineSymbol(math2, main, bin, "", "\\uplus", true);
defineSymbol(math2, main, bin, "", "\\sqcap", true);
defineSymbol(math2, main, bin, "", "\\ast");
defineSymbol(math2, main, bin, "", "\\sqcup", true);
defineSymbol(math2, main, bin, "", "\\bigcirc", true);
defineSymbol(math2, main, bin, "", "\\bullet", true);
defineSymbol(math2, main, bin, "", "\\ddagger");
defineSymbol(math2, main, bin, "", "\\wr", true);
defineSymbol(math2, main, bin, "", "\\amalg");
defineSymbol(math2, main, bin, "&", "\\And");
defineSymbol(math2, main, rel, "", "\\longleftarrow", true);
defineSymbol(math2, main, rel, "", "\\Leftarrow", true);
defineSymbol(math2, main, rel, "", "\\Longleftarrow", true);
defineSymbol(math2, main, rel, "", "\\longrightarrow", true);
defineSymbol(math2, main, rel, "", "\\Rightarrow", true);
defineSymbol(math2, main, rel, "", "\\Longrightarrow", true);
defineSymbol(math2, main, rel, "", "\\leftrightarrow", true);
defineSymbol(math2, main, rel, "", "\\longleftrightarrow", true);
defineSymbol(math2, main, rel, "", "\\Leftrightarrow", true);
defineSymbol(math2, main, rel, "", "\\Longleftrightarrow", true);
defineSymbol(math2, main, rel, "", "\\mapsto", true);
defineSymbol(math2, main, rel, "", "\\longmapsto", true);
defineSymbol(math2, main, rel, "", "\\nearrow", true);
defineSymbol(math2, main, rel, "", "\\hookleftarrow", true);
defineSymbol(math2, main, rel, "", "\\hookrightarrow", true);
defineSymbol(math2, main, rel, "", "\\searrow", true);
defineSymbol(math2, main, rel, "", "\\leftharpoonup", true);
defineSymbol(math2, main, rel, "", "\\rightharpoonup", true);
defineSymbol(math2, main, rel, "", "\\swarrow", true);
defineSymbol(math2, main, rel, "", "\\leftharpoondown", true);
defineSymbol(math2, main, rel, "", "\\rightharpoondown", true);
defineSymbol(math2, main, rel, "", "\\nwarrow", true);
defineSymbol(math2, main, rel, "", "\\rightleftharpoons", true);
defineSymbol(math2, ams, rel, "", "\\nless", true);
defineSymbol(math2, ams, rel, "", "\\@nleqslant");
defineSymbol(math2, ams, rel, "", "\\@nleqq");
defineSymbol(math2, ams, rel, "", "\\lneq", true);
defineSymbol(math2, ams, rel, "", "\\lneqq", true);
defineSymbol(math2, ams, rel, "", "\\@lvertneqq");
defineSymbol(math2, ams, rel, "", "\\lnsim", true);
defineSymbol(math2, ams, rel, "", "\\lnapprox", true);
defineSymbol(math2, ams, rel, "", "\\nprec", true);
defineSymbol(math2, ams, rel, "", "\\npreceq", true);
defineSymbol(math2, ams, rel, "", "\\precnsim", true);
defineSymbol(math2, ams, rel, "", "\\precnapprox", true);
defineSymbol(math2, ams, rel, "", "\\nsim", true);
defineSymbol(math2, ams, rel, "", "\\@nshortmid");
defineSymbol(math2, ams, rel, "", "\\nmid", true);
defineSymbol(math2, ams, rel, "", "\\nvdash", true);
defineSymbol(math2, ams, rel, "", "\\nvDash", true);
defineSymbol(math2, ams, rel, "", "\\ntriangleleft");
defineSymbol(math2, ams, rel, "", "\\ntrianglelefteq", true);
defineSymbol(math2, ams, rel, "", "\\subsetneq", true);
defineSymbol(math2, ams, rel, "", "\\@varsubsetneq");
defineSymbol(math2, ams, rel, "", "\\subsetneqq", true);
defineSymbol(math2, ams, rel, "", "\\@varsubsetneqq");
defineSymbol(math2, ams, rel, "", "\\ngtr", true);
defineSymbol(math2, ams, rel, "", "\\@ngeqslant");
defineSymbol(math2, ams, rel, "", "\\@ngeqq");
defineSymbol(math2, ams, rel, "", "\\gneq", true);
defineSymbol(math2, ams, rel, "", "\\gneqq", true);
defineSymbol(math2, ams, rel, "", "\\@gvertneqq");
defineSymbol(math2, ams, rel, "", "\\gnsim", true);
defineSymbol(math2, ams, rel, "", "\\gnapprox", true);
defineSymbol(math2, ams, rel, "", "\\nsucc", true);
defineSymbol(math2, ams, rel, "", "\\nsucceq", true);
defineSymbol(math2, ams, rel, "", "\\succnsim", true);
defineSymbol(math2, ams, rel, "", "\\succnapprox", true);
defineSymbol(math2, ams, rel, "", "\\ncong", true);
defineSymbol(math2, ams, rel, "", "\\@nshortparallel");
defineSymbol(math2, ams, rel, "", "\\nparallel", true);
defineSymbol(math2, ams, rel, "", "\\nVDash", true);
defineSymbol(math2, ams, rel, "", "\\ntriangleright");
defineSymbol(math2, ams, rel, "", "\\ntrianglerighteq", true);
defineSymbol(math2, ams, rel, "", "\\@nsupseteqq");
defineSymbol(math2, ams, rel, "", "\\supsetneq", true);
defineSymbol(math2, ams, rel, "", "\\@varsupsetneq");
defineSymbol(math2, ams, rel, "", "\\supsetneqq", true);
defineSymbol(math2, ams, rel, "", "\\@varsupsetneqq");
defineSymbol(math2, ams, rel, "", "\\nVdash", true);
defineSymbol(math2, ams, rel, "", "\\precneqq", true);
defineSymbol(math2, ams, rel, "", "\\succneqq", true);
defineSymbol(math2, ams, rel, "", "\\@nsubseteqq");
defineSymbol(math2, ams, bin, "", "\\unlhd");
defineSymbol(math2, ams, bin, "", "\\unrhd");
defineSymbol(math2, ams, rel, "", "\\nleftarrow", true);
defineSymbol(math2, ams, rel, "", "\\nrightarrow", true);
defineSymbol(math2, ams, rel, "", "\\nLeftarrow", true);
defineSymbol(math2, ams, rel, "", "\\nRightarrow", true);
defineSymbol(math2, ams, rel, "", "\\nleftrightarrow", true);
defineSymbol(math2, ams, rel, "", "\\nLeftrightarrow", true);
defineSymbol(math2, ams, rel, "", "\\vartriangle");
defineSymbol(math2, ams, textord, "", "\\hslash");
defineSymbol(math2, ams, textord, "", "\\triangledown");
defineSymbol(math2, ams, textord, "", "\\lozenge");
defineSymbol(math2, ams, textord, "", "\\circledS");
defineSymbol(math2, ams, textord, "", "\\circledR");
defineSymbol(text7, ams, textord, "", "\\circledR");
defineSymbol(math2, ams, textord, "", "\\measuredangle", true);
defineSymbol(math2, ams, textord, "", "\\nexists");
defineSymbol(math2, ams, textord, "", "\\mho");
defineSymbol(math2, ams, textord, "", "\\Finv", true);
defineSymbol(math2, ams, textord, "", "\\Game", true);
defineSymbol(math2, ams, textord, "", "\\backprime");
defineSymbol(math2, ams, textord, "", "\\blacktriangle");
defineSymbol(math2, ams, textord, "", "\\blacktriangledown");
defineSymbol(math2, ams, textord, "", "\\blacksquare");
defineSymbol(math2, ams, textord, "", "\\blacklozenge");
defineSymbol(math2, ams, textord, "", "\\bigstar");
defineSymbol(math2, ams, textord, "", "\\sphericalangle", true);
defineSymbol(math2, ams, textord, "", "\\complement", true);
defineSymbol(math2, ams, textord, "", "\\eth", true);
defineSymbol(text7, main, textord, "", "");
defineSymbol(math2, ams, textord, "", "\\diagup");
defineSymbol(math2, ams, textord, "", "\\diagdown");
defineSymbol(math2, ams, textord, "", "\\square");
defineSymbol(math2, ams, textord, "", "\\Box");
defineSymbol(math2, ams, textord, "", "\\Diamond");
defineSymbol(math2, ams, textord, "", "\\yen", true);
defineSymbol(text7, ams, textord, "", "\\yen", true);
defineSymbol(math2, ams, textord, "", "\\checkmark", true);
defineSymbol(text7, ams, textord, "", "\\checkmark");
defineSymbol(math2, ams, textord, "", "\\beth", true);
defineSymbol(math2, ams, textord, "", "\\daleth", true);
defineSymbol(math2, ams, textord, "", "\\gimel", true);
defineSymbol(math2, ams, textord, "", "\\digamma", true);
defineSymbol(math2, ams, textord, "", "\\varkappa");
defineSymbol(math2, ams, open, "", "\\@ulcorner", true);
defineSymbol(math2, ams, close, "", "\\@urcorner", true);
defineSymbol(math2, ams, open, "", "\\@llcorner", true);
defineSymbol(math2, ams, close, "", "\\@lrcorner", true);
defineSymbol(math2, ams, rel, "", "\\leqq", true);
defineSymbol(math2, ams, rel, "", "\\leqslant", true);
defineSymbol(math2, ams, rel, "", "\\eqslantless", true);
defineSymbol(math2, ams, rel, "", "\\lesssim", true);
defineSymbol(math2, ams, rel, "", "\\lessapprox", true);
defineSymbol(math2, ams, rel, "", "\\approxeq", true);
defineSymbol(math2, ams, bin, "", "\\lessdot");
defineSymbol(math2, ams, rel, "", "\\lll", true);
defineSymbol(math2, ams, rel, "", "\\lessgtr", true);
defineSymbol(math2, ams, rel, "", "\\lesseqgtr", true);
defineSymbol(math2, ams, rel, "", "\\lesseqqgtr", true);
defineSymbol(math2, ams, rel, "", "\\doteqdot");
defineSymbol(math2, ams, rel, "", "\\risingdotseq", true);
defineSymbol(math2, ams, rel, "", "\\fallingdotseq", true);
defineSymbol(math2, ams, rel, "", "\\backsim", true);
defineSymbol(math2, ams, rel, "", "\\backsimeq", true);
defineSymbol(math2, ams, rel, "", "\\subseteqq", true);
defineSymbol(math2, ams, rel, "", "\\Subset", true);
defineSymbol(math2, ams, rel, "", "\\sqsubset", true);
defineSymbol(math2, ams, rel, "", "\\preccurlyeq", true);
defineSymbol(math2, ams, rel, "", "\\curlyeqprec", true);
defineSymbol(math2, ams, rel, "", "\\precsim", true);
defineSymbol(math2, ams, rel, "", "\\precapprox", true);
defineSymbol(math2, ams, rel, "", "\\vartriangleleft");
defineSymbol(math2, ams, rel, "", "\\trianglelefteq");
defineSymbol(math2, ams, rel, "", "\\vDash", true);
defineSymbol(math2, ams, rel, "", "\\Vvdash", true);
defineSymbol(math2, ams, rel, "", "\\smallsmile");
defineSymbol(math2, ams, rel, "", "\\smallfrown");
defineSymbol(math2, ams, rel, "", "\\bumpeq", true);
defineSymbol(math2, ams, rel, "", "\\Bumpeq", true);
defineSymbol(math2, ams, rel, "", "\\geqq", true);
defineSymbol(math2, ams, rel, "", "\\geqslant", true);
defineSymbol(math2, ams, rel, "", "\\eqslantgtr", true);
defineSymbol(math2, ams, rel, "", "\\gtrsim", true);
defineSymbol(math2, ams, rel, "", "\\gtrapprox", true);
defineSymbol(math2, ams, bin, "", "\\gtrdot");
defineSymbol(math2, ams, rel, "", "\\ggg", true);
defineSymbol(math2, ams, rel, "", "\\gtrless", true);
defineSymbol(math2, ams, rel, "", "\\gtreqless", true);
defineSymbol(math2, ams, rel, "", "\\gtreqqless", true);
defineSymbol(math2, ams, rel, "", "\\eqcirc", true);
defineSymbol(math2, ams, rel, "", "\\circeq", true);
defineSymbol(math2, ams, rel, "", "\\triangleq", true);
defineSymbol(math2, ams, rel, "", "\\thicksim");
defineSymbol(math2, ams, rel, "", "\\thickapprox");
defineSymbol(math2, ams, rel, "", "\\supseteqq", true);
defineSymbol(math2, ams, rel, "", "\\Supset", true);
defineSymbol(math2, ams, rel, "", "\\sqsupset", true);
defineSymbol(math2, ams, rel, "", "\\succcurlyeq", true);
defineSymbol(math2, ams, rel, "", "\\curlyeqsucc", true);
defineSymbol(math2, ams, rel, "", "\\succsim", true);
defineSymbol(math2, ams, rel, "", "\\succapprox", true);
defineSymbol(math2, ams, rel, "", "\\vartriangleright");
defineSymbol(math2, ams, rel, "", "\\trianglerighteq");
defineSymbol(math2, ams, rel, "", "\\Vdash", true);
defineSymbol(math2, ams, rel, "", "\\shortmid");
defineSymbol(math2, ams, rel, "", "\\shortparallel");
defineSymbol(math2, ams, rel, "", "\\between", true);
defineSymbol(math2, ams, rel, "", "\\pitchfork", true);
defineSymbol(math2, ams, rel, "", "\\varpropto");
defineSymbol(math2, ams, rel, "", "\\blacktriangleleft");
defineSymbol(math2, ams, rel, "", "\\therefore", true);
defineSymbol(math2, ams, rel, "", "\\backepsilon");
defineSymbol(math2, ams, rel, "", "\\blacktriangleright");
defineSymbol(math2, ams, rel, "", "\\because", true);
defineSymbol(math2, ams, rel, "", "\\llless");
defineSymbol(math2, ams, rel, "", "\\gggtr");
defineSymbol(math2, ams, bin, "", "\\lhd");
defineSymbol(math2, ams, bin, "", "\\rhd");
defineSymbol(math2, ams, rel, "", "\\eqsim", true);
defineSymbol(math2, main, rel, "", "\\Join");
defineSymbol(math2, ams, rel, "", "\\Doteq", true);
defineSymbol(math2, ams, bin, "", "\\dotplus", true);
defineSymbol(math2, ams, bin, "", "\\smallsetminus");
defineSymbol(math2, ams, bin, "", "\\Cap", true);
defineSymbol(math2, ams, bin, "", "\\Cup", true);
defineSymbol(math2, ams, bin, "", "\\doublebarwedge", true);
defineSymbol(math2, ams, bin, "", "\\boxminus", true);
defineSymbol(math2, ams, bin, "", "\\boxplus", true);
defineSymbol(math2, ams, bin, "", "\\divideontimes", true);
defineSymbol(math2, ams, bin, "", "\\ltimes", true);
defineSymbol(math2, ams, bin, "", "\\rtimes", true);
defineSymbol(math2, ams, bin, "", "\\leftthreetimes", true);
defineSymbol(math2, ams, bin, "", "\\rightthreetimes", true);
defineSymbol(math2, ams, bin, "", "\\curlywedge", true);
defineSymbol(math2, ams, bin, "", "\\curlyvee", true);
defineSymbol(math2, ams, bin, "", "\\circleddash", true);
defineSymbol(math2, ams, bin, "", "\\circledast", true);
defineSymbol(math2, ams, bin, "", "\\centerdot");
defineSymbol(math2, ams, bin, "", "\\intercal", true);
defineSymbol(math2, ams, bin, "", "\\doublecap");
defineSymbol(math2, ams, bin, "", "\\doublecup");
defineSymbol(math2, ams, bin, "", "\\boxtimes", true);
defineSymbol(math2, ams, rel, "", "\\dashrightarrow", true);
defineSymbol(math2, ams, rel, "", "\\dashleftarrow", true);
defineSymbol(math2, ams, rel, "", "\\leftleftarrows", true);
defineSymbol(math2, ams, rel, "", "\\leftrightarrows", true);
defineSymbol(math2, ams, rel, "", "\\Lleftarrow", true);
defineSymbol(math2, ams, rel, "", "\\twoheadleftarrow", true);
defineSymbol(math2, ams, rel, "", "\\leftarrowtail", true);
defineSymbol(math2, ams, rel, "", "\\looparrowleft", true);
defineSymbol(math2, ams, rel, "", "\\leftrightharpoons", true);
defineSymbol(math2, ams, rel, "", "\\curvearrowleft", true);
defineSymbol(math2, ams, rel, "", "\\circlearrowleft", true);
defineSymbol(math2, ams, rel, "", "\\Lsh", true);
defineSymbol(math2, ams, rel, "", "\\upuparrows", true);
defineSymbol(math2, ams, rel, "", "\\upharpoonleft", true);
defineSymbol(math2, ams, rel, "", "\\downharpoonleft", true);
defineSymbol(math2, main, rel, "", "\\origof", true);
defineSymbol(math2, main, rel, "", "\\imageof", true);
defineSymbol(math2, ams, rel, "", "\\multimap", true);
defineSymbol(math2, ams, rel, "", "\\leftrightsquigarrow", true);
defineSymbol(math2, ams, rel, "", "\\rightrightarrows", true);
defineSymbol(math2, ams, rel, "", "\\rightleftarrows", true);
defineSymbol(math2, ams, rel, "", "\\twoheadrightarrow", true);
defineSymbol(math2, ams, rel, "", "\\rightarrowtail", true);
defineSymbol(math2, ams, rel, "", "\\looparrowright", true);
defineSymbol(math2, ams, rel, "", "\\curvearrowright", true);
defineSymbol(math2, ams, rel, "", "\\circlearrowright", true);
defineSymbol(math2, ams, rel, "", "\\Rsh", true);
defineSymbol(math2, ams, rel, "", "\\downdownarrows", true);
defineSymbol(math2, ams, rel, "", "\\upharpoonright", true);
defineSymbol(math2, ams, rel, "", "\\downharpoonright", true);
defineSymbol(math2, ams, rel, "", "\\rightsquigarrow", true);
defineSymbol(math2, ams, rel, "", "\\leadsto");
defineSymbol(math2, ams, rel, "", "\\Rrightarrow", true);
defineSymbol(math2, ams, rel, "", "\\restriction");
defineSymbol(math2, main, textord, "", "`");
defineSymbol(math2, main, textord, "$", "\\$");
defineSymbol(text7, main, textord, "$", "\\$");
defineSymbol(text7, main, textord, "$", "\\textdollar");
defineSymbol(math2, main, textord, "%", "\\%");
defineSymbol(text7, main, textord, "%", "\\%");
defineSymbol(math2, main, textord, "_", "\\_");
defineSymbol(text7, main, textord, "_", "\\_");
defineSymbol(text7, main, textord, "_", "\\textunderscore");
defineSymbol(math2, main, textord, "", "\\angle", true);
defineSymbol(math2, main, textord, "", "\\infty", true);
defineSymbol(math2, main, textord, "", "\\prime");
defineSymbol(math2, main, textord, "", "\\triangle");
defineSymbol(math2, main, textord, "", "\\Gamma", true);
defineSymbol(math2, main, textord, "", "\\Delta", true);
defineSymbol(math2, main, textord, "", "\\Theta", true);
defineSymbol(math2, main, textord, "", "\\Lambda", true);
defineSymbol(math2, main, textord, "", "\\Xi", true);
defineSymbol(math2, main, textord, "", "\\Pi", true);
defineSymbol(math2, main, textord, "", "\\Sigma", true);
defineSymbol(math2, main, textord, "", "\\Upsilon", true);
defineSymbol(math2, main, textord, "", "\\Phi", true);
defineSymbol(math2, main, textord, "", "\\Psi", true);
defineSymbol(math2, main, textord, "", "\\Omega", true);
defineSymbol(math2, main, textord, "A", "");
defineSymbol(math2, main, textord, "B", "");
defineSymbol(math2, main, textord, "E", "");
defineSymbol(math2, main, textord, "Z", "");
defineSymbol(math2, main, textord, "H", "");
defineSymbol(math2, main, textord, "I", "");
defineSymbol(math2, main, textord, "K", "");
defineSymbol(math2, main, textord, "M", "");
defineSymbol(math2, main, textord, "N", "");
defineSymbol(math2, main, textord, "O", "");
defineSymbol(math2, main, textord, "P", "");
defineSymbol(math2, main, textord, "T", "");
defineSymbol(math2, main, textord, "X", "");
defineSymbol(math2, main, textord, "", "\\neg", true);
defineSymbol(math2, main, textord, "", "\\lnot");
defineSymbol(math2, main, textord, "", "\\top");
defineSymbol(math2, main, textord, "", "\\bot");
defineSymbol(math2, main, textord, "", "\\emptyset");
defineSymbol(math2, ams, textord, "", "\\varnothing");
defineSymbol(math2, main, mathord, "", "\\alpha", true);
defineSymbol(math2, main, mathord, "", "\\beta", true);
defineSymbol(math2, main, mathord, "", "\\gamma", true);
defineSymbol(math2, main, mathord, "", "\\delta", true);
defineSymbol(math2, main, mathord, "", "\\epsilon", true);
defineSymbol(math2, main, mathord, "", "\\zeta", true);
defineSymbol(math2, main, mathord, "", "\\eta", true);
defineSymbol(math2, main, mathord, "", "\\theta", true);
defineSymbol(math2, main, mathord, "", "\\iota", true);
defineSymbol(math2, main, mathord, "", "\\kappa", true);
defineSymbol(math2, main, mathord, "", "\\lambda", true);
defineSymbol(math2, main, mathord, "", "\\mu", true);
defineSymbol(math2, main, mathord, "", "\\nu", true);
defineSymbol(math2, main, mathord, "", "\\xi", true);
defineSymbol(math2, main, mathord, "", "\\omicron", true);
defineSymbol(math2, main, mathord, "", "\\pi", true);
defineSymbol(math2, main, mathord, "", "\\rho", true);
defineSymbol(math2, main, mathord, "", "\\sigma", true);
defineSymbol(math2, main, mathord, "", "\\tau", true);
defineSymbol(math2, main, mathord, "", "\\upsilon", true);
defineSymbol(math2, main, mathord, "", "\\phi", true);
defineSymbol(math2, main, mathord, "", "\\chi", true);
defineSymbol(math2, main, mathord, "", "\\psi", true);
defineSymbol(math2, main, mathord, "", "\\omega", true);
defineSymbol(math2, main, mathord, "", "\\varepsilon", true);
defineSymbol(math2, main, mathord, "", "\\vartheta", true);
defineSymbol(math2, main, mathord, "", "\\varpi", true);
defineSymbol(math2, main, mathord, "", "\\varrho", true);
defineSymbol(math2, main, mathord, "", "\\varsigma", true);
defineSymbol(math2, main, mathord, "", "\\varphi", true);
defineSymbol(math2, main, bin, "", "*", true);
defineSymbol(math2, main, bin, "+", "+");
defineSymbol(math2, main, bin, "", "-", true);
defineSymbol(math2, main, bin, "", "\\cdot", true);
defineSymbol(math2, main, bin, "", "\\circ", true);
defineSymbol(math2, main, bin, "", "\\div", true);
defineSymbol(math2, main, bin, "", "\\pm", true);
defineSymbol(math2, main, bin, "", "\\times", true);
defineSymbol(math2, main, bin, "", "\\cap", true);
defineSymbol(math2, main, bin, "", "\\cup", true);
defineSymbol(math2, main, bin, "", "\\setminus", true);
defineSymbol(math2, main, bin, "", "\\land");
defineSymbol(math2, main, bin, "", "\\lor");
defineSymbol(math2, main, bin, "", "\\wedge", true);
defineSymbol(math2, main, bin, "", "\\vee", true);
defineSymbol(math2, main, textord, "", "\\surd");
defineSymbol(math2, main, open, "", "\\langle", true);
defineSymbol(math2, main, open, "", "\\lvert");
defineSymbol(math2, main, open, "", "\\lVert");
defineSymbol(math2, main, close, "?", "?");
defineSymbol(math2, main, close, "!", "!");
defineSymbol(math2, main, close, "", "\\rangle", true);
defineSymbol(math2, main, close, "", "\\rvert");
defineSymbol(math2, main, close, "", "\\rVert");
defineSymbol(math2, main, rel, "=", "=");
defineSymbol(math2, main, rel, ":", ":");
defineSymbol(math2, main, rel, "", "\\approx", true);
defineSymbol(math2, main, rel, "", "\\cong", true);
defineSymbol(math2, main, rel, "", "\\ge");
defineSymbol(math2, main, rel, "", "\\geq", true);
defineSymbol(math2, main, rel, "", "\\gets");
defineSymbol(math2, main, rel, ">", "\\gt", true);
defineSymbol(math2, main, rel, "", "\\in", true);
defineSymbol(math2, main, rel, "", "\\@not");
defineSymbol(math2, main, rel, "", "\\subset", true);
defineSymbol(math2, main, rel, "", "\\supset", true);
defineSymbol(math2, main, rel, "", "\\subseteq", true);
defineSymbol(math2, main, rel, "", "\\supseteq", true);
defineSymbol(math2, ams, rel, "", "\\nsubseteq", true);
defineSymbol(math2, ams, rel, "", "\\nsupseteq", true);
defineSymbol(math2, main, rel, "", "\\models");
defineSymbol(math2, main, rel, "", "\\leftarrow", true);
defineSymbol(math2, main, rel, "", "\\le");
defineSymbol(math2, main, rel, "", "\\leq", true);
defineSymbol(math2, main, rel, "<", "\\lt", true);
defineSymbol(math2, main, rel, "", "\\rightarrow", true);
defineSymbol(math2, main, rel, "", "\\to");
defineSymbol(math2, ams, rel, "", "\\ngeq", true);
defineSymbol(math2, ams, rel, "", "\\nleq", true);
defineSymbol(math2, main, spacing, "", "\\ ");
defineSymbol(math2, main, spacing, "", "\\space");
defineSymbol(math2, main, spacing, "", "\\nobreakspace");
defineSymbol(text7, main, spacing, "", "\\ ");
defineSymbol(text7, main, spacing, "", " ");
defineSymbol(text7, main, spacing, "", "\\space");
defineSymbol(text7, main, spacing, "", "\\nobreakspace");
defineSymbol(math2, main, spacing, null, "\\nobreak");
defineSymbol(math2, main, spacing, null, "\\allowbreak");
defineSymbol(math2, main, punct, ",", ",");
defineSymbol(math2, main, punct, ";", ";");
defineSymbol(math2, ams, bin, "", "\\barwedge", true);
defineSymbol(math2, ams, bin, "", "\\veebar", true);
defineSymbol(math2, main, bin, "", "\\odot", true);
defineSymbol(math2, main, bin, "", "\\oplus", true);
defineSymbol(math2, main, bin, "", "\\otimes", true);
defineSymbol(math2, main, textord, "", "\\partial", true);
defineSymbol(math2, main, bin, "", "\\oslash", true);
defineSymbol(math2, ams, bin, "", "\\circledcirc", true);
defineSymbol(math2, ams, bin, "", "\\boxdot", true);
defineSymbol(math2, main, bin, "", "\\bigtriangleup");
defineSymbol(math2, main, bin, "", "\\bigtriangledown");
defineSymbol(math2, main, bin, "", "\\dagger");
defineSymbol(math2, main, bin, "", "\\diamond");
defineSymbol(math2, main, bin, "", "\\star");
defineSymbol(math2, main, bin, "", "\\triangleleft");
defineSymbol(math2, main, bin, "", "\\triangleright");
defineSymbol(math2, main, open, "{", "\\{");
defineSymbol(text7, main, textord, "{", "\\{");
defineSymbol(text7, main, textord, "{", "\\textbraceleft");
defineSymbol(math2, main, close, "}", "\\}");
defineSymbol(text7, main, textord, "}", "\\}");
defineSymbol(text7, main, textord, "}", "\\textbraceright");
defineSymbol(math2, main, open, "{", "\\lbrace");
defineSymbol(math2, main, close, "}", "\\rbrace");
defineSymbol(math2, main, open, "[", "\\lbrack", true);
defineSymbol(text7, main, textord, "[", "\\lbrack", true);
defineSymbol(math2, main, close, "]", "\\rbrack", true);
defineSymbol(text7, main, textord, "]", "\\rbrack", true);
defineSymbol(math2, main, open, "(", "\\lparen", true);
defineSymbol(math2, main, close, ")", "\\rparen", true);
defineSymbol(text7, main, textord, "<", "\\textless", true);
defineSymbol(text7, main, textord, ">", "\\textgreater", true);
defineSymbol(math2, main, open, "", "\\lfloor", true);
defineSymbol(math2, main, close, "", "\\rfloor", true);
defineSymbol(math2, main, open, "", "\\lceil", true);
defineSymbol(math2, main, close, "", "\\rceil", true);
defineSymbol(math2, main, textord, "\\", "\\backslash");
defineSymbol(math2, main, textord, "", "|");
defineSymbol(math2, main, textord, "", "\\vert");
defineSymbol(text7, main, textord, "|", "\\textbar", true);
defineSymbol(math2, main, textord, "", "\\|");
defineSymbol(math2, main, textord, "", "\\Vert");
defineSymbol(text7, main, textord, "", "\\textbardbl");
defineSymbol(text7, main, textord, "~", "\\textasciitilde");
defineSymbol(text7, main, textord, "\\", "\\textbackslash");
defineSymbol(text7, main, textord, "^", "\\textasciicircum");
defineSymbol(math2, main, rel, "", "\\uparrow", true);
defineSymbol(math2, main, rel, "", "\\Uparrow", true);
defineSymbol(math2, main, rel, "", "\\downarrow", true);
defineSymbol(math2, main, rel, "", "\\Downarrow", true);
defineSymbol(math2, main, rel, "", "\\updownarrow", true);
defineSymbol(math2, main, rel, "", "\\Updownarrow", true);
defineSymbol(math2, main, op, "", "\\coprod");
defineSymbol(math2, main, op, "", "\\bigvee");
defineSymbol(math2, main, op, "", "\\bigwedge");
defineSymbol(math2, main, op, "", "\\biguplus");
defineSymbol(math2, main, op, "", "\\bigcap");
defineSymbol(math2, main, op, "", "\\bigcup");
defineSymbol(math2, main, op, "", "\\int");
defineSymbol(math2, main, op, "", "\\intop");
defineSymbol(math2, main, op, "", "\\iint");
defineSymbol(math2, main, op, "", "\\iiint");
defineSymbol(math2, main, op, "", "\\prod");
defineSymbol(math2, main, op, "", "\\sum");
defineSymbol(math2, main, op, "", "\\bigotimes");
defineSymbol(math2, main, op, "", "\\bigoplus");
defineSymbol(math2, main, op, "", "\\bigodot");
defineSymbol(math2, main, op, "", "\\oint");
defineSymbol(math2, main, op, "", "\\oiint");
defineSymbol(math2, main, op, "", "\\oiiint");
defineSymbol(math2, main, op, "", "\\bigsqcup");
defineSymbol(math2, main, op, "", "\\smallint");
defineSymbol(text7, main, inner2, "", "\\textellipsis");
defineSymbol(math2, main, inner2, "", "\\mathellipsis");
defineSymbol(text7, main, inner2, "", "\\ldots", true);
defineSymbol(math2, main, inner2, "", "\\ldots", true);
defineSymbol(math2, main, inner2, "", "\\@cdots", true);
defineSymbol(math2, main, inner2, "", "\\ddots", true);
defineSymbol(math2, main, textord, "", "\\varvdots");
defineSymbol(text7, main, textord, "", "\\varvdots");
defineSymbol(math2, main, accent, "", "\\acute");
defineSymbol(math2, main, accent, "", "\\grave");
defineSymbol(math2, main, accent, "", "\\ddot");
defineSymbol(math2, main, accent, "~", "\\tilde");
defineSymbol(math2, main, accent, "", "\\bar");
defineSymbol(math2, main, accent, "", "\\breve");
defineSymbol(math2, main, accent, "", "\\check");
defineSymbol(math2, main, accent, "^", "\\hat");
defineSymbol(math2, main, accent, "", "\\vec");
defineSymbol(math2, main, accent, "", "\\dot");
defineSymbol(math2, main, accent, "", "\\mathring");
defineSymbol(math2, main, mathord, "", "\\@imath");
defineSymbol(math2, main, mathord, "", "\\@jmath");
defineSymbol(math2, main, textord, "", "");
defineSymbol(math2, main, textord, "", "");
defineSymbol(text7, main, textord, "", "\\i", true);
defineSymbol(text7, main, textord, "", "\\j", true);
defineSymbol(text7, main, textord, "", "\\ss", true);
defineSymbol(text7, main, textord, "", "\\ae", true);
defineSymbol(text7, main, textord, "", "\\oe", true);
defineSymbol(text7, main, textord, "", "\\o", true);
defineSymbol(text7, main, textord, "", "\\AE", true);
defineSymbol(text7, main, textord, "", "\\OE", true);
defineSymbol(text7, main, textord, "", "\\O", true);
defineSymbol(text7, main, accent, "", "\\'");
defineSymbol(text7, main, accent, "", "\\`");
defineSymbol(text7, main, accent, "", "\\^");
defineSymbol(text7, main, accent, "", "\\~");
defineSymbol(text7, main, accent, "", "\\=");
defineSymbol(text7, main, accent, "", "\\u");
defineSymbol(text7, main, accent, "", "\\.");
defineSymbol(text7, main, accent, "", "\\c");
defineSymbol(text7, main, accent, "", "\\r");
defineSymbol(text7, main, accent, "", "\\v");
defineSymbol(text7, main, accent, "", '\\"');
defineSymbol(text7, main, accent, "", "\\H");
defineSymbol(text7, main, accent, "", "\\textcircled");
var ligatures = {
  "--": true,
  "---": true,
  "``": true,
  "''": true
};
defineSymbol(text7, main, textord, "", "--", true);
defineSymbol(text7, main, textord, "", "\\textendash");
defineSymbol(text7, main, textord, "", "---", true);
defineSymbol(text7, main, textord, "", "\\textemdash");
defineSymbol(text7, main, textord, "", "`", true);
defineSymbol(text7, main, textord, "", "\\textquoteleft");
defineSymbol(text7, main, textord, "", "'", true);
defineSymbol(text7, main, textord, "", "\\textquoteright");
defineSymbol(text7, main, textord, "", "``", true);
defineSymbol(text7, main, textord, "", "\\textquotedblleft");
defineSymbol(text7, main, textord, "", "''", true);
defineSymbol(text7, main, textord, "", "\\textquotedblright");
defineSymbol(math2, main, textord, "", "\\degree", true);
defineSymbol(text7, main, textord, "", "\\degree");
defineSymbol(text7, main, textord, "", "\\textdegree", true);
defineSymbol(math2, main, textord, "", "\\pounds");
defineSymbol(math2, main, textord, "", "\\mathsterling", true);
defineSymbol(text7, main, textord, "", "\\pounds");
defineSymbol(text7, main, textord, "", "\\textsterling", true);
defineSymbol(math2, ams, textord, "", "\\maltese");
defineSymbol(text7, ams, textord, "", "\\maltese");
var mathTextSymbols = '0123456789/@."';
for (i16 = 0; i16 < mathTextSymbols.length; i16++) {
  ch = mathTextSymbols.charAt(i16);
  defineSymbol(math2, main, textord, ch, ch);
}
var ch;
var i16;
var textSymbols = '0123456789!@*()-=+";:?/.,';
for (_i = 0; _i < textSymbols.length; _i++) {
  _ch = textSymbols.charAt(_i);
  defineSymbol(text7, main, textord, _ch, _ch);
}
var _ch;
var _i;
var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (_i2 = 0; _i2 < letters.length; _i2++) {
  _ch2 = letters.charAt(_i2);
  defineSymbol(math2, main, mathord, _ch2, _ch2);
  defineSymbol(text7, main, textord, _ch2, _ch2);
}
var _ch2;
var _i2;
defineSymbol(math2, ams, textord, "C", "");
defineSymbol(text7, ams, textord, "C", "");
defineSymbol(math2, ams, textord, "H", "");
defineSymbol(text7, ams, textord, "H", "");
defineSymbol(math2, ams, textord, "N", "");
defineSymbol(text7, ams, textord, "N", "");
defineSymbol(math2, ams, textord, "P", "");
defineSymbol(text7, ams, textord, "P", "");
defineSymbol(math2, ams, textord, "Q", "");
defineSymbol(text7, ams, textord, "Q", "");
defineSymbol(math2, ams, textord, "R", "");
defineSymbol(text7, ams, textord, "R", "");
defineSymbol(math2, ams, textord, "Z", "");
defineSymbol(text7, ams, textord, "Z", "");
defineSymbol(math2, main, mathord, "h", "");
defineSymbol(text7, main, mathord, "h", "");
var wideChar = "";
for (_i3 = 0; _i3 < letters.length; _i3++) {
  _ch3 = letters.charAt(_i3);
  wideChar = String.fromCharCode(55349, 56320 + _i3);
  defineSymbol(math2, main, mathord, _ch3, wideChar);
  defineSymbol(text7, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56372 + _i3);
  defineSymbol(math2, main, mathord, _ch3, wideChar);
  defineSymbol(text7, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56424 + _i3);
  defineSymbol(math2, main, mathord, _ch3, wideChar);
  defineSymbol(text7, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56580 + _i3);
  defineSymbol(math2, main, mathord, _ch3, wideChar);
  defineSymbol(text7, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56684 + _i3);
  defineSymbol(math2, main, mathord, _ch3, wideChar);
  defineSymbol(text7, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56736 + _i3);
  defineSymbol(math2, main, mathord, _ch3, wideChar);
  defineSymbol(text7, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56788 + _i3);
  defineSymbol(math2, main, mathord, _ch3, wideChar);
  defineSymbol(text7, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56840 + _i3);
  defineSymbol(math2, main, mathord, _ch3, wideChar);
  defineSymbol(text7, main, textord, _ch3, wideChar);
  wideChar = String.fromCharCode(55349, 56944 + _i3);
  defineSymbol(math2, main, mathord, _ch3, wideChar);
  defineSymbol(text7, main, textord, _ch3, wideChar);
  if (_i3 < 26) {
    wideChar = String.fromCharCode(55349, 56632 + _i3);
    defineSymbol(math2, main, mathord, _ch3, wideChar);
    defineSymbol(text7, main, textord, _ch3, wideChar);
    wideChar = String.fromCharCode(55349, 56476 + _i3);
    defineSymbol(math2, main, mathord, _ch3, wideChar);
    defineSymbol(text7, main, textord, _ch3, wideChar);
  }
}
var _ch3;
var _i3;
wideChar = String.fromCharCode(55349, 56668);
defineSymbol(math2, main, mathord, "k", wideChar);
defineSymbol(text7, main, textord, "k", wideChar);
for (_i4 = 0; _i4 < 10; _i4++) {
  _ch4 = _i4.toString();
  wideChar = String.fromCharCode(55349, 57294 + _i4);
  defineSymbol(math2, main, mathord, _ch4, wideChar);
  defineSymbol(text7, main, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(55349, 57314 + _i4);
  defineSymbol(math2, main, mathord, _ch4, wideChar);
  defineSymbol(text7, main, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(55349, 57324 + _i4);
  defineSymbol(math2, main, mathord, _ch4, wideChar);
  defineSymbol(text7, main, textord, _ch4, wideChar);
  wideChar = String.fromCharCode(55349, 57334 + _i4);
  defineSymbol(math2, main, mathord, _ch4, wideChar);
  defineSymbol(text7, main, textord, _ch4, wideChar);
}
var _ch4;
var _i4;
var extraLatin = "";
for (_i5 = 0; _i5 < extraLatin.length; _i5++) {
  _ch5 = extraLatin.charAt(_i5);
  defineSymbol(math2, main, mathord, _ch5, _ch5);
  defineSymbol(text7, main, textord, _ch5, _ch5);
}
var _ch5;
var _i5;
var wideLatinLetterData = [
  ["mathbf", "textbf", "Main-Bold"],
  // A-Z bold upright
  ["mathbf", "textbf", "Main-Bold"],
  // a-z bold upright
  ["mathnormal", "textit", "Math-Italic"],
  // A-Z italic
  ["mathnormal", "textit", "Math-Italic"],
  // a-z italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // A-Z bold italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // a-z bold italic
  // Map fancy A-Z letters to script, not calligraphic.
  // This aligns with unicode-math and math fonts (except Cambria Math).
  ["mathscr", "textscr", "Script-Regular"],
  // A-Z script
  ["", "", ""],
  // a-z script.  No font
  ["", "", ""],
  // A-Z bold script. No font
  ["", "", ""],
  // a-z bold script. No font
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // A-Z Fraktur
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // a-z Fraktur
  ["mathbb", "textbb", "AMS-Regular"],
  // A-Z double-struck
  ["mathbb", "textbb", "AMS-Regular"],
  // k double-struck
  // Note that we are using a bold font, but font metrics for regular Fraktur.
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // A-Z bold Fraktur
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // a-z bold Fraktur
  ["mathsf", "textsf", "SansSerif-Regular"],
  // A-Z sans-serif
  ["mathsf", "textsf", "SansSerif-Regular"],
  // a-z sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // A-Z bold sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // a-z bold sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // A-Z italic sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // a-z italic sans-serif
  ["", "", ""],
  // A-Z bold italic sans. No font
  ["", "", ""],
  // a-z bold italic sans. No font
  ["mathtt", "texttt", "Typewriter-Regular"],
  // A-Z monospace
  ["mathtt", "texttt", "Typewriter-Regular"]
  // a-z monospace
];
var wideNumeralData = [
  ["mathbf", "textbf", "Main-Bold"],
  // 0-9 bold
  ["", "", ""],
  // 0-9 double-struck. No KaTeX font.
  ["mathsf", "textsf", "SansSerif-Regular"],
  // 0-9 sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // 0-9 bold sans-serif
  ["mathtt", "texttt", "Typewriter-Regular"]
  // 0-9 monospace
];
var wideCharacterFont = function wideCharacterFont2(wideChar2, mode) {
  var H9 = wideChar2.charCodeAt(0);
  var L7 = wideChar2.charCodeAt(1);
  var codePoint = (H9 - 55296) * 1024 + (L7 - 56320) + 65536;
  var j11 = mode === "math" ? 0 : 1;
  if (119808 <= codePoint && codePoint < 120484) {
    var i16 = Math.floor((codePoint - 119808) / 26);
    return [wideLatinLetterData[i16][2], wideLatinLetterData[i16][j11]];
  } else if (120782 <= codePoint && codePoint <= 120831) {
    var _i = Math.floor((codePoint - 120782) / 10);
    return [wideNumeralData[_i][2], wideNumeralData[_i][j11]];
  } else if (codePoint === 120485 || codePoint === 120486) {
    return [wideLatinLetterData[0][2], wideLatinLetterData[0][j11]];
  } else if (120486 < codePoint && codePoint < 120782) {
    return ["", ""];
  } else {
    throw new ParseError("Unsupported character: " + wideChar2);
  }
};
var lookupSymbol = function lookupSymbol2(value, fontName, mode) {
  if (symbols[mode][value] && symbols[mode][value].replace) {
    value = symbols[mode][value].replace;
  }
  return {
    value,
    metrics: getCharacterMetrics(value, fontName, mode)
  };
};
var makeSymbol = function makeSymbol2(value, fontName, mode, options, classes) {
  var lookup = lookupSymbol(value, fontName, mode);
  var metrics = lookup.metrics;
  value = lookup.value;
  var symbolNode;
  if (metrics) {
    var italic = metrics.italic;
    if (mode === "text" || options && options.font === "mathit") {
      italic = 0;
    }
    symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
  } else {
    typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
    symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
  }
  if (options) {
    symbolNode.maxFontSize = options.sizeMultiplier;
    if (options.style.isTight()) {
      symbolNode.classes.push("mtight");
    }
    var color2 = options.getColor();
    if (color2) {
      symbolNode.style.color = color2;
    }
  }
  return symbolNode;
};
var mathsym = function mathsym2(value, mode, options, classes) {
  if (classes === void 0) {
    classes = [];
  }
  if (options.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
    return makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
  } else if (value === "\\" || symbols[mode][value].font === "main") {
    return makeSymbol(value, "Main-Regular", mode, options, classes);
  } else {
    return makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
  }
};
var boldsymbol = function boldsymbol2(value, mode, options, classes, type) {
  if (type !== "textord" && lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
    return {
      fontName: "Math-BoldItalic",
      fontClass: "boldsymbol"
    };
  } else {
    return {
      fontName: "Main-Bold",
      fontClass: "mathbf"
    };
  }
};
var makeOrd = function makeOrd2(group, options, type) {
  var mode = group.mode;
  var text10 = group.text;
  var classes = ["mord"];
  var isFont = mode === "math" || mode === "text" && options.font;
  var fontOrFamily = isFont ? options.font : options.fontFamily;
  var wideFontName = "";
  var wideFontClass = "";
  if (text10.charCodeAt(0) === 55349) {
    [wideFontName, wideFontClass] = wideCharacterFont(text10, mode);
  }
  if (wideFontName.length > 0) {
    return makeSymbol(text10, wideFontName, mode, options, classes.concat(wideFontClass));
  } else if (fontOrFamily) {
    var fontName;
    var fontClasses;
    if (fontOrFamily === "boldsymbol") {
      var fontData = boldsymbol(text10, mode, options, classes, type);
      fontName = fontData.fontName;
      fontClasses = [fontData.fontClass];
    } else if (isFont) {
      fontName = fontMap[fontOrFamily].fontName;
      fontClasses = [fontOrFamily];
    } else {
      fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
      fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
    }
    if (lookupSymbol(text10, fontName, mode).metrics) {
      return makeSymbol(text10, fontName, mode, options, classes.concat(fontClasses));
    } else if (ligatures.hasOwnProperty(text10) && fontName.slice(0, 10) === "Typewriter") {
      var parts = [];
      for (var i16 = 0; i16 < text10.length; i16++) {
        parts.push(makeSymbol(text10[i16], fontName, mode, options, classes.concat(fontClasses)));
      }
      return makeFragment(parts);
    }
  }
  if (type === "mathord") {
    return makeSymbol(text10, "Math-Italic", mode, options, classes.concat(["mathnormal"]));
  } else if (type === "textord") {
    var font = symbols[mode][text10] && symbols[mode][text10].font;
    if (font === "ams") {
      var _fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
      return makeSymbol(text10, _fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
    } else if (font === "main" || !font) {
      var _fontName2 = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
      return makeSymbol(text10, _fontName2, mode, options, classes.concat(options.fontWeight, options.fontShape));
    } else {
      var _fontName3 = retrieveTextFontName(font, options.fontWeight, options.fontShape);
      return makeSymbol(text10, _fontName3, mode, options, classes.concat(_fontName3, options.fontWeight, options.fontShape));
    }
  } else {
    throw new Error("unexpected type: " + type + " in makeOrd");
  }
};
var canCombine = (prev, next2) => {
  if (createClass(prev.classes) !== createClass(next2.classes) || prev.skew !== next2.skew || prev.maxFontSize !== next2.maxFontSize) {
    return false;
  }
  if (prev.classes.length === 1) {
    var cls = prev.classes[0];
    if (cls === "mbin" || cls === "mord") {
      return false;
    }
  }
  for (var style2 in prev.style) {
    if (prev.style.hasOwnProperty(style2) && prev.style[style2] !== next2.style[style2]) {
      return false;
    }
  }
  for (var _style in next2.style) {
    if (next2.style.hasOwnProperty(_style) && prev.style[_style] !== next2.style[_style]) {
      return false;
    }
  }
  return true;
};
var tryCombineChars = (chars) => {
  for (var i16 = 0; i16 < chars.length - 1; i16++) {
    var prev = chars[i16];
    var next2 = chars[i16 + 1];
    if (prev instanceof SymbolNode && next2 instanceof SymbolNode && canCombine(prev, next2)) {
      prev.text += next2.text;
      prev.height = Math.max(prev.height, next2.height);
      prev.depth = Math.max(prev.depth, next2.depth);
      prev.italic = next2.italic;
      chars.splice(i16 + 1, 1);
      i16--;
    }
  }
  return chars;
};
var sizeElementFromChildren = function sizeElementFromChildren2(elem) {
  var height = 0;
  var depth = 0;
  var maxFontSize = 0;
  for (var i16 = 0; i16 < elem.children.length; i16++) {
    var child = elem.children[i16];
    if (child.height > height) {
      height = child.height;
    }
    if (child.depth > depth) {
      depth = child.depth;
    }
    if (child.maxFontSize > maxFontSize) {
      maxFontSize = child.maxFontSize;
    }
  }
  elem.height = height;
  elem.depth = depth;
  elem.maxFontSize = maxFontSize;
};
var makeSpan$2 = function makeSpan(classes, children, options, style2) {
  var span = new Span(classes, children, options, style2);
  sizeElementFromChildren(span);
  return span;
};
var makeSvgSpan = (classes, children, options, style2) => new Span(classes, children, options, style2);
var makeLineSpan = function makeLineSpan2(className, options, thickness) {
  var line = makeSpan$2([className], [], options);
  line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
  line.style.borderBottomWidth = makeEm(line.height);
  line.maxFontSize = 1;
  return line;
};
var makeAnchor = function makeAnchor2(href, classes, children, options) {
  var anchor = new Anchor(href, classes, children, options);
  sizeElementFromChildren(anchor);
  return anchor;
};
var makeFragment = function makeFragment2(children) {
  var fragment2 = new DocumentFragment(children);
  sizeElementFromChildren(fragment2);
  return fragment2;
};
var wrapFragment = function wrapFragment2(group, options) {
  if (group instanceof DocumentFragment) {
    return makeSpan$2([], [group], options);
  }
  return group;
};
var getVListChildrenAndDepth = function getVListChildrenAndDepth2(params) {
  if (params.positionType === "individualShift") {
    var oldChildren = params.children;
    var children = [oldChildren[0]];
    var _depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
    var currPos = _depth;
    for (var i16 = 1; i16 < oldChildren.length; i16++) {
      var diff = -oldChildren[i16].shift - currPos - oldChildren[i16].elem.depth;
      var size4 = diff - (oldChildren[i16 - 1].elem.height + oldChildren[i16 - 1].elem.depth);
      currPos = currPos + diff;
      children.push({
        type: "kern",
        size: size4
      });
      children.push(oldChildren[i16]);
    }
    return {
      children,
      depth: _depth
    };
  }
  var depth;
  if (params.positionType === "top") {
    var bottom = params.positionData;
    for (var _i = 0; _i < params.children.length; _i++) {
      var child = params.children[_i];
      bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
    }
    depth = bottom;
  } else if (params.positionType === "bottom") {
    depth = -params.positionData;
  } else {
    var firstChild = params.children[0];
    if (firstChild.type !== "elem") {
      throw new Error('First child must have type "elem".');
    }
    if (params.positionType === "shift") {
      depth = -firstChild.elem.depth - params.positionData;
    } else if (params.positionType === "firstBaseline") {
      depth = -firstChild.elem.depth;
    } else {
      throw new Error("Invalid positionType " + params.positionType + ".");
    }
  }
  return {
    children: params.children,
    depth
  };
};
var makeVList = function makeVList2(params, options) {
  var {
    children,
    depth
  } = getVListChildrenAndDepth(params);
  var pstrutSize = 0;
  for (var i16 = 0; i16 < children.length; i16++) {
    var child = children[i16];
    if (child.type === "elem") {
      var elem = child.elem;
      pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
    }
  }
  pstrutSize += 2;
  var pstrut = makeSpan$2(["pstrut"], []);
  pstrut.style.height = makeEm(pstrutSize);
  var realChildren = [];
  var minPos = depth;
  var maxPos = depth;
  var currPos = depth;
  for (var _i2 = 0; _i2 < children.length; _i2++) {
    var _child = children[_i2];
    if (_child.type === "kern") {
      currPos += _child.size;
    } else {
      var _elem = _child.elem;
      var classes = _child.wrapperClasses || [];
      var style2 = _child.wrapperStyle || {};
      var childWrap = makeSpan$2(classes, [pstrut, _elem], void 0, style2);
      childWrap.style.top = makeEm(-pstrutSize - currPos - _elem.depth);
      if (_child.marginLeft) {
        childWrap.style.marginLeft = _child.marginLeft;
      }
      if (_child.marginRight) {
        childWrap.style.marginRight = _child.marginRight;
      }
      realChildren.push(childWrap);
      currPos += _elem.height + _elem.depth;
    }
    minPos = Math.min(minPos, currPos);
    maxPos = Math.max(maxPos, currPos);
  }
  var vlist = makeSpan$2(["vlist"], realChildren);
  vlist.style.height = makeEm(maxPos);
  var rows;
  if (minPos < 0) {
    var emptySpan = makeSpan$2([], []);
    var depthStrut = makeSpan$2(["vlist"], [emptySpan]);
    depthStrut.style.height = makeEm(-minPos);
    var topStrut = makeSpan$2(["vlist-s"], [new SymbolNode("")]);
    rows = [makeSpan$2(["vlist-r"], [vlist, topStrut]), makeSpan$2(["vlist-r"], [depthStrut])];
  } else {
    rows = [makeSpan$2(["vlist-r"], [vlist])];
  }
  var vtable = makeSpan$2(["vlist-t"], rows);
  if (rows.length === 2) {
    vtable.classes.push("vlist-t2");
  }
  vtable.height = maxPos;
  vtable.depth = -minPos;
  return vtable;
};
var makeGlue = (measurement, options) => {
  var rule = makeSpan$2(["mspace"], [], options);
  var size4 = calculateSize(measurement, options);
  rule.style.marginRight = makeEm(size4);
  return rule;
};
var retrieveTextFontName = function retrieveTextFontName2(fontFamily, fontWeight, fontShape) {
  var baseFontName = "";
  switch (fontFamily) {
    case "amsrm":
      baseFontName = "AMS";
      break;
    case "textrm":
      baseFontName = "Main";
      break;
    case "textsf":
      baseFontName = "SansSerif";
      break;
    case "texttt":
      baseFontName = "Typewriter";
      break;
    default:
      baseFontName = fontFamily;
  }
  var fontStylesName;
  if (fontWeight === "textbf" && fontShape === "textit") {
    fontStylesName = "BoldItalic";
  } else if (fontWeight === "textbf") {
    fontStylesName = "Bold";
  } else if (fontWeight === "textit") {
    fontStylesName = "Italic";
  } else {
    fontStylesName = "Regular";
  }
  return baseFontName + "-" + fontStylesName;
};
var fontMap = {
  // styles
  "mathbf": {
    variant: "bold",
    fontName: "Main-Bold"
  },
  "mathrm": {
    variant: "normal",
    fontName: "Main-Regular"
  },
  "textit": {
    variant: "italic",
    fontName: "Main-Italic"
  },
  "mathit": {
    variant: "italic",
    fontName: "Main-Italic"
  },
  "mathnormal": {
    variant: "italic",
    fontName: "Math-Italic"
  },
  "mathsfit": {
    variant: "sans-serif-italic",
    fontName: "SansSerif-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  "mathbb": {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  "mathcal": {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  "mathfrak": {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  "mathscr": {
    variant: "script",
    fontName: "Script-Regular"
  },
  "mathsf": {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  "mathtt": {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
};
var svgData = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
};
var staticSvg = function staticSvg2(value, options) {
  var [pathName, width, height] = svgData[value];
  var path3 = new PathNode(pathName);
  var svgNode = new SvgNode([path3], {
    "width": makeEm(width),
    "height": makeEm(height),
    // Override CSS rule `.katex svg { width: 100% }`
    "style": "width:" + makeEm(width),
    "viewBox": "0 0 " + 1e3 * width + " " + 1e3 * height,
    "preserveAspectRatio": "xMinYMin"
  });
  var span = makeSvgSpan(["overlay"], [svgNode], options);
  span.height = height;
  span.style.height = makeEm(height);
  span.style.width = makeEm(width);
  return span;
};
var buildCommon = {
  fontMap,
  makeSymbol,
  mathsym,
  makeSpan: makeSpan$2,
  makeSvgSpan,
  makeLineSpan,
  makeAnchor,
  makeFragment,
  wrapFragment,
  makeVList,
  makeOrd,
  makeGlue,
  staticSvg,
  svgData,
  tryCombineChars
};
var thinspace = {
  number: 3,
  unit: "mu"
};
var mediumspace = {
  number: 4,
  unit: "mu"
};
var thickspace = {
  number: 5,
  unit: "mu"
};
var spacings = {
  mord: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    minner: thinspace
  },
  mbin: {
    mord: mediumspace,
    mop: mediumspace,
    mopen: mediumspace,
    minner: mediumspace
  },
  mrel: {
    mord: thickspace,
    mop: thickspace,
    mopen: thickspace,
    minner: thickspace
  },
  mopen: {},
  mclose: {
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    minner: thinspace
  },
  mpunct: {
    mord: thinspace,
    mop: thinspace,
    mrel: thickspace,
    mopen: thinspace,
    mclose: thinspace,
    mpunct: thinspace,
    minner: thinspace
  },
  minner: {
    mord: thinspace,
    mop: thinspace,
    mbin: mediumspace,
    mrel: thickspace,
    mopen: thinspace,
    mpunct: thinspace,
    minner: thinspace
  }
};
var tightSpacings = {
  mord: {
    mop: thinspace
  },
  mop: {
    mord: thinspace,
    mop: thinspace
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: thinspace
  },
  mpunct: {},
  minner: {
    mop: thinspace
  }
};
var _functions = {};
var _htmlGroupBuilders = {};
var _mathmlGroupBuilders = {};
function defineFunction(_ref) {
  var {
    type,
    names,
    props,
    handler,
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  } = _ref;
  var data = {
    type,
    numArgs: props.numArgs,
    argTypes: props.argTypes,
    allowedInArgument: !!props.allowedInArgument,
    allowedInText: !!props.allowedInText,
    allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
    numOptionalArgs: props.numOptionalArgs || 0,
    infix: !!props.infix,
    primitive: !!props.primitive,
    handler
  };
  for (var i16 = 0; i16 < names.length; ++i16) {
    _functions[names[i16]] = data;
  }
  if (type) {
    if (htmlBuilder3) {
      _htmlGroupBuilders[type] = htmlBuilder3;
    }
    if (mathmlBuilder3) {
      _mathmlGroupBuilders[type] = mathmlBuilder3;
    }
  }
}
function defineFunctionBuilders(_ref2) {
  var {
    type,
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  } = _ref2;
  defineFunction({
    type,
    names: [],
    props: {
      numArgs: 0
    },
    handler() {
      throw new Error("Should never be called.");
    },
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  });
}
var normalizeArgument = function normalizeArgument2(arg) {
  return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
};
var ordargument = function ordargument2(arg) {
  return arg.type === "ordgroup" ? arg.body : [arg];
};
var makeSpan$1 = buildCommon.makeSpan;
var binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
var binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
var styleMap$1 = {
  "display": Style$1.DISPLAY,
  "text": Style$1.TEXT,
  "script": Style$1.SCRIPT,
  "scriptscript": Style$1.SCRIPTSCRIPT
};
var DomEnum = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
};
var buildExpression$1 = function buildExpression(expression, options, isRealGroup, surrounding) {
  if (surrounding === void 0) {
    surrounding = [null, null];
  }
  var groups = [];
  for (var i16 = 0; i16 < expression.length; i16++) {
    var output = buildGroup$1(expression[i16], options);
    if (output instanceof DocumentFragment) {
      var children = output.children;
      groups.push(...children);
    } else {
      groups.push(output);
    }
  }
  buildCommon.tryCombineChars(groups);
  if (!isRealGroup) {
    return groups;
  }
  var glueOptions = options;
  if (expression.length === 1) {
    var node2 = expression[0];
    if (node2.type === "sizing") {
      glueOptions = options.havingSize(node2.size);
    } else if (node2.type === "styling") {
      glueOptions = options.havingStyle(styleMap$1[node2.style]);
    }
  }
  var dummyPrev = makeSpan$1([surrounding[0] || "leftmost"], [], options);
  var dummyNext = makeSpan$1([surrounding[1] || "rightmost"], [], options);
  var isRoot = isRealGroup === "root";
  traverseNonSpaceNodes(groups, (node3, prev) => {
    var prevType = prev.classes[0];
    var type = node3.classes[0];
    if (prevType === "mbin" && binRightCanceller.includes(type)) {
      prev.classes[0] = "mord";
    } else if (type === "mbin" && binLeftCanceller.includes(prevType)) {
      node3.classes[0] = "mord";
    }
  }, {
    node: dummyPrev
  }, dummyNext, isRoot);
  traverseNonSpaceNodes(groups, (node3, prev) => {
    var prevType = getTypeOfDomTree(prev);
    var type = getTypeOfDomTree(node3);
    var space = prevType && type ? node3.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;
    if (space) {
      return buildCommon.makeGlue(space, glueOptions);
    }
  }, {
    node: dummyPrev
  }, dummyNext, isRoot);
  return groups;
};
var traverseNonSpaceNodes = function traverseNonSpaceNodes2(nodes, callback, prev, next2, isRoot) {
  if (next2) {
    nodes.push(next2);
  }
  var i16 = 0;
  for (; i16 < nodes.length; i16++) {
    var node2 = nodes[i16];
    var partialGroup = checkPartialGroup(node2);
    if (partialGroup) {
      traverseNonSpaceNodes2(partialGroup.children, callback, prev, null, isRoot);
      continue;
    }
    var nonspace = !node2.hasClass("mspace");
    if (nonspace) {
      var result = callback(node2, prev.node);
      if (result) {
        if (prev.insertAfter) {
          prev.insertAfter(result);
        } else {
          nodes.unshift(result);
          i16++;
        }
      }
    }
    if (nonspace) {
      prev.node = node2;
    } else if (isRoot && node2.hasClass("newline")) {
      prev.node = makeSpan$1(["leftmost"]);
    }
    prev.insertAfter = /* @__PURE__ */ ((index4) => (n17) => {
      nodes.splice(index4 + 1, 0, n17);
      i16++;
    })(i16);
  }
  if (next2) {
    nodes.pop();
  }
};
var checkPartialGroup = function checkPartialGroup2(node2) {
  if (node2 instanceof DocumentFragment || node2 instanceof Anchor || node2 instanceof Span && node2.hasClass("enclosing")) {
    return node2;
  }
  return null;
};
var getOutermostNode = function getOutermostNode2(node2, side) {
  var partialGroup = checkPartialGroup(node2);
  if (partialGroup) {
    var children = partialGroup.children;
    if (children.length) {
      if (side === "right") {
        return getOutermostNode2(children[children.length - 1], "right");
      } else if (side === "left") {
        return getOutermostNode2(children[0], "left");
      }
    }
  }
  return node2;
};
var getTypeOfDomTree = function getTypeOfDomTree2(node2, side) {
  if (!node2) {
    return null;
  }
  if (side) {
    node2 = getOutermostNode(node2, side);
  }
  return DomEnum[node2.classes[0]] || null;
};
var makeNullDelimiter = function makeNullDelimiter2(options, classes) {
  var moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
  return makeSpan$1(classes.concat(moreClasses));
};
var buildGroup$1 = function buildGroup(group, options, baseOptions) {
  if (!group) {
    return makeSpan$1();
  }
  if (_htmlGroupBuilders[group.type]) {
    var groupNode = _htmlGroupBuilders[group.type](group, options);
    if (baseOptions && options.size !== baseOptions.size) {
      groupNode = makeSpan$1(options.sizingClasses(baseOptions), [groupNode], options);
      var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
      groupNode.height *= multiplier;
      groupNode.depth *= multiplier;
    }
    return groupNode;
  } else {
    throw new ParseError("Got group of unknown type: '" + group.type + "'");
  }
};
function buildHTMLUnbreakable(children, options) {
  var body = makeSpan$1(["base"], children, options);
  var strut = makeSpan$1(["strut"]);
  strut.style.height = makeEm(body.height + body.depth);
  if (body.depth) {
    strut.style.verticalAlign = makeEm(-body.depth);
  }
  body.children.unshift(strut);
  return body;
}
function buildHTML(tree, options) {
  var tag = null;
  if (tree.length === 1 && tree[0].type === "tag") {
    tag = tree[0].tag;
    tree = tree[0].body;
  }
  var expression = buildExpression$1(tree, options, "root");
  var eqnNum;
  if (expression.length === 2 && expression[1].hasClass("tag")) {
    eqnNum = expression.pop();
  }
  var children = [];
  var parts = [];
  for (var i16 = 0; i16 < expression.length; i16++) {
    parts.push(expression[i16]);
    if (expression[i16].hasClass("mbin") || expression[i16].hasClass("mrel") || expression[i16].hasClass("allowbreak")) {
      var nobreak = false;
      while (i16 < expression.length - 1 && expression[i16 + 1].hasClass("mspace") && !expression[i16 + 1].hasClass("newline")) {
        i16++;
        parts.push(expression[i16]);
        if (expression[i16].hasClass("nobreak")) {
          nobreak = true;
        }
      }
      if (!nobreak) {
        children.push(buildHTMLUnbreakable(parts, options));
        parts = [];
      }
    } else if (expression[i16].hasClass("newline")) {
      parts.pop();
      if (parts.length > 0) {
        children.push(buildHTMLUnbreakable(parts, options));
        parts = [];
      }
      children.push(expression[i16]);
    }
  }
  if (parts.length > 0) {
    children.push(buildHTMLUnbreakable(parts, options));
  }
  var tagChild;
  if (tag) {
    tagChild = buildHTMLUnbreakable(buildExpression$1(tag, options, true));
    tagChild.classes = ["tag"];
    children.push(tagChild);
  } else if (eqnNum) {
    children.push(eqnNum);
  }
  var htmlNode = makeSpan$1(["katex-html"], children);
  htmlNode.setAttribute("aria-hidden", "true");
  if (tagChild) {
    var strut = tagChild.children[0];
    strut.style.height = makeEm(htmlNode.height + htmlNode.depth);
    if (htmlNode.depth) {
      strut.style.verticalAlign = makeEm(-htmlNode.depth);
    }
  }
  return htmlNode;
}
function newDocumentFragment(children) {
  return new DocumentFragment(children);
}
var MathNode = class {
  constructor(type, children, classes) {
    this.type = void 0;
    this.attributes = void 0;
    this.children = void 0;
    this.classes = void 0;
    this.type = type;
    this.attributes = {};
    this.children = children || [];
    this.classes = classes || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(name2, value) {
    this.attributes[name2] = value;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(name2) {
    return this.attributes[name2];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    var node2 = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (var attr2 in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
        node2.setAttribute(attr2, this.attributes[attr2]);
      }
    }
    if (this.classes.length > 0) {
      node2.className = createClass(this.classes);
    }
    for (var i16 = 0; i16 < this.children.length; i16++) {
      if (this.children[i16] instanceof TextNode && this.children[i16 + 1] instanceof TextNode) {
        var text10 = this.children[i16].toText() + this.children[++i16].toText();
        while (this.children[i16 + 1] instanceof TextNode) {
          text10 += this.children[++i16].toText();
        }
        node2.appendChild(new TextNode(text10).toNode());
      } else {
        node2.appendChild(this.children[i16].toNode());
      }
    }
    return node2;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    var markup = "<" + this.type;
    for (var attr2 in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr2)) {
        markup += " " + attr2 + '="';
        markup += utils.escape(this.attributes[attr2]);
        markup += '"';
      }
    }
    if (this.classes.length > 0) {
      markup += ' class ="' + utils.escape(createClass(this.classes)) + '"';
    }
    markup += ">";
    for (var i16 = 0; i16 < this.children.length; i16++) {
      markup += this.children[i16].toMarkup();
    }
    markup += "</" + this.type + ">";
    return markup;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((child) => child.toText()).join("");
  }
};
var TextNode = class {
  constructor(text10) {
    this.text = void 0;
    this.text = text10;
  }
  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return utils.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
};
var SpaceNode = class {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(width) {
    this.width = void 0;
    this.character = void 0;
    this.width = width;
    if (width >= 0.05555 && width <= 0.05556) {
      this.character = "";
    } else if (width >= 0.1666 && width <= 0.1667) {
      this.character = "";
    } else if (width >= 0.2222 && width <= 0.2223) {
      this.character = "";
    } else if (width >= 0.2777 && width <= 0.2778) {
      this.character = "";
    } else if (width >= -0.05556 && width <= -0.05555) {
      this.character = "";
    } else if (width >= -0.1667 && width <= -0.1666) {
      this.character = "";
    } else if (width >= -0.2223 && width <= -0.2222) {
      this.character = "";
    } else if (width >= -0.2778 && width <= -0.2777) {
      this.character = "";
    } else {
      this.character = null;
    }
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    if (this.character) {
      return document.createTextNode(this.character);
    } else {
      var node2 = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
      node2.setAttribute("width", makeEm(this.width));
      return node2;
    }
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    if (this.character) {
      return "<mtext>" + this.character + "</mtext>";
    } else {
      return '<mspace width="' + makeEm(this.width) + '"/>';
    }
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */
  toText() {
    if (this.character) {
      return this.character;
    } else {
      return " ";
    }
  }
};
var mathMLTree = {
  MathNode,
  TextNode,
  SpaceNode,
  newDocumentFragment
};
var makeText = function makeText2(text10, mode, options) {
  if (symbols[mode][text10] && symbols[mode][text10].replace && text10.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text10) && options && (options.fontFamily && options.fontFamily.slice(4, 6) === "tt" || options.font && options.font.slice(4, 6) === "tt"))) {
    text10 = symbols[mode][text10].replace;
  }
  return new mathMLTree.TextNode(text10);
};
var makeRow = function makeRow2(body) {
  if (body.length === 1) {
    return body[0];
  } else {
    return new mathMLTree.MathNode("mrow", body);
  }
};
var getVariant = function getVariant2(group, options) {
  if (options.fontFamily === "texttt") {
    return "monospace";
  } else if (options.fontFamily === "textsf") {
    if (options.fontShape === "textit" && options.fontWeight === "textbf") {
      return "sans-serif-bold-italic";
    } else if (options.fontShape === "textit") {
      return "sans-serif-italic";
    } else if (options.fontWeight === "textbf") {
      return "bold-sans-serif";
    } else {
      return "sans-serif";
    }
  } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
    return "bold-italic";
  } else if (options.fontShape === "textit") {
    return "italic";
  } else if (options.fontWeight === "textbf") {
    return "bold";
  }
  var font = options.font;
  if (!font || font === "mathnormal") {
    return null;
  }
  var mode = group.mode;
  if (font === "mathit") {
    return "italic";
  } else if (font === "boldsymbol") {
    return group.type === "textord" ? "bold" : "bold-italic";
  } else if (font === "mathbf") {
    return "bold";
  } else if (font === "mathbb") {
    return "double-struck";
  } else if (font === "mathsfit") {
    return "sans-serif-italic";
  } else if (font === "mathfrak") {
    return "fraktur";
  } else if (font === "mathscr" || font === "mathcal") {
    return "script";
  } else if (font === "mathsf") {
    return "sans-serif";
  } else if (font === "mathtt") {
    return "monospace";
  }
  var text10 = group.text;
  if (["\\imath", "\\jmath"].includes(text10)) {
    return null;
  }
  if (symbols[mode][text10] && symbols[mode][text10].replace) {
    text10 = symbols[mode][text10].replace;
  }
  var fontName = buildCommon.fontMap[font].fontName;
  if (getCharacterMetrics(text10, fontName, mode)) {
    return buildCommon.fontMap[font].variant;
  }
  return null;
};
function isNumberPunctuation(group) {
  if (!group) {
    return false;
  }
  if (group.type === "mi" && group.children.length === 1) {
    var child = group.children[0];
    return child instanceof TextNode && child.text === ".";
  } else if (group.type === "mo" && group.children.length === 1 && group.getAttribute("separator") === "true" && group.getAttribute("lspace") === "0em" && group.getAttribute("rspace") === "0em") {
    var _child = group.children[0];
    return _child instanceof TextNode && _child.text === ",";
  } else {
    return false;
  }
}
var buildExpression2 = function buildExpression3(expression, options, isOrdgroup) {
  if (expression.length === 1) {
    var group = buildGroup2(expression[0], options);
    if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
      group.setAttribute("lspace", "0em");
      group.setAttribute("rspace", "0em");
    }
    return [group];
  }
  var groups = [];
  var lastGroup;
  for (var i16 = 0; i16 < expression.length; i16++) {
    var _group = buildGroup2(expression[i16], options);
    if (_group instanceof MathNode && lastGroup instanceof MathNode) {
      if (_group.type === "mtext" && lastGroup.type === "mtext" && _group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
        lastGroup.children.push(..._group.children);
        continue;
      } else if (_group.type === "mn" && lastGroup.type === "mn") {
        lastGroup.children.push(..._group.children);
        continue;
      } else if (isNumberPunctuation(_group) && lastGroup.type === "mn") {
        lastGroup.children.push(..._group.children);
        continue;
      } else if (_group.type === "mn" && isNumberPunctuation(lastGroup)) {
        _group.children = [...lastGroup.children, ..._group.children];
        groups.pop();
      } else if ((_group.type === "msup" || _group.type === "msub") && _group.children.length >= 1 && (lastGroup.type === "mn" || isNumberPunctuation(lastGroup))) {
        var base = _group.children[0];
        if (base instanceof MathNode && base.type === "mn") {
          base.children = [...lastGroup.children, ...base.children];
          groups.pop();
        }
      } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
        var lastChild = lastGroup.children[0];
        if (lastChild instanceof TextNode && lastChild.text === "" && (_group.type === "mo" || _group.type === "mi" || _group.type === "mn")) {
          var child = _group.children[0];
          if (child instanceof TextNode && child.text.length > 0) {
            child.text = child.text.slice(0, 1) + "" + child.text.slice(1);
            groups.pop();
          }
        }
      }
    }
    groups.push(_group);
    lastGroup = _group;
  }
  return groups;
};
var buildExpressionRow = function buildExpressionRow2(expression, options, isOrdgroup) {
  return makeRow(buildExpression2(expression, options, isOrdgroup));
};
var buildGroup2 = function buildGroup3(group, options) {
  if (!group) {
    return new mathMLTree.MathNode("mrow");
  }
  if (_mathmlGroupBuilders[group.type]) {
    var result = _mathmlGroupBuilders[group.type](group, options);
    return result;
  } else {
    throw new ParseError("Got group of unknown type: '" + group.type + "'");
  }
};
function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
  var expression = buildExpression2(tree, options);
  var wrapper;
  if (expression.length === 1 && expression[0] instanceof MathNode && ["mrow", "mtable"].includes(expression[0].type)) {
    wrapper = expression[0];
  } else {
    wrapper = new mathMLTree.MathNode("mrow", expression);
  }
  var annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
  annotation.setAttribute("encoding", "application/x-tex");
  var semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
  var math3 = new mathMLTree.MathNode("math", [semantics]);
  math3.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
  if (isDisplayMode) {
    math3.setAttribute("display", "block");
  }
  var wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
  return buildCommon.makeSpan([wrapperClass], [math3]);
}
var optionsFromSettings = function optionsFromSettings2(settings) {
  return new Options({
    style: settings.displayMode ? Style$1.DISPLAY : Style$1.TEXT,
    maxSize: settings.maxSize,
    minRuleThickness: settings.minRuleThickness
  });
};
var displayWrap = function displayWrap2(node2, settings) {
  if (settings.displayMode) {
    var classes = ["katex-display"];
    if (settings.leqno) {
      classes.push("leqno");
    }
    if (settings.fleqn) {
      classes.push("fleqn");
    }
    node2 = buildCommon.makeSpan(classes, [node2]);
  }
  return node2;
};
var buildTree = function buildTree2(tree, expression, settings) {
  var options = optionsFromSettings(settings);
  var katexNode;
  if (settings.output === "mathml") {
    return buildMathML(tree, expression, options, settings.displayMode, true);
  } else if (settings.output === "html") {
    var htmlNode = buildHTML(tree, options);
    katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
  } else {
    var mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);
    var _htmlNode = buildHTML(tree, options);
    katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, _htmlNode]);
  }
  return displayWrap(katexNode, settings);
};
var buildHTMLTree = function buildHTMLTree2(tree, expression, settings) {
  var options = optionsFromSettings(settings);
  var htmlNode = buildHTML(tree, options);
  var katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
  return displayWrap(katexNode, settings);
};
var stretchyCodePoint = {
  widehat: "^",
  widecheck: "",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "",
  underleftarrow: "",
  xleftarrow: "",
  overrightarrow: "",
  underrightarrow: "",
  xrightarrow: "",
  underbrace: "",
  overbrace: "",
  overgroup: "",
  undergroup: "",
  overleftrightarrow: "",
  underleftrightarrow: "",
  xleftrightarrow: "",
  Overrightarrow: "",
  xRightarrow: "",
  overleftharpoon: "",
  xleftharpoonup: "",
  overrightharpoon: "",
  xrightharpoonup: "",
  xLeftarrow: "",
  xLeftrightarrow: "",
  xhookleftarrow: "",
  xhookrightarrow: "",
  xmapsto: "",
  xrightharpoondown: "",
  xleftharpoondown: "",
  xrightleftharpoons: "",
  xleftrightharpoons: "",
  xtwoheadleftarrow: "",
  xtwoheadrightarrow: "",
  xlongequal: "=",
  xtofrom: "",
  xrightleftarrows: "",
  xrightequilibrium: "",
  // Not a perfect match.
  xleftequilibrium: "",
  // None better available.
  "\\cdrightarrow": "",
  "\\cdleftarrow": "",
  "\\cdlongequal": "="
};
var mathMLnode = function mathMLnode2(label) {
  var node2 = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, "")])]);
  node2.setAttribute("stretchy", "true");
  return node2;
};
var katexImagesData = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
};
var groupLength = function groupLength2(arg) {
  if (arg.type === "ordgroup") {
    return arg.body.length;
  } else {
    return 1;
  }
};
var svgSpan = function svgSpan2(group, options) {
  function buildSvgSpan_() {
    var viewBoxWidth = 4e5;
    var label = group.label.slice(1);
    if (["widehat", "widecheck", "widetilde", "utilde"].includes(label)) {
      var grp = group;
      var numChars = groupLength(grp.base);
      var viewBoxHeight;
      var pathName;
      var _height;
      if (numChars > 5) {
        if (label === "widehat" || label === "widecheck") {
          viewBoxHeight = 420;
          viewBoxWidth = 2364;
          _height = 0.42;
          pathName = label + "4";
        } else {
          viewBoxHeight = 312;
          viewBoxWidth = 2340;
          _height = 0.34;
          pathName = "tilde4";
        }
      } else {
        var imgIndex = [1, 1, 2, 2, 3, 3][numChars];
        if (label === "widehat" || label === "widecheck") {
          viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
          viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
          _height = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
          pathName = label + imgIndex;
        } else {
          viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
          viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
          _height = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
          pathName = "tilde" + imgIndex;
        }
      }
      var path3 = new PathNode(pathName);
      var svgNode = new SvgNode([path3], {
        "width": "100%",
        "height": makeEm(_height),
        "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
        "preserveAspectRatio": "none"
      });
      return {
        span: buildCommon.makeSvgSpan([], [svgNode], options),
        minWidth: 0,
        height: _height
      };
    } else {
      var spans = [];
      var data = katexImagesData[label];
      var [paths, _minWidth, _viewBoxHeight] = data;
      var _height2 = _viewBoxHeight / 1e3;
      var numSvgChildren = paths.length;
      var widthClasses;
      var aligns;
      if (numSvgChildren === 1) {
        var align1 = data[3];
        widthClasses = ["hide-tail"];
        aligns = [align1];
      } else if (numSvgChildren === 2) {
        widthClasses = ["halfarrow-left", "halfarrow-right"];
        aligns = ["xMinYMin", "xMaxYMin"];
      } else if (numSvgChildren === 3) {
        widthClasses = ["brace-left", "brace-center", "brace-right"];
        aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      } else {
        throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
      }
      for (var i16 = 0; i16 < numSvgChildren; i16++) {
        var _path = new PathNode(paths[i16]);
        var _svgNode = new SvgNode([_path], {
          "width": "400em",
          "height": makeEm(_height2),
          "viewBox": "0 0 " + viewBoxWidth + " " + _viewBoxHeight,
          "preserveAspectRatio": aligns[i16] + " slice"
        });
        var _span = buildCommon.makeSvgSpan([widthClasses[i16]], [_svgNode], options);
        if (numSvgChildren === 1) {
          return {
            span: _span,
            minWidth: _minWidth,
            height: _height2
          };
        } else {
          _span.style.height = makeEm(_height2);
          spans.push(_span);
        }
      }
      return {
        span: buildCommon.makeSpan(["stretchy"], spans, options),
        minWidth: _minWidth,
        height: _height2
      };
    }
  }
  var {
    span,
    minWidth,
    height
  } = buildSvgSpan_();
  span.height = height;
  span.style.height = makeEm(height);
  if (minWidth > 0) {
    span.style.minWidth = makeEm(minWidth);
  }
  return span;
};
var encloseSpan = function encloseSpan2(inner3, label, topPad, bottomPad, options) {
  var img;
  var totalHeight = inner3.height + inner3.depth + topPad + bottomPad;
  if (/fbox|color|angl/.test(label)) {
    img = buildCommon.makeSpan(["stretchy", label], [], options);
    if (label === "fbox") {
      var color2 = options.color && options.getColor();
      if (color2) {
        img.style.borderColor = color2;
      }
    }
  } else {
    var lines = [];
    if (/^[bx]cancel$/.test(label)) {
      lines.push(new LineNode({
        "x1": "0",
        "y1": "0",
        "x2": "100%",
        "y2": "100%",
        "stroke-width": "0.046em"
      }));
    }
    if (/^x?cancel$/.test(label)) {
      lines.push(new LineNode({
        "x1": "0",
        "y1": "100%",
        "x2": "100%",
        "y2": "0",
        "stroke-width": "0.046em"
      }));
    }
    var svgNode = new SvgNode(lines, {
      "width": "100%",
      "height": makeEm(totalHeight)
    });
    img = buildCommon.makeSvgSpan([], [svgNode], options);
  }
  img.height = totalHeight;
  img.style.height = makeEm(totalHeight);
  return img;
};
var stretchy = {
  encloseSpan,
  mathMLnode,
  svgSpan
};
function assertNodeType(node2, type) {
  if (!node2 || node2.type !== type) {
    throw new Error("Expected node of type " + type + ", but got " + (node2 ? "node of type " + node2.type : String(node2)));
  }
  return node2;
}
function assertSymbolNodeType(node2) {
  var typedNode = checkSymbolNodeType(node2);
  if (!typedNode) {
    throw new Error("Expected node of symbol group type, but got " + (node2 ? "node of type " + node2.type : String(node2)));
  }
  return typedNode;
}
function checkSymbolNodeType(node2) {
  if (node2 && (node2.type === "atom" || NON_ATOMS.hasOwnProperty(node2.type))) {
    return node2;
  }
  return null;
}
var htmlBuilder$a = (grp, options) => {
  var base;
  var group;
  var supSubGroup;
  if (grp && grp.type === "supsub") {
    group = assertNodeType(grp.base, "accent");
    base = group.base;
    grp.base = base;
    supSubGroup = assertSpan(buildGroup$1(grp, options));
    grp.base = group;
  } else {
    group = assertNodeType(grp, "accent");
    base = group.base;
  }
  var body = buildGroup$1(base, options.havingCrampedStyle());
  var mustShift = group.isShifty && utils.isCharacterBox(base);
  var skew = 0;
  if (mustShift) {
    var baseChar = utils.getBaseElem(base);
    var baseGroup = buildGroup$1(baseChar, options.havingCrampedStyle());
    skew = assertSymbolDomNode(baseGroup).skew;
  }
  var accentBelow = group.label === "\\c";
  var clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options.fontMetrics().xHeight);
  var accentBody;
  if (!group.isStretchy) {
    var accent2;
    var width;
    if (group.label === "\\vec") {
      accent2 = buildCommon.staticSvg("vec", options);
      width = buildCommon.svgData.vec[1];
    } else {
      accent2 = buildCommon.makeOrd({
        mode: group.mode,
        text: group.label
      }, options, "textord");
      accent2 = assertSymbolDomNode(accent2);
      accent2.italic = 0;
      width = accent2.width;
      if (accentBelow) {
        clearance += accent2.depth;
      }
    }
    accentBody = buildCommon.makeSpan(["accent-body"], [accent2]);
    var accentFull = group.label === "\\textcircled";
    if (accentFull) {
      accentBody.classes.push("accent-full");
      clearance = body.height;
    }
    var left = skew;
    if (!accentFull) {
      left -= width / 2;
    }
    accentBody.style.left = makeEm(left);
    if (group.label === "\\textcircled") {
      accentBody.style.top = ".2em";
    }
    accentBody = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "kern",
        size: -clearance
      }, {
        type: "elem",
        elem: accentBody
      }]
    }, options);
  } else {
    accentBody = stretchy.svgSpan(group, options);
    accentBody = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "elem",
        elem: accentBody,
        wrapperClasses: ["svg-align"],
        wrapperStyle: skew > 0 ? {
          width: "calc(100% - " + makeEm(2 * skew) + ")",
          marginLeft: makeEm(2 * skew)
        } : void 0
      }]
    }, options);
  }
  var accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);
  if (supSubGroup) {
    supSubGroup.children[0] = accentWrap;
    supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
    supSubGroup.classes[0] = "mord";
    return supSubGroup;
  } else {
    return accentWrap;
  }
};
var mathmlBuilder$9 = (group, options) => {
  var accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
  var node2 = new mathMLTree.MathNode("mover", [buildGroup2(group.base, options), accentNode]);
  node2.setAttribute("accent", "true");
  return node2;
};
var NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((accent2) => "\\" + accent2).join("|"));
defineFunction({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (context, args) => {
    var base = normalizeArgument(args[0]);
    var isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
    var isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: context.parser.mode,
      label: context.funcName,
      isStretchy,
      isShifty,
      base
    };
  },
  htmlBuilder: htmlBuilder$a,
  mathmlBuilder: mathmlBuilder$9
});
defineFunction({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: true,
    allowedInMath: true,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    var base = args[0];
    var mode = context.parser.mode;
    if (mode === "math") {
      context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
      mode = "text";
    }
    return {
      type: "accent",
      mode,
      label: context.funcName,
      isStretchy: false,
      isShifty: true,
      base
    };
  },
  htmlBuilder: htmlBuilder$a,
  mathmlBuilder: mathmlBuilder$9
});
defineFunction({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var base = args[0];
    return {
      type: "accentUnder",
      mode: parser.mode,
      label: funcName,
      base
    };
  },
  htmlBuilder: (group, options) => {
    var innerGroup = buildGroup$1(group.base, options);
    var accentBody = stretchy.svgSpan(group, options);
    var kern = group.label === "\\utilde" ? 0.12 : 0;
    var vlist = buildCommon.makeVList({
      positionType: "top",
      positionData: innerGroup.height,
      children: [{
        type: "elem",
        elem: accentBody,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: kern
      }, {
        type: "elem",
        elem: innerGroup
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
  },
  mathmlBuilder: (group, options) => {
    var accentNode = stretchy.mathMLnode(group.label);
    var node2 = new mathMLTree.MathNode("munder", [buildGroup2(group.base, options), accentNode]);
    node2.setAttribute("accentunder", "true");
    return node2;
  }
});
var paddedNode = (group) => {
  var node2 = new mathMLTree.MathNode("mpadded", group ? [group] : []);
  node2.setAttribute("width", "+0.6em");
  node2.setAttribute("lspace", "0.3em");
  return node2;
};
defineFunction({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    "\\xtofrom",
    // The next 3 functions are here to support the mhchem extension.
    // Direct use of these functions is discouraged and may break someday.
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(_ref, args, optArgs) {
    var {
      parser,
      funcName
    } = _ref;
    return {
      type: "xArrow",
      mode: parser.mode,
      label: funcName,
      body: args[0],
      below: optArgs[0]
    };
  },
  // Flow is unable to correctly infer the type of `group`, even though it's
  // unambiguously determined from the passed-in `type` above.
  htmlBuilder(group, options) {
    var style2 = options.style;
    var newOptions = options.havingStyle(style2.sup());
    var upperGroup = buildCommon.wrapFragment(buildGroup$1(group.body, newOptions, options), options);
    var arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
    upperGroup.classes.push(arrowPrefix + "-arrow-pad");
    var lowerGroup;
    if (group.below) {
      newOptions = options.havingStyle(style2.sub());
      lowerGroup = buildCommon.wrapFragment(buildGroup$1(group.below, newOptions, options), options);
      lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
    }
    var arrowBody = stretchy.svgSpan(group, options);
    var arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height;
    var upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
    if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
      upperShift -= upperGroup.depth;
    }
    var vlist;
    if (lowerGroup) {
      var lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: upperGroup,
          shift: upperShift
        }, {
          type: "elem",
          elem: arrowBody,
          shift: arrowShift
        }, {
          type: "elem",
          elem: lowerGroup,
          shift: lowerShift
        }]
      }, options);
    } else {
      vlist = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: upperGroup,
          shift: upperShift
        }, {
          type: "elem",
          elem: arrowBody,
          shift: arrowShift
        }]
      }, options);
    }
    vlist.children[0].children[0].children[1].classes.push("svg-align");
    return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
  },
  mathmlBuilder(group, options) {
    var arrowNode = stretchy.mathMLnode(group.label);
    arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var node2;
    if (group.body) {
      var upperNode = paddedNode(buildGroup2(group.body, options));
      if (group.below) {
        var lowerNode = paddedNode(buildGroup2(group.below, options));
        node2 = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
      } else {
        node2 = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
      }
    } else if (group.below) {
      var _lowerNode = paddedNode(buildGroup2(group.below, options));
      node2 = new mathMLTree.MathNode("munder", [arrowNode, _lowerNode]);
    } else {
      node2 = paddedNode();
      node2 = new mathMLTree.MathNode("mover", [arrowNode, node2]);
    }
    return node2;
  }
});
var makeSpan2 = buildCommon.makeSpan;
function htmlBuilder$9(group, options) {
  var elements = buildExpression$1(group.body, options, true);
  return makeSpan2([group.mclass], elements, options);
}
function mathmlBuilder$8(group, options) {
  var node2;
  var inner3 = buildExpression2(group.body, options);
  if (group.mclass === "minner") {
    node2 = new mathMLTree.MathNode("mpadded", inner3);
  } else if (group.mclass === "mord") {
    if (group.isCharacterBox) {
      node2 = inner3[0];
      node2.type = "mi";
    } else {
      node2 = new mathMLTree.MathNode("mi", inner3);
    }
  } else {
    if (group.isCharacterBox) {
      node2 = inner3[0];
      node2.type = "mo";
    } else {
      node2 = new mathMLTree.MathNode("mo", inner3);
    }
    if (group.mclass === "mbin") {
      node2.attributes.lspace = "0.22em";
      node2.attributes.rspace = "0.22em";
    } else if (group.mclass === "mpunct") {
      node2.attributes.lspace = "0em";
      node2.attributes.rspace = "0.17em";
    } else if (group.mclass === "mopen" || group.mclass === "mclose") {
      node2.attributes.lspace = "0em";
      node2.attributes.rspace = "0em";
    } else if (group.mclass === "minner") {
      node2.attributes.lspace = "0.0556em";
      node2.attributes.width = "+0.1111em";
    }
  }
  return node2;
}
defineFunction({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: "m" + funcName.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: ordargument(body),
      isCharacterBox: utils.isCharacterBox(body)
    };
  },
  htmlBuilder: htmlBuilder$9,
  mathmlBuilder: mathmlBuilder$8
});
var binrelClass = (arg) => {
  var atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
  if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
    return "m" + atom.family;
  } else {
    return "mord";
  }
};
defineFunction({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler(_ref2, args) {
    var {
      parser
    } = _ref2;
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: binrelClass(args[0]),
      body: ordargument(args[1]),
      isCharacterBox: utils.isCharacterBox(args[1])
    };
  }
});
defineFunction({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler(_ref3, args) {
    var {
      parser,
      funcName
    } = _ref3;
    var baseArg = args[1];
    var shiftedArg = args[0];
    var mclass;
    if (funcName !== "\\stackrel") {
      mclass = binrelClass(baseArg);
    } else {
      mclass = "mrel";
    }
    var baseOp = {
      type: "op",
      mode: baseArg.mode,
      limits: true,
      alwaysHandleSupSub: true,
      parentIsSupSub: false,
      symbol: false,
      suppressBaseShift: funcName !== "\\stackrel",
      body: ordargument(baseArg)
    };
    var supsub = {
      type: "supsub",
      mode: shiftedArg.mode,
      base: baseOp,
      sup: funcName === "\\underset" ? null : shiftedArg,
      sub: funcName === "\\underset" ? shiftedArg : null
    };
    return {
      type: "mclass",
      mode: parser.mode,
      mclass,
      body: [supsub],
      isCharacterBox: utils.isCharacterBox(supsub)
    };
  },
  htmlBuilder: htmlBuilder$9,
  mathmlBuilder: mathmlBuilder$8
});
defineFunction({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "pmb",
      mode: parser.mode,
      mclass: binrelClass(args[0]),
      body: ordargument(args[0])
    };
  },
  htmlBuilder(group, options) {
    var elements = buildExpression$1(group.body, options, true);
    var node2 = buildCommon.makeSpan([group.mclass], elements, options);
    node2.style.textShadow = "0.02em 0.01em 0.04px";
    return node2;
  },
  mathmlBuilder(group, style2) {
    var inner3 = buildExpression2(group.body, style2);
    var node2 = new mathMLTree.MathNode("mstyle", inner3);
    node2.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
    return node2;
  }
});
var cdArrowFunctionName = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  "A": "\\uparrow",
  "V": "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
};
var newCell = () => {
  return {
    type: "styling",
    body: [],
    mode: "math",
    style: "display"
  };
};
var isStartOfArrow = (node2) => {
  return node2.type === "textord" && node2.text === "@";
};
var isLabelEnd = (node2, endChar) => {
  return (node2.type === "mathord" || node2.type === "atom") && node2.text === endChar;
};
function cdArrow(arrowChar, labels, parser) {
  var funcName = cdArrowFunctionName[arrowChar];
  switch (funcName) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return parser.callFunction(funcName, [labels[0]], [labels[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      var leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
      var bareArrow = {
        type: "atom",
        text: funcName,
        mode: "math",
        family: "rel"
      };
      var sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
      var rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
      var arrowGroup = {
        type: "ordgroup",
        mode: "math",
        body: [leftLabel, sizedArrow, rightLabel]
      };
      return parser.callFunction("\\\\cdparent", [arrowGroup], []);
    }
    case "\\\\cdlongequal":
      return parser.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      var arrow4 = {
        type: "textord",
        text: "\\Vert",
        mode: "math"
      };
      return parser.callFunction("\\Big", [arrow4], []);
    }
    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}
function parseCD(parser) {
  var parsedRows = [];
  parser.gullet.beginGroup();
  parser.gullet.macros.set("\\cr", "\\\\\\relax");
  parser.gullet.beginGroup();
  while (true) {
    parsedRows.push(parser.parseExpression(false, "\\\\"));
    parser.gullet.endGroup();
    parser.gullet.beginGroup();
    var next2 = parser.fetch().text;
    if (next2 === "&" || next2 === "\\\\") {
      parser.consume();
    } else if (next2 === "\\end") {
      if (parsedRows[parsedRows.length - 1].length === 0) {
        parsedRows.pop();
      }
      break;
    } else {
      throw new ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
    }
  }
  var row = [];
  var body = [row];
  for (var i16 = 0; i16 < parsedRows.length; i16++) {
    var rowNodes = parsedRows[i16];
    var cell = newCell();
    for (var j11 = 0; j11 < rowNodes.length; j11++) {
      if (!isStartOfArrow(rowNodes[j11])) {
        cell.body.push(rowNodes[j11]);
      } else {
        row.push(cell);
        j11 += 1;
        var arrowChar = assertSymbolNodeType(rowNodes[j11]).text;
        var labels = new Array(2);
        labels[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        };
        labels[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        };
        if ("=|.".indexOf(arrowChar) > -1) ;
        else if ("<>AV".indexOf(arrowChar) > -1) {
          for (var labelNum = 0; labelNum < 2; labelNum++) {
            var inLabel = true;
            for (var k13 = j11 + 1; k13 < rowNodes.length; k13++) {
              if (isLabelEnd(rowNodes[k13], arrowChar)) {
                inLabel = false;
                j11 = k13;
                break;
              }
              if (isStartOfArrow(rowNodes[k13])) {
                throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k13]);
              }
              labels[labelNum].body.push(rowNodes[k13]);
            }
            if (inLabel) {
              throw new ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j11]);
            }
          }
        } else {
          throw new ParseError('Expected one of "<>AV=|." after @', rowNodes[j11]);
        }
        var arrow4 = cdArrow(arrowChar, labels, parser);
        var wrappedArrow = {
          type: "styling",
          body: [arrow4],
          mode: "math",
          style: "display"
          // CD is always displaystyle.
        };
        row.push(wrappedArrow);
        cell = newCell();
      }
    }
    if (i16 % 2 === 0) {
      row.push(cell);
    } else {
      row.shift();
    }
    row = [];
    body.push(row);
  }
  parser.gullet.endGroup();
  parser.gullet.endGroup();
  var cols = new Array(body[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25
    // So pre and post each get half an \enskip, i.e. 0.25em.
  });
  return {
    type: "array",
    mode: "math",
    body,
    arraystretch: 1,
    addJot: true,
    rowGaps: [null],
    cols,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(body.length + 1).fill([])
  };
}
defineFunction({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    return {
      type: "cdlabel",
      mode: parser.mode,
      side: funcName.slice(4),
      label: args[0]
    };
  },
  htmlBuilder(group, options) {
    var newOptions = options.havingStyle(options.style.sup());
    var label = buildCommon.wrapFragment(buildGroup$1(group.label, newOptions, options), options);
    label.classes.push("cd-label-" + group.side);
    label.style.bottom = makeEm(0.8 - label.depth);
    label.height = 0;
    label.depth = 0;
    return label;
  },
  mathmlBuilder(group, options) {
    var label = new mathMLTree.MathNode("mrow", [buildGroup2(group.label, options)]);
    label = new mathMLTree.MathNode("mpadded", [label]);
    label.setAttribute("width", "0");
    if (group.side === "left") {
      label.setAttribute("lspace", "-1width");
    }
    label.setAttribute("voffset", "0.7em");
    label = new mathMLTree.MathNode("mstyle", [label]);
    label.setAttribute("displaystyle", "false");
    label.setAttribute("scriptlevel", "1");
    return label;
  }
});
defineFunction({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler(_ref2, args) {
    var {
      parser
    } = _ref2;
    return {
      type: "cdlabelparent",
      mode: parser.mode,
      fragment: args[0]
    };
  },
  htmlBuilder(group, options) {
    var parent = buildCommon.wrapFragment(buildGroup$1(group.fragment, options), options);
    parent.classes.push("cd-vert-arrow");
    return parent;
  },
  mathmlBuilder(group, options) {
    return new mathMLTree.MathNode("mrow", [buildGroup2(group.fragment, options)]);
  }
});
defineFunction({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var arg = assertNodeType(args[0], "ordgroup");
    var group = arg.body;
    var number3 = "";
    for (var i16 = 0; i16 < group.length; i16++) {
      var node2 = assertNodeType(group[i16], "textord");
      number3 += node2.text;
    }
    var code4 = parseInt(number3);
    var text10;
    if (isNaN(code4)) {
      throw new ParseError("\\@char has non-numeric argument " + number3);
    } else if (code4 < 0 || code4 >= 1114111) {
      throw new ParseError("\\@char with invalid code point " + number3);
    } else if (code4 <= 65535) {
      text10 = String.fromCharCode(code4);
    } else {
      code4 -= 65536;
      text10 = String.fromCharCode((code4 >> 10) + 55296, (code4 & 1023) + 56320);
    }
    return {
      type: "textord",
      mode: parser.mode,
      text: text10
    };
  }
});
var htmlBuilder$8 = (group, options) => {
  var elements = buildExpression$1(group.body, options.withColor(group.color), false);
  return buildCommon.makeFragment(elements);
};
var mathmlBuilder$7 = (group, options) => {
  var inner3 = buildExpression2(group.body, options.withColor(group.color));
  var node2 = new mathMLTree.MathNode("mstyle", inner3);
  node2.setAttribute("mathcolor", group.color);
  return node2;
};
defineFunction({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: true,
    argTypes: ["color", "original"]
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var color2 = assertNodeType(args[0], "color-token").color;
    var body = args[1];
    return {
      type: "color",
      mode: parser.mode,
      color: color2,
      body: ordargument(body)
    };
  },
  htmlBuilder: htmlBuilder$8,
  mathmlBuilder: mathmlBuilder$7
});
defineFunction({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: true,
    argTypes: ["color"]
  },
  handler(_ref2, args) {
    var {
      parser,
      breakOnTokenText
    } = _ref2;
    var color2 = assertNodeType(args[0], "color-token").color;
    parser.gullet.macros.set("\\current@color", color2);
    var body = parser.parseExpression(true, breakOnTokenText);
    return {
      type: "color",
      mode: parser.mode,
      color: color2,
      body
    };
  },
  htmlBuilder: htmlBuilder$8,
  mathmlBuilder: mathmlBuilder$7
});
defineFunction({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: true
  },
  handler(_ref, args, optArgs) {
    var {
      parser
    } = _ref;
    var size4 = parser.gullet.future().text === "[" ? parser.parseSizeGroup(true) : null;
    var newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
    return {
      type: "cr",
      mode: parser.mode,
      newLine,
      size: size4 && assertNodeType(size4, "size").value
    };
  },
  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(group, options) {
    var span = buildCommon.makeSpan(["mspace"], [], options);
    if (group.newLine) {
      span.classes.push("newline");
      if (group.size) {
        span.style.marginTop = makeEm(calculateSize(group.size, options));
      }
    }
    return span;
  },
  mathmlBuilder(group, options) {
    var node2 = new mathMLTree.MathNode("mspace");
    if (group.newLine) {
      node2.setAttribute("linebreak", "newline");
      if (group.size) {
        node2.setAttribute("height", makeEm(calculateSize(group.size, options)));
      }
    }
    return node2;
  }
});
var globalMap = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
};
var checkControlSequence = (tok) => {
  var name2 = tok.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(name2)) {
    throw new ParseError("Expected a control sequence", tok);
  }
  return name2;
};
var getRHS = (parser) => {
  var tok = parser.gullet.popToken();
  if (tok.text === "=") {
    tok = parser.gullet.popToken();
    if (tok.text === " ") {
      tok = parser.gullet.popToken();
    }
  }
  return tok;
};
var letCommand = (parser, name2, tok, global) => {
  var macro = parser.gullet.macros.get(tok.text);
  if (macro == null) {
    tok.noexpand = true;
    macro = {
      tokens: [tok],
      numArgs: 0,
      // reproduce the same behavior in expansion
      unexpandable: !parser.gullet.isExpandable(tok.text)
    };
  }
  parser.gullet.macros.set(name2, macro, global);
};
defineFunction({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(_ref) {
    var {
      parser,
      funcName
    } = _ref;
    parser.consumeSpaces();
    var token = parser.fetch();
    if (globalMap[token.text]) {
      if (funcName === "\\global" || funcName === "\\\\globallong") {
        token.text = globalMap[token.text];
      }
      return assertNodeType(parser.parseFunction(), "internal");
    }
    throw new ParseError("Invalid token after macro prefix", token);
  }
});
defineFunction({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref2) {
    var {
      parser,
      funcName
    } = _ref2;
    var tok = parser.gullet.popToken();
    var name2 = tok.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(name2)) {
      throw new ParseError("Expected a control sequence", tok);
    }
    var numArgs = 0;
    var insert;
    var delimiters2 = [[]];
    while (parser.gullet.future().text !== "{") {
      tok = parser.gullet.popToken();
      if (tok.text === "#") {
        if (parser.gullet.future().text === "{") {
          insert = parser.gullet.future();
          delimiters2[numArgs].push("{");
          break;
        }
        tok = parser.gullet.popToken();
        if (!/^[1-9]$/.test(tok.text)) {
          throw new ParseError('Invalid argument number "' + tok.text + '"');
        }
        if (parseInt(tok.text) !== numArgs + 1) {
          throw new ParseError('Argument number "' + tok.text + '" out of order');
        }
        numArgs++;
        delimiters2.push([]);
      } else if (tok.text === "EOF") {
        throw new ParseError("Expected a macro definition");
      } else {
        delimiters2[numArgs].push(tok.text);
      }
    }
    var {
      tokens
    } = parser.gullet.consumeArg();
    if (insert) {
      tokens.unshift(insert);
    }
    if (funcName === "\\edef" || funcName === "\\xdef") {
      tokens = parser.gullet.expandTokens(tokens);
      tokens.reverse();
    }
    parser.gullet.macros.set(name2, {
      tokens,
      numArgs,
      delimiters: delimiters2
    }, funcName === globalMap[funcName]);
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});
defineFunction({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref3) {
    var {
      parser,
      funcName
    } = _ref3;
    var name2 = checkControlSequence(parser.gullet.popToken());
    parser.gullet.consumeSpaces();
    var tok = getRHS(parser);
    letCommand(parser, name2, tok, funcName === "\\\\globallet");
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});
defineFunction({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
    // cant be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref4) {
    var {
      parser,
      funcName
    } = _ref4;
    var name2 = checkControlSequence(parser.gullet.popToken());
    var middle = parser.gullet.popToken();
    var tok = parser.gullet.popToken();
    letCommand(parser, name2, tok, funcName === "\\\\globalfuture");
    parser.gullet.pushToken(tok);
    parser.gullet.pushToken(middle);
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});
var getMetrics = function getMetrics2(symbol, font, mode) {
  var replace2 = symbols.math[symbol] && symbols.math[symbol].replace;
  var metrics = getCharacterMetrics(replace2 || symbol, font, mode);
  if (!metrics) {
    throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
  }
  return metrics;
};
var styleWrap = function styleWrap2(delim, toStyle, options, classes) {
  var newOptions = options.havingBaseStyle(toStyle);
  var span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
  var delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
  span.height *= delimSizeMultiplier;
  span.depth *= delimSizeMultiplier;
  span.maxFontSize = newOptions.sizeMultiplier;
  return span;
};
var centerSpan = function centerSpan2(span, options, style2) {
  var newOptions = options.havingBaseStyle(style2);
  var shift4 = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
  span.classes.push("delimcenter");
  span.style.top = makeEm(shift4);
  span.height -= shift4;
  span.depth += shift4;
};
var makeSmallDelim = function makeSmallDelim2(delim, style2, center, options, mode, classes) {
  var text10 = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
  var span = styleWrap(text10, style2, options, classes);
  if (center) {
    centerSpan(span, options, style2);
  }
  return span;
};
var mathrmSize = function mathrmSize2(value, size4, mode, options) {
  return buildCommon.makeSymbol(value, "Size" + size4 + "-Regular", mode, options);
};
var makeLargeDelim = function makeLargeDelim2(delim, size4, center, options, mode, classes) {
  var inner3 = mathrmSize(delim, size4, mode, options);
  var span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size4], [inner3], options), Style$1.TEXT, options, classes);
  if (center) {
    centerSpan(span, options, Style$1.TEXT);
  }
  return span;
};
var makeGlyphSpan = function makeGlyphSpan2(symbol, font, mode) {
  var sizeClass;
  if (font === "Size1-Regular") {
    sizeClass = "delim-size1";
  } else {
    sizeClass = "delim-size4";
  }
  var corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
  return {
    type: "elem",
    elem: corner
  };
};
var makeInner = function makeInner2(ch, height, options) {
  var width = fontMetricsData["Size4-Regular"][ch.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][ch.charCodeAt(0)][4] : fontMetricsData["Size1-Regular"][ch.charCodeAt(0)][4];
  var path3 = new PathNode("inner", innerPath(ch, Math.round(1e3 * height)));
  var svgNode = new SvgNode([path3], {
    "width": makeEm(width),
    "height": makeEm(height),
    // Override CSS rule `.katex svg { width: 100% }`
    "style": "width:" + makeEm(width),
    "viewBox": "0 0 " + 1e3 * width + " " + Math.round(1e3 * height),
    "preserveAspectRatio": "xMinYMin"
  });
  var span = buildCommon.makeSvgSpan([], [svgNode], options);
  span.height = height;
  span.style.height = makeEm(height);
  span.style.width = makeEm(width);
  return {
    type: "elem",
    elem: span
  };
};
var lapInEms = 8e-3;
var lap = {
  type: "kern",
  size: -1 * lapInEms
};
var verts = ["|", "\\lvert", "\\rvert", "\\vert"];
var doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
var makeStackedDelim = function makeStackedDelim2(delim, heightTotal, center, options, mode, classes) {
  var top;
  var middle;
  var repeat;
  var bottom;
  var svgLabel = "";
  var viewBoxWidth = 0;
  top = repeat = bottom = delim;
  middle = null;
  var font = "Size1-Regular";
  if (delim === "\\uparrow") {
    repeat = bottom = "";
  } else if (delim === "\\Uparrow") {
    repeat = bottom = "";
  } else if (delim === "\\downarrow") {
    top = repeat = "";
  } else if (delim === "\\Downarrow") {
    top = repeat = "";
  } else if (delim === "\\updownarrow") {
    top = "\\uparrow";
    repeat = "";
    bottom = "\\downarrow";
  } else if (delim === "\\Updownarrow") {
    top = "\\Uparrow";
    repeat = "";
    bottom = "\\Downarrow";
  } else if (verts.includes(delim)) {
    repeat = "";
    svgLabel = "vert";
    viewBoxWidth = 333;
  } else if (doubleVerts.includes(delim)) {
    repeat = "";
    svgLabel = "doublevert";
    viewBoxWidth = 556;
  } else if (delim === "[" || delim === "\\lbrack") {
    top = "";
    repeat = "";
    bottom = "";
    font = "Size4-Regular";
    svgLabel = "lbrack";
    viewBoxWidth = 667;
  } else if (delim === "]" || delim === "\\rbrack") {
    top = "";
    repeat = "";
    bottom = "";
    font = "Size4-Regular";
    svgLabel = "rbrack";
    viewBoxWidth = 667;
  } else if (delim === "\\lfloor" || delim === "") {
    repeat = top = "";
    bottom = "";
    font = "Size4-Regular";
    svgLabel = "lfloor";
    viewBoxWidth = 667;
  } else if (delim === "\\lceil" || delim === "") {
    top = "";
    repeat = bottom = "";
    font = "Size4-Regular";
    svgLabel = "lceil";
    viewBoxWidth = 667;
  } else if (delim === "\\rfloor" || delim === "") {
    repeat = top = "";
    bottom = "";
    font = "Size4-Regular";
    svgLabel = "rfloor";
    viewBoxWidth = 667;
  } else if (delim === "\\rceil" || delim === "") {
    top = "";
    repeat = bottom = "";
    font = "Size4-Regular";
    svgLabel = "rceil";
    viewBoxWidth = 667;
  } else if (delim === "(" || delim === "\\lparen") {
    top = "";
    repeat = "";
    bottom = "";
    font = "Size4-Regular";
    svgLabel = "lparen";
    viewBoxWidth = 875;
  } else if (delim === ")" || delim === "\\rparen") {
    top = "";
    repeat = "";
    bottom = "";
    font = "Size4-Regular";
    svgLabel = "rparen";
    viewBoxWidth = 875;
  } else if (delim === "\\{" || delim === "\\lbrace") {
    top = "";
    middle = "";
    bottom = "";
    repeat = "";
    font = "Size4-Regular";
  } else if (delim === "\\}" || delim === "\\rbrace") {
    top = "";
    middle = "";
    bottom = "";
    repeat = "";
    font = "Size4-Regular";
  } else if (delim === "\\lgroup" || delim === "") {
    top = "";
    bottom = "";
    repeat = "";
    font = "Size4-Regular";
  } else if (delim === "\\rgroup" || delim === "") {
    top = "";
    bottom = "";
    repeat = "";
    font = "Size4-Regular";
  } else if (delim === "\\lmoustache" || delim === "") {
    top = "";
    bottom = "";
    repeat = "";
    font = "Size4-Regular";
  } else if (delim === "\\rmoustache" || delim === "") {
    top = "";
    bottom = "";
    repeat = "";
    font = "Size4-Regular";
  }
  var topMetrics = getMetrics(top, font, mode);
  var topHeightTotal = topMetrics.height + topMetrics.depth;
  var repeatMetrics = getMetrics(repeat, font, mode);
  var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
  var bottomMetrics = getMetrics(bottom, font, mode);
  var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
  var middleHeightTotal = 0;
  var middleFactor = 1;
  if (middle !== null) {
    var middleMetrics = getMetrics(middle, font, mode);
    middleHeightTotal = middleMetrics.height + middleMetrics.depth;
    middleFactor = 2;
  }
  var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
  var repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
  var realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
  var axisHeight = options.fontMetrics().axisHeight;
  if (center) {
    axisHeight *= options.sizeMultiplier;
  }
  var depth = realHeightTotal / 2 - axisHeight;
  var stack = [];
  if (svgLabel.length > 0) {
    var midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;
    var viewBoxHeight = Math.round(realHeightTotal * 1e3);
    var pathStr = tallDelim(svgLabel, Math.round(midHeight * 1e3));
    var path3 = new PathNode(svgLabel, pathStr);
    var width = (viewBoxWidth / 1e3).toFixed(3) + "em";
    var height = (viewBoxHeight / 1e3).toFixed(3) + "em";
    var svg6 = new SvgNode([path3], {
      "width": width,
      "height": height,
      "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight
    });
    var wrapper = buildCommon.makeSvgSpan([], [svg6], options);
    wrapper.height = viewBoxHeight / 1e3;
    wrapper.style.width = width;
    wrapper.style.height = height;
    stack.push({
      type: "elem",
      elem: wrapper
    });
  } else {
    stack.push(makeGlyphSpan(bottom, font, mode));
    stack.push(lap);
    if (middle === null) {
      var innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
      stack.push(makeInner(repeat, innerHeight, options));
    } else {
      var _innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;
      stack.push(makeInner(repeat, _innerHeight, options));
      stack.push(lap);
      stack.push(makeGlyphSpan(middle, font, mode));
      stack.push(lap);
      stack.push(makeInner(repeat, _innerHeight, options));
    }
    stack.push(lap);
    stack.push(makeGlyphSpan(top, font, mode));
  }
  var newOptions = options.havingBaseStyle(Style$1.TEXT);
  var inner3 = buildCommon.makeVList({
    positionType: "bottom",
    positionData: depth,
    children: stack
  }, newOptions);
  return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner3], newOptions), Style$1.TEXT, options, classes);
};
var vbPad = 80;
var emPad = 0.08;
var sqrtSvg = function sqrtSvg2(sqrtName, height, viewBoxHeight, extraVinculum, options) {
  var path3 = sqrtPath(sqrtName, extraVinculum, viewBoxHeight);
  var pathNode = new PathNode(sqrtName, path3);
  var svg6 = new SvgNode([pathNode], {
    // Note: 1000:1 ratio of viewBox to document em width.
    "width": "400em",
    "height": makeEm(height),
    "viewBox": "0 0 400000 " + viewBoxHeight,
    "preserveAspectRatio": "xMinYMin slice"
  });
  return buildCommon.makeSvgSpan(["hide-tail"], [svg6], options);
};
var makeSqrtImage = function makeSqrtImage2(height, options) {
  var newOptions = options.havingBaseSizing();
  var delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
  var sizeMultiplier = newOptions.sizeMultiplier;
  var extraVinculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness);
  var span;
  var spanHeight = 0;
  var texHeight = 0;
  var viewBoxHeight = 0;
  var advanceWidth;
  if (delim.type === "small") {
    viewBoxHeight = 1e3 + 1e3 * extraVinculum + vbPad;
    if (height < 1) {
      sizeMultiplier = 1;
    } else if (height < 1.4) {
      sizeMultiplier = 0.7;
    }
    spanHeight = (1 + extraVinculum + emPad) / sizeMultiplier;
    texHeight = (1 + extraVinculum) / sizeMultiplier;
    span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraVinculum, options);
    span.style.minWidth = "0.853em";
    advanceWidth = 0.833 / sizeMultiplier;
  } else if (delim.type === "large") {
    viewBoxHeight = (1e3 + vbPad) * sizeToMaxHeight[delim.size];
    texHeight = (sizeToMaxHeight[delim.size] + extraVinculum) / sizeMultiplier;
    spanHeight = (sizeToMaxHeight[delim.size] + extraVinculum + emPad) / sizeMultiplier;
    span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraVinculum, options);
    span.style.minWidth = "1.02em";
    advanceWidth = 1 / sizeMultiplier;
  } else {
    spanHeight = height + extraVinculum + emPad;
    texHeight = height + extraVinculum;
    viewBoxHeight = Math.floor(1e3 * height + extraVinculum) + vbPad;
    span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraVinculum, options);
    span.style.minWidth = "0.742em";
    advanceWidth = 1.056;
  }
  span.height = texHeight;
  span.style.height = makeEm(spanHeight);
  return {
    span,
    advanceWidth,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraVinculum) * sizeMultiplier
  };
};
var stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "", "", "\\lceil", "\\rceil", "", "", "\\surd"];
var stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "", "", "\\lmoustache", "\\rmoustache", "", ""];
var stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
var makeSizedDelim = function makeSizedDelim2(delim, size4, options, mode, classes) {
  if (delim === "<" || delim === "\\lt" || delim === "") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt" || delim === "") {
    delim = "\\rangle";
  }
  if (stackLargeDelimiters.includes(delim) || stackNeverDelimiters.includes(delim)) {
    return makeLargeDelim(delim, size4, false, options, mode, classes);
  } else if (stackAlwaysDelimiters.includes(delim)) {
    return makeStackedDelim(delim, sizeToMaxHeight[size4], false, options, mode, classes);
  } else {
    throw new ParseError("Illegal delimiter: '" + delim + "'");
  }
};
var stackNeverDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}];
var stackAlwaysDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "stack"
}];
var stackLargeDelimiterSequence = [{
  type: "small",
  style: Style$1.SCRIPTSCRIPT
}, {
  type: "small",
  style: Style$1.SCRIPT
}, {
  type: "small",
  style: Style$1.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}];
var delimTypeToFont = function delimTypeToFont2(type) {
  if (type.type === "small") {
    return "Main-Regular";
  } else if (type.type === "large") {
    return "Size" + type.size + "-Regular";
  } else if (type.type === "stack") {
    return "Size4-Regular";
  } else {
    throw new Error("Add support for delim type '" + type.type + "' here.");
  }
};
var traverseSequence = function traverseSequence2(delim, height, sequence, options) {
  var start2 = Math.min(2, 3 - options.style.size);
  for (var i16 = start2; i16 < sequence.length; i16++) {
    if (sequence[i16].type === "stack") {
      break;
    }
    var metrics = getMetrics(delim, delimTypeToFont(sequence[i16]), "math");
    var heightDepth = metrics.height + metrics.depth;
    if (sequence[i16].type === "small") {
      var newOptions = options.havingBaseStyle(sequence[i16].style);
      heightDepth *= newOptions.sizeMultiplier;
    }
    if (heightDepth > height) {
      return sequence[i16];
    }
  }
  return sequence[sequence.length - 1];
};
var makeCustomSizedDelim = function makeCustomSizedDelim2(delim, height, center, options, mode, classes) {
  if (delim === "<" || delim === "\\lt" || delim === "") {
    delim = "\\langle";
  } else if (delim === ">" || delim === "\\gt" || delim === "") {
    delim = "\\rangle";
  }
  var sequence;
  if (stackNeverDelimiters.includes(delim)) {
    sequence = stackNeverDelimiterSequence;
  } else if (stackLargeDelimiters.includes(delim)) {
    sequence = stackLargeDelimiterSequence;
  } else {
    sequence = stackAlwaysDelimiterSequence;
  }
  var delimType = traverseSequence(delim, height, sequence, options);
  if (delimType.type === "small") {
    return makeSmallDelim(delim, delimType.style, center, options, mode, classes);
  } else if (delimType.type === "large") {
    return makeLargeDelim(delim, delimType.size, center, options, mode, classes);
  } else {
    return makeStackedDelim(delim, height, center, options, mode, classes);
  }
};
var makeLeftRightDelim = function makeLeftRightDelim2(delim, height, depth, options, mode, classes) {
  var axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier;
  var delimiterFactor = 901;
  var delimiterExtend = 5 / options.fontMetrics().ptPerEm;
  var maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
  var totalHeight = Math.max(
    // In real TeX, calculations are done using integral values which are
    // 65536 per pt, or 655360 per em. So, the division here truncates in
    // TeX but doesn't here, producing different results. If we wanted to
    // exactly match TeX's calculation, we could do
    //   Math.floor(655360 * maxDistFromAxis / 500) *
    //    delimiterFactor / 655360
    // (To see the difference, compare
    //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
    // in TeX and KaTeX)
    maxDistFromAxis / 500 * delimiterFactor,
    2 * maxDistFromAxis - delimiterExtend
  );
  return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
};
var delimiter = {
  sqrtImage: makeSqrtImage,
  sizedDelim: makeSizedDelim,
  sizeToMaxHeight,
  customSizedDelim: makeCustomSizedDelim,
  leftRightDelim: makeLeftRightDelim
};
var delimiterSizes = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
};
var delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "", "", "\\lceil", "\\rceil", "", "", "<", ">", "\\langle", "", "\\rangle", "", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "", "", "\\lmoustache", "\\rmoustache", "", "", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
function checkDelimiter(delim, context) {
  var symDelim = checkSymbolNodeType(delim);
  if (symDelim && delimiters.includes(symDelim.text)) {
    return symDelim;
  } else if (symDelim) {
    throw new ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
  } else {
    throw new ParseError("Invalid delimiter type '" + delim.type + "'", delim);
  }
}
defineFunction({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    var delim = checkDelimiter(args[0], context);
    return {
      type: "delimsizing",
      mode: context.parser.mode,
      size: delimiterSizes[context.funcName].size,
      mclass: delimiterSizes[context.funcName].mclass,
      delim: delim.text
    };
  },
  htmlBuilder: (group, options) => {
    if (group.delim === ".") {
      return buildCommon.makeSpan([group.mclass]);
    }
    return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
  },
  mathmlBuilder: (group) => {
    var children = [];
    if (group.delim !== ".") {
      children.push(makeText(group.delim, group.mode));
    }
    var node2 = new mathMLTree.MathNode("mo", children);
    if (group.mclass === "mopen" || group.mclass === "mclose") {
      node2.setAttribute("fence", "true");
    } else {
      node2.setAttribute("fence", "false");
    }
    node2.setAttribute("stretchy", "true");
    var size4 = makeEm(delimiter.sizeToMaxHeight[group.size]);
    node2.setAttribute("minsize", size4);
    node2.setAttribute("maxsize", size4);
    return node2;
  }
});
function assertParsed(group) {
  if (!group.body) {
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
  }
}
defineFunction({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    var color2 = context.parser.gullet.macros.get("\\current@color");
    if (color2 && typeof color2 !== "string") {
      throw new ParseError("\\current@color set to non-string in \\right");
    }
    return {
      type: "leftright-right",
      mode: context.parser.mode,
      delim: checkDelimiter(args[0], context).text,
      color: color2
      // undefined if not set via \color
    };
  }
});
defineFunction({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    var delim = checkDelimiter(args[0], context);
    var parser = context.parser;
    ++parser.leftrightDepth;
    var body = parser.parseExpression(false);
    --parser.leftrightDepth;
    parser.expect("\\right", false);
    var right = assertNodeType(parser.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: parser.mode,
      body,
      left: delim.text,
      right: right.delim,
      rightColor: right.color
    };
  },
  htmlBuilder: (group, options) => {
    assertParsed(group);
    var inner3 = buildExpression$1(group.body, options, true, ["mopen", "mclose"]);
    var innerHeight = 0;
    var innerDepth = 0;
    var hadMiddle = false;
    for (var i16 = 0; i16 < inner3.length; i16++) {
      if (inner3[i16].isMiddle) {
        hadMiddle = true;
      } else {
        innerHeight = Math.max(inner3[i16].height, innerHeight);
        innerDepth = Math.max(inner3[i16].depth, innerDepth);
      }
    }
    innerHeight *= options.sizeMultiplier;
    innerDepth *= options.sizeMultiplier;
    var leftDelim;
    if (group.left === ".") {
      leftDelim = makeNullDelimiter(options, ["mopen"]);
    } else {
      leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
    }
    inner3.unshift(leftDelim);
    if (hadMiddle) {
      for (var _i = 1; _i < inner3.length; _i++) {
        var middleDelim = inner3[_i];
        var isMiddle = middleDelim.isMiddle;
        if (isMiddle) {
          inner3[_i] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
        }
      }
    }
    var rightDelim;
    if (group.right === ".") {
      rightDelim = makeNullDelimiter(options, ["mclose"]);
    } else {
      var colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
      rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
    }
    inner3.push(rightDelim);
    return buildCommon.makeSpan(["minner"], inner3, options);
  },
  mathmlBuilder: (group, options) => {
    assertParsed(group);
    var inner3 = buildExpression2(group.body, options);
    if (group.left !== ".") {
      var leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
      leftNode.setAttribute("fence", "true");
      inner3.unshift(leftNode);
    }
    if (group.right !== ".") {
      var rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
      rightNode.setAttribute("fence", "true");
      if (group.rightColor) {
        rightNode.setAttribute("mathcolor", group.rightColor);
      }
      inner3.push(rightNode);
    }
    return makeRow(inner3);
  }
});
defineFunction({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (context, args) => {
    var delim = checkDelimiter(args[0], context);
    if (!context.parser.leftrightDepth) {
      throw new ParseError("\\middle without preceding \\left", delim);
    }
    return {
      type: "middle",
      mode: context.parser.mode,
      delim: delim.text
    };
  },
  htmlBuilder: (group, options) => {
    var middleDelim;
    if (group.delim === ".") {
      middleDelim = makeNullDelimiter(options, []);
    } else {
      middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);
      var isMiddle = {
        delim: group.delim,
        options
      };
      middleDelim.isMiddle = isMiddle;
    }
    return middleDelim;
  },
  mathmlBuilder: (group, options) => {
    var textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
    var middleNode = new mathMLTree.MathNode("mo", [textNode]);
    middleNode.setAttribute("fence", "true");
    middleNode.setAttribute("lspace", "0.05em");
    middleNode.setAttribute("rspace", "0.05em");
    return middleNode;
  }
});
var htmlBuilder$7 = (group, options) => {
  var inner3 = buildCommon.wrapFragment(buildGroup$1(group.body, options), options);
  var label = group.label.slice(1);
  var scale = options.sizeMultiplier;
  var img;
  var imgShift = 0;
  var isSingleChar = utils.isCharacterBox(group.body);
  if (label === "sout") {
    img = buildCommon.makeSpan(["stretchy", "sout"]);
    img.height = options.fontMetrics().defaultRuleThickness / scale;
    imgShift = -0.5 * options.fontMetrics().xHeight;
  } else if (label === "phase") {
    var lineWeight = calculateSize({
      number: 0.6,
      unit: "pt"
    }, options);
    var clearance = calculateSize({
      number: 0.35,
      unit: "ex"
    }, options);
    var newOptions = options.havingBaseSizing();
    scale = scale / newOptions.sizeMultiplier;
    var angleHeight = inner3.height + inner3.depth + lineWeight + clearance;
    inner3.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight);
    var viewBoxHeight = Math.floor(1e3 * angleHeight * scale);
    var path3 = phasePath(viewBoxHeight);
    var svgNode = new SvgNode([new PathNode("phase", path3)], {
      "width": "400em",
      "height": makeEm(viewBoxHeight / 1e3),
      "viewBox": "0 0 400000 " + viewBoxHeight,
      "preserveAspectRatio": "xMinYMin slice"
    });
    img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode], options);
    img.style.height = makeEm(angleHeight);
    imgShift = inner3.depth + lineWeight + clearance;
  } else {
    if (/cancel/.test(label)) {
      if (!isSingleChar) {
        inner3.classes.push("cancel-pad");
      }
    } else if (label === "angl") {
      inner3.classes.push("anglpad");
    } else {
      inner3.classes.push("boxpad");
    }
    var topPad = 0;
    var bottomPad = 0;
    var ruleThickness = 0;
    if (/box/.test(label)) {
      ruleThickness = Math.max(
        options.fontMetrics().fboxrule,
        // default
        options.minRuleThickness
        // User override.
      );
      topPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
      bottomPad = topPad;
    } else if (label === "angl") {
      ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
      topPad = 4 * ruleThickness;
      bottomPad = Math.max(0, 0.25 - inner3.depth);
    } else {
      topPad = isSingleChar ? 0.2 : 0;
      bottomPad = topPad;
    }
    img = stretchy.encloseSpan(inner3, label, topPad, bottomPad, options);
    if (/fbox|boxed|fcolorbox/.test(label)) {
      img.style.borderStyle = "solid";
      img.style.borderWidth = makeEm(ruleThickness);
    } else if (label === "angl" && ruleThickness !== 0.049) {
      img.style.borderTopWidth = makeEm(ruleThickness);
      img.style.borderRightWidth = makeEm(ruleThickness);
    }
    imgShift = inner3.depth + bottomPad;
    if (group.backgroundColor) {
      img.style.backgroundColor = group.backgroundColor;
      if (group.borderColor) {
        img.style.borderColor = group.borderColor;
      }
    }
  }
  var vlist;
  if (group.backgroundColor) {
    vlist = buildCommon.makeVList({
      positionType: "individualShift",
      children: [
        // Put the color background behind inner;
        {
          type: "elem",
          elem: img,
          shift: imgShift
        },
        {
          type: "elem",
          elem: inner3,
          shift: 0
        }
      ]
    }, options);
  } else {
    var classes = /cancel|phase/.test(label) ? ["svg-align"] : [];
    vlist = buildCommon.makeVList({
      positionType: "individualShift",
      children: [
        // Write the \cancel stroke on top of inner.
        {
          type: "elem",
          elem: inner3,
          shift: 0
        },
        {
          type: "elem",
          elem: img,
          shift: imgShift,
          wrapperClasses: classes
        }
      ]
    }, options);
  }
  if (/cancel/.test(label)) {
    vlist.height = inner3.height;
    vlist.depth = inner3.depth;
  }
  if (/cancel/.test(label) && !isSingleChar) {
    return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
  } else {
    return buildCommon.makeSpan(["mord"], [vlist], options);
  }
};
var mathmlBuilder$6 = (group, options) => {
  var fboxsep = 0;
  var node2 = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildGroup2(group.body, options)]);
  switch (group.label) {
    case "\\cancel":
      node2.setAttribute("notation", "updiagonalstrike");
      break;
    case "\\bcancel":
      node2.setAttribute("notation", "downdiagonalstrike");
      break;
    case "\\phase":
      node2.setAttribute("notation", "phasorangle");
      break;
    case "\\sout":
      node2.setAttribute("notation", "horizontalstrike");
      break;
    case "\\fbox":
      node2.setAttribute("notation", "box");
      break;
    case "\\angl":
      node2.setAttribute("notation", "actuarial");
      break;
    case "\\fcolorbox":
    case "\\colorbox":
      fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
      node2.setAttribute("width", "+" + 2 * fboxsep + "pt");
      node2.setAttribute("height", "+" + 2 * fboxsep + "pt");
      node2.setAttribute("lspace", fboxsep + "pt");
      node2.setAttribute("voffset", fboxsep + "pt");
      if (group.label === "\\fcolorbox") {
        var thk = Math.max(
          options.fontMetrics().fboxrule,
          // default
          options.minRuleThickness
          // user override
        );
        node2.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
      }
      break;
    case "\\xcancel":
      node2.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }
  if (group.backgroundColor) {
    node2.setAttribute("mathbackground", group.backgroundColor);
  }
  return node2;
};
defineFunction({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: true,
    argTypes: ["color", "text"]
  },
  handler(_ref, args, optArgs) {
    var {
      parser,
      funcName
    } = _ref;
    var color2 = assertNodeType(args[0], "color-token").color;
    var body = args[1];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor: color2,
      body
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: true,
    argTypes: ["color", "color", "text"]
  },
  handler(_ref2, args, optArgs) {
    var {
      parser,
      funcName
    } = _ref2;
    var borderColor = assertNodeType(args[0], "color-token").color;
    var backgroundColor = assertNodeType(args[1], "color-token").color;
    var body = args[2];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor,
      borderColor,
      body
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: true
  },
  handler(_ref3, args) {
    var {
      parser
    } = _ref3;
    return {
      type: "enclose",
      mode: parser.mode,
      label: "\\fbox",
      body: args[0]
    };
  }
});
defineFunction({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },
  handler(_ref4, args) {
    var {
      parser,
      funcName
    } = _ref4;
    var body = args[0];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      body
    };
  },
  htmlBuilder: htmlBuilder$7,
  mathmlBuilder: mathmlBuilder$6
});
defineFunction({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: false
  },
  handler(_ref5, args) {
    var {
      parser
    } = _ref5;
    return {
      type: "enclose",
      mode: parser.mode,
      label: "\\angl",
      body: args[0]
    };
  }
});
var _environments = {};
function defineEnvironment(_ref) {
  var {
    type,
    names,
    props,
    handler,
    htmlBuilder: htmlBuilder3,
    mathmlBuilder: mathmlBuilder3
  } = _ref;
  var data = {
    type,
    numArgs: props.numArgs || 0,
    allowedInText: false,
    numOptionalArgs: 0,
    handler
  };
  for (var i16 = 0; i16 < names.length; ++i16) {
    _environments[names[i16]] = data;
  }
  if (htmlBuilder3) {
    _htmlGroupBuilders[type] = htmlBuilder3;
  }
  if (mathmlBuilder3) {
    _mathmlGroupBuilders[type] = mathmlBuilder3;
  }
}
var _macros = {};
function defineMacro(name2, body) {
  _macros[name2] = body;
}
function getHLines(parser) {
  var hlineInfo = [];
  parser.consumeSpaces();
  var nxt = parser.fetch().text;
  if (nxt === "\\relax") {
    parser.consume();
    parser.consumeSpaces();
    nxt = parser.fetch().text;
  }
  while (nxt === "\\hline" || nxt === "\\hdashline") {
    parser.consume();
    hlineInfo.push(nxt === "\\hdashline");
    parser.consumeSpaces();
    nxt = parser.fetch().text;
  }
  return hlineInfo;
}
var validateAmsEnvironmentContext = (context) => {
  var settings = context.parser.settings;
  if (!settings.displayMode) {
    throw new ParseError("{" + context.envName + "} can be used only in display mode.");
  }
};
function getAutoTag(name2) {
  if (name2.indexOf("ed") === -1) {
    return name2.indexOf("*") === -1;
  }
}
function parseArray(parser, _ref, style2) {
  var {
    hskipBeforeAndAfter,
    addJot,
    cols,
    arraystretch,
    colSeparationType,
    autoTag,
    singleRow,
    emptySingleRow,
    maxNumCols,
    leqno
  } = _ref;
  parser.gullet.beginGroup();
  if (!singleRow) {
    parser.gullet.macros.set("\\cr", "\\\\\\relax");
  }
  if (!arraystretch) {
    var stretch = parser.gullet.expandMacroAsText("\\arraystretch");
    if (stretch == null) {
      arraystretch = 1;
    } else {
      arraystretch = parseFloat(stretch);
      if (!arraystretch || arraystretch < 0) {
        throw new ParseError("Invalid \\arraystretch: " + stretch);
      }
    }
  }
  parser.gullet.beginGroup();
  var row = [];
  var body = [row];
  var rowGaps = [];
  var hLinesBeforeRow = [];
  var tags = autoTag != null ? [] : void 0;
  function beginRow() {
    if (autoTag) {
      parser.gullet.macros.set("\\@eqnsw", "1", true);
    }
  }
  function endRow() {
    if (tags) {
      if (parser.gullet.macros.get("\\df@tag")) {
        tags.push(parser.subparse([new Token("\\df@tag")]));
        parser.gullet.macros.set("\\df@tag", void 0, true);
      } else {
        tags.push(Boolean(autoTag) && parser.gullet.macros.get("\\@eqnsw") === "1");
      }
    }
  }
  beginRow();
  hLinesBeforeRow.push(getHLines(parser));
  while (true) {
    var cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
    parser.gullet.endGroup();
    parser.gullet.beginGroup();
    cell = {
      type: "ordgroup",
      mode: parser.mode,
      body: cell
    };
    if (style2) {
      cell = {
        type: "styling",
        mode: parser.mode,
        style: style2,
        body: [cell]
      };
    }
    row.push(cell);
    var next2 = parser.fetch().text;
    if (next2 === "&") {
      if (maxNumCols && row.length === maxNumCols) {
        if (singleRow || colSeparationType) {
          throw new ParseError("Too many tab characters: &", parser.nextToken);
        } else {
          parser.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
        }
      }
      parser.consume();
    } else if (next2 === "\\end") {
      endRow();
      if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
        body.pop();
      }
      if (hLinesBeforeRow.length < body.length + 1) {
        hLinesBeforeRow.push([]);
      }
      break;
    } else if (next2 === "\\\\") {
      parser.consume();
      var size4 = void 0;
      if (parser.gullet.future().text !== " ") {
        size4 = parser.parseSizeGroup(true);
      }
      rowGaps.push(size4 ? size4.value : null);
      endRow();
      hLinesBeforeRow.push(getHLines(parser));
      row = [];
      body.push(row);
      beginRow();
    } else {
      throw new ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
    }
  }
  parser.gullet.endGroup();
  parser.gullet.endGroup();
  return {
    type: "array",
    mode: parser.mode,
    addJot,
    arraystretch,
    body,
    cols,
    rowGaps,
    hskipBeforeAndAfter,
    hLinesBeforeRow,
    colSeparationType,
    tags,
    leqno
  };
}
function dCellStyle(envName) {
  if (envName.slice(0, 1) === "d") {
    return "display";
  } else {
    return "text";
  }
}
var htmlBuilder$6 = function htmlBuilder(group, options) {
  var r22;
  var c21;
  var nr = group.body.length;
  var hLinesBeforeRow = group.hLinesBeforeRow;
  var nc = 0;
  var body = new Array(nr);
  var hlines = [];
  var ruleThickness = Math.max(
    // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
    options.fontMetrics().arrayRuleWidth,
    options.minRuleThickness
    // User override.
  );
  var pt2 = 1 / options.fontMetrics().ptPerEm;
  var arraycolsep = 5 * pt2;
  if (group.colSeparationType && group.colSeparationType === "small") {
    var localMultiplier = options.havingStyle(Style$1.SCRIPT).sizeMultiplier;
    arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
  }
  var baselineskip = group.colSeparationType === "CD" ? calculateSize({
    number: 3,
    unit: "ex"
  }, options) : 12 * pt2;
  var jot = 3 * pt2;
  var arrayskip = group.arraystretch * baselineskip;
  var arstrutHeight = 0.7 * arrayskip;
  var arstrutDepth = 0.3 * arrayskip;
  var totalHeight = 0;
  function setHLinePos(hlinesInGap) {
    for (var i16 = 0; i16 < hlinesInGap.length; ++i16) {
      if (i16 > 0) {
        totalHeight += 0.25;
      }
      hlines.push({
        pos: totalHeight,
        isDashed: hlinesInGap[i16]
      });
    }
  }
  setHLinePos(hLinesBeforeRow[0]);
  for (r22 = 0; r22 < group.body.length; ++r22) {
    var inrow = group.body[r22];
    var height = arstrutHeight;
    var depth = arstrutDepth;
    if (nc < inrow.length) {
      nc = inrow.length;
    }
    var outrow = new Array(inrow.length);
    for (c21 = 0; c21 < inrow.length; ++c21) {
      var elt = buildGroup$1(inrow[c21], options);
      if (depth < elt.depth) {
        depth = elt.depth;
      }
      if (height < elt.height) {
        height = elt.height;
      }
      outrow[c21] = elt;
    }
    var rowGap = group.rowGaps[r22];
    var gap = 0;
    if (rowGap) {
      gap = calculateSize(rowGap, options);
      if (gap > 0) {
        gap += arstrutDepth;
        if (depth < gap) {
          depth = gap;
        }
        gap = 0;
      }
    }
    if (group.addJot) {
      depth += jot;
    }
    outrow.height = height;
    outrow.depth = depth;
    totalHeight += height;
    outrow.pos = totalHeight;
    totalHeight += depth + gap;
    body[r22] = outrow;
    setHLinePos(hLinesBeforeRow[r22 + 1]);
  }
  var offset4 = totalHeight / 2 + options.fontMetrics().axisHeight;
  var colDescriptions = group.cols || [];
  var cols = [];
  var colSep;
  var colDescrNum;
  var tagSpans = [];
  if (group.tags && group.tags.some((tag2) => tag2)) {
    for (r22 = 0; r22 < nr; ++r22) {
      var rw = body[r22];
      var shift4 = rw.pos - offset4;
      var tag = group.tags[r22];
      var tagSpan = void 0;
      if (tag === true) {
        tagSpan = buildCommon.makeSpan(["eqn-num"], [], options);
      } else if (tag === false) {
        tagSpan = buildCommon.makeSpan([], [], options);
      } else {
        tagSpan = buildCommon.makeSpan([], buildExpression$1(tag, options, true), options);
      }
      tagSpan.depth = rw.depth;
      tagSpan.height = rw.height;
      tagSpans.push({
        type: "elem",
        elem: tagSpan,
        shift: shift4
      });
    }
  }
  for (
    c21 = 0, colDescrNum = 0;
    // Continue while either there are more columns or more column
    // descriptions, so trailing separators don't get lost.
    c21 < nc || colDescrNum < colDescriptions.length;
    ++c21, ++colDescrNum
  ) {
    var colDescr = colDescriptions[colDescrNum] || {};
    var firstSeparator = true;
    while (colDescr.type === "separator") {
      if (!firstSeparator) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(options.fontMetrics().doubleRuleSep);
        cols.push(colSep);
      }
      if (colDescr.separator === "|" || colDescr.separator === ":") {
        var lineType = colDescr.separator === "|" ? "solid" : "dashed";
        var separator = buildCommon.makeSpan(["vertical-separator"], [], options);
        separator.style.height = makeEm(totalHeight);
        separator.style.borderRightWidth = makeEm(ruleThickness);
        separator.style.borderRightStyle = lineType;
        separator.style.margin = "0 " + makeEm(-ruleThickness / 2);
        var _shift = totalHeight - offset4;
        if (_shift) {
          separator.style.verticalAlign = makeEm(-_shift);
        }
        cols.push(separator);
      } else {
        throw new ParseError("Invalid separator type: " + colDescr.separator);
      }
      colDescrNum++;
      colDescr = colDescriptions[colDescrNum] || {};
      firstSeparator = false;
    }
    if (c21 >= nc) {
      continue;
    }
    var sepwidth = void 0;
    if (c21 > 0 || group.hskipBeforeAndAfter) {
      sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
      if (sepwidth !== 0) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(sepwidth);
        cols.push(colSep);
      }
    }
    var col = [];
    for (r22 = 0; r22 < nr; ++r22) {
      var row = body[r22];
      var elem = row[c21];
      if (!elem) {
        continue;
      }
      var _shift2 = row.pos - offset4;
      elem.depth = row.depth;
      elem.height = row.height;
      col.push({
        type: "elem",
        elem,
        shift: _shift2
      });
    }
    col = buildCommon.makeVList({
      positionType: "individualShift",
      children: col
    }, options);
    col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
    cols.push(col);
    if (c21 < nc - 1 || group.hskipBeforeAndAfter) {
      sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
      if (sepwidth !== 0) {
        colSep = buildCommon.makeSpan(["arraycolsep"], []);
        colSep.style.width = makeEm(sepwidth);
        cols.push(colSep);
      }
    }
  }
  body = buildCommon.makeSpan(["mtable"], cols);
  if (hlines.length > 0) {
    var line = buildCommon.makeLineSpan("hline", options, ruleThickness);
    var dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
    var vListElems = [{
      type: "elem",
      elem: body,
      shift: 0
    }];
    while (hlines.length > 0) {
      var hline = hlines.pop();
      var lineShift = hline.pos - offset4;
      if (hline.isDashed) {
        vListElems.push({
          type: "elem",
          elem: dashes,
          shift: lineShift
        });
      } else {
        vListElems.push({
          type: "elem",
          elem: line,
          shift: lineShift
        });
      }
    }
    body = buildCommon.makeVList({
      positionType: "individualShift",
      children: vListElems
    }, options);
  }
  if (tagSpans.length === 0) {
    return buildCommon.makeSpan(["mord"], [body], options);
  } else {
    var eqnNumCol = buildCommon.makeVList({
      positionType: "individualShift",
      children: tagSpans
    }, options);
    eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options);
    return buildCommon.makeFragment([body, eqnNumCol]);
  }
};
var alignMap = {
  c: "center ",
  l: "left ",
  r: "right "
};
var mathmlBuilder$5 = function mathmlBuilder(group, options) {
  var tbl = [];
  var glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
  var tag = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);
  for (var i16 = 0; i16 < group.body.length; i16++) {
    var rw = group.body[i16];
    var row = [];
    for (var j11 = 0; j11 < rw.length; j11++) {
      row.push(new mathMLTree.MathNode("mtd", [buildGroup2(rw[j11], options)]));
    }
    if (group.tags && group.tags[i16]) {
      row.unshift(glue);
      row.push(glue);
      if (group.leqno) {
        row.unshift(tag);
      } else {
        row.push(tag);
      }
    }
    tbl.push(new mathMLTree.MathNode("mtr", row));
  }
  var table2 = new mathMLTree.MathNode("mtable", tbl);
  var gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
  table2.setAttribute("rowspacing", makeEm(gap));
  var menclose = "";
  var align = "";
  if (group.cols && group.cols.length > 0) {
    var cols = group.cols;
    var columnLines = "";
    var prevTypeWasAlign = false;
    var iStart = 0;
    var iEnd = cols.length;
    if (cols[0].type === "separator") {
      menclose += "top ";
      iStart = 1;
    }
    if (cols[cols.length - 1].type === "separator") {
      menclose += "bottom ";
      iEnd -= 1;
    }
    for (var _i = iStart; _i < iEnd; _i++) {
      if (cols[_i].type === "align") {
        align += alignMap[cols[_i].align];
        if (prevTypeWasAlign) {
          columnLines += "none ";
        }
        prevTypeWasAlign = true;
      } else if (cols[_i].type === "separator") {
        if (prevTypeWasAlign) {
          columnLines += cols[_i].separator === "|" ? "solid " : "dashed ";
          prevTypeWasAlign = false;
        }
      }
    }
    table2.setAttribute("columnalign", align.trim());
    if (/[sd]/.test(columnLines)) {
      table2.setAttribute("columnlines", columnLines.trim());
    }
  }
  if (group.colSeparationType === "align") {
    var _cols = group.cols || [];
    var spacing2 = "";
    for (var _i2 = 1; _i2 < _cols.length; _i2++) {
      spacing2 += _i2 % 2 ? "0em " : "1em ";
    }
    table2.setAttribute("columnspacing", spacing2.trim());
  } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
    table2.setAttribute("columnspacing", "0em");
  } else if (group.colSeparationType === "small") {
    table2.setAttribute("columnspacing", "0.2778em");
  } else if (group.colSeparationType === "CD") {
    table2.setAttribute("columnspacing", "0.5em");
  } else {
    table2.setAttribute("columnspacing", "1em");
  }
  var rowLines = "";
  var hlines = group.hLinesBeforeRow;
  menclose += hlines[0].length > 0 ? "left " : "";
  menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
  for (var _i3 = 1; _i3 < hlines.length - 1; _i3++) {
    rowLines += hlines[_i3].length === 0 ? "none " : hlines[_i3][0] ? "dashed " : "solid ";
  }
  if (/[sd]/.test(rowLines)) {
    table2.setAttribute("rowlines", rowLines.trim());
  }
  if (menclose !== "") {
    table2 = new mathMLTree.MathNode("menclose", [table2]);
    table2.setAttribute("notation", menclose.trim());
  }
  if (group.arraystretch && group.arraystretch < 1) {
    table2 = new mathMLTree.MathNode("mstyle", [table2]);
    table2.setAttribute("scriptlevel", "1");
  }
  return table2;
};
var alignedHandler = function alignedHandler2(context, args) {
  if (context.envName.indexOf("ed") === -1) {
    validateAmsEnvironmentContext(context);
  }
  var cols = [];
  var separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
  var isSplit = context.envName === "split";
  var res = parseArray(context.parser, {
    cols,
    addJot: true,
    autoTag: isSplit ? void 0 : getAutoTag(context.envName),
    emptySingleRow: true,
    colSeparationType: separationType,
    maxNumCols: isSplit ? 2 : void 0,
    leqno: context.parser.settings.leqno
  }, "display");
  var numMaths;
  var numCols = 0;
  var emptyGroup = {
    type: "ordgroup",
    mode: context.mode,
    body: []
  };
  if (args[0] && args[0].type === "ordgroup") {
    var arg0 = "";
    for (var i16 = 0; i16 < args[0].body.length; i16++) {
      var textord2 = assertNodeType(args[0].body[i16], "textord");
      arg0 += textord2.text;
    }
    numMaths = Number(arg0);
    numCols = numMaths * 2;
  }
  var isAligned = !numCols;
  res.body.forEach(function(row) {
    for (var _i4 = 1; _i4 < row.length; _i4 += 2) {
      var styling = assertNodeType(row[_i4], "styling");
      var ordgroup = assertNodeType(styling.body[0], "ordgroup");
      ordgroup.body.unshift(emptyGroup);
    }
    if (!isAligned) {
      var curMaths = row.length / 2;
      if (numMaths < curMaths) {
        throw new ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
      }
    } else if (numCols < row.length) {
      numCols = row.length;
    }
  });
  for (var _i5 = 0; _i5 < numCols; ++_i5) {
    var align = "r";
    var pregap = 0;
    if (_i5 % 2 === 1) {
      align = "l";
    } else if (_i5 > 0 && isAligned) {
      pregap = 1;
    }
    cols[_i5] = {
      type: "align",
      align,
      pregap,
      postgap: 0
    };
  }
  res.colSeparationType = isAligned ? "align" : "alignat";
  return res;
};
defineEnvironment({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(context, args) {
    var symNode = checkSymbolNodeType(args[0]);
    var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    var cols = colalign.map(function(nde) {
      var node2 = assertSymbolNodeType(nde);
      var ca = node2.text;
      if ("lcr".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      } else if (ca === "|") {
        return {
          type: "separator",
          separator: "|"
        };
      } else if (ca === ":") {
        return {
          type: "separator",
          separator: ":"
        };
      }
      throw new ParseError("Unknown column alignment: " + ca, nde);
    });
    var res = {
      cols,
      hskipBeforeAndAfter: true,
      // \@preamble in lttab.dtx
      maxNumCols: cols.length
    };
    return parseArray(context.parser, res, dCellStyle(context.envName));
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    var delimiters2 = {
      "matrix": null,
      "pmatrix": ["(", ")"],
      "bmatrix": ["[", "]"],
      "Bmatrix": ["\\{", "\\}"],
      "vmatrix": ["|", "|"],
      "Vmatrix": ["\\Vert", "\\Vert"]
    }[context.envName.replace("*", "")];
    var colAlign = "c";
    var payload = {
      hskipBeforeAndAfter: false,
      cols: [{
        type: "align",
        align: colAlign
      }]
    };
    if (context.envName.charAt(context.envName.length - 1) === "*") {
      var parser = context.parser;
      parser.consumeSpaces();
      if (parser.fetch().text === "[") {
        parser.consume();
        parser.consumeSpaces();
        colAlign = parser.fetch().text;
        if ("lcr".indexOf(colAlign) === -1) {
          throw new ParseError("Expected l or c or r", parser.nextToken);
        }
        parser.consume();
        parser.consumeSpaces();
        parser.expect("]");
        parser.consume();
        payload.cols = [{
          type: "align",
          align: colAlign
        }];
      }
    }
    var res = parseArray(context.parser, payload, dCellStyle(context.envName));
    var numCols = Math.max(0, ...res.body.map((row) => row.length));
    res.cols = new Array(numCols).fill({
      type: "align",
      align: colAlign
    });
    return delimiters2 ? {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: delimiters2[0],
      right: delimiters2[1],
      rightColor: void 0
      // \right uninfluenced by \color in array
    } : res;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(context) {
    var payload = {
      arraystretch: 0.5
    };
    var res = parseArray(context.parser, payload, "script");
    res.colSeparationType = "small";
    return res;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(context, args) {
    var symNode = checkSymbolNodeType(args[0]);
    var colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    var cols = colalign.map(function(nde) {
      var node2 = assertSymbolNodeType(nde);
      var ca = node2.text;
      if ("lc".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      }
      throw new ParseError("Unknown column alignment: " + ca, nde);
    });
    if (cols.length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }
    var res = {
      cols,
      hskipBeforeAndAfter: false,
      arraystretch: 0.5
    };
    res = parseArray(context.parser, res, "script");
    if (res.body.length > 0 && res.body[0].length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }
    return res;
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(context) {
    var payload = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1
        /* 1em quad */
      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    };
    var res = parseArray(context.parser, payload, dCellStyle(context.envName));
    return {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: context.envName.indexOf("r") > -1 ? "." : "\\{",
      right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: alignedHandler,
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    if (["gather", "gather*"].includes(context.envName)) {
      validateAmsEnvironmentContext(context);
    }
    var res = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: true,
      colSeparationType: "gather",
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: alignedHandler,
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    var res = {
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      singleRow: true,
      maxNumCols: 1,
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineEnvironment({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    return parseCD(context.parser);
  },
  htmlBuilder: htmlBuilder$6,
  mathmlBuilder: mathmlBuilder$5
});
defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
defineMacro("\\notag", "\\nonumber");
defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: true
  },
  handler(context, args) {
    throw new ParseError(context.funcName + " valid only within array environment");
  }
});
var environments = _environments;
defineFunction({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var nameGroup = args[0];
    if (nameGroup.type !== "ordgroup") {
      throw new ParseError("Invalid environment name", nameGroup);
    }
    var envName = "";
    for (var i16 = 0; i16 < nameGroup.body.length; ++i16) {
      envName += assertNodeType(nameGroup.body[i16], "textord").text;
    }
    if (funcName === "\\begin") {
      if (!environments.hasOwnProperty(envName)) {
        throw new ParseError("No such environment: " + envName, nameGroup);
      }
      var env2 = environments[envName];
      var {
        args: _args,
        optArgs
      } = parser.parseArguments("\\begin{" + envName + "}", env2);
      var context = {
        mode: parser.mode,
        envName,
        parser
      };
      var result = env2.handler(context, _args, optArgs);
      parser.expect("\\end", false);
      var endNameToken = parser.nextToken;
      var end = assertNodeType(parser.parseFunction(), "environment");
      if (end.name !== envName) {
        throw new ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
      }
      return result;
    }
    return {
      type: "environment",
      mode: parser.mode,
      name: envName,
      nameGroup
    };
  }
});
var htmlBuilder$5 = (group, options) => {
  var font = group.font;
  var newOptions = options.withFont(font);
  return buildGroup$1(group.body, newOptions);
};
var mathmlBuilder$4 = (group, options) => {
  var font = group.font;
  var newOptions = options.withFont(font);
  return buildGroup2(group.body, newOptions);
};
var fontAliases = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
defineFunction({
  type: "font",
  names: [
    // styles, except \boldsymbol defined below
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    "\\mathsfit",
    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    // aliases, except \bm defined below
    "\\Bbb",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var body = normalizeArgument(args[0]);
    var func = funcName;
    if (func in fontAliases) {
      func = fontAliases[func];
    }
    return {
      type: "font",
      mode: parser.mode,
      font: func.slice(1),
      body
    };
  },
  htmlBuilder: htmlBuilder$5,
  mathmlBuilder: mathmlBuilder$4
});
defineFunction({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var body = args[0];
    var isCharacterBox3 = utils.isCharacterBox(body);
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: binrelClass(body),
      body: [{
        type: "font",
        mode: parser.mode,
        font: "boldsymbol",
        body
      }],
      isCharacterBox: isCharacterBox3
    };
  }
});
defineFunction({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: (_ref3, args) => {
    var {
      parser,
      funcName,
      breakOnTokenText
    } = _ref3;
    var {
      mode
    } = parser;
    var body = parser.parseExpression(true, breakOnTokenText);
    var style2 = "math" + funcName.slice(1);
    return {
      type: "font",
      mode,
      font: style2,
      body: {
        type: "ordgroup",
        mode: parser.mode,
        body
      }
    };
  },
  htmlBuilder: htmlBuilder$5,
  mathmlBuilder: mathmlBuilder$4
});
var adjustStyle = (size4, originalStyle) => {
  var style2 = originalStyle;
  if (size4 === "display") {
    style2 = style2.id >= Style$1.SCRIPT.id ? style2.text() : Style$1.DISPLAY;
  } else if (size4 === "text" && style2.size === Style$1.DISPLAY.size) {
    style2 = Style$1.TEXT;
  } else if (size4 === "script") {
    style2 = Style$1.SCRIPT;
  } else if (size4 === "scriptscript") {
    style2 = Style$1.SCRIPTSCRIPT;
  }
  return style2;
};
var htmlBuilder$4 = (group, options) => {
  var style2 = adjustStyle(group.size, options.style);
  var nstyle = style2.fracNum();
  var dstyle = style2.fracDen();
  var newOptions;
  newOptions = options.havingStyle(nstyle);
  var numerm = buildGroup$1(group.numer, newOptions, options);
  if (group.continued) {
    var hStrut = 8.5 / options.fontMetrics().ptPerEm;
    var dStrut = 3.5 / options.fontMetrics().ptPerEm;
    numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
    numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
  }
  newOptions = options.havingStyle(dstyle);
  var denomm = buildGroup$1(group.denom, newOptions, options);
  var rule;
  var ruleWidth;
  var ruleSpacing;
  if (group.hasBarLine) {
    if (group.barSize) {
      ruleWidth = calculateSize(group.barSize, options);
      rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
    } else {
      rule = buildCommon.makeLineSpan("frac-line", options);
    }
    ruleWidth = rule.height;
    ruleSpacing = rule.height;
  } else {
    rule = null;
    ruleWidth = 0;
    ruleSpacing = options.fontMetrics().defaultRuleThickness;
  }
  var numShift;
  var clearance;
  var denomShift;
  if (style2.size === Style$1.DISPLAY.size || group.size === "display") {
    numShift = options.fontMetrics().num1;
    if (ruleWidth > 0) {
      clearance = 3 * ruleSpacing;
    } else {
      clearance = 7 * ruleSpacing;
    }
    denomShift = options.fontMetrics().denom1;
  } else {
    if (ruleWidth > 0) {
      numShift = options.fontMetrics().num2;
      clearance = ruleSpacing;
    } else {
      numShift = options.fontMetrics().num3;
      clearance = 3 * ruleSpacing;
    }
    denomShift = options.fontMetrics().denom2;
  }
  var frac;
  if (!rule) {
    var candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
    if (candidateClearance < clearance) {
      numShift += 0.5 * (clearance - candidateClearance);
      denomShift += 0.5 * (clearance - candidateClearance);
    }
    frac = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: denomm,
        shift: denomShift
      }, {
        type: "elem",
        elem: numerm,
        shift: -numShift
      }]
    }, options);
  } else {
    var axisHeight = options.fontMetrics().axisHeight;
    if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
      numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
    }
    if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
      denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
    }
    var midShift = -(axisHeight - 0.5 * ruleWidth);
    frac = buildCommon.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: denomm,
        shift: denomShift
      }, {
        type: "elem",
        elem: rule,
        shift: midShift
      }, {
        type: "elem",
        elem: numerm,
        shift: -numShift
      }]
    }, options);
  }
  newOptions = options.havingStyle(style2);
  frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
  frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier;
  var delimSize;
  if (style2.size === Style$1.DISPLAY.size) {
    delimSize = options.fontMetrics().delim1;
  } else if (style2.size === Style$1.SCRIPTSCRIPT.size) {
    delimSize = options.havingStyle(Style$1.SCRIPT).fontMetrics().delim2;
  } else {
    delimSize = options.fontMetrics().delim2;
  }
  var leftDelim;
  var rightDelim;
  if (group.leftDelim == null) {
    leftDelim = makeNullDelimiter(options, ["mopen"]);
  } else {
    leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style2), group.mode, ["mopen"]);
  }
  if (group.continued) {
    rightDelim = buildCommon.makeSpan([]);
  } else if (group.rightDelim == null) {
    rightDelim = makeNullDelimiter(options, ["mclose"]);
  } else {
    rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style2), group.mode, ["mclose"]);
  }
  return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
};
var mathmlBuilder$3 = (group, options) => {
  var node2 = new mathMLTree.MathNode("mfrac", [buildGroup2(group.numer, options), buildGroup2(group.denom, options)]);
  if (!group.hasBarLine) {
    node2.setAttribute("linethickness", "0px");
  } else if (group.barSize) {
    var ruleWidth = calculateSize(group.barSize, options);
    node2.setAttribute("linethickness", makeEm(ruleWidth));
  }
  var style2 = adjustStyle(group.size, options.style);
  if (style2.size !== options.style.size) {
    node2 = new mathMLTree.MathNode("mstyle", [node2]);
    var isDisplay = style2.size === Style$1.DISPLAY.size ? "true" : "false";
    node2.setAttribute("displaystyle", isDisplay);
    node2.setAttribute("scriptlevel", "0");
  }
  if (group.leftDelim != null || group.rightDelim != null) {
    var withDelims = [];
    if (group.leftDelim != null) {
      var leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
      leftOp.setAttribute("fence", "true");
      withDelims.push(leftOp);
    }
    withDelims.push(node2);
    if (group.rightDelim != null) {
      var rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
      rightOp.setAttribute("fence", "true");
      withDelims.push(rightOp);
    }
    return makeRow(withDelims);
  }
  return node2;
};
defineFunction({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    // cant be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac"
    // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var numer = args[0];
    var denom = args[1];
    var hasBarLine;
    var leftDelim = null;
    var rightDelim = null;
    var size4 = "auto";
    switch (funcName) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        hasBarLine = true;
        break;
      case "\\\\atopfrac":
        hasBarLine = false;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        hasBarLine = false;
        leftDelim = "(";
        rightDelim = ")";
        break;
      case "\\\\bracefrac":
        hasBarLine = false;
        leftDelim = "\\{";
        rightDelim = "\\}";
        break;
      case "\\\\brackfrac":
        hasBarLine = false;
        leftDelim = "[";
        rightDelim = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (funcName) {
      case "\\dfrac":
      case "\\dbinom":
        size4 = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        size4 = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: parser.mode,
      continued: false,
      numer,
      denom,
      hasBarLine,
      leftDelim,
      rightDelim,
      size: size4,
      barSize: null
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
defineFunction({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (_ref2, args) => {
    var {
      parser,
      funcName
    } = _ref2;
    var numer = args[0];
    var denom = args[1];
    return {
      type: "genfrac",
      mode: parser.mode,
      continued: true,
      numer,
      denom,
      hasBarLine: true,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
});
defineFunction({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: true
  },
  handler(_ref3) {
    var {
      parser,
      funcName,
      token
    } = _ref3;
    var replaceWith;
    switch (funcName) {
      case "\\over":
        replaceWith = "\\frac";
        break;
      case "\\choose":
        replaceWith = "\\binom";
        break;
      case "\\atop":
        replaceWith = "\\\\atopfrac";
        break;
      case "\\brace":
        replaceWith = "\\\\bracefrac";
        break;
      case "\\brack":
        replaceWith = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: parser.mode,
      replaceWith,
      token
    };
  }
});
var stylArray = ["display", "text", "script", "scriptscript"];
var delimFromValue = function delimFromValue2(delimString) {
  var delim = null;
  if (delimString.length > 0) {
    delim = delimString;
    delim = delim === "." ? null : delim;
  }
  return delim;
};
defineFunction({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: true,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler(_ref4, args) {
    var {
      parser
    } = _ref4;
    var numer = args[4];
    var denom = args[5];
    var leftNode = normalizeArgument(args[0]);
    var leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
    var rightNode = normalizeArgument(args[1]);
    var rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
    var barNode = assertNodeType(args[2], "size");
    var hasBarLine;
    var barSize = null;
    if (barNode.isBlank) {
      hasBarLine = true;
    } else {
      barSize = barNode.value;
      hasBarLine = barSize.number > 0;
    }
    var size4 = "auto";
    var styl = args[3];
    if (styl.type === "ordgroup") {
      if (styl.body.length > 0) {
        var textOrd = assertNodeType(styl.body[0], "textord");
        size4 = stylArray[Number(textOrd.text)];
      }
    } else {
      styl = assertNodeType(styl, "textord");
      size4 = stylArray[Number(styl.text)];
    }
    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim,
      rightDelim,
      size: size4
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
defineFunction({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: true
  },
  handler(_ref5, args) {
    var {
      parser,
      funcName,
      token
    } = _ref5;
    return {
      type: "infix",
      mode: parser.mode,
      replaceWith: "\\\\abovefrac",
      size: assertNodeType(args[0], "size").value,
      token
    };
  }
});
defineFunction({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (_ref6, args) => {
    var {
      parser,
      funcName
    } = _ref6;
    var numer = args[0];
    var barSize = assert2(assertNodeType(args[1], "infix").size);
    var denom = args[2];
    var hasBarLine = barSize.number > 0;
    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: htmlBuilder$4,
  mathmlBuilder: mathmlBuilder$3
});
var htmlBuilder$3 = (grp, options) => {
  var style2 = options.style;
  var supSubGroup;
  var group;
  if (grp.type === "supsub") {
    supSubGroup = grp.sup ? buildGroup$1(grp.sup, options.havingStyle(style2.sup()), options) : buildGroup$1(grp.sub, options.havingStyle(style2.sub()), options);
    group = assertNodeType(grp.base, "horizBrace");
  } else {
    group = assertNodeType(grp, "horizBrace");
  }
  var body = buildGroup$1(group.base, options.havingBaseStyle(Style$1.DISPLAY));
  var braceBody = stretchy.svgSpan(group, options);
  var vlist;
  if (group.isOver) {
    vlist = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: body
      }, {
        type: "kern",
        size: 0.1
      }, {
        type: "elem",
        elem: braceBody
      }]
    }, options);
    vlist.children[0].children[0].children[1].classes.push("svg-align");
  } else {
    vlist = buildCommon.makeVList({
      positionType: "bottom",
      positionData: body.depth + 0.1 + braceBody.height,
      children: [{
        type: "elem",
        elem: braceBody
      }, {
        type: "kern",
        size: 0.1
      }, {
        type: "elem",
        elem: body
      }]
    }, options);
    vlist.children[0].children[0].children[0].classes.push("svg-align");
  }
  if (supSubGroup) {
    var vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
    if (group.isOver) {
      vlist = buildCommon.makeVList({
        positionType: "firstBaseline",
        children: [{
          type: "elem",
          elem: vSpan
        }, {
          type: "kern",
          size: 0.2
        }, {
          type: "elem",
          elem: supSubGroup
        }]
      }, options);
    } else {
      vlist = buildCommon.makeVList({
        positionType: "bottom",
        positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
        children: [{
          type: "elem",
          elem: supSubGroup
        }, {
          type: "kern",
          size: 0.2
        }, {
          type: "elem",
          elem: vSpan
        }]
      }, options);
    }
  }
  return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
};
var mathmlBuilder$2 = (group, options) => {
  var accentNode = stretchy.mathMLnode(group.label);
  return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildGroup2(group.base, options), accentNode]);
};
defineFunction({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    return {
      type: "horizBrace",
      mode: parser.mode,
      label: funcName,
      isOver: /^\\over/.test(funcName),
      base: args[0]
    };
  },
  htmlBuilder: htmlBuilder$3,
  mathmlBuilder: mathmlBuilder$2
});
defineFunction({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    var body = args[1];
    var href = assertNodeType(args[0], "url").url;
    if (!parser.settings.isTrusted({
      command: "\\href",
      url: href
    })) {
      return parser.formatUnsupportedCmd("\\href");
    }
    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options) => {
    var elements = buildExpression$1(group.body, options, false);
    return buildCommon.makeAnchor(group.href, [], elements, options);
  },
  mathmlBuilder: (group, options) => {
    var math3 = buildExpressionRow(group.body, options);
    if (!(math3 instanceof MathNode)) {
      math3 = new MathNode("mrow", [math3]);
    }
    math3.setAttribute("href", group.href);
    return math3;
  }
});
defineFunction({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: true
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var href = assertNodeType(args[0], "url").url;
    if (!parser.settings.isTrusted({
      command: "\\url",
      url: href
    })) {
      return parser.formatUnsupportedCmd("\\url");
    }
    var chars = [];
    for (var i16 = 0; i16 < href.length; i16++) {
      var c21 = href[i16];
      if (c21 === "~") {
        c21 = "\\textasciitilde";
      }
      chars.push({
        type: "textord",
        mode: "text",
        text: c21
      });
    }
    var body = {
      type: "text",
      mode: parser.mode,
      font: "\\texttt",
      body: chars
    };
    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  }
});
defineFunction({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: true,
    primitive: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "hbox",
      mode: parser.mode,
      body: ordargument(args[0])
    };
  },
  htmlBuilder(group, options) {
    var elements = buildExpression$1(group.body, options, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder(group, options) {
    return new mathMLTree.MathNode("mrow", buildExpression2(group.body, options));
  }
});
defineFunction({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName,
      token
    } = _ref;
    var value = assertNodeType(args[0], "raw").string;
    var body = args[1];
    if (parser.settings.strict) {
      parser.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    }
    var trustContext;
    var attributes = {};
    switch (funcName) {
      case "\\htmlClass":
        attributes.class = value;
        trustContext = {
          command: "\\htmlClass",
          class: value
        };
        break;
      case "\\htmlId":
        attributes.id = value;
        trustContext = {
          command: "\\htmlId",
          id: value
        };
        break;
      case "\\htmlStyle":
        attributes.style = value;
        trustContext = {
          command: "\\htmlStyle",
          style: value
        };
        break;
      case "\\htmlData": {
        var data = value.split(",");
        for (var i16 = 0; i16 < data.length; i16++) {
          var keyVal = data[i16].split("=");
          if (keyVal.length !== 2) {
            throw new ParseError("Error parsing key-value for \\htmlData");
          }
          attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
        }
        trustContext = {
          command: "\\htmlData",
          attributes
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    if (!parser.settings.isTrusted(trustContext)) {
      return parser.formatUnsupportedCmd(funcName);
    }
    return {
      type: "html",
      mode: parser.mode,
      attributes,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options) => {
    var elements = buildExpression$1(group.body, options, false);
    var classes = ["enclosing"];
    if (group.attributes.class) {
      classes.push(...group.attributes.class.trim().split(/\s+/));
    }
    var span = buildCommon.makeSpan(classes, elements, options);
    for (var attr2 in group.attributes) {
      if (attr2 !== "class" && group.attributes.hasOwnProperty(attr2)) {
        span.setAttribute(attr2, group.attributes[attr2]);
      }
    }
    return span;
  },
  mathmlBuilder: (group, options) => {
    return buildExpressionRow(group.body, options);
  }
});
defineFunction({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    return {
      type: "htmlmathml",
      mode: parser.mode,
      html: ordargument(args[0]),
      mathml: ordargument(args[1])
    };
  },
  htmlBuilder: (group, options) => {
    var elements = buildExpression$1(group.html, options, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options) => {
    return buildExpressionRow(group.mathml, options);
  }
});
var sizeData = function sizeData2(str) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
    return {
      number: +str,
      unit: "bp"
    };
  } else {
    var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
    if (!match) {
      throw new ParseError("Invalid size: '" + str + "' in \\includegraphics");
    }
    var data = {
      number: +(match[1] + match[2]),
      // sign + magnitude, cast to number
      unit: match[3]
    };
    if (!validUnit(data)) {
      throw new ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
    }
    return data;
  }
};
defineFunction({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: false
  },
  handler: (_ref, args, optArgs) => {
    var {
      parser
    } = _ref;
    var width = {
      number: 0,
      unit: "em"
    };
    var height = {
      number: 0.9,
      unit: "em"
    };
    var totalheight = {
      number: 0,
      unit: "em"
    };
    var alt = "";
    if (optArgs[0]) {
      var attributeStr = assertNodeType(optArgs[0], "raw").string;
      var attributes = attributeStr.split(",");
      for (var i16 = 0; i16 < attributes.length; i16++) {
        var keyVal = attributes[i16].split("=");
        if (keyVal.length === 2) {
          var str = keyVal[1].trim();
          switch (keyVal[0].trim()) {
            case "alt":
              alt = str;
              break;
            case "width":
              width = sizeData(str);
              break;
            case "height":
              height = sizeData(str);
              break;
            case "totalheight":
              totalheight = sizeData(str);
              break;
            default:
              throw new ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
          }
        }
      }
    }
    var src = assertNodeType(args[0], "url").url;
    if (alt === "") {
      alt = src;
      alt = alt.replace(/^.*[\\/]/, "");
      alt = alt.substring(0, alt.lastIndexOf("."));
    }
    if (!parser.settings.isTrusted({
      command: "\\includegraphics",
      url: src
    })) {
      return parser.formatUnsupportedCmd("\\includegraphics");
    }
    return {
      type: "includegraphics",
      mode: parser.mode,
      alt,
      width,
      height,
      totalheight,
      src
    };
  },
  htmlBuilder: (group, options) => {
    var height = calculateSize(group.height, options);
    var depth = 0;
    if (group.totalheight.number > 0) {
      depth = calculateSize(group.totalheight, options) - height;
    }
    var width = 0;
    if (group.width.number > 0) {
      width = calculateSize(group.width, options);
    }
    var style2 = {
      height: makeEm(height + depth)
    };
    if (width > 0) {
      style2.width = makeEm(width);
    }
    if (depth > 0) {
      style2.verticalAlign = makeEm(-depth);
    }
    var node2 = new Img(group.src, group.alt, style2);
    node2.height = height;
    node2.depth = depth;
    return node2;
  },
  mathmlBuilder: (group, options) => {
    var node2 = new mathMLTree.MathNode("mglyph", []);
    node2.setAttribute("alt", group.alt);
    var height = calculateSize(group.height, options);
    var depth = 0;
    if (group.totalheight.number > 0) {
      depth = calculateSize(group.totalheight, options) - height;
      node2.setAttribute("valign", makeEm(-depth));
    }
    node2.setAttribute("height", makeEm(height + depth));
    if (group.width.number > 0) {
      var width = calculateSize(group.width, options);
      node2.setAttribute("width", makeEm(width));
    }
    node2.setAttribute("src", group.src);
    return node2;
  }
});
defineFunction({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: true,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var size4 = assertNodeType(args[0], "size");
    if (parser.settings.strict) {
      var mathFunction = funcName[1] === "m";
      var muUnit = size4.value.unit === "mu";
      if (mathFunction) {
        if (!muUnit) {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size4.value.unit + " units"));
        }
        if (parser.mode !== "math") {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
        }
      } else {
        if (muUnit) {
          parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
        }
      }
    }
    return {
      type: "kern",
      mode: parser.mode,
      dimension: size4.value
    };
  },
  htmlBuilder(group, options) {
    return buildCommon.makeGlue(group.dimension, options);
  },
  mathmlBuilder(group, options) {
    var dimension = calculateSize(group.dimension, options);
    return new mathMLTree.SpaceNode(dimension);
  }
});
defineFunction({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "lap",
      mode: parser.mode,
      alignment: funcName.slice(5),
      body
    };
  },
  htmlBuilder: (group, options) => {
    var inner3;
    if (group.alignment === "clap") {
      inner3 = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]);
      inner3 = buildCommon.makeSpan(["inner"], [inner3], options);
    } else {
      inner3 = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options)]);
    }
    var fix = buildCommon.makeSpan(["fix"], []);
    var node2 = buildCommon.makeSpan([group.alignment], [inner3, fix], options);
    var strut = buildCommon.makeSpan(["strut"]);
    strut.style.height = makeEm(node2.height + node2.depth);
    if (node2.depth) {
      strut.style.verticalAlign = makeEm(-node2.depth);
    }
    node2.children.unshift(strut);
    node2 = buildCommon.makeSpan(["thinbox"], [node2], options);
    return buildCommon.makeSpan(["mord", "vbox"], [node2], options);
  },
  mathmlBuilder: (group, options) => {
    var node2 = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)]);
    if (group.alignment !== "rlap") {
      var offset4 = group.alignment === "llap" ? "-1" : "-0.5";
      node2.setAttribute("lspace", offset4 + "width");
    }
    node2.setAttribute("width", "0px");
    return node2;
  }
});
defineFunction({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler(_ref, args) {
    var {
      funcName,
      parser
    } = _ref;
    var outerMode = parser.mode;
    parser.switchMode("math");
    var close2 = funcName === "\\(" ? "\\)" : "$";
    var body = parser.parseExpression(false, close2);
    parser.expect(close2);
    parser.switchMode(outerMode);
    return {
      type: "styling",
      mode: parser.mode,
      style: "text",
      body
    };
  }
});
defineFunction({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler(context, args) {
    throw new ParseError("Mismatched " + context.funcName);
  }
});
var chooseMathStyle = (group, options) => {
  switch (options.style.size) {
    case Style$1.DISPLAY.size:
      return group.display;
    case Style$1.TEXT.size:
      return group.text;
    case Style$1.SCRIPT.size:
      return group.script;
    case Style$1.SCRIPTSCRIPT.size:
      return group.scriptscript;
    default:
      return group.text;
  }
};
defineFunction({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    return {
      type: "mathchoice",
      mode: parser.mode,
      display: ordargument(args[0]),
      text: ordargument(args[1]),
      script: ordargument(args[2]),
      scriptscript: ordargument(args[3])
    };
  },
  htmlBuilder: (group, options) => {
    var body = chooseMathStyle(group, options);
    var elements = buildExpression$1(body, options, false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options) => {
    var body = chooseMathStyle(group, options);
    return buildExpressionRow(body, options);
  }
});
var assembleSupSub = (base, supGroup, subGroup, options, style2, slant, baseShift) => {
  base = buildCommon.makeSpan([], [base]);
  var subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);
  var sub2;
  var sup2;
  if (supGroup) {
    var elem = buildGroup$1(supGroup, options.havingStyle(style2.sup()), options);
    sup2 = {
      elem,
      kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
    };
  }
  if (subGroup) {
    var _elem = buildGroup$1(subGroup, options.havingStyle(style2.sub()), options);
    sub2 = {
      elem: _elem,
      kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - _elem.height)
    };
  }
  var finalGroup;
  if (sup2 && sub2) {
    var bottom = options.fontMetrics().bigOpSpacing5 + sub2.elem.height + sub2.elem.depth + sub2.kern + base.depth + baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "bottom",
      positionData: bottom,
      children: [{
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: sub2.elem,
        marginLeft: makeEm(-slant)
      }, {
        type: "kern",
        size: sub2.kern
      }, {
        type: "elem",
        elem: base
      }, {
        type: "kern",
        size: sup2.kern
      }, {
        type: "elem",
        elem: sup2.elem,
        marginLeft: makeEm(slant)
      }, {
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }]
    }, options);
  } else if (sub2) {
    var top = base.height - baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "top",
      positionData: top,
      children: [{
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: sub2.elem,
        marginLeft: makeEm(-slant)
      }, {
        type: "kern",
        size: sub2.kern
      }, {
        type: "elem",
        elem: base
      }]
    }, options);
  } else if (sup2) {
    var _bottom = base.depth + baseShift;
    finalGroup = buildCommon.makeVList({
      positionType: "bottom",
      positionData: _bottom,
      children: [{
        type: "elem",
        elem: base
      }, {
        type: "kern",
        size: sup2.kern
      }, {
        type: "elem",
        elem: sup2.elem,
        marginLeft: makeEm(slant)
      }, {
        type: "kern",
        size: options.fontMetrics().bigOpSpacing5
      }]
    }, options);
  } else {
    return base;
  }
  var parts = [finalGroup];
  if (sub2 && slant !== 0 && !subIsSingleCharacter) {
    var spacer = buildCommon.makeSpan(["mspace"], [], options);
    spacer.style.marginRight = makeEm(slant);
    parts.unshift(spacer);
  }
  return buildCommon.makeSpan(["mop", "op-limits"], parts, options);
};
var noSuccessor = ["\\smallint"];
var htmlBuilder$2 = (grp, options) => {
  var supGroup;
  var subGroup;
  var hasLimits = false;
  var group;
  if (grp.type === "supsub") {
    supGroup = grp.sup;
    subGroup = grp.sub;
    group = assertNodeType(grp.base, "op");
    hasLimits = true;
  } else {
    group = assertNodeType(grp, "op");
  }
  var style2 = options.style;
  var large = false;
  if (style2.size === Style$1.DISPLAY.size && group.symbol && !noSuccessor.includes(group.name)) {
    large = true;
  }
  var base;
  if (group.symbol) {
    var fontName = large ? "Size2-Regular" : "Size1-Regular";
    var stash = "";
    if (group.name === "\\oiint" || group.name === "\\oiiint") {
      stash = group.name.slice(1);
      group.name = stash === "oiint" ? "\\iint" : "\\iiint";
    }
    base = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
    if (stash.length > 0) {
      var italic = base.italic;
      var oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
      base = buildCommon.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: base,
          shift: 0
        }, {
          type: "elem",
          elem: oval,
          shift: large ? 0.08 : 0
        }]
      }, options);
      group.name = "\\" + stash;
      base.classes.unshift("mop");
      base.italic = italic;
    }
  } else if (group.body) {
    var inner3 = buildExpression$1(group.body, options, true);
    if (inner3.length === 1 && inner3[0] instanceof SymbolNode) {
      base = inner3[0];
      base.classes[0] = "mop";
    } else {
      base = buildCommon.makeSpan(["mop"], inner3, options);
    }
  } else {
    var output = [];
    for (var i16 = 1; i16 < group.name.length; i16++) {
      output.push(buildCommon.mathsym(group.name[i16], group.mode, options));
    }
    base = buildCommon.makeSpan(["mop"], output, options);
  }
  var baseShift = 0;
  var slant = 0;
  if ((base instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
    baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight;
    slant = base.italic;
  }
  if (hasLimits) {
    return assembleSupSub(base, supGroup, subGroup, options, style2, slant, baseShift);
  } else {
    if (baseShift) {
      base.style.position = "relative";
      base.style.top = makeEm(baseShift);
    }
    return base;
  }
};
var mathmlBuilder$1 = (group, options) => {
  var node2;
  if (group.symbol) {
    node2 = new MathNode("mo", [makeText(group.name, group.mode)]);
    if (noSuccessor.includes(group.name)) {
      node2.setAttribute("largeop", "false");
    }
  } else if (group.body) {
    node2 = new MathNode("mo", buildExpression2(group.body, options));
  } else {
    node2 = new MathNode("mi", [new TextNode(group.name.slice(1))]);
    var operator = new MathNode("mo", [makeText("", "text")]);
    if (group.parentIsSupSub) {
      node2 = new MathNode("mrow", [node2, operator]);
    } else {
      node2 = newDocumentFragment([node2, operator]);
    }
  }
  return node2;
};
var singleCharBigOps = {
  "": "\\prod",
  "": "\\coprod",
  "": "\\sum",
  "": "\\bigwedge",
  "": "\\bigvee",
  "": "\\bigcap",
  "": "\\bigcup",
  "": "\\bigodot",
  "": "\\bigoplus",
  "": "\\bigotimes",
  "": "\\biguplus",
  "": "\\bigsqcup"
};
defineFunction({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "", "", "", "", "", "", "", "", "", "", "", ""],
  props: {
    numArgs: 0
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var fName = funcName;
    if (fName.length === 1) {
      fName = singleCharBigOps[fName];
    }
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: true,
      name: fName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var body = args[0];
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      body: ordargument(body)
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
var singleCharIntegrals = {
  "": "\\int",
  "": "\\iint",
  "": "\\iiint",
  "": "\\oint",
  "": "\\oiint",
  "": "\\oiiint"
};
defineFunction({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler(_ref3) {
    var {
      parser,
      funcName
    } = _ref3;
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      name: funcName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler(_ref4) {
    var {
      parser,
      funcName
    } = _ref4;
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: false,
      name: funcName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
defineFunction({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "", "", "", "", "", ""],
  props: {
    numArgs: 0
  },
  handler(_ref5) {
    var {
      parser,
      funcName
    } = _ref5;
    var fName = funcName;
    if (fName.length === 1) {
      fName = singleCharIntegrals[fName];
    }
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: true,
      name: fName
    };
  },
  htmlBuilder: htmlBuilder$2,
  mathmlBuilder: mathmlBuilder$1
});
var htmlBuilder$1 = (grp, options) => {
  var supGroup;
  var subGroup;
  var hasLimits = false;
  var group;
  if (grp.type === "supsub") {
    supGroup = grp.sup;
    subGroup = grp.sub;
    group = assertNodeType(grp.base, "operatorname");
    hasLimits = true;
  } else {
    group = assertNodeType(grp, "operatorname");
  }
  var base;
  if (group.body.length > 0) {
    var body = group.body.map((child2) => {
      var childText = child2.text;
      if (typeof childText === "string") {
        return {
          type: "textord",
          mode: child2.mode,
          text: childText
        };
      } else {
        return child2;
      }
    });
    var expression = buildExpression$1(body, options.withFont("mathrm"), true);
    for (var i16 = 0; i16 < expression.length; i16++) {
      var child = expression[i16];
      if (child instanceof SymbolNode) {
        child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
      }
    }
    base = buildCommon.makeSpan(["mop"], expression, options);
  } else {
    base = buildCommon.makeSpan(["mop"], [], options);
  }
  if (hasLimits) {
    return assembleSupSub(base, supGroup, subGroup, options, options.style, 0, 0);
  } else {
    return base;
  }
};
var mathmlBuilder2 = (group, options) => {
  var expression = buildExpression2(group.body, options.withFont("mathrm"));
  var isAllString = true;
  for (var i16 = 0; i16 < expression.length; i16++) {
    var node2 = expression[i16];
    if (node2 instanceof mathMLTree.SpaceNode) ;
    else if (node2 instanceof mathMLTree.MathNode) {
      switch (node2.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        case "mo": {
          var child = node2.children[0];
          if (node2.children.length === 1 && child instanceof mathMLTree.TextNode) {
            child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
          } else {
            isAllString = false;
          }
          break;
        }
        default:
          isAllString = false;
      }
    } else {
      isAllString = false;
    }
  }
  if (isAllString) {
    var word = expression.map((node3) => node3.toText()).join("");
    expression = [new mathMLTree.TextNode(word)];
  }
  var identifier = new mathMLTree.MathNode("mi", expression);
  identifier.setAttribute("mathvariant", "normal");
  var operator = new mathMLTree.MathNode("mo", [makeText("", "text")]);
  if (group.parentIsSupSub) {
    return new mathMLTree.MathNode("mrow", [identifier, operator]);
  } else {
    return mathMLTree.newDocumentFragment([identifier, operator]);
  }
};
defineFunction({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (_ref, args) => {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "operatorname",
      mode: parser.mode,
      body: ordargument(body),
      alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
      limits: false,
      parentIsSupSub: false
    };
  },
  htmlBuilder: htmlBuilder$1,
  mathmlBuilder: mathmlBuilder2
});
defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
defineFunctionBuilders({
  type: "ordgroup",
  htmlBuilder(group, options) {
    if (group.semisimple) {
      return buildCommon.makeFragment(buildExpression$1(group.body, options, false));
    }
    return buildCommon.makeSpan(["mord"], buildExpression$1(group.body, options, true), options);
  },
  mathmlBuilder(group, options) {
    return buildExpressionRow(group.body, options, true);
  }
});
defineFunction({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var body = args[0];
    return {
      type: "overline",
      mode: parser.mode,
      body
    };
  },
  htmlBuilder(group, options) {
    var innerGroup = buildGroup$1(group.body, options.havingCrampedStyle());
    var line = buildCommon.makeLineSpan("overline-line", options);
    var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
    var vlist = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: innerGroup
      }, {
        type: "kern",
        size: 3 * defaultRuleThickness
      }, {
        type: "elem",
        elem: line
      }, {
        type: "kern",
        size: defaultRuleThickness
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
  },
  mathmlBuilder(group, options) {
    var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("")]);
    operator.setAttribute("stretchy", "true");
    var node2 = new mathMLTree.MathNode("mover", [buildGroup2(group.body, options), operator]);
    node2.setAttribute("accent", "true");
    return node2;
  }
});
defineFunction({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      parser
    } = _ref;
    var body = args[0];
    return {
      type: "phantom",
      mode: parser.mode,
      body: ordargument(body)
    };
  },
  htmlBuilder: (group, options) => {
    var elements = buildExpression$1(group.body, options.withPhantom(), false);
    return buildCommon.makeFragment(elements);
  },
  mathmlBuilder: (group, options) => {
    var inner3 = buildExpression2(group.body, options);
    return new mathMLTree.MathNode("mphantom", inner3);
  }
});
defineFunction({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref2, args) => {
    var {
      parser
    } = _ref2;
    var body = args[0];
    return {
      type: "hphantom",
      mode: parser.mode,
      body
    };
  },
  htmlBuilder: (group, options) => {
    var node2 = buildCommon.makeSpan([], [buildGroup$1(group.body, options.withPhantom())]);
    node2.height = 0;
    node2.depth = 0;
    if (node2.children) {
      for (var i16 = 0; i16 < node2.children.length; i16++) {
        node2.children[i16].height = 0;
        node2.children[i16].depth = 0;
      }
    }
    node2 = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: node2
      }]
    }, options);
    return buildCommon.makeSpan(["mord"], [node2], options);
  },
  mathmlBuilder: (group, options) => {
    var inner3 = buildExpression2(ordargument(group.body), options);
    var phantom = new mathMLTree.MathNode("mphantom", inner3);
    var node2 = new mathMLTree.MathNode("mpadded", [phantom]);
    node2.setAttribute("height", "0px");
    node2.setAttribute("depth", "0px");
    return node2;
  }
});
defineFunction({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: (_ref3, args) => {
    var {
      parser
    } = _ref3;
    var body = args[0];
    return {
      type: "vphantom",
      mode: parser.mode,
      body
    };
  },
  htmlBuilder: (group, options) => {
    var inner3 = buildCommon.makeSpan(["inner"], [buildGroup$1(group.body, options.withPhantom())]);
    var fix = buildCommon.makeSpan(["fix"], []);
    return buildCommon.makeSpan(["mord", "rlap"], [inner3, fix], options);
  },
  mathmlBuilder: (group, options) => {
    var inner3 = buildExpression2(ordargument(group.body), options);
    var phantom = new mathMLTree.MathNode("mphantom", inner3);
    var node2 = new mathMLTree.MathNode("mpadded", [phantom]);
    node2.setAttribute("width", "0px");
    return node2;
  }
});
defineFunction({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    var amount = assertNodeType(args[0], "size").value;
    var body = args[1];
    return {
      type: "raisebox",
      mode: parser.mode,
      dy: amount,
      body
    };
  },
  htmlBuilder(group, options) {
    var body = buildGroup$1(group.body, options);
    var dy = calculateSize(group.dy, options);
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: -dy,
      children: [{
        type: "elem",
        elem: body
      }]
    }, options);
  },
  mathmlBuilder(group, options) {
    var node2 = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)]);
    var dy = group.dy.number + group.dy.unit;
    node2.setAttribute("voffset", dy);
    return node2;
  }
});
defineFunction({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInArgument: true
  },
  handler(_ref) {
    var {
      parser
    } = _ref;
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});
defineFunction({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: true,
    allowedInMath: true,
    argTypes: ["size", "size", "size"]
  },
  handler(_ref, args, optArgs) {
    var {
      parser
    } = _ref;
    var shift4 = optArgs[0];
    var width = assertNodeType(args[0], "size");
    var height = assertNodeType(args[1], "size");
    return {
      type: "rule",
      mode: parser.mode,
      shift: shift4 && assertNodeType(shift4, "size").value,
      width: width.value,
      height: height.value
    };
  },
  htmlBuilder(group, options) {
    var rule = buildCommon.makeSpan(["mord", "rule"], [], options);
    var width = calculateSize(group.width, options);
    var height = calculateSize(group.height, options);
    var shift4 = group.shift ? calculateSize(group.shift, options) : 0;
    rule.style.borderRightWidth = makeEm(width);
    rule.style.borderTopWidth = makeEm(height);
    rule.style.bottom = makeEm(shift4);
    rule.width = width;
    rule.height = height + shift4;
    rule.depth = -shift4;
    rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
    return rule;
  },
  mathmlBuilder(group, options) {
    var width = calculateSize(group.width, options);
    var height = calculateSize(group.height, options);
    var shift4 = group.shift ? calculateSize(group.shift, options) : 0;
    var color2 = options.color && options.getColor() || "black";
    var rule = new mathMLTree.MathNode("mspace");
    rule.setAttribute("mathbackground", color2);
    rule.setAttribute("width", makeEm(width));
    rule.setAttribute("height", makeEm(height));
    var wrapper = new mathMLTree.MathNode("mpadded", [rule]);
    if (shift4 >= 0) {
      wrapper.setAttribute("height", makeEm(shift4));
    } else {
      wrapper.setAttribute("height", makeEm(shift4));
      wrapper.setAttribute("depth", makeEm(-shift4));
    }
    wrapper.setAttribute("voffset", makeEm(shift4));
    return wrapper;
  }
});
function sizingGroup(value, options, baseOptions) {
  var inner3 = buildExpression$1(value, options, false);
  var multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
  for (var i16 = 0; i16 < inner3.length; i16++) {
    var pos = inner3[i16].classes.indexOf("sizing");
    if (pos < 0) {
      Array.prototype.push.apply(inner3[i16].classes, options.sizingClasses(baseOptions));
    } else if (inner3[i16].classes[pos + 1] === "reset-size" + options.size) {
      inner3[i16].classes[pos + 1] = "reset-size" + baseOptions.size;
    }
    inner3[i16].height *= multiplier;
    inner3[i16].depth *= multiplier;
  }
  return buildCommon.makeFragment(inner3);
}
var sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
var htmlBuilder2 = (group, options) => {
  var newOptions = options.havingSize(group.size);
  return sizingGroup(group.body, newOptions, options);
};
defineFunction({
  type: "sizing",
  names: sizeFuncs,
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: (_ref, args) => {
    var {
      breakOnTokenText,
      funcName,
      parser
    } = _ref;
    var body = parser.parseExpression(false, breakOnTokenText);
    return {
      type: "sizing",
      mode: parser.mode,
      // Figure out what size to use based on the list of functions above
      size: sizeFuncs.indexOf(funcName) + 1,
      body
    };
  },
  htmlBuilder: htmlBuilder2,
  mathmlBuilder: (group, options) => {
    var newOptions = options.havingSize(group.size);
    var inner3 = buildExpression2(group.body, newOptions);
    var node2 = new mathMLTree.MathNode("mstyle", inner3);
    node2.setAttribute("mathsize", makeEm(newOptions.sizeMultiplier));
    return node2;
  }
});
defineFunction({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: true
  },
  handler: (_ref, args, optArgs) => {
    var {
      parser
    } = _ref;
    var smashHeight = false;
    var smashDepth = false;
    var tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
    if (tbArg) {
      var letter = "";
      for (var i16 = 0; i16 < tbArg.body.length; ++i16) {
        var node2 = tbArg.body[i16];
        letter = node2.text;
        if (letter === "t") {
          smashHeight = true;
        } else if (letter === "b") {
          smashDepth = true;
        } else {
          smashHeight = false;
          smashDepth = false;
          break;
        }
      }
    } else {
      smashHeight = true;
      smashDepth = true;
    }
    var body = args[0];
    return {
      type: "smash",
      mode: parser.mode,
      body,
      smashHeight,
      smashDepth
    };
  },
  htmlBuilder: (group, options) => {
    var node2 = buildCommon.makeSpan([], [buildGroup$1(group.body, options)]);
    if (!group.smashHeight && !group.smashDepth) {
      return node2;
    }
    if (group.smashHeight) {
      node2.height = 0;
      if (node2.children) {
        for (var i16 = 0; i16 < node2.children.length; i16++) {
          node2.children[i16].height = 0;
        }
      }
    }
    if (group.smashDepth) {
      node2.depth = 0;
      if (node2.children) {
        for (var _i = 0; _i < node2.children.length; _i++) {
          node2.children[_i].depth = 0;
        }
      }
    }
    var smashedNode = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: node2
      }]
    }, options);
    return buildCommon.makeSpan(["mord"], [smashedNode], options);
  },
  mathmlBuilder: (group, options) => {
    var node2 = new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)]);
    if (group.smashHeight) {
      node2.setAttribute("height", "0px");
    }
    if (group.smashDepth) {
      node2.setAttribute("depth", "0px");
    }
    return node2;
  }
});
defineFunction({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(_ref, args, optArgs) {
    var {
      parser
    } = _ref;
    var index4 = optArgs[0];
    var body = args[0];
    return {
      type: "sqrt",
      mode: parser.mode,
      body,
      index: index4
    };
  },
  htmlBuilder(group, options) {
    var inner3 = buildGroup$1(group.body, options.havingCrampedStyle());
    if (inner3.height === 0) {
      inner3.height = options.fontMetrics().xHeight;
    }
    inner3 = buildCommon.wrapFragment(inner3, options);
    var metrics = options.fontMetrics();
    var theta = metrics.defaultRuleThickness;
    var phi = theta;
    if (options.style.id < Style$1.TEXT.id) {
      phi = options.fontMetrics().xHeight;
    }
    var lineClearance = theta + phi / 4;
    var minDelimiterHeight = inner3.height + inner3.depth + lineClearance + theta;
    var {
      span: img,
      ruleWidth,
      advanceWidth
    } = delimiter.sqrtImage(minDelimiterHeight, options);
    var delimDepth = img.height - ruleWidth;
    if (delimDepth > inner3.height + inner3.depth + lineClearance) {
      lineClearance = (lineClearance + delimDepth - inner3.height - inner3.depth) / 2;
    }
    var imgShift = img.height - inner3.height - lineClearance - ruleWidth;
    inner3.style.paddingLeft = makeEm(advanceWidth);
    var body = buildCommon.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: inner3,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(inner3.height + imgShift)
      }, {
        type: "elem",
        elem: img
      }, {
        type: "kern",
        size: ruleWidth
      }]
    }, options);
    if (!group.index) {
      return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
    } else {
      var newOptions = options.havingStyle(Style$1.SCRIPTSCRIPT);
      var rootm = buildGroup$1(group.index, newOptions, options);
      var toShift = 0.6 * (body.height - body.depth);
      var rootVList = buildCommon.makeVList({
        positionType: "shift",
        positionData: -toShift,
        children: [{
          type: "elem",
          elem: rootm
        }]
      }, options);
      var rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
      return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
    }
  },
  mathmlBuilder(group, options) {
    var {
      body,
      index: index4
    } = group;
    return index4 ? new mathMLTree.MathNode("mroot", [buildGroup2(body, options), buildGroup2(index4, options)]) : new mathMLTree.MathNode("msqrt", [buildGroup2(body, options)]);
  }
});
var styleMap = {
  "display": Style$1.DISPLAY,
  "text": Style$1.TEXT,
  "script": Style$1.SCRIPT,
  "scriptscript": Style$1.SCRIPTSCRIPT
};
defineFunction({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler(_ref, args) {
    var {
      breakOnTokenText,
      funcName,
      parser
    } = _ref;
    var body = parser.parseExpression(true, breakOnTokenText);
    var style2 = funcName.slice(1, funcName.length - 5);
    return {
      type: "styling",
      mode: parser.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style: style2,
      body
    };
  },
  htmlBuilder(group, options) {
    var newStyle = styleMap[group.style];
    var newOptions = options.havingStyle(newStyle).withFont("");
    return sizingGroup(group.body, newOptions, options);
  },
  mathmlBuilder(group, options) {
    var newStyle = styleMap[group.style];
    var newOptions = options.havingStyle(newStyle);
    var inner3 = buildExpression2(group.body, newOptions);
    var node2 = new mathMLTree.MathNode("mstyle", inner3);
    var styleAttributes = {
      "display": ["0", "true"],
      "text": ["0", "false"],
      "script": ["1", "false"],
      "scriptscript": ["2", "false"]
    };
    var attr2 = styleAttributes[group.style];
    node2.setAttribute("scriptlevel", attr2[0]);
    node2.setAttribute("displaystyle", attr2[1]);
    return node2;
  }
});
var htmlBuilderDelegate = function htmlBuilderDelegate2(group, options) {
  var base = group.base;
  if (!base) {
    return null;
  } else if (base.type === "op") {
    var delegate = base.limits && (options.style.size === Style$1.DISPLAY.size || base.alwaysHandleSupSub);
    return delegate ? htmlBuilder$2 : null;
  } else if (base.type === "operatorname") {
    var _delegate = base.alwaysHandleSupSub && (options.style.size === Style$1.DISPLAY.size || base.limits);
    return _delegate ? htmlBuilder$1 : null;
  } else if (base.type === "accent") {
    return utils.isCharacterBox(base.base) ? htmlBuilder$a : null;
  } else if (base.type === "horizBrace") {
    var isSup = !group.sub;
    return isSup === base.isOver ? htmlBuilder$3 : null;
  } else {
    return null;
  }
};
defineFunctionBuilders({
  type: "supsub",
  htmlBuilder(group, options) {
    var builderDelegate = htmlBuilderDelegate(group, options);
    if (builderDelegate) {
      return builderDelegate(group, options);
    }
    var {
      base: valueBase,
      sup: valueSup,
      sub: valueSub
    } = group;
    var base = buildGroup$1(valueBase, options);
    var supm;
    var subm;
    var metrics = options.fontMetrics();
    var supShift = 0;
    var subShift = 0;
    var isCharacterBox3 = valueBase && utils.isCharacterBox(valueBase);
    if (valueSup) {
      var newOptions = options.havingStyle(options.style.sup());
      supm = buildGroup$1(valueSup, newOptions, options);
      if (!isCharacterBox3) {
        supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
      }
    }
    if (valueSub) {
      var _newOptions = options.havingStyle(options.style.sub());
      subm = buildGroup$1(valueSub, _newOptions, options);
      if (!isCharacterBox3) {
        subShift = base.depth + _newOptions.fontMetrics().subDrop * _newOptions.sizeMultiplier / options.sizeMultiplier;
      }
    }
    var minSupShift;
    if (options.style === Style$1.DISPLAY) {
      minSupShift = metrics.sup1;
    } else if (options.style.cramped) {
      minSupShift = metrics.sup3;
    } else {
      minSupShift = metrics.sup2;
    }
    var multiplier = options.sizeMultiplier;
    var marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);
    var marginLeft = null;
    if (subm) {
      var isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
      if (base instanceof SymbolNode || isOiint) {
        marginLeft = makeEm(-base.italic);
      }
    }
    var supsub;
    if (supm && subm) {
      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
      subShift = Math.max(subShift, metrics.sub2);
      var ruleWidth = metrics.defaultRuleThickness;
      var maxWidth = 4 * ruleWidth;
      if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
        subShift = maxWidth - (supShift - supm.depth) + subm.height;
        var psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
        if (psi > 0) {
          supShift += psi;
          subShift -= psi;
        }
      }
      var vlistElem = [{
        type: "elem",
        elem: subm,
        shift: subShift,
        marginRight,
        marginLeft
      }, {
        type: "elem",
        elem: supm,
        shift: -supShift,
        marginRight
      }];
      supsub = buildCommon.makeVList({
        positionType: "individualShift",
        children: vlistElem
      }, options);
    } else if (subm) {
      subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
      var _vlistElem = [{
        type: "elem",
        elem: subm,
        marginLeft,
        marginRight
      }];
      supsub = buildCommon.makeVList({
        positionType: "shift",
        positionData: subShift,
        children: _vlistElem
      }, options);
    } else if (supm) {
      supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
      supsub = buildCommon.makeVList({
        positionType: "shift",
        positionData: -supShift,
        children: [{
          type: "elem",
          elem: supm,
          marginRight
        }]
      }, options);
    } else {
      throw new Error("supsub must have either sup or sub.");
    }
    var mclass = getTypeOfDomTree(base, "right") || "mord";
    return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan(["msupsub"], [supsub])], options);
  },
  mathmlBuilder(group, options) {
    var isBrace = false;
    var isOver;
    var isSup;
    if (group.base && group.base.type === "horizBrace") {
      isSup = !!group.sup;
      if (isSup === group.base.isOver) {
        isBrace = true;
        isOver = group.base.isOver;
      }
    }
    if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
      group.base.parentIsSupSub = true;
    }
    var children = [buildGroup2(group.base, options)];
    if (group.sub) {
      children.push(buildGroup2(group.sub, options));
    }
    if (group.sup) {
      children.push(buildGroup2(group.sup, options));
    }
    var nodeType;
    if (isBrace) {
      nodeType = isOver ? "mover" : "munder";
    } else if (!group.sub) {
      var base = group.base;
      if (base && base.type === "op" && base.limits && (options.style === Style$1.DISPLAY || base.alwaysHandleSupSub)) {
        nodeType = "mover";
      } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options.style === Style$1.DISPLAY)) {
        nodeType = "mover";
      } else {
        nodeType = "msup";
      }
    } else if (!group.sup) {
      var _base = group.base;
      if (_base && _base.type === "op" && _base.limits && (options.style === Style$1.DISPLAY || _base.alwaysHandleSupSub)) {
        nodeType = "munder";
      } else if (_base && _base.type === "operatorname" && _base.alwaysHandleSupSub && (_base.limits || options.style === Style$1.DISPLAY)) {
        nodeType = "munder";
      } else {
        nodeType = "msub";
      }
    } else {
      var _base2 = group.base;
      if (_base2 && _base2.type === "op" && _base2.limits && options.style === Style$1.DISPLAY) {
        nodeType = "munderover";
      } else if (_base2 && _base2.type === "operatorname" && _base2.alwaysHandleSupSub && (options.style === Style$1.DISPLAY || _base2.limits)) {
        nodeType = "munderover";
      } else {
        nodeType = "msubsup";
      }
    }
    return new mathMLTree.MathNode(nodeType, children);
  }
});
defineFunctionBuilders({
  type: "atom",
  htmlBuilder(group, options) {
    return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
  },
  mathmlBuilder(group, options) {
    var node2 = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
    if (group.family === "bin") {
      var variant = getVariant(group, options);
      if (variant === "bold-italic") {
        node2.setAttribute("mathvariant", variant);
      }
    } else if (group.family === "punct") {
      node2.setAttribute("separator", "true");
    } else if (group.family === "open" || group.family === "close") {
      node2.setAttribute("stretchy", "false");
    }
    return node2;
  }
});
var defaultVariant = {
  "mi": "italic",
  "mn": "normal",
  "mtext": "normal"
};
defineFunctionBuilders({
  type: "mathord",
  htmlBuilder(group, options) {
    return buildCommon.makeOrd(group, options, "mathord");
  },
  mathmlBuilder(group, options) {
    var node2 = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
    var variant = getVariant(group, options) || "italic";
    if (variant !== defaultVariant[node2.type]) {
      node2.setAttribute("mathvariant", variant);
    }
    return node2;
  }
});
defineFunctionBuilders({
  type: "textord",
  htmlBuilder(group, options) {
    return buildCommon.makeOrd(group, options, "textord");
  },
  mathmlBuilder(group, options) {
    var text10 = makeText(group.text, group.mode, options);
    var variant = getVariant(group, options) || "normal";
    var node2;
    if (group.mode === "text") {
      node2 = new mathMLTree.MathNode("mtext", [text10]);
    } else if (/[0-9]/.test(group.text)) {
      node2 = new mathMLTree.MathNode("mn", [text10]);
    } else if (group.text === "\\prime") {
      node2 = new mathMLTree.MathNode("mo", [text10]);
    } else {
      node2 = new mathMLTree.MathNode("mi", [text10]);
    }
    if (variant !== defaultVariant[node2.type]) {
      node2.setAttribute("mathvariant", variant);
    }
    return node2;
  }
});
var cssSpace = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
};
var regularSpace = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
defineFunctionBuilders({
  type: "spacing",
  htmlBuilder(group, options) {
    if (regularSpace.hasOwnProperty(group.text)) {
      var className = regularSpace[group.text].className || "";
      if (group.mode === "text") {
        var ord = buildCommon.makeOrd(group, options, "textord");
        ord.classes.push(className);
        return ord;
      } else {
        return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
      }
    } else if (cssSpace.hasOwnProperty(group.text)) {
      return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
    } else {
      throw new ParseError('Unknown type of space "' + group.text + '"');
    }
  },
  mathmlBuilder(group, options) {
    var node2;
    if (regularSpace.hasOwnProperty(group.text)) {
      node2 = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("")]);
    } else if (cssSpace.hasOwnProperty(group.text)) {
      return new mathMLTree.MathNode("mspace");
    } else {
      throw new ParseError('Unknown type of space "' + group.text + '"');
    }
    return node2;
  }
});
var pad = () => {
  var padNode = new mathMLTree.MathNode("mtd", []);
  padNode.setAttribute("width", "50%");
  return padNode;
};
defineFunctionBuilders({
  type: "tag",
  mathmlBuilder(group, options) {
    var table2 = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
    table2.setAttribute("width", "100%");
    return table2;
  }
});
var textFontFamilies = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
};
var textFontWeights = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
};
var textFontShapes = {
  "\\textit": "textit",
  "\\textup": "textup"
};
var optionsWithFont = (group, options) => {
  var font = group.font;
  if (!font) {
    return options;
  } else if (textFontFamilies[font]) {
    return options.withTextFontFamily(textFontFamilies[font]);
  } else if (textFontWeights[font]) {
    return options.withTextFontWeight(textFontWeights[font]);
  } else if (font === "\\emph") {
    return options.fontShape === "textit" ? options.withTextFontShape("textup") : options.withTextFontShape("textit");
  }
  return options.withTextFontShape(textFontShapes[font]);
};
defineFunction({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: true,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser,
      funcName
    } = _ref;
    var body = args[0];
    return {
      type: "text",
      mode: parser.mode,
      body: ordargument(body),
      font: funcName
    };
  },
  htmlBuilder(group, options) {
    var newOptions = optionsWithFont(group, options);
    var inner3 = buildExpression$1(group.body, newOptions, true);
    return buildCommon.makeSpan(["mord", "text"], inner3, newOptions);
  },
  mathmlBuilder(group, options) {
    var newOptions = optionsWithFont(group, options);
    return buildExpressionRow(group.body, newOptions);
  }
});
defineFunction({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "underline",
      mode: parser.mode,
      body: args[0]
    };
  },
  htmlBuilder(group, options) {
    var innerGroup = buildGroup$1(group.body, options);
    var line = buildCommon.makeLineSpan("underline-line", options);
    var defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
    var vlist = buildCommon.makeVList({
      positionType: "top",
      positionData: innerGroup.height,
      children: [{
        type: "kern",
        size: defaultRuleThickness
      }, {
        type: "elem",
        elem: line
      }, {
        type: "kern",
        size: 3 * defaultRuleThickness
      }, {
        type: "elem",
        elem: innerGroup
      }]
    }, options);
    return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
  },
  mathmlBuilder(group, options) {
    var operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("")]);
    operator.setAttribute("stretchy", "true");
    var node2 = new mathMLTree.MathNode("munder", [buildGroup2(group.body, options), operator]);
    node2.setAttribute("accentunder", "true");
    return node2;
  }
});
defineFunction({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: false
  },
  handler(_ref, args) {
    var {
      parser
    } = _ref;
    return {
      type: "vcenter",
      mode: parser.mode,
      body: args[0]
    };
  },
  htmlBuilder(group, options) {
    var body = buildGroup$1(group.body, options);
    var axisHeight = options.fontMetrics().axisHeight;
    var dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
    return buildCommon.makeVList({
      positionType: "shift",
      positionData: dy,
      children: [{
        type: "elem",
        elem: body
      }]
    }, options);
  },
  mathmlBuilder(group, options) {
    return new mathMLTree.MathNode("mpadded", [buildGroup2(group.body, options)], ["vcenter"]);
  }
});
defineFunction({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(context, args, optArgs) {
    throw new ParseError("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder(group, options) {
    var text10 = makeVerb(group);
    var body = [];
    var newOptions = options.havingStyle(options.style.text());
    for (var i16 = 0; i16 < text10.length; i16++) {
      var c21 = text10[i16];
      if (c21 === "~") {
        c21 = "\\textasciitilde";
      }
      body.push(buildCommon.makeSymbol(c21, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
    }
    return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
  },
  mathmlBuilder(group, options) {
    var text10 = new mathMLTree.TextNode(makeVerb(group));
    var node2 = new mathMLTree.MathNode("mtext", [text10]);
    node2.setAttribute("mathvariant", "monospace");
    return node2;
  }
});
var makeVerb = (group) => group.body.replace(/ /g, group.star ? "" : "");
var functions = _functions;
var spaceRegexString = "[ \r\n	]";
var controlWordRegexString = "\\\\[a-zA-Z@]+";
var controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
var controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
var controlSpaceRegexString = "\\\\(\n|[ \r	]+\n?)[ \r	]*";
var combiningDiacriticalMarkString = "[-]";
var combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
var tokenRegexString = "(" + spaceRegexString + "+)|" + // whitespace
(controlSpaceRegexString + "|") + // \whitespace
"([!-\\[\\]---]" + // single codepoint
(combiningDiacriticalMarkString + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
(combiningDiacriticalMarkString + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
("|" + controlWordWhitespaceRegexString) + // \macroName + spaces
("|" + controlSymbolRegexString + ")");
var Lexer = class {
  // Category codes. The lexer only supports comment characters (14) for now.
  // MacroExpander additionally distinguishes active (13).
  constructor(input, settings) {
    this.input = void 0;
    this.settings = void 0;
    this.tokenRegex = void 0;
    this.catcodes = void 0;
    this.input = input;
    this.settings = settings;
    this.tokenRegex = new RegExp(tokenRegexString, "g");
    this.catcodes = {
      "%": 14,
      // comment character
      "~": 13
      // active character
    };
  }
  setCatcode(char, code4) {
    this.catcodes[char] = code4;
  }
  /**
   * This function lexes a single token.
   */
  lex() {
    var input = this.input;
    var pos = this.tokenRegex.lastIndex;
    if (pos === input.length) {
      return new Token("EOF", new SourceLocation(this, pos, pos));
    }
    var match = this.tokenRegex.exec(input);
    if (match === null || match.index !== pos) {
      throw new ParseError("Unexpected character: '" + input[pos] + "'", new Token(input[pos], new SourceLocation(this, pos, pos + 1)));
    }
    var text10 = match[6] || match[3] || (match[2] ? "\\ " : " ");
    if (this.catcodes[text10] === 14) {
      var nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
      if (nlIndex === -1) {
        this.tokenRegex.lastIndex = input.length;
        this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
      } else {
        this.tokenRegex.lastIndex = nlIndex + 1;
      }
      return this.lex();
    }
    return new Token(text10, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
  }
};
var Namespace = class {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(builtins, globalMacros) {
    if (builtins === void 0) {
      builtins = {};
    }
    if (globalMacros === void 0) {
      globalMacros = {};
    }
    this.current = void 0;
    this.builtins = void 0;
    this.undefStack = void 0;
    this.current = globalMacros;
    this.builtins = builtins;
    this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0) {
      throw new ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
    }
    var undefs = this.undefStack.pop();
    for (var undef in undefs) {
      if (undefs.hasOwnProperty(undef)) {
        if (undefs[undef] == null) {
          delete this.current[undef];
        } else {
          this.current[undef] = undefs[undef];
        }
      }
    }
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    while (this.undefStack.length > 0) {
      this.endGroup();
    }
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(name2) {
    return this.current.hasOwnProperty(name2) || this.builtins.hasOwnProperty(name2);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(name2) {
    if (this.current.hasOwnProperty(name2)) {
      return this.current[name2];
    } else {
      return this.builtins[name2];
    }
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   * A value of undefined means to delete existing definitions.
   */
  set(name2, value, global) {
    if (global === void 0) {
      global = false;
    }
    if (global) {
      for (var i16 = 0; i16 < this.undefStack.length; i16++) {
        delete this.undefStack[i16][name2];
      }
      if (this.undefStack.length > 0) {
        this.undefStack[this.undefStack.length - 1][name2] = value;
      }
    } else {
      var top = this.undefStack[this.undefStack.length - 1];
      if (top && !top.hasOwnProperty(name2)) {
        top[name2] = this.current[name2];
      }
    }
    if (value == null) {
      delete this.current[name2];
    } else {
      this.current[name2] = value;
    }
  }
};
var macros = _macros;
defineMacro("\\noexpand", function(context) {
  var t14 = context.popToken();
  if (context.isExpandable(t14.text)) {
    t14.noexpand = true;
    t14.treatAsRelax = true;
  }
  return {
    tokens: [t14],
    numArgs: 0
  };
});
defineMacro("\\expandafter", function(context) {
  var t14 = context.popToken();
  context.expandOnce(true);
  return {
    tokens: [t14],
    numArgs: 0
  };
});
defineMacro("\\@firstoftwo", function(context) {
  var args = context.consumeArgs(2);
  return {
    tokens: args[0],
    numArgs: 0
  };
});
defineMacro("\\@secondoftwo", function(context) {
  var args = context.consumeArgs(2);
  return {
    tokens: args[1],
    numArgs: 0
  };
});
defineMacro("\\@ifnextchar", function(context) {
  var args = context.consumeArgs(3);
  context.consumeSpaces();
  var nextToken = context.future();
  if (args[0].length === 1 && args[0][0].text === nextToken.text) {
    return {
      tokens: args[1],
      numArgs: 0
    };
  } else {
    return {
      tokens: args[2],
      numArgs: 0
    };
  }
});
defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
defineMacro("\\TextOrMath", function(context) {
  var args = context.consumeArgs(2);
  if (context.mode === "text") {
    return {
      tokens: args[0],
      numArgs: 0
    };
  } else {
    return {
      tokens: args[1],
      numArgs: 0
    };
  }
});
var digitToNumber = {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  "a": 10,
  "A": 10,
  "b": 11,
  "B": 11,
  "c": 12,
  "C": 12,
  "d": 13,
  "D": 13,
  "e": 14,
  "E": 14,
  "f": 15,
  "F": 15
};
defineMacro("\\char", function(context) {
  var token = context.popToken();
  var base;
  var number3 = "";
  if (token.text === "'") {
    base = 8;
    token = context.popToken();
  } else if (token.text === '"') {
    base = 16;
    token = context.popToken();
  } else if (token.text === "`") {
    token = context.popToken();
    if (token.text[0] === "\\") {
      number3 = token.text.charCodeAt(1);
    } else if (token.text === "EOF") {
      throw new ParseError("\\char` missing argument");
    } else {
      number3 = token.text.charCodeAt(0);
    }
  } else {
    base = 10;
  }
  if (base) {
    number3 = digitToNumber[token.text];
    if (number3 == null || number3 >= base) {
      throw new ParseError("Invalid base-" + base + " digit " + token.text);
    }
    var digit;
    while ((digit = digitToNumber[context.future().text]) != null && digit < base) {
      number3 *= base;
      number3 += digit;
      context.popToken();
    }
  }
  return "\\@char{" + number3 + "}";
});
var newcommand = (context, existsOK, nonexistsOK, skipIfExists) => {
  var arg = context.consumeArg().tokens;
  if (arg.length !== 1) {
    throw new ParseError("\\newcommand's first argument must be a macro name");
  }
  var name2 = arg[0].text;
  var exists = context.isDefined(name2);
  if (exists && !existsOK) {
    throw new ParseError("\\newcommand{" + name2 + "} attempting to redefine " + (name2 + "; use \\renewcommand"));
  }
  if (!exists && !nonexistsOK) {
    throw new ParseError("\\renewcommand{" + name2 + "} when command " + name2 + " does not yet exist; use \\newcommand");
  }
  var numArgs = 0;
  arg = context.consumeArg().tokens;
  if (arg.length === 1 && arg[0].text === "[") {
    var argText = "";
    var token = context.expandNextToken();
    while (token.text !== "]" && token.text !== "EOF") {
      argText += token.text;
      token = context.expandNextToken();
    }
    if (!argText.match(/^\s*[0-9]+\s*$/)) {
      throw new ParseError("Invalid number of arguments: " + argText);
    }
    numArgs = parseInt(argText);
    arg = context.consumeArg().tokens;
  }
  if (!(exists && skipIfExists)) {
    context.macros.set(name2, {
      tokens: arg,
      numArgs
    });
  }
  return "";
};
defineMacro("\\newcommand", (context) => newcommand(context, false, true, false));
defineMacro("\\renewcommand", (context) => newcommand(context, true, false, false));
defineMacro("\\providecommand", (context) => newcommand(context, true, true, true));
defineMacro("\\message", (context) => {
  var arg = context.consumeArgs(1)[0];
  console.log(arg.reverse().map((token) => token.text).join(""));
  return "";
});
defineMacro("\\errmessage", (context) => {
  var arg = context.consumeArgs(1)[0];
  console.error(arg.reverse().map((token) => token.text).join(""));
  return "";
});
defineMacro("\\show", (context) => {
  var tok = context.popToken();
  var name2 = tok.text;
  console.log(tok, context.macros.get(name2), functions[name2], symbols.math[name2], symbols.text[name2]);
  return "";
});
defineMacro("\\bgroup", "{");
defineMacro("\\egroup", "}");
defineMacro("~", "\\nobreakspace");
defineMacro("\\lq", "`");
defineMacro("\\rq", "'");
defineMacro("\\aa", "\\r a");
defineMacro("\\AA", "\\r A");
defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`}");
defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`}");
defineMacro("", "\\mathscr{B}");
defineMacro("", "\\mathscr{E}");
defineMacro("", "\\mathscr{F}");
defineMacro("", "\\mathscr{H}");
defineMacro("", "\\mathscr{I}");
defineMacro("", "\\mathscr{L}");
defineMacro("", "\\mathscr{M}");
defineMacro("", "\\mathscr{R}");
defineMacro("", "\\mathfrak{C}");
defineMacro("", "\\mathfrak{H}");
defineMacro("", "\\mathfrak{Z}");
defineMacro("\\Bbbk", "\\Bbb{k}");
defineMacro("", "\\cdotp");
defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
defineMacro("\\mathstrut", "\\vphantom{(}");
defineMacro("\\underbar", "\\underline{\\text{#1}}");
defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`}}");
defineMacro("\\ne", "\\neq");
defineMacro("", "\\neq");
defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`}}");
defineMacro("", "\\notin");
defineMacro("", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`}}");
defineMacro("", "\\perp");
defineMacro("", "\\mathclose{!\\mkern-0.8mu!}");
defineMacro("", "\\notni");
defineMacro("", "\\ulcorner");
defineMacro("", "\\urcorner");
defineMacro("", "\\llcorner");
defineMacro("", "\\lrcorner");
defineMacro("", "\\copyright");
defineMacro("", "\\textregistered");
defineMacro("", "\\textregistered");
defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
defineMacro("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
defineMacro("", "\\vdots");
defineMacro("\\varGamma", "\\mathit{\\Gamma}");
defineMacro("\\varDelta", "\\mathit{\\Delta}");
defineMacro("\\varTheta", "\\mathit{\\Theta}");
defineMacro("\\varLambda", "\\mathit{\\Lambda}");
defineMacro("\\varXi", "\\mathit{\\Xi}");
defineMacro("\\varPi", "\\mathit{\\Pi}");
defineMacro("\\varSigma", "\\mathit{\\Sigma}");
defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
defineMacro("\\varPhi", "\\mathit{\\Phi}");
defineMacro("\\varPsi", "\\mathit{\\Psi}");
defineMacro("\\varOmega", "\\mathit{\\Omega}");
defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
defineMacro("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
defineMacro("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
var dotsByToken = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};
defineMacro("\\dots", function(context) {
  var thedots = "\\dotso";
  var next2 = context.expandAfterFuture().text;
  if (next2 in dotsByToken) {
    thedots = dotsByToken[next2];
  } else if (next2.slice(0, 4) === "\\not") {
    thedots = "\\dotsb";
  } else if (next2 in symbols.math) {
    if (["bin", "rel"].includes(symbols.math[next2].group)) {
      thedots = "\\dotsb";
    }
  }
  return thedots;
});
var spaceAfterDots = {
  // \rightdelim@ checks for the following:
  ")": true,
  "]": true,
  "\\rbrack": true,
  "\\}": true,
  "\\rbrace": true,
  "\\rangle": true,
  "\\rceil": true,
  "\\rfloor": true,
  "\\rgroup": true,
  "\\rmoustache": true,
  "\\right": true,
  "\\bigr": true,
  "\\biggr": true,
  "\\Bigr": true,
  "\\Biggr": true,
  // \extra@ also tests for the following:
  "$": true,
  // \extrap@ checks for the following:
  ";": true,
  ".": true,
  ",": true
};
defineMacro("\\dotso", function(context) {
  var next2 = context.future().text;
  if (next2 in spaceAfterDots) {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});
defineMacro("\\dotsc", function(context) {
  var next2 = context.future().text;
  if (next2 in spaceAfterDots && next2 !== ",") {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});
defineMacro("\\cdots", function(context) {
  var next2 = context.future().text;
  if (next2 in spaceAfterDots) {
    return "\\@cdots\\,";
  } else {
    return "\\@cdots";
  }
});
defineMacro("\\dotsb", "\\cdots");
defineMacro("\\dotsm", "\\cdots");
defineMacro("\\dotsi", "\\!\\cdots");
defineMacro("\\dotsx", "\\ldots\\,");
defineMacro("\\DOTSI", "\\relax");
defineMacro("\\DOTSB", "\\relax");
defineMacro("\\DOTSX", "\\relax");
defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
defineMacro("\\thinspace", "\\,");
defineMacro("\\>", "\\mskip{4mu}");
defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
defineMacro("\\medspace", "\\:");
defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
defineMacro("\\thickspace", "\\;");
defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
defineMacro("\\negthinspace", "\\!");
defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
defineMacro("\\enspace", "\\kern.5em ");
defineMacro("\\enskip", "\\hskip.5em\\relax");
defineMacro("\\quad", "\\hskip1em\\relax");
defineMacro("\\qquad", "\\hskip2em\\relax");
defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
defineMacro("\\tag@literal", (context) => {
  if (context.macros.get("\\df@tag")) {
    throw new ParseError("Multiple \\tag");
  }
  return "\\gdef\\df@tag{\\text{#1}}";
});
defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
defineMacro("\\newline", "\\\\\\relax");
defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var latexRaiseA = makeEm(fontMetricsData["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData["Main-Regular"]["A".charCodeAt(0)][1]);
defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
defineMacro("\\@hspace", "\\hskip #1\\relax");
defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
defineMacro("\\ordinarycolon", ":");
defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
defineMacro("", "\\dblcolon");
defineMacro("", "\\eqcolon");
defineMacro("", "\\coloneqq");
defineMacro("", "\\eqqcolon");
defineMacro("", "\\Coloneqq");
defineMacro("\\ratio", "\\vcentcolon");
defineMacro("\\coloncolon", "\\dblcolon");
defineMacro("\\colonequals", "\\coloneqq");
defineMacro("\\coloncolonequals", "\\Coloneqq");
defineMacro("\\equalscolon", "\\eqqcolon");
defineMacro("\\equalscoloncolon", "\\Eqqcolon");
defineMacro("\\colonminus", "\\coloneq");
defineMacro("\\coloncolonminus", "\\Coloneq");
defineMacro("\\minuscolon", "\\eqcolon");
defineMacro("\\minuscoloncolon", "\\Eqcolon");
defineMacro("\\coloncolonapprox", "\\Colonapprox");
defineMacro("\\coloncolonsim", "\\Colonsim");
defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`}}");
defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{}");
defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{}");
defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{}");
defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{}");
defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{}");
defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{}");
defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{}");
defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{}");
defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{}");
defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{}");
defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{}");
defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{}");
defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{}");
defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{}");
defineMacro("\\imath", "\\html@mathml{\\@imath}{}");
defineMacro("\\jmath", "\\html@mathml{\\@jmath}{}");
defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`}}");
defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`}}");
defineMacro("", "\\llbracket");
defineMacro("", "\\rrbracket");
defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`}}");
defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`}}");
defineMacro("", "\\lBrace");
defineMacro("", "\\rBrace");
defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`}}");
defineMacro("", "\\minuso");
defineMacro("\\darr", "\\downarrow");
defineMacro("\\dArr", "\\Downarrow");
defineMacro("\\Darr", "\\Downarrow");
defineMacro("\\lang", "\\langle");
defineMacro("\\rang", "\\rangle");
defineMacro("\\uarr", "\\uparrow");
defineMacro("\\uArr", "\\Uparrow");
defineMacro("\\Uarr", "\\Uparrow");
defineMacro("\\N", "\\mathbb{N}");
defineMacro("\\R", "\\mathbb{R}");
defineMacro("\\Z", "\\mathbb{Z}");
defineMacro("\\alef", "\\aleph");
defineMacro("\\alefsym", "\\aleph");
defineMacro("\\Alpha", "\\mathrm{A}");
defineMacro("\\Beta", "\\mathrm{B}");
defineMacro("\\bull", "\\bullet");
defineMacro("\\Chi", "\\mathrm{X}");
defineMacro("\\clubs", "\\clubsuit");
defineMacro("\\cnums", "\\mathbb{C}");
defineMacro("\\Complex", "\\mathbb{C}");
defineMacro("\\Dagger", "\\ddagger");
defineMacro("\\diamonds", "\\diamondsuit");
defineMacro("\\empty", "\\emptyset");
defineMacro("\\Epsilon", "\\mathrm{E}");
defineMacro("\\Eta", "\\mathrm{H}");
defineMacro("\\exist", "\\exists");
defineMacro("\\harr", "\\leftrightarrow");
defineMacro("\\hArr", "\\Leftrightarrow");
defineMacro("\\Harr", "\\Leftrightarrow");
defineMacro("\\hearts", "\\heartsuit");
defineMacro("\\image", "\\Im");
defineMacro("\\infin", "\\infty");
defineMacro("\\Iota", "\\mathrm{I}");
defineMacro("\\isin", "\\in");
defineMacro("\\Kappa", "\\mathrm{K}");
defineMacro("\\larr", "\\leftarrow");
defineMacro("\\lArr", "\\Leftarrow");
defineMacro("\\Larr", "\\Leftarrow");
defineMacro("\\lrarr", "\\leftrightarrow");
defineMacro("\\lrArr", "\\Leftrightarrow");
defineMacro("\\Lrarr", "\\Leftrightarrow");
defineMacro("\\Mu", "\\mathrm{M}");
defineMacro("\\natnums", "\\mathbb{N}");
defineMacro("\\Nu", "\\mathrm{N}");
defineMacro("\\Omicron", "\\mathrm{O}");
defineMacro("\\plusmn", "\\pm");
defineMacro("\\rarr", "\\rightarrow");
defineMacro("\\rArr", "\\Rightarrow");
defineMacro("\\Rarr", "\\Rightarrow");
defineMacro("\\real", "\\Re");
defineMacro("\\reals", "\\mathbb{R}");
defineMacro("\\Reals", "\\mathbb{R}");
defineMacro("\\Rho", "\\mathrm{P}");
defineMacro("\\sdot", "\\cdot");
defineMacro("\\sect", "\\S");
defineMacro("\\spades", "\\spadesuit");
defineMacro("\\sub", "\\subset");
defineMacro("\\sube", "\\subseteq");
defineMacro("\\supe", "\\supseteq");
defineMacro("\\Tau", "\\mathrm{T}");
defineMacro("\\thetasym", "\\vartheta");
defineMacro("\\weierp", "\\wp");
defineMacro("\\Zeta", "\\mathrm{Z}");
defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
defineMacro("\\Bra", "\\left\\langle#1\\right|");
defineMacro("\\Ket", "\\left|#1\\right\\rangle");
var braketHelper = (one5) => (context) => {
  var left = context.consumeArg().tokens;
  var middle = context.consumeArg().tokens;
  var middleDouble = context.consumeArg().tokens;
  var right = context.consumeArg().tokens;
  var oldMiddle = context.macros.get("|");
  var oldMiddleDouble = context.macros.get("\\|");
  context.macros.beginGroup();
  var midMacro = (double) => (context2) => {
    if (one5) {
      context2.macros.set("|", oldMiddle);
      if (middleDouble.length) {
        context2.macros.set("\\|", oldMiddleDouble);
      }
    }
    var doubled = double;
    if (!double && middleDouble.length) {
      var nextToken = context2.future();
      if (nextToken.text === "|") {
        context2.popToken();
        doubled = true;
      }
    }
    return {
      tokens: doubled ? middleDouble : middle,
      numArgs: 0
    };
  };
  context.macros.set("|", midMacro(false));
  if (middleDouble.length) {
    context.macros.set("\\|", midMacro(true));
  }
  var arg = context.consumeArg().tokens;
  var expanded = context.expandTokens([
    ...right,
    ...arg,
    ...left
    // reversed
  ]);
  context.macros.endGroup();
  return {
    tokens: expanded.reverse(),
    numArgs: 0
  };
};
defineMacro("\\bra@ket", braketHelper(false));
defineMacro("\\bra@set", braketHelper(true));
defineMacro("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
defineMacro("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
defineMacro("\\angln", "{\\angl n}");
defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
defineMacro("\\red", "\\textcolor{##df0030}{#1}");
defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
defineMacro("\\gray", "\\textcolor{gray}{#1}");
defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
var implicitCommands = {
  "^": true,
  // Parser.js
  "_": true,
  // Parser.js
  "\\limits": true,
  // Parser.js
  "\\nolimits": true
  // Parser.js
};
var MacroExpander = class {
  constructor(input, settings, mode) {
    this.settings = void 0;
    this.expansionCount = void 0;
    this.lexer = void 0;
    this.macros = void 0;
    this.stack = void 0;
    this.mode = void 0;
    this.settings = settings;
    this.expansionCount = 0;
    this.feed(input);
    this.macros = new Namespace(macros, settings.macros);
    this.mode = mode;
    this.stack = [];
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(input) {
    this.lexer = new Lexer(input, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(newMode) {
    this.mode = newMode;
  }
  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    this.macros.endGroups();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    if (this.stack.length === 0) {
      this.pushToken(this.lexer.lex());
    }
    return this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    this.future();
    return this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(token) {
    this.stack.push(token);
  }
  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(tokens) {
    this.stack.push(...tokens);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(isOptional) {
    var start2;
    var end;
    var tokens;
    if (isOptional) {
      this.consumeSpaces();
      if (this.future().text !== "[") {
        return null;
      }
      start2 = this.popToken();
      ({
        tokens,
        end
      } = this.consumeArg(["]"]));
    } else {
      ({
        tokens,
        start: start2,
        end
      } = this.consumeArg());
    }
    this.pushToken(new Token("EOF", end.loc));
    this.pushTokens(tokens);
    return new Token("", SourceLocation.range(start2, end));
  }
  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (; ; ) {
      var token = this.future();
      if (token.text === " ") {
        this.stack.pop();
      } else {
        break;
      }
    }
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(delims) {
    var tokens = [];
    var isDelimited = delims && delims.length > 0;
    if (!isDelimited) {
      this.consumeSpaces();
    }
    var start2 = this.future();
    var tok;
    var depth = 0;
    var match = 0;
    do {
      tok = this.popToken();
      tokens.push(tok);
      if (tok.text === "{") {
        ++depth;
      } else if (tok.text === "}") {
        --depth;
        if (depth === -1) {
          throw new ParseError("Extra }", tok);
        }
      } else if (tok.text === "EOF") {
        throw new ParseError("Unexpected end of input in a macro argument, expected '" + (delims && isDelimited ? delims[match] : "}") + "'", tok);
      }
      if (delims && isDelimited) {
        if ((depth === 0 || depth === 1 && delims[match] === "{") && tok.text === delims[match]) {
          ++match;
          if (match === delims.length) {
            tokens.splice(-match, match);
            break;
          }
        } else {
          match = 0;
        }
      }
    } while (depth !== 0 || isDelimited);
    if (start2.text === "{" && tokens[tokens.length - 1].text === "}") {
      tokens.pop();
      tokens.shift();
    }
    tokens.reverse();
    return {
      tokens,
      start: start2,
      end: tok
    };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(numArgs, delimiters2) {
    if (delimiters2) {
      if (delimiters2.length !== numArgs + 1) {
        throw new ParseError("The length of delimiters doesn't match the number of args!");
      }
      var delims = delimiters2[0];
      for (var i16 = 0; i16 < delims.length; i16++) {
        var tok = this.popToken();
        if (delims[i16] !== tok.text) {
          throw new ParseError("Use of the macro doesn't match its definition", tok);
        }
      }
    }
    var args = [];
    for (var _i = 0; _i < numArgs; _i++) {
      args.push(this.consumeArg(delimiters2 && delimiters2[_i + 1]).tokens);
    }
    return args;
  }
  /**
   * Increment `expansionCount` by the specified amount.
   * Throw an error if it exceeds `maxExpand`.
   */
  countExpansion(amount) {
    this.expansionCount += amount;
    if (this.expansionCount > this.settings.maxExpand) {
      throw new ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
    }
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(expandableOnly) {
    var topToken = this.popToken();
    var name2 = topToken.text;
    var expansion = !topToken.noexpand ? this._getExpansion(name2) : null;
    if (expansion == null || expandableOnly && expansion.unexpandable) {
      if (expandableOnly && expansion == null && name2[0] === "\\" && !this.isDefined(name2)) {
        throw new ParseError("Undefined control sequence: " + name2);
      }
      this.pushToken(topToken);
      return false;
    }
    this.countExpansion(1);
    var tokens = expansion.tokens;
    var args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
    if (expansion.numArgs) {
      tokens = tokens.slice();
      for (var i16 = tokens.length - 1; i16 >= 0; --i16) {
        var tok = tokens[i16];
        if (tok.text === "#") {
          if (i16 === 0) {
            throw new ParseError("Incomplete placeholder at end of macro body", tok);
          }
          tok = tokens[--i16];
          if (tok.text === "#") {
            tokens.splice(i16 + 1, 1);
          } else if (/^[1-9]$/.test(tok.text)) {
            tokens.splice(i16, 2, ...args[+tok.text - 1]);
          } else {
            throw new ParseError("Not a valid argument number", tok);
          }
        }
      }
    }
    this.pushTokens(tokens);
    return tokens.length;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    this.expandOnce();
    return this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (; ; ) {
      if (this.expandOnce() === false) {
        var token = this.stack.pop();
        if (token.treatAsRelax) {
          token.text = "\\relax";
        }
        return token;
      }
    }
    throw new Error();
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(name2) {
    return this.macros.has(name2) ? this.expandTokens([new Token(name2)]) : void 0;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(tokens) {
    var output = [];
    var oldStackLength = this.stack.length;
    this.pushTokens(tokens);
    while (this.stack.length > oldStackLength) {
      if (this.expandOnce(true) === false) {
        var token = this.stack.pop();
        if (token.treatAsRelax) {
          token.noexpand = false;
          token.treatAsRelax = false;
        }
        output.push(token);
      }
    }
    this.countExpansion(output.length);
    return output;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(name2) {
    var tokens = this.expandMacro(name2);
    if (tokens) {
      return tokens.map((token) => token.text).join("");
    } else {
      return tokens;
    }
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(name2) {
    var definition3 = this.macros.get(name2);
    if (definition3 == null) {
      return definition3;
    }
    if (name2.length === 1) {
      var catcode = this.lexer.catcodes[name2];
      if (catcode != null && catcode !== 13) {
        return;
      }
    }
    var expansion = typeof definition3 === "function" ? definition3(this) : definition3;
    if (typeof expansion === "string") {
      var numArgs = 0;
      if (expansion.indexOf("#") !== -1) {
        var stripped = expansion.replace(/##/g, "");
        while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
          ++numArgs;
        }
      }
      var bodyLexer = new Lexer(expansion, this.settings);
      var tokens = [];
      var tok = bodyLexer.lex();
      while (tok.text !== "EOF") {
        tokens.push(tok);
        tok = bodyLexer.lex();
      }
      tokens.reverse();
      var expanded = {
        tokens,
        numArgs
      };
      return expanded;
    }
    return expansion;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(name2) {
    return this.macros.has(name2) || functions.hasOwnProperty(name2) || symbols.math.hasOwnProperty(name2) || symbols.text.hasOwnProperty(name2) || implicitCommands.hasOwnProperty(name2);
  }
  /**
   * Determine whether a command is expandable.
   */
  isExpandable(name2) {
    var macro = this.macros.get(name2);
    return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : functions.hasOwnProperty(name2) && !functions[name2].primitive;
  }
};
var unicodeSubRegEx = /^[]/;
var uSubsAndSups = Object.freeze({
  "": "+",
  "": "-",
  "": "=",
  "": "(",
  "": ")",
  "": "0",
  "": "1",
  "": "2",
  "": "3",
  "": "4",
  "": "5",
  "": "6",
  "": "7",
  "": "8",
  "": "9",
  "": "a",
  "": "e",
  "": "h",
  "": "i",
  "": "j",
  "": "k",
  "": "l",
  "": "m",
  "": "n",
  "": "o",
  "": "p",
  "": "r",
  "": "s",
  "": "t",
  "": "u",
  "": "v",
  "": "x",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "+",
  "": "-",
  "": "=",
  "": "(",
  "": ")",
  "": "0",
  "": "1",
  "": "2",
  "": "3",
  "": "4",
  "": "5",
  "": "6",
  "": "7",
  "": "8",
  "": "9",
  "": "A",
  "": "B",
  "": "D",
  "": "E",
  "": "G",
  "": "H",
  "": "I",
  "": "J",
  "": "K",
  "": "L",
  "": "M",
  "": "N",
  "": "O",
  "": "P",
  "": "R",
  "": "T",
  "": "U",
  "": "V",
  "": "W",
  "": "a",
  "": "b",
  "": "c",
  "": "d",
  "": "e",
  "": "f",
  "": "g",
  "": "h",
  "": "i",
  "": "j",
  "": "k",
  "": "l",
  "": "m",
  "": "n",
  "": "o",
  "": "p",
  "": "r",
  "": "s",
  "": "t",
  "": "u",
  "": "v",
  "": "w",
  "": "x",
  "": "y",
  "": "z",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": ""
});
var unicodeAccents = {
  "": {
    "text": "\\'",
    "math": "\\acute"
  },
  "": {
    "text": "\\`",
    "math": "\\grave"
  },
  "": {
    "text": '\\"',
    "math": "\\ddot"
  },
  "": {
    "text": "\\~",
    "math": "\\tilde"
  },
  "": {
    "text": "\\=",
    "math": "\\bar"
  },
  "": {
    "text": "\\u",
    "math": "\\breve"
  },
  "": {
    "text": "\\v",
    "math": "\\check"
  },
  "": {
    "text": "\\^",
    "math": "\\hat"
  },
  "": {
    "text": "\\.",
    "math": "\\dot"
  },
  "": {
    "text": "\\r",
    "math": "\\mathring"
  },
  "": {
    "text": "\\H"
  },
  "": {
    "text": "\\c"
  }
};
var unicodeSymbols = {
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "b",
  "": "c",
  "": "c",
  "": "c",
  "": "c",
  "": "c",
  "": "c",
  "": "d",
  "": "d",
  "": "d",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "f",
  "": "g",
  "": "g",
  "": "g",
  "": "g",
  "": "g",
  "": "g",
  "": "g",
  "": "h",
  "": "h",
  "": "h",
  "": "h",
  "": "h",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "j",
  "": "j",
  "": "k",
  "": "k",
  "": "k",
  "": "l",
  "": "l",
  "": "l",
  "": "m",
  "": "m",
  "": "n",
  "": "n",
  "": "n",
  "": "n",
  "": "n",
  "": "n",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "p",
  "": "p",
  "": "r",
  "": "r",
  "": "r",
  "": "r",
  "": "s",
  "": "s",
  "": "s",
  "": "s",
  "": "s",
  "": "s",
  "": "s",
  "": "t",
  "": "t",
  "": "t",
  "": "t",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "v",
  "": "w",
  "": "w",
  "": "w",
  "": "w",
  "": "w",
  "": "w",
  "": "x",
  "": "x",
  "": "y",
  "": "y",
  "": "y",
  "": "y",
  "": "y",
  "": "y",
  "": "y",
  "": "y",
  "": "z",
  "": "z",
  "": "z",
  "": "z",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "B",
  "": "C",
  "": "C",
  "": "C",
  "": "C",
  "": "C",
  "": "C",
  "": "D",
  "": "D",
  "": "D",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "F",
  "": "G",
  "": "G",
  "": "G",
  "": "G",
  "": "G",
  "": "G",
  "": "G",
  "": "H",
  "": "H",
  "": "H",
  "": "H",
  "": "H",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "J",
  "": "K",
  "": "K",
  "": "K",
  "": "L",
  "": "L",
  "": "L",
  "": "M",
  "": "M",
  "": "N",
  "": "N",
  "": "N",
  "": "N",
  "": "N",
  "": "N",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "P",
  "": "P",
  "": "R",
  "": "R",
  "": "R",
  "": "R",
  "": "S",
  "": "S",
  "": "S",
  "": "S",
  "": "S",
  "": "S",
  "": "S",
  "": "T",
  "": "T",
  "": "T",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "V",
  "": "W",
  "": "W",
  "": "W",
  "": "W",
  "": "W",
  "": "X",
  "": "X",
  "": "Y",
  "": "Y",
  "": "Y",
  "": "Y",
  "": "Y",
  "": "Y",
  "": "Y",
  "": "Z",
  "": "Z",
  "": "Z",
  "": "Z",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": "",
  "": ""
};
var Parser = class _Parser {
  constructor(input, settings) {
    this.mode = void 0;
    this.gullet = void 0;
    this.settings = void 0;
    this.leftrightDepth = void 0;
    this.nextToken = void 0;
    this.mode = "math";
    this.gullet = new MacroExpander(input, settings, this.mode);
    this.settings = settings;
    this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(text10, consume) {
    if (consume === void 0) {
      consume = true;
    }
    if (this.fetch().text !== text10) {
      throw new ParseError("Expected '" + text10 + "', got '" + this.fetch().text + "'", this.fetch());
    }
    if (consume) {
      this.consume();
    }
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    if (this.nextToken == null) {
      this.nextToken = this.gullet.expandNextToken();
    }
    return this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(newMode) {
    this.mode = newMode;
    this.gullet.switchMode(newMode);
  }
  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    if (!this.settings.globalGroup) {
      this.gullet.beginGroup();
    }
    if (this.settings.colorIsTextColor) {
      this.gullet.macros.set("\\color", "\\textcolor");
    }
    try {
      var parse4 = this.parseExpression(false);
      this.expect("EOF");
      if (!this.settings.globalGroup) {
        this.gullet.endGroup();
      }
      return parse4;
    } finally {
      this.gullet.endGroups();
    }
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(tokens) {
    var oldToken = this.nextToken;
    this.consume();
    this.gullet.pushToken(new Token("}"));
    this.gullet.pushTokens(tokens);
    var parse4 = this.parseExpression(false);
    this.expect("}");
    this.nextToken = oldToken;
    return parse4;
  }
  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */
  parseExpression(breakOnInfix, breakOnTokenText) {
    var body = [];
    while (true) {
      if (this.mode === "math") {
        this.consumeSpaces();
      }
      var lex = this.fetch();
      if (_Parser.endOfExpression.indexOf(lex.text) !== -1) {
        break;
      }
      if (breakOnTokenText && lex.text === breakOnTokenText) {
        break;
      }
      if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
        break;
      }
      var atom = this.parseAtom(breakOnTokenText);
      if (!atom) {
        break;
      } else if (atom.type === "internal") {
        continue;
      }
      body.push(atom);
    }
    if (this.mode === "text") {
      this.formLigatures(body);
    }
    return this.handleInfixNodes(body);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(body) {
    var overIndex = -1;
    var funcName;
    for (var i16 = 0; i16 < body.length; i16++) {
      if (body[i16].type === "infix") {
        if (overIndex !== -1) {
          throw new ParseError("only one infix operator per group", body[i16].token);
        }
        overIndex = i16;
        funcName = body[i16].replaceWith;
      }
    }
    if (overIndex !== -1 && funcName) {
      var numerNode;
      var denomNode;
      var numerBody = body.slice(0, overIndex);
      var denomBody = body.slice(overIndex + 1);
      if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
        numerNode = numerBody[0];
      } else {
        numerNode = {
          type: "ordgroup",
          mode: this.mode,
          body: numerBody
        };
      }
      if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
        denomNode = denomBody[0];
      } else {
        denomNode = {
          type: "ordgroup",
          mode: this.mode,
          body: denomBody
        };
      }
      var node2;
      if (funcName === "\\\\abovefrac") {
        node2 = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
      } else {
        node2 = this.callFunction(funcName, [numerNode, denomNode], []);
      }
      return [node2];
    } else {
      return body;
    }
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(name2) {
    var symbolToken = this.fetch();
    var symbol = symbolToken.text;
    this.consume();
    this.consumeSpaces();
    var group;
    do {
      var _group;
      group = this.parseGroup(name2);
    } while (((_group = group) == null ? void 0 : _group.type) === "internal");
    if (!group) {
      throw new ParseError("Expected group after '" + symbol + "'", symbolToken);
    }
    return group;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(text10) {
    var textordArray = [];
    for (var i16 = 0; i16 < text10.length; i16++) {
      textordArray.push({
        type: "textord",
        mode: "text",
        text: text10[i16]
      });
    }
    var textNode = {
      type: "text",
      mode: this.mode,
      body: textordArray
    };
    var colorNode = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [textNode]
    };
    return colorNode;
  }
  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(breakOnTokenText) {
    var base = this.parseGroup("atom", breakOnTokenText);
    if ((base == null ? void 0 : base.type) === "internal") {
      return base;
    }
    if (this.mode === "text") {
      return base;
    }
    var superscript;
    var subscript;
    while (true) {
      this.consumeSpaces();
      var lex = this.fetch();
      if (lex.text === "\\limits" || lex.text === "\\nolimits") {
        if (base && base.type === "op") {
          var limits = lex.text === "\\limits";
          base.limits = limits;
          base.alwaysHandleSupSub = true;
        } else if (base && base.type === "operatorname") {
          if (base.alwaysHandleSupSub) {
            base.limits = lex.text === "\\limits";
          }
        } else {
          throw new ParseError("Limit controls must follow a math operator", lex);
        }
        this.consume();
      } else if (lex.text === "^") {
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }
        superscript = this.handleSupSubscript("superscript");
      } else if (lex.text === "_") {
        if (subscript) {
          throw new ParseError("Double subscript", lex);
        }
        subscript = this.handleSupSubscript("subscript");
      } else if (lex.text === "'") {
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }
        var prime = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        };
        var primes = [prime];
        this.consume();
        while (this.fetch().text === "'") {
          primes.push(prime);
          this.consume();
        }
        if (this.fetch().text === "^") {
          primes.push(this.handleSupSubscript("superscript"));
        }
        superscript = {
          type: "ordgroup",
          mode: this.mode,
          body: primes
        };
      } else if (uSubsAndSups[lex.text]) {
        var isSub = unicodeSubRegEx.test(lex.text);
        var subsupTokens = [];
        subsupTokens.push(new Token(uSubsAndSups[lex.text]));
        this.consume();
        while (true) {
          var token = this.fetch().text;
          if (!uSubsAndSups[token]) {
            break;
          }
          if (unicodeSubRegEx.test(token) !== isSub) {
            break;
          }
          subsupTokens.unshift(new Token(uSubsAndSups[token]));
          this.consume();
        }
        var body = this.subparse(subsupTokens);
        if (isSub) {
          subscript = {
            type: "ordgroup",
            mode: "math",
            body
          };
        } else {
          superscript = {
            type: "ordgroup",
            mode: "math",
            body
          };
        }
      } else {
        break;
      }
    }
    if (superscript || subscript) {
      return {
        type: "supsub",
        mode: this.mode,
        base,
        sup: superscript,
        sub: subscript
      };
    } else {
      return base;
    }
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(breakOnTokenText, name2) {
    var token = this.fetch();
    var func = token.text;
    var funcData = functions[func];
    if (!funcData) {
      return null;
    }
    this.consume();
    if (name2 && name2 !== "atom" && !funcData.allowedInArgument) {
      throw new ParseError("Got function '" + func + "' with no arguments" + (name2 ? " as " + name2 : ""), token);
    } else if (this.mode === "text" && !funcData.allowedInText) {
      throw new ParseError("Can't use function '" + func + "' in text mode", token);
    } else if (this.mode === "math" && funcData.allowedInMath === false) {
      throw new ParseError("Can't use function '" + func + "' in math mode", token);
    }
    var {
      args,
      optArgs
    } = this.parseArguments(func, funcData);
    return this.callFunction(func, args, optArgs, token, breakOnTokenText);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(name2, args, optArgs, token, breakOnTokenText) {
    var context = {
      funcName: name2,
      parser: this,
      token,
      breakOnTokenText
    };
    var func = functions[name2];
    if (func && func.handler) {
      return func.handler(context, args, optArgs);
    } else {
      throw new ParseError("No function handler for " + name2);
    }
  }
  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(func, funcData) {
    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
    if (totalArgs === 0) {
      return {
        args: [],
        optArgs: []
      };
    }
    var args = [];
    var optArgs = [];
    for (var i16 = 0; i16 < totalArgs; i16++) {
      var argType = funcData.argTypes && funcData.argTypes[i16];
      var isOptional = i16 < funcData.numOptionalArgs;
      if (funcData.primitive && argType == null || // \sqrt expands into primitive if optional argument doesn't exist
      funcData.type === "sqrt" && i16 === 1 && optArgs[0] == null) {
        argType = "primitive";
      }
      var arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
      if (isOptional) {
        optArgs.push(arg);
      } else if (arg != null) {
        args.push(arg);
      } else {
        throw new ParseError("Null argument, please report this as a bug");
      }
    }
    return {
      args,
      optArgs
    };
  }
  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(name2, type, optional) {
    switch (type) {
      case "color":
        return this.parseColorGroup(optional);
      case "size":
        return this.parseSizeGroup(optional);
      case "url":
        return this.parseUrlGroup(optional);
      case "math":
      case "text":
        return this.parseArgumentGroup(optional, type);
      case "hbox": {
        var group = this.parseArgumentGroup(optional, "text");
        return group != null ? {
          type: "styling",
          mode: group.mode,
          body: [group],
          style: "text"
          // simulate \textstyle
        } : null;
      }
      case "raw": {
        var token = this.parseStringGroup("raw", optional);
        return token != null ? {
          type: "raw",
          mode: "text",
          string: token.text
        } : null;
      }
      case "primitive": {
        if (optional) {
          throw new ParseError("A primitive argument cannot be optional");
        }
        var _group2 = this.parseGroup(name2);
        if (_group2 == null) {
          throw new ParseError("Expected group as " + name2, this.fetch());
        }
        return _group2;
      }
      case "original":
      case null:
      case void 0:
        return this.parseArgumentGroup(optional);
      default:
        throw new ParseError("Unknown group type as " + name2, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    while (this.fetch().text === " ") {
      this.consume();
    }
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(modeName, optional) {
    var argToken = this.gullet.scanArgument(optional);
    if (argToken == null) {
      return null;
    }
    var str = "";
    var nextToken;
    while ((nextToken = this.fetch()).text !== "EOF") {
      str += nextToken.text;
      this.consume();
    }
    this.consume();
    argToken.text = str;
    return argToken;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(regex, modeName) {
    var firstToken = this.fetch();
    var lastToken = firstToken;
    var str = "";
    var nextToken;
    while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
      lastToken = nextToken;
      str += lastToken.text;
      this.consume();
    }
    if (str === "") {
      throw new ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
    }
    return firstToken.range(lastToken, str);
  }
  /**
   * Parses a color description.
   */
  parseColorGroup(optional) {
    var res = this.parseStringGroup("color", optional);
    if (res == null) {
      return null;
    }
    var match = /^(#[a-f0-9]{3,4}|#[a-f0-9]{6}|#[a-f0-9]{8}|[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
    if (!match) {
      throw new ParseError("Invalid color: '" + res.text + "'", res);
    }
    var color2 = match[0];
    if (/^[0-9a-f]{6}$/i.test(color2)) {
      color2 = "#" + color2;
    }
    return {
      type: "color-token",
      mode: this.mode,
      color: color2
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(optional) {
    var res;
    var isBlank = false;
    this.gullet.consumeSpaces();
    if (!optional && this.gullet.future().text !== "{") {
      res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
    } else {
      res = this.parseStringGroup("size", optional);
    }
    if (!res) {
      return null;
    }
    if (!optional && res.text.length === 0) {
      res.text = "0pt";
      isBlank = true;
    }
    var match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
    if (!match) {
      throw new ParseError("Invalid size: '" + res.text + "'", res);
    }
    var data = {
      number: +(match[1] + match[2]),
      // sign + magnitude, cast to number
      unit: match[3]
    };
    if (!validUnit(data)) {
      throw new ParseError("Invalid unit: '" + data.unit + "'", res);
    }
    return {
      type: "size",
      mode: this.mode,
      value: data,
      isBlank
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(optional) {
    this.gullet.lexer.setCatcode("%", 13);
    this.gullet.lexer.setCatcode("~", 12);
    var res = this.parseStringGroup("url", optional);
    this.gullet.lexer.setCatcode("%", 14);
    this.gullet.lexer.setCatcode("~", 13);
    if (res == null) {
      return null;
    }
    var url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
    return {
      type: "url",
      mode: this.mode,
      url
    };
  }
  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(optional, mode) {
    var argToken = this.gullet.scanArgument(optional);
    if (argToken == null) {
      return null;
    }
    var outerMode = this.mode;
    if (mode) {
      this.switchMode(mode);
    }
    this.gullet.beginGroup();
    var expression = this.parseExpression(false, "EOF");
    this.expect("EOF");
    this.gullet.endGroup();
    var result = {
      type: "ordgroup",
      mode: this.mode,
      loc: argToken.loc,
      body: expression
    };
    if (mode) {
      this.switchMode(outerMode);
    }
    return result;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(name2, breakOnTokenText) {
    var firstToken = this.fetch();
    var text10 = firstToken.text;
    var result;
    if (text10 === "{" || text10 === "\\begingroup") {
      this.consume();
      var groupEnd = text10 === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup();
      var expression = this.parseExpression(false, groupEnd);
      var lastToken = this.fetch();
      this.expect(groupEnd);
      this.gullet.endGroup();
      result = {
        type: "ordgroup",
        mode: this.mode,
        loc: SourceLocation.range(firstToken, lastToken),
        body: expression,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: text10 === "\\begingroup" || void 0
      };
    } else {
      result = this.parseFunction(breakOnTokenText, name2) || this.parseSymbol();
      if (result == null && text10[0] === "\\" && !implicitCommands.hasOwnProperty(text10)) {
        if (this.settings.throwOnError) {
          throw new ParseError("Undefined control sequence: " + text10, firstToken);
        }
        result = this.formatUnsupportedCmd(text10);
        this.consume();
      }
    }
    return result;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(group) {
    var n17 = group.length - 1;
    for (var i16 = 0; i16 < n17; ++i16) {
      var a28 = group[i16];
      var v11 = a28.text;
      if (v11 === "-" && group[i16 + 1].text === "-") {
        if (i16 + 1 < n17 && group[i16 + 2].text === "-") {
          group.splice(i16, 3, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a28, group[i16 + 2]),
            text: "---"
          });
          n17 -= 2;
        } else {
          group.splice(i16, 2, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a28, group[i16 + 1]),
            text: "--"
          });
          n17 -= 1;
        }
      }
      if ((v11 === "'" || v11 === "`") && group[i16 + 1].text === v11) {
        group.splice(i16, 2, {
          type: "textord",
          mode: "text",
          loc: SourceLocation.range(a28, group[i16 + 1]),
          text: v11 + v11
        });
        n17 -= 1;
      }
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    var nucleus = this.fetch();
    var text10 = nucleus.text;
    if (/^\\verb[^a-zA-Z]/.test(text10)) {
      this.consume();
      var arg = text10.slice(5);
      var star = arg.charAt(0) === "*";
      if (star) {
        arg = arg.slice(1);
      }
      if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
        throw new ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
      }
      arg = arg.slice(1, -1);
      return {
        type: "verb",
        mode: "text",
        body: arg,
        star
      };
    }
    if (unicodeSymbols.hasOwnProperty(text10[0]) && !symbols[this.mode][text10[0]]) {
      if (this.settings.strict && this.mode === "math") {
        this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text10[0] + '" used in math mode', nucleus);
      }
      text10 = unicodeSymbols[text10[0]] + text10.slice(1);
    }
    var match = combiningDiacriticalMarksEndRegex.exec(text10);
    if (match) {
      text10 = text10.substring(0, match.index);
      if (text10 === "i") {
        text10 = "";
      } else if (text10 === "j") {
        text10 = "";
      }
    }
    var symbol;
    if (symbols[this.mode][text10]) {
      if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text10) >= 0) {
        this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text10[0] + '" used in math mode', nucleus);
      }
      var group = symbols[this.mode][text10].group;
      var loc = SourceLocation.range(nucleus);
      var s21;
      if (ATOMS.hasOwnProperty(group)) {
        var family = group;
        s21 = {
          type: "atom",
          mode: this.mode,
          family,
          loc,
          text: text10
        };
      } else {
        s21 = {
          type: group,
          mode: this.mode,
          loc,
          text: text10
        };
      }
      symbol = s21;
    } else if (text10.charCodeAt(0) >= 128) {
      if (this.settings.strict) {
        if (!supportedCodepoint(text10.charCodeAt(0))) {
          this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text10[0] + '"' + (" (" + text10.charCodeAt(0) + ")"), nucleus);
        } else if (this.mode === "math") {
          this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text10[0] + '" used in math mode', nucleus);
        }
      }
      symbol = {
        type: "textord",
        mode: "text",
        loc: SourceLocation.range(nucleus),
        text: text10
      };
    } else {
      return null;
    }
    this.consume();
    if (match) {
      for (var i16 = 0; i16 < match[0].length; i16++) {
        var accent2 = match[0][i16];
        if (!unicodeAccents[accent2]) {
          throw new ParseError("Unknown accent ' " + accent2 + "'", nucleus);
        }
        var command = unicodeAccents[accent2][this.mode] || unicodeAccents[accent2].text;
        if (!command) {
          throw new ParseError("Accent " + accent2 + " unsupported in " + this.mode + " mode", nucleus);
        }
        symbol = {
          type: "accent",
          mode: this.mode,
          loc: SourceLocation.range(nucleus),
          label: command,
          isStretchy: false,
          isShifty: true,
          // $FlowFixMe
          base: symbol
        };
      }
    }
    return symbol;
  }
};
Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
var parseTree = function parseTree2(toParse, settings) {
  if (!(typeof toParse === "string" || toParse instanceof String)) {
    throw new TypeError("KaTeX can only parse string typed expression");
  }
  var parser = new Parser(toParse, settings);
  delete parser.gullet.macros.current["\\df@tag"];
  var tree = parser.parse();
  delete parser.gullet.macros.current["\\current@color"];
  delete parser.gullet.macros.current["\\color"];
  if (parser.gullet.macros.get("\\df@tag")) {
    if (!settings.displayMode) {
      throw new ParseError("\\tag works only in display equations");
    }
    tree = [{
      type: "tag",
      mode: "text",
      body: tree,
      tag: parser.subparse([new Token("\\df@tag")])
    }];
  }
  return tree;
};
var render = function render2(expression, baseNode, options) {
  baseNode.textContent = "";
  var node2 = renderToDomTree(expression, options).toNode();
  baseNode.appendChild(node2);
};
if (typeof document !== "undefined") {
  if (document.compatMode !== "CSS1Compat") {
    typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
    render = function render3() {
      throw new ParseError("KaTeX doesn't work in quirks mode.");
    };
  }
}
var renderToString = function renderToString2(expression, options) {
  var markup = renderToDomTree(expression, options).toMarkup();
  return markup;
};
var generateParseTree = function generateParseTree2(expression, options) {
  var settings = new Settings(options);
  return parseTree(expression, settings);
};
var renderError = function renderError2(error2, expression, options) {
  if (options.throwOnError || !(error2 instanceof ParseError)) {
    throw error2;
  }
  var node2 = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
  node2.setAttribute("title", error2.toString());
  node2.setAttribute("style", "color:" + options.errorColor);
  return node2;
};
var renderToDomTree = function renderToDomTree2(expression, options) {
  var settings = new Settings(options);
  try {
    var tree = parseTree(expression, settings);
    return buildTree(tree, expression, settings);
  } catch (error2) {
    return renderError(error2, expression, settings);
  }
};
var renderToHTMLTree = function renderToHTMLTree2(expression, options) {
  var settings = new Settings(options);
  try {
    var tree = parseTree(expression, settings);
    return buildHTMLTree(tree, expression, settings);
  } catch (error2) {
    return renderError(error2, expression, settings);
  }
};
var version = "0.16.25";
var __domTree = {
  Span,
  Anchor,
  SymbolNode,
  SvgNode,
  PathNode,
  LineNode
};
var katex = {
  /**
   * Current KaTeX version
   */
  version,
  /**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */
  render,
  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString,
  /**
   * KaTeX error, usually during parsing.
   */
  ParseError,
  /**
   * The schema of Settings
   */
  SETTINGS_SCHEMA,
  /**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: generateParseTree,
  /**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToDomTree: renderToDomTree,
  /**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToHTMLTree: renderToHTMLTree,
  /**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */
  __setFontMetrics: setFontMetrics,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: defineSymbol,
  /**
   * adds a new function to builtin function list,
   * which directly produce parse tree elements
   * and have their own html/mathml builders
   */
  __defineFunction: defineFunction,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: defineMacro,
  /**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: These methods are not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __domTree
};

// node_modules/micromark-extension-math/dev/lib/html.js
var renderToString3 = katex.renderToString;

// node_modules/remark-math/lib/index.js
var emptyOptions5 = {};
function remarkMath(options) {
  const self2 = (
    /** @type {Processor} */
    this
  );
  const settings = options || emptyOptions5;
  const data = self2.data();
  const micromarkExtensions = data.micromarkExtensions || (data.micromarkExtensions = []);
  const fromMarkdownExtensions = data.fromMarkdownExtensions || (data.fromMarkdownExtensions = []);
  const toMarkdownExtensions = data.toMarkdownExtensions || (data.toMarkdownExtensions = []);
  micromarkExtensions.push(math(settings));
  fromMarkdownExtensions.push(mathFromMarkdown());
  toMarkdownExtensions.push(mathToMarkdown(settings));
}

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/schema.js
var Schema2 = class {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(property, normal, space) {
    this.normal = normal;
    this.property = property;
    if (space) {
      this.space = space;
    }
  }
};
Schema2.prototype.normal = {};
Schema2.prototype.property = {};
Schema2.prototype.space = void 0;

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/merge.js
function merge2(definitions, space) {
  const property = {};
  const normal = {};
  for (const definition3 of definitions) {
    Object.assign(property, definition3.property);
    Object.assign(normal, definition3.normal);
  }
  return new Schema2(property, normal, space);
}

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/normalize.js
function normalize3(value) {
  return value.toLowerCase();
}

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/info.js
var Info2 = class {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(property, attribute) {
    this.attribute = attribute;
    this.property = property;
  }
};
Info2.prototype.attribute = "";
Info2.prototype.booleanish = false;
Info2.prototype.boolean = false;
Info2.prototype.commaOrSpaceSeparated = false;
Info2.prototype.commaSeparated = false;
Info2.prototype.defined = false;
Info2.prototype.mustUseProperty = false;
Info2.prototype.number = false;
Info2.prototype.overloadedBoolean = false;
Info2.prototype.property = "";
Info2.prototype.spaceSeparated = false;
Info2.prototype.space = void 0;

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/types.js
var types_exports2 = {};
__export(types_exports2, {
  boolean: () => boolean2,
  booleanish: () => booleanish2,
  commaOrSpaceSeparated: () => commaOrSpaceSeparated2,
  commaSeparated: () => commaSeparated2,
  number: () => number2,
  overloadedBoolean: () => overloadedBoolean2,
  spaceSeparated: () => spaceSeparated2
});
var powers2 = 0;
var boolean2 = increment2();
var booleanish2 = increment2();
var overloadedBoolean2 = increment2();
var number2 = increment2();
var spaceSeparated2 = increment2();
var commaSeparated2 = increment2();
var commaOrSpaceSeparated2 = increment2();
function increment2() {
  return 2 ** ++powers2;
}

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/defined-info.js
var checks2 = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(types_exports2)
);
var DefinedInfo2 = class extends Info2 {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(property, attribute, mask, space) {
    let index4 = -1;
    super(property, attribute);
    mark2(this, "space", space);
    if (typeof mask === "number") {
      while (++index4 < checks2.length) {
        const check = checks2[index4];
        mark2(this, checks2[index4], (mask & types_exports2[check]) === types_exports2[check]);
      }
    }
  }
};
DefinedInfo2.prototype.defined = true;
function mark2(values2, key, value) {
  if (value) {
    values2[key] = value;
  }
}

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/create.js
function create2(definition3) {
  const properties = {};
  const normals = {};
  for (const [property, value] of Object.entries(definition3.properties)) {
    const info = new DefinedInfo2(
      property,
      definition3.transform(definition3.attributes || {}, property),
      value,
      definition3.space
    );
    if (definition3.mustUseProperty && definition3.mustUseProperty.includes(property)) {
      info.mustUseProperty = true;
    }
    properties[property] = info;
    normals[normalize3(property)] = property;
    normals[normalize3(info.attribute)] = property;
  }
  return new Schema2(properties, normals, definition3.space);
}

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/aria.js
var aria2 = create2({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish2,
    ariaAutoComplete: null,
    ariaBusy: booleanish2,
    ariaChecked: booleanish2,
    ariaColCount: number2,
    ariaColIndex: number2,
    ariaColSpan: number2,
    ariaControls: spaceSeparated2,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated2,
    ariaDetails: null,
    ariaDisabled: booleanish2,
    ariaDropEffect: spaceSeparated2,
    ariaErrorMessage: null,
    ariaExpanded: booleanish2,
    ariaFlowTo: spaceSeparated2,
    ariaGrabbed: booleanish2,
    ariaHasPopup: null,
    ariaHidden: booleanish2,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated2,
    ariaLevel: number2,
    ariaLive: null,
    ariaModal: booleanish2,
    ariaMultiLine: booleanish2,
    ariaMultiSelectable: booleanish2,
    ariaOrientation: null,
    ariaOwns: spaceSeparated2,
    ariaPlaceholder: null,
    ariaPosInSet: number2,
    ariaPressed: booleanish2,
    ariaReadOnly: booleanish2,
    ariaRelevant: null,
    ariaRequired: booleanish2,
    ariaRoleDescription: spaceSeparated2,
    ariaRowCount: number2,
    ariaRowIndex: number2,
    ariaRowSpan: number2,
    ariaSelected: booleanish2,
    ariaSetSize: number2,
    ariaSort: null,
    ariaValueMax: number2,
    ariaValueMin: number2,
    ariaValueNow: number2,
    ariaValueText: null,
    role: null
  },
  transform(_10, property) {
    return property === "role" ? property : "aria-" + property.slice(4).toLowerCase();
  }
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/case-sensitive-transform.js
function caseSensitiveTransform2(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/case-insensitive-transform.js
function caseInsensitiveTransform2(attributes, property) {
  return caseSensitiveTransform2(attributes, property.toLowerCase());
}

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/html.js
var html6 = create2({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated2,
    acceptCharset: spaceSeparated2,
    accessKey: spaceSeparated2,
    action: null,
    allow: null,
    allowFullScreen: boolean2,
    allowPaymentRequest: boolean2,
    allowUserMedia: boolean2,
    alt: null,
    as: null,
    async: boolean2,
    autoCapitalize: null,
    autoComplete: spaceSeparated2,
    autoFocus: boolean2,
    autoPlay: boolean2,
    blocking: spaceSeparated2,
    capture: null,
    charSet: null,
    checked: boolean2,
    cite: null,
    className: spaceSeparated2,
    cols: number2,
    colSpan: null,
    content: null,
    contentEditable: booleanish2,
    controls: boolean2,
    controlsList: spaceSeparated2,
    coords: number2 | commaSeparated2,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean2,
    defer: boolean2,
    dir: null,
    dirName: null,
    disabled: boolean2,
    download: overloadedBoolean2,
    draggable: booleanish2,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean2,
    formTarget: null,
    headers: spaceSeparated2,
    height: number2,
    hidden: overloadedBoolean2,
    high: number2,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated2,
    httpEquiv: spaceSeparated2,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean2,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean2,
    itemId: null,
    itemProp: spaceSeparated2,
    itemRef: spaceSeparated2,
    itemScope: boolean2,
    itemType: spaceSeparated2,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean2,
    low: number2,
    manifest: null,
    max: null,
    maxLength: number2,
    media: null,
    method: null,
    min: null,
    minLength: number2,
    multiple: boolean2,
    muted: boolean2,
    name: null,
    nonce: null,
    noModule: boolean2,
    noValidate: boolean2,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean2,
    optimum: number2,
    pattern: null,
    ping: spaceSeparated2,
    placeholder: null,
    playsInline: boolean2,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean2,
    referrerPolicy: null,
    rel: spaceSeparated2,
    required: boolean2,
    reversed: boolean2,
    rows: number2,
    rowSpan: number2,
    sandbox: spaceSeparated2,
    scope: null,
    scoped: boolean2,
    seamless: boolean2,
    selected: boolean2,
    shadowRootClonable: boolean2,
    shadowRootDelegatesFocus: boolean2,
    shadowRootMode: null,
    shape: null,
    size: number2,
    sizes: null,
    slot: null,
    span: number2,
    spellCheck: booleanish2,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number2,
    step: null,
    style: null,
    tabIndex: number2,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean2,
    useMap: null,
    value: booleanish2,
    width: number2,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated2,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number2,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number2,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean2,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean2,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number2,
    // `<img>` and `<object>`
    leftMargin: number2,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number2,
    // `<body>`
    marginWidth: number2,
    // `<body>`
    noResize: boolean2,
    // `<frame>`
    noHref: boolean2,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean2,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean2,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number2,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish2,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number2,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number2,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean2,
    disableRemotePlayback: boolean2,
    prefix: null,
    property: null,
    results: number2,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: caseInsensitiveTransform2
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/svg.js
var svg4 = create2({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: commaOrSpaceSeparated2,
    accentHeight: number2,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number2,
    amplitude: number2,
    arabicForm: null,
    ascent: number2,
    attributeName: null,
    attributeType: null,
    azimuth: number2,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number2,
    by: null,
    calcMode: null,
    capHeight: number2,
    className: spaceSeparated2,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number2,
    diffuseConstant: number2,
    direction: null,
    display: null,
    dur: null,
    divisor: number2,
    dominantBaseline: null,
    download: boolean2,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number2,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number2,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number2,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated2,
    g2: commaSeparated2,
    glyphName: commaSeparated2,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number2,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number2,
    horizOriginX: number2,
    horizOriginY: number2,
    id: null,
    ideographic: number2,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number2,
    k: number2,
    k1: number2,
    k2: number2,
    k3: number2,
    k4: number2,
    kernelMatrix: commaOrSpaceSeparated2,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number2,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number2,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number2,
    overlineThickness: number2,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number2,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated2,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number2,
    pointsAtY: number2,
    pointsAtZ: number2,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated2,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated2,
    rev: commaOrSpaceSeparated2,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated2,
    requiredFeatures: commaOrSpaceSeparated2,
    requiredFonts: commaOrSpaceSeparated2,
    requiredFormats: commaOrSpaceSeparated2,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number2,
    specularExponent: number2,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number2,
    strikethroughThickness: number2,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated2,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number2,
    strokeOpacity: number2,
    strokeWidth: null,
    style: null,
    surfaceScale: number2,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated2,
    tabIndex: number2,
    tableValues: null,
    target: null,
    targetX: number2,
    targetY: number2,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated2,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number2,
    underlineThickness: number2,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number2,
    values: null,
    vAlphabetic: number2,
    vMathematical: number2,
    vectorEffect: null,
    vHanging: number2,
    vIdeographic: number2,
    version: null,
    vertAdvY: number2,
    vertOriginX: number2,
    vertOriginY: number2,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number2,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: caseSensitiveTransform2
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/xlink.js
var xlink2 = create2({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(_10, property) {
    return "xlink:" + property.slice(5).toLowerCase();
  }
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/xmlns.js
var xmlns2 = create2({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: caseInsensitiveTransform2
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/xml.js
var xml2 = create2({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(_10, property) {
    return "xml:" + property.slice(3).toLowerCase();
  }
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/find.js
var cap3 = /[A-Z]/g;
var dash2 = /-[a-z]/g;
var valid2 = /^data[-\w.:]+$/i;
function find3(schema, value) {
  const normal = normalize3(value);
  let property = value;
  let Type = Info2;
  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === "data" && valid2.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace(dash2, camelcase2);
      property = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!dash2.test(rest)) {
        let dashes = rest.replace(cap3, kebab2);
        if (dashes.charAt(0) !== "-") {
          dashes = "-" + dashes;
        }
        value = "data" + dashes;
      }
    }
    Type = DefinedInfo2;
  }
  return new Type(property, value);
}
function kebab2($0) {
  return "-" + $0.toLowerCase();
}
function camelcase2($0) {
  return $0.charAt(1).toUpperCase();
}

// node_modules/hast-util-from-parse5/node_modules/property-information/index.js
var html7 = merge2([aria2, html6, xlink2, xmlns2, xml2], "html");
var svg5 = merge2([aria2, svg4, xlink2, xmlns2, xml2], "svg");

// node_modules/hast-util-from-parse5/node_modules/hast-util-parse-selector/lib/index.js
var search2 = /[#.]/g;
function parseSelector(selector, defaultTagName) {
  const value = selector || "";
  const props = {};
  let start2 = 0;
  let previous4;
  let tagName;
  while (start2 < value.length) {
    search2.lastIndex = start2;
    const match = search2.exec(value);
    const subvalue = value.slice(start2, match ? match.index : value.length);
    if (subvalue) {
      if (!previous4) {
        tagName = subvalue;
      } else if (previous4 === "#") {
        props.id = subvalue;
      } else if (Array.isArray(props.className)) {
        props.className.push(subvalue);
      } else {
        props.className = [subvalue];
      }
      start2 += subvalue.length;
    }
    if (match) {
      previous4 = match[0];
      start2++;
    }
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: tagName || defaultTagName || "div",
    properties: props,
    children: []
  };
}

// node_modules/hast-util-from-parse5/node_modules/hastscript/lib/create-h.js
function createH(schema, defaultTagName, caseSensitive) {
  const adjust = caseSensitive ? createAdjustMap(caseSensitive) : void 0;
  function h16(selector, properties, ...children) {
    let node2;
    if (selector === null || selector === void 0) {
      node2 = { type: "root", children: [] };
      const child = (
        /** @type {Child} */
        properties
      );
      children.unshift(child);
    } else {
      node2 = parseSelector(selector, defaultTagName);
      const lower = node2.tagName.toLowerCase();
      const adjusted = adjust ? adjust.get(lower) : void 0;
      node2.tagName = adjusted || lower;
      if (isChild(properties)) {
        children.unshift(properties);
      } else {
        for (const [key, value] of Object.entries(properties)) {
          addProperty(schema, node2.properties, key, value);
        }
      }
    }
    for (const child of children) {
      addChild(node2.children, child);
    }
    if (node2.type === "element" && node2.tagName === "template") {
      node2.content = { type: "root", children: node2.children };
      node2.children = [];
    }
    return node2;
  }
  return h16;
}
function isChild(value) {
  if (value === null || typeof value !== "object" || Array.isArray(value)) {
    return true;
  }
  if (typeof value.type !== "string") return false;
  const record = (
    /** @type {Record<string, unknown>} */
    value
  );
  const keys2 = Object.keys(value);
  for (const key of keys2) {
    const value2 = record[key];
    if (value2 && typeof value2 === "object") {
      if (!Array.isArray(value2)) return true;
      const list4 = (
        /** @type {ReadonlyArray<unknown>} */
        value2
      );
      for (const item of list4) {
        if (typeof item !== "number" && typeof item !== "string") {
          return true;
        }
      }
    }
  }
  if ("children" in value && Array.isArray(value.children)) {
    return true;
  }
  return false;
}
function addProperty(schema, properties, key, value) {
  const info = find3(schema, key);
  let result;
  if (value === null || value === void 0) return;
  if (typeof value === "number") {
    if (Number.isNaN(value)) return;
    result = value;
  } else if (typeof value === "boolean") {
    result = value;
  } else if (typeof value === "string") {
    if (info.spaceSeparated) {
      result = parse(value);
    } else if (info.commaSeparated) {
      result = parse2(value);
    } else if (info.commaOrSpaceSeparated) {
      result = parse(parse2(value).join(" "));
    } else {
      result = parsePrimitive(info, info.property, value);
    }
  } else if (Array.isArray(value)) {
    result = [...value];
  } else {
    result = info.property === "style" ? style(value) : String(value);
  }
  if (Array.isArray(result)) {
    const finalResult = [];
    for (const item of result) {
      finalResult.push(
        /** @type {number | string} */
        parsePrimitive(info, info.property, item)
      );
    }
    result = finalResult;
  }
  if (info.property === "className" && Array.isArray(properties.className)) {
    result = properties.className.concat(
      /** @type {Array<number | string> | number | string} */
      result
    );
  }
  properties[info.property] = result;
}
function addChild(nodes, value) {
  if (value === null || value === void 0) {
  } else if (typeof value === "number" || typeof value === "string") {
    nodes.push({ type: "text", value: String(value) });
  } else if (Array.isArray(value)) {
    for (const child of value) {
      addChild(nodes, child);
    }
  } else if (typeof value === "object" && "type" in value) {
    if (value.type === "root") {
      addChild(nodes, value.children);
    } else {
      nodes.push(value);
    }
  } else {
    throw new Error("Expected node, nodes, or string, got `" + value + "`");
  }
}
function parsePrimitive(info, name2, value) {
  if (typeof value === "string") {
    if (info.number && value && !Number.isNaN(Number(value))) {
      return Number(value);
    }
    if ((info.boolean || info.overloadedBoolean) && (value === "" || normalize3(value) === normalize3(name2))) {
      return true;
    }
  }
  return value;
}
function style(styles2) {
  const result = [];
  for (const [key, value] of Object.entries(styles2)) {
    result.push([key, value].join(": "));
  }
  return result.join("; ");
}
function createAdjustMap(values2) {
  const result = /* @__PURE__ */ new Map();
  for (const value of values2) {
    result.set(value.toLowerCase(), value);
  }
  return result;
}

// node_modules/hast-util-from-parse5/node_modules/hastscript/lib/svg-case-sensitive-tag-names.js
var svgCaseSensitiveTagNames = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
];

// node_modules/hast-util-from-parse5/node_modules/hastscript/lib/index.js
var h15 = createH(html7, "div");
var s20 = createH(svg5, "g", svgCaseSensitiveTagNames);

// node_modules/vfile-location/lib/index.js
function location2(file) {
  const value = String(file);
  const indices = [];
  return { toOffset, toPoint };
  function toPoint(offset4) {
    if (typeof offset4 === "number" && offset4 > -1 && offset4 <= value.length) {
      let index4 = 0;
      while (true) {
        let end = indices[index4];
        if (end === void 0) {
          const eol = next(value, indices[index4 - 1]);
          end = eol === -1 ? value.length + 1 : eol + 1;
          indices[index4] = end;
        }
        if (end > offset4) {
          return {
            line: index4 + 1,
            column: offset4 - (index4 > 0 ? indices[index4 - 1] : 0) + 1,
            offset: offset4
          };
        }
        index4++;
      }
    }
  }
  function toOffset(point5) {
    if (point5 && typeof point5.line === "number" && typeof point5.column === "number" && !Number.isNaN(point5.line) && !Number.isNaN(point5.column)) {
      while (indices.length < point5.line) {
        const from = indices[indices.length - 1];
        const eol = next(value, from);
        const end = eol === -1 ? value.length + 1 : eol + 1;
        if (from === end) break;
        indices.push(end);
      }
      const offset4 = (point5.line > 1 ? indices[point5.line - 2] : 0) + point5.column - 1;
      if (offset4 < indices[point5.line - 1]) return offset4;
    }
  }
}
function next(value, from) {
  const cr = value.indexOf("\r", from);
  const lf = value.indexOf("\n", from);
  if (lf === -1) return cr;
  if (cr === -1 || cr + 1 === lf) return lf;
  return cr < lf ? cr : lf;
}

// node_modules/web-namespaces/index.js
var webNamespaces = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/hast-util-from-parse5/lib/index.js
var own8 = {}.hasOwnProperty;
var proto = Object.prototype;
function fromParse5(tree, options) {
  const settings = options || {};
  return one3(
    {
      file: settings.file || void 0,
      location: false,
      schema: settings.space === "svg" ? svg5 : html7,
      verbose: settings.verbose || false
    },
    tree
  );
}
function one3(state, node2) {
  let result;
  switch (node2.nodeName) {
    case "#comment": {
      const reference = (
        /** @type {DefaultTreeAdapterMap['commentNode']} */
        node2
      );
      result = { type: "comment", value: reference.data };
      patch2(state, reference, result);
      return result;
    }
    case "#document":
    case "#document-fragment": {
      const reference = (
        /** @type {DefaultTreeAdapterMap['document'] | DefaultTreeAdapterMap['documentFragment']} */
        node2
      );
      const quirksMode = "mode" in reference ? reference.mode === "quirks" || reference.mode === "limited-quirks" : false;
      result = {
        type: "root",
        children: all2(state, node2.childNodes),
        data: { quirksMode }
      };
      if (state.file && state.location) {
        const document4 = String(state.file);
        const loc = location2(document4);
        const start2 = loc.toPoint(0);
        const end = loc.toPoint(document4.length);
        ok(start2, "expected `start`");
        ok(end, "expected `end`");
        result.position = { start: start2, end };
      }
      return result;
    }
    case "#documentType": {
      const reference = (
        /** @type {DefaultTreeAdapterMap['documentType']} */
        node2
      );
      result = { type: "doctype" };
      patch2(state, reference, result);
      return result;
    }
    case "#text": {
      const reference = (
        /** @type {DefaultTreeAdapterMap['textNode']} */
        node2
      );
      result = { type: "text", value: reference.value };
      patch2(state, reference, result);
      return result;
    }
    default: {
      const reference = (
        /** @type {DefaultTreeAdapterMap['element']} */
        node2
      );
      result = element2(state, reference);
      return result;
    }
  }
}
function all2(state, nodes) {
  let index4 = -1;
  const results = [];
  while (++index4 < nodes.length) {
    const result = (
      /** @type {RootContent} */
      one3(state, nodes[index4])
    );
    results.push(result);
  }
  return results;
}
function element2(state, node2) {
  const schema = state.schema;
  state.schema = node2.namespaceURI === webNamespaces.svg ? svg5 : html7;
  let index4 = -1;
  const properties = {};
  while (++index4 < node2.attrs.length) {
    const attribute = node2.attrs[index4];
    const name2 = (attribute.prefix ? attribute.prefix + ":" : "") + attribute.name;
    if (!own8.call(proto, name2)) {
      properties[name2] = attribute.value;
    }
  }
  const x10 = state.schema.space === "svg" ? s20 : h15;
  const result = x10(node2.tagName, properties, all2(state, node2.childNodes));
  patch2(state, node2, result);
  if (result.tagName === "template") {
    const reference = (
      /** @type {DefaultTreeAdapterMap['template']} */
      node2
    );
    const pos = reference.sourceCodeLocation;
    const startTag2 = pos && pos.startTag && position3(pos.startTag);
    const endTag2 = pos && pos.endTag && position3(pos.endTag);
    const content3 = (
      /** @type {Root} */
      one3(state, reference.content)
    );
    if (startTag2 && endTag2 && state.file) {
      content3.position = { start: startTag2.end, end: endTag2.start };
    }
    result.content = content3;
  }
  state.schema = schema;
  return result;
}
function patch2(state, from, to) {
  if ("sourceCodeLocation" in from && from.sourceCodeLocation && state.file) {
    const position4 = createLocation(state, to, from.sourceCodeLocation);
    if (position4) {
      state.location = true;
      to.position = position4;
    }
  }
}
function createLocation(state, node2, location3) {
  const result = position3(location3);
  if (node2.type === "element") {
    const tail = node2.children[node2.children.length - 1];
    if (result && !location3.endTag && tail && tail.position && tail.position.end) {
      result.end = Object.assign({}, tail.position.end);
    }
    if (state.verbose) {
      const properties = {};
      let key;
      if (location3.attrs) {
        for (key in location3.attrs) {
          if (own8.call(location3.attrs, key)) {
            properties[find3(state.schema, key).property] = position3(
              location3.attrs[key]
            );
          }
        }
      }
      ok(location3.startTag, "a start tag should exist");
      const opening = position3(location3.startTag);
      const closing = location3.endTag ? position3(location3.endTag) : void 0;
      const data = { opening };
      if (closing) data.closing = closing;
      data.properties = properties;
      node2.data = { position: data };
    }
  }
  return result;
}
function position3(loc) {
  const start2 = point4({
    line: loc.startLine,
    column: loc.startCol,
    offset: loc.startOffset
  });
  const end = point4({
    line: loc.endLine,
    column: loc.endCol,
    offset: loc.endOffset
  });
  return start2 || end ? { start: start2, end } : void 0;
}
function point4(point5) {
  return point5.line && point5.column ? point5 : void 0;
}

// node_modules/hast-util-to-parse5/lib/index.js
var emptyOptions6 = {};
var own9 = {}.hasOwnProperty;
var one4 = zwitch("type", { handlers: { root: root4, element: element3, text: text8, comment, doctype } });
function toParse5(tree, options) {
  const settings = options || emptyOptions6;
  const space = settings.space;
  return one4(tree, space === "svg" ? svg : html);
}
function root4(node2, schema) {
  const result = {
    nodeName: "#document",
    // @ts-expect-error: `parse5` uses enums, which are actually strings.
    mode: (node2.data || {}).quirksMode ? "quirks" : "no-quirks",
    childNodes: []
  };
  result.childNodes = all3(node2.children, result, schema);
  patch3(node2, result);
  return result;
}
function fragment(node2, schema) {
  const result = { nodeName: "#document-fragment", childNodes: [] };
  result.childNodes = all3(node2.children, result, schema);
  patch3(node2, result);
  return result;
}
function doctype(node2) {
  const result = {
    nodeName: "#documentType",
    name: "html",
    publicId: "",
    systemId: "",
    parentNode: null
  };
  patch3(node2, result);
  return result;
}
function text8(node2) {
  const result = {
    nodeName: "#text",
    value: node2.value,
    parentNode: null
  };
  patch3(node2, result);
  return result;
}
function comment(node2) {
  const result = {
    nodeName: "#comment",
    data: node2.value,
    parentNode: null
  };
  patch3(node2, result);
  return result;
}
function element3(node2, schema) {
  const parentSchema = schema;
  let currentSchema = parentSchema;
  if (node2.type === "element" && node2.tagName.toLowerCase() === "svg" && parentSchema.space === "html") {
    currentSchema = svg;
  }
  const attrs = [];
  let prop;
  if (node2.properties) {
    for (prop in node2.properties) {
      if (prop !== "children" && own9.call(node2.properties, prop)) {
        const result2 = createProperty2(
          currentSchema,
          prop,
          node2.properties[prop]
        );
        if (result2) {
          attrs.push(result2);
        }
      }
    }
  }
  const space = currentSchema.space;
  ok(space);
  const result = {
    nodeName: node2.tagName,
    tagName: node2.tagName,
    attrs,
    // @ts-expect-error: `parse5` types are wrong.
    namespaceURI: webNamespaces[space],
    childNodes: [],
    parentNode: null
  };
  result.childNodes = all3(node2.children, result, currentSchema);
  patch3(node2, result);
  if (node2.tagName === "template" && node2.content) {
    result.content = fragment(node2.content, currentSchema);
  }
  return result;
}
function createProperty2(schema, prop, value) {
  const info = find(schema, prop);
  if (value === false || value === null || value === void 0 || typeof value === "number" && Number.isNaN(value) || !value && info.boolean) {
    return;
  }
  if (Array.isArray(value)) {
    value = info.commaSeparated ? stringify2(value) : stringify(value);
  }
  const attribute = {
    name: info.attribute,
    value: value === true ? "" : String(value)
  };
  if (info.space && info.space !== "html" && info.space !== "svg") {
    const index4 = attribute.name.indexOf(":");
    if (index4 < 0) {
      attribute.prefix = "";
    } else {
      attribute.name = attribute.name.slice(index4 + 1);
      attribute.prefix = info.attribute.slice(0, index4);
    }
    attribute.namespace = webNamespaces[info.space];
  }
  return attribute;
}
function all3(children, parentNode, schema) {
  let index4 = -1;
  const results = [];
  if (children) {
    while (++index4 < children.length) {
      const child = one4(children[index4], schema);
      child.parentNode = parentNode;
      results.push(child);
    }
  }
  return results;
}
function patch3(from, to) {
  const position4 = from.position;
  if (position4 && position4.start && position4.end) {
    ok(typeof position4.start.offset === "number");
    ok(typeof position4.end.offset === "number");
    to.sourceCodeLocation = {
      startLine: position4.start.line,
      startCol: position4.start.column,
      startOffset: position4.start.offset,
      endLine: position4.end.line,
      endCol: position4.end.column,
      endOffset: position4.end.offset
    };
  }
}

// node_modules/html-void-elements/index.js
var htmlVoidElements = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];

// node_modules/parse5/dist/common/unicode.js
var UNDEFINED_CODE_POINTS = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]);
var REPLACEMENT_CHARACTER = "";
var CODE_POINTS;
(function(CODE_POINTS2) {
  CODE_POINTS2[CODE_POINTS2["EOF"] = -1] = "EOF";
  CODE_POINTS2[CODE_POINTS2["NULL"] = 0] = "NULL";
  CODE_POINTS2[CODE_POINTS2["TABULATION"] = 9] = "TABULATION";
  CODE_POINTS2[CODE_POINTS2["CARRIAGE_RETURN"] = 13] = "CARRIAGE_RETURN";
  CODE_POINTS2[CODE_POINTS2["LINE_FEED"] = 10] = "LINE_FEED";
  CODE_POINTS2[CODE_POINTS2["FORM_FEED"] = 12] = "FORM_FEED";
  CODE_POINTS2[CODE_POINTS2["SPACE"] = 32] = "SPACE";
  CODE_POINTS2[CODE_POINTS2["EXCLAMATION_MARK"] = 33] = "EXCLAMATION_MARK";
  CODE_POINTS2[CODE_POINTS2["QUOTATION_MARK"] = 34] = "QUOTATION_MARK";
  CODE_POINTS2[CODE_POINTS2["AMPERSAND"] = 38] = "AMPERSAND";
  CODE_POINTS2[CODE_POINTS2["APOSTROPHE"] = 39] = "APOSTROPHE";
  CODE_POINTS2[CODE_POINTS2["HYPHEN_MINUS"] = 45] = "HYPHEN_MINUS";
  CODE_POINTS2[CODE_POINTS2["SOLIDUS"] = 47] = "SOLIDUS";
  CODE_POINTS2[CODE_POINTS2["DIGIT_0"] = 48] = "DIGIT_0";
  CODE_POINTS2[CODE_POINTS2["DIGIT_9"] = 57] = "DIGIT_9";
  CODE_POINTS2[CODE_POINTS2["SEMICOLON"] = 59] = "SEMICOLON";
  CODE_POINTS2[CODE_POINTS2["LESS_THAN_SIGN"] = 60] = "LESS_THAN_SIGN";
  CODE_POINTS2[CODE_POINTS2["EQUALS_SIGN"] = 61] = "EQUALS_SIGN";
  CODE_POINTS2[CODE_POINTS2["GREATER_THAN_SIGN"] = 62] = "GREATER_THAN_SIGN";
  CODE_POINTS2[CODE_POINTS2["QUESTION_MARK"] = 63] = "QUESTION_MARK";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_A"] = 65] = "LATIN_CAPITAL_A";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_Z"] = 90] = "LATIN_CAPITAL_Z";
  CODE_POINTS2[CODE_POINTS2["RIGHT_SQUARE_BRACKET"] = 93] = "RIGHT_SQUARE_BRACKET";
  CODE_POINTS2[CODE_POINTS2["GRAVE_ACCENT"] = 96] = "GRAVE_ACCENT";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_A"] = 97] = "LATIN_SMALL_A";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_Z"] = 122] = "LATIN_SMALL_Z";
})(CODE_POINTS || (CODE_POINTS = {}));
var SEQUENCES = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function isSurrogate(cp) {
  return cp >= 55296 && cp <= 57343;
}
function isSurrogatePair(cp) {
  return cp >= 56320 && cp <= 57343;
}
function getSurrogatePairCodePoint(cp1, cp2) {
  return (cp1 - 55296) * 1024 + 9216 + cp2;
}
function isControlCodePoint(cp) {
  return cp !== 32 && cp !== 10 && cp !== 13 && cp !== 9 && cp !== 12 && cp >= 1 && cp <= 31 || cp >= 127 && cp <= 159;
}
function isUndefinedCodePoint(cp) {
  return cp >= 64976 && cp <= 65007 || UNDEFINED_CODE_POINTS.has(cp);
}

// node_modules/parse5/dist/common/error-codes.js
var ERR;
(function(ERR2) {
  ERR2["controlCharacterInInputStream"] = "control-character-in-input-stream";
  ERR2["noncharacterInInputStream"] = "noncharacter-in-input-stream";
  ERR2["surrogateInInputStream"] = "surrogate-in-input-stream";
  ERR2["nonVoidHtmlElementStartTagWithTrailingSolidus"] = "non-void-html-element-start-tag-with-trailing-solidus";
  ERR2["endTagWithAttributes"] = "end-tag-with-attributes";
  ERR2["endTagWithTrailingSolidus"] = "end-tag-with-trailing-solidus";
  ERR2["unexpectedSolidusInTag"] = "unexpected-solidus-in-tag";
  ERR2["unexpectedNullCharacter"] = "unexpected-null-character";
  ERR2["unexpectedQuestionMarkInsteadOfTagName"] = "unexpected-question-mark-instead-of-tag-name";
  ERR2["invalidFirstCharacterOfTagName"] = "invalid-first-character-of-tag-name";
  ERR2["unexpectedEqualsSignBeforeAttributeName"] = "unexpected-equals-sign-before-attribute-name";
  ERR2["missingEndTagName"] = "missing-end-tag-name";
  ERR2["unexpectedCharacterInAttributeName"] = "unexpected-character-in-attribute-name";
  ERR2["unknownNamedCharacterReference"] = "unknown-named-character-reference";
  ERR2["missingSemicolonAfterCharacterReference"] = "missing-semicolon-after-character-reference";
  ERR2["unexpectedCharacterAfterDoctypeSystemIdentifier"] = "unexpected-character-after-doctype-system-identifier";
  ERR2["unexpectedCharacterInUnquotedAttributeValue"] = "unexpected-character-in-unquoted-attribute-value";
  ERR2["eofBeforeTagName"] = "eof-before-tag-name";
  ERR2["eofInTag"] = "eof-in-tag";
  ERR2["missingAttributeValue"] = "missing-attribute-value";
  ERR2["missingWhitespaceBetweenAttributes"] = "missing-whitespace-between-attributes";
  ERR2["missingWhitespaceAfterDoctypePublicKeyword"] = "missing-whitespace-after-doctype-public-keyword";
  ERR2["missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers"] = "missing-whitespace-between-doctype-public-and-system-identifiers";
  ERR2["missingWhitespaceAfterDoctypeSystemKeyword"] = "missing-whitespace-after-doctype-system-keyword";
  ERR2["missingQuoteBeforeDoctypePublicIdentifier"] = "missing-quote-before-doctype-public-identifier";
  ERR2["missingQuoteBeforeDoctypeSystemIdentifier"] = "missing-quote-before-doctype-system-identifier";
  ERR2["missingDoctypePublicIdentifier"] = "missing-doctype-public-identifier";
  ERR2["missingDoctypeSystemIdentifier"] = "missing-doctype-system-identifier";
  ERR2["abruptDoctypePublicIdentifier"] = "abrupt-doctype-public-identifier";
  ERR2["abruptDoctypeSystemIdentifier"] = "abrupt-doctype-system-identifier";
  ERR2["cdataInHtmlContent"] = "cdata-in-html-content";
  ERR2["incorrectlyOpenedComment"] = "incorrectly-opened-comment";
  ERR2["eofInScriptHtmlCommentLikeText"] = "eof-in-script-html-comment-like-text";
  ERR2["eofInDoctype"] = "eof-in-doctype";
  ERR2["nestedComment"] = "nested-comment";
  ERR2["abruptClosingOfEmptyComment"] = "abrupt-closing-of-empty-comment";
  ERR2["eofInComment"] = "eof-in-comment";
  ERR2["incorrectlyClosedComment"] = "incorrectly-closed-comment";
  ERR2["eofInCdata"] = "eof-in-cdata";
  ERR2["absenceOfDigitsInNumericCharacterReference"] = "absence-of-digits-in-numeric-character-reference";
  ERR2["nullCharacterReference"] = "null-character-reference";
  ERR2["surrogateCharacterReference"] = "surrogate-character-reference";
  ERR2["characterReferenceOutsideUnicodeRange"] = "character-reference-outside-unicode-range";
  ERR2["controlCharacterReference"] = "control-character-reference";
  ERR2["noncharacterCharacterReference"] = "noncharacter-character-reference";
  ERR2["missingWhitespaceBeforeDoctypeName"] = "missing-whitespace-before-doctype-name";
  ERR2["missingDoctypeName"] = "missing-doctype-name";
  ERR2["invalidCharacterSequenceAfterDoctypeName"] = "invalid-character-sequence-after-doctype-name";
  ERR2["duplicateAttribute"] = "duplicate-attribute";
  ERR2["nonConformingDoctype"] = "non-conforming-doctype";
  ERR2["missingDoctype"] = "missing-doctype";
  ERR2["misplacedDoctype"] = "misplaced-doctype";
  ERR2["endTagWithoutMatchingOpenElement"] = "end-tag-without-matching-open-element";
  ERR2["closingOfElementWithOpenChildElements"] = "closing-of-element-with-open-child-elements";
  ERR2["disallowedContentInNoscriptInHead"] = "disallowed-content-in-noscript-in-head";
  ERR2["openElementsLeftAfterEof"] = "open-elements-left-after-eof";
  ERR2["abandonedHeadElementChild"] = "abandoned-head-element-child";
  ERR2["misplacedStartTagForHeadElement"] = "misplaced-start-tag-for-head-element";
  ERR2["nestedNoscriptInHead"] = "nested-noscript-in-head";
  ERR2["eofInElementThatCanContainOnlyText"] = "eof-in-element-that-can-contain-only-text";
})(ERR || (ERR = {}));

// node_modules/parse5/dist/tokenizer/preprocessor.js
var DEFAULT_BUFFER_WATERLINE = 1 << 16;
var Preprocessor = class {
  constructor(handler) {
    this.handler = handler;
    this.html = "";
    this.pos = -1;
    this.lastGapPos = -2;
    this.gapStack = [];
    this.skipNextNewLine = false;
    this.lastChunkWritten = false;
    this.endOfChunkHit = false;
    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
    this.isEol = false;
    this.lineStartPos = 0;
    this.droppedBufferSize = 0;
    this.line = 1;
    this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(code4, cpOffset) {
    const { line, col, offset: offset4 } = this;
    const startCol = col + cpOffset;
    const startOffset = offset4 + cpOffset;
    return {
      code: code4,
      startLine: line,
      endLine: line,
      startCol,
      endCol: startCol,
      startOffset,
      endOffset: startOffset
    };
  }
  _err(code4) {
    if (this.handler.onParseError && this.lastErrOffset !== this.offset) {
      this.lastErrOffset = this.offset;
      this.handler.onParseError(this.getError(code4, 0));
    }
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos);
    this.lastGapPos = this.pos;
  }
  _processSurrogate(cp) {
    if (this.pos !== this.html.length - 1) {
      const nextCp = this.html.charCodeAt(this.pos + 1);
      if (isSurrogatePair(nextCp)) {
        this.pos++;
        this._addGap();
        return getSurrogatePairCodePoint(cp, nextCp);
      }
    } else if (!this.lastChunkWritten) {
      this.endOfChunkHit = true;
      return CODE_POINTS.EOF;
    }
    this._err(ERR.surrogateInInputStream);
    return cp;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    if (this.willDropParsedChunk()) {
      this.html = this.html.substring(this.pos);
      this.lineStartPos -= this.pos;
      this.droppedBufferSize += this.pos;
      this.pos = 0;
      this.lastGapPos = -2;
      this.gapStack.length = 0;
    }
  }
  write(chunk, isLastChunk) {
    if (this.html.length > 0) {
      this.html += chunk;
    } else {
      this.html = chunk;
    }
    this.endOfChunkHit = false;
    this.lastChunkWritten = isLastChunk;
  }
  insertHtmlAtCurrentPos(chunk) {
    this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);
    this.endOfChunkHit = false;
  }
  startsWith(pattern, caseSensitive) {
    if (this.pos + pattern.length > this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return false;
    }
    if (caseSensitive) {
      return this.html.startsWith(pattern, this.pos);
    }
    for (let i16 = 0; i16 < pattern.length; i16++) {
      const cp = this.html.charCodeAt(this.pos + i16) | 32;
      if (cp !== pattern.charCodeAt(i16)) {
        return false;
      }
    }
    return true;
  }
  peek(offset4) {
    const pos = this.pos + offset4;
    if (pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return CODE_POINTS.EOF;
    }
    const code4 = this.html.charCodeAt(pos);
    return code4 === CODE_POINTS.CARRIAGE_RETURN ? CODE_POINTS.LINE_FEED : code4;
  }
  advance() {
    this.pos++;
    if (this.isEol) {
      this.isEol = false;
      this.line++;
      this.lineStartPos = this.pos;
    }
    if (this.pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return CODE_POINTS.EOF;
    }
    let cp = this.html.charCodeAt(this.pos);
    if (cp === CODE_POINTS.CARRIAGE_RETURN) {
      this.isEol = true;
      this.skipNextNewLine = true;
      return CODE_POINTS.LINE_FEED;
    }
    if (cp === CODE_POINTS.LINE_FEED) {
      this.isEol = true;
      if (this.skipNextNewLine) {
        this.line--;
        this.skipNextNewLine = false;
        this._addGap();
        return this.advance();
      }
    }
    this.skipNextNewLine = false;
    if (isSurrogate(cp)) {
      cp = this._processSurrogate(cp);
    }
    const isCommonValidRange = this.handler.onParseError === null || cp > 31 && cp < 127 || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.CARRIAGE_RETURN || cp > 159 && cp < 64976;
    if (!isCommonValidRange) {
      this._checkForProblematicCharacters(cp);
    }
    return cp;
  }
  _checkForProblematicCharacters(cp) {
    if (isControlCodePoint(cp)) {
      this._err(ERR.controlCharacterInInputStream);
    } else if (isUndefinedCodePoint(cp)) {
      this._err(ERR.noncharacterInInputStream);
    }
  }
  retreat(count2) {
    this.pos -= count2;
    while (this.pos < this.lastGapPos) {
      this.lastGapPos = this.gapStack.pop();
      this.pos--;
    }
    this.isEol = false;
  }
};

// node_modules/parse5/dist/common/token.js
var token_exports = {};
__export(token_exports, {
  TokenType: () => TokenType,
  getTokenAttr: () => getTokenAttr
});
var TokenType;
(function(TokenType2) {
  TokenType2[TokenType2["CHARACTER"] = 0] = "CHARACTER";
  TokenType2[TokenType2["NULL_CHARACTER"] = 1] = "NULL_CHARACTER";
  TokenType2[TokenType2["WHITESPACE_CHARACTER"] = 2] = "WHITESPACE_CHARACTER";
  TokenType2[TokenType2["START_TAG"] = 3] = "START_TAG";
  TokenType2[TokenType2["END_TAG"] = 4] = "END_TAG";
  TokenType2[TokenType2["COMMENT"] = 5] = "COMMENT";
  TokenType2[TokenType2["DOCTYPE"] = 6] = "DOCTYPE";
  TokenType2[TokenType2["EOF"] = 7] = "EOF";
  TokenType2[TokenType2["HIBERNATION"] = 8] = "HIBERNATION";
})(TokenType || (TokenType = {}));
function getTokenAttr(token, attrName) {
  for (let i16 = token.attrs.length - 1; i16 >= 0; i16--) {
    if (token.attrs[i16].name === attrName) {
      return token.attrs[i16].value;
    }
  }
  return null;
}

// node_modules/entities/dist/esm/generated/decode-data-html.js
var htmlDecodeTree = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map((c21) => c21.charCodeAt(0))
);

// node_modules/entities/dist/esm/generated/decode-data-xml.js
var xmlDecodeTree = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map((c21) => c21.charCodeAt(0))
);

// node_modules/entities/dist/esm/decode-codepoint.js
var _a;
var decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, n/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a2;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
}

// node_modules/entities/dist/esm/decode.js
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
  CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
  CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code4) {
  return code4 >= CharCodes.ZERO && code4 <= CharCodes.NINE;
}
function isHexadecimalCharacter(code4) {
  return code4 >= CharCodes.UPPER_A && code4 <= CharCodes.UPPER_F || code4 >= CharCodes.LOWER_A && code4 <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code4) {
  return code4 >= CharCodes.UPPER_A && code4 <= CharCodes.UPPER_Z || code4 >= CharCodes.LOWER_A && code4 <= CharCodes.LOWER_Z || isNumber(code4);
}
function isEntityInAttributeInvalidEnd(code4) {
  return code4 === CharCodes.EQUALS || isAsciiAlphaNumeric(code4);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
  constructor(decodeTree, emitCodePoint, errors) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(input, offset4) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (input.charCodeAt(offset4) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(input, offset4 + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(input, offset4);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(input, offset4);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(input, offset4);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(input, offset4);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(input, offset4);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(input, offset4) {
    if (offset4 >= input.length) {
      return -1;
    }
    if ((input.charCodeAt(offset4) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(input, offset4 + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(input, offset4);
  }
  addToNumericResult(input, start2, end, base) {
    if (start2 !== end) {
      const digitCount = end - start2;
      this.result = this.result * Math.pow(base, digitCount) + Number.parseInt(input.substr(start2, digitCount), base);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(input, offset4) {
    const startIndex = offset4;
    while (offset4 < input.length) {
      const char = input.charCodeAt(offset4);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset4 += 1;
      } else {
        this.addToNumericResult(input, startIndex, offset4, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(input, startIndex, offset4, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(input, offset4) {
    const startIndex = offset4;
    while (offset4 < input.length) {
      const char = input.charCodeAt(offset4);
      if (isNumber(char)) {
        offset4 += 1;
      } else {
        this.addToNumericResult(input, startIndex, offset4, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(input, startIndex, offset4, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a2;
    if (this.consumed <= expectedLength) {
      (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param input The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(input, offset4) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset4 < input.length; offset4++, this.excess++) {
      const char = input.charCodeAt(offset4);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a2;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a2;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a2 = this.errors) === null || _a2 === void 0 ? void 0 : _a2.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
};
function getDecoder(decodeTree) {
  let returnValue = "";
  const decoder = new EntityDecoder(decodeTree, (data) => returnValue += fromCodePoint(data));
  return function decodeWithTrie(input, decodeMode) {
    let lastIndex = 0;
    let offset4 = 0;
    while ((offset4 = input.indexOf("&", offset4)) >= 0) {
      returnValue += input.slice(lastIndex, offset4);
      decoder.startEntity(decodeMode);
      const length = decoder.write(
        input,
        // Skip the "&"
        offset4 + 1
      );
      if (length < 0) {
        lastIndex = offset4 + decoder.end();
        break;
      }
      lastIndex = offset4 + length;
      offset4 = length === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = returnValue + input.slice(lastIndex);
    returnValue = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIndex, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIndex : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIndex + value] - 1;
  }
  let lo2 = nodeIndex;
  let hi = lo2 + branchCount - 1;
  while (lo2 <= hi) {
    const mid = lo2 + hi >>> 1;
    const midValue = decodeTree[mid];
    if (midValue < char) {
      lo2 = mid + 1;
    } else if (midValue > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var htmlDecoder = getDecoder(htmlDecodeTree);
var xmlDecoder = getDecoder(xmlDecodeTree);

// node_modules/parse5/dist/common/html.js
var html_exports = {};
__export(html_exports, {
  ATTRS: () => ATTRS,
  DOCUMENT_MODE: () => DOCUMENT_MODE,
  NS: () => NS,
  NUMBERED_HEADERS: () => NUMBERED_HEADERS,
  SPECIAL_ELEMENTS: () => SPECIAL_ELEMENTS,
  TAG_ID: () => TAG_ID,
  TAG_NAMES: () => TAG_NAMES,
  getTagID: () => getTagID,
  hasUnescapedText: () => hasUnescapedText
});
var NS;
(function(NS2) {
  NS2["HTML"] = "http://www.w3.org/1999/xhtml";
  NS2["MATHML"] = "http://www.w3.org/1998/Math/MathML";
  NS2["SVG"] = "http://www.w3.org/2000/svg";
  NS2["XLINK"] = "http://www.w3.org/1999/xlink";
  NS2["XML"] = "http://www.w3.org/XML/1998/namespace";
  NS2["XMLNS"] = "http://www.w3.org/2000/xmlns/";
})(NS || (NS = {}));
var ATTRS;
(function(ATTRS2) {
  ATTRS2["TYPE"] = "type";
  ATTRS2["ACTION"] = "action";
  ATTRS2["ENCODING"] = "encoding";
  ATTRS2["PROMPT"] = "prompt";
  ATTRS2["NAME"] = "name";
  ATTRS2["COLOR"] = "color";
  ATTRS2["FACE"] = "face";
  ATTRS2["SIZE"] = "size";
})(ATTRS || (ATTRS = {}));
var DOCUMENT_MODE;
(function(DOCUMENT_MODE2) {
  DOCUMENT_MODE2["NO_QUIRKS"] = "no-quirks";
  DOCUMENT_MODE2["QUIRKS"] = "quirks";
  DOCUMENT_MODE2["LIMITED_QUIRKS"] = "limited-quirks";
})(DOCUMENT_MODE || (DOCUMENT_MODE = {}));
var TAG_NAMES;
(function(TAG_NAMES2) {
  TAG_NAMES2["A"] = "a";
  TAG_NAMES2["ADDRESS"] = "address";
  TAG_NAMES2["ANNOTATION_XML"] = "annotation-xml";
  TAG_NAMES2["APPLET"] = "applet";
  TAG_NAMES2["AREA"] = "area";
  TAG_NAMES2["ARTICLE"] = "article";
  TAG_NAMES2["ASIDE"] = "aside";
  TAG_NAMES2["B"] = "b";
  TAG_NAMES2["BASE"] = "base";
  TAG_NAMES2["BASEFONT"] = "basefont";
  TAG_NAMES2["BGSOUND"] = "bgsound";
  TAG_NAMES2["BIG"] = "big";
  TAG_NAMES2["BLOCKQUOTE"] = "blockquote";
  TAG_NAMES2["BODY"] = "body";
  TAG_NAMES2["BR"] = "br";
  TAG_NAMES2["BUTTON"] = "button";
  TAG_NAMES2["CAPTION"] = "caption";
  TAG_NAMES2["CENTER"] = "center";
  TAG_NAMES2["CODE"] = "code";
  TAG_NAMES2["COL"] = "col";
  TAG_NAMES2["COLGROUP"] = "colgroup";
  TAG_NAMES2["DD"] = "dd";
  TAG_NAMES2["DESC"] = "desc";
  TAG_NAMES2["DETAILS"] = "details";
  TAG_NAMES2["DIALOG"] = "dialog";
  TAG_NAMES2["DIR"] = "dir";
  TAG_NAMES2["DIV"] = "div";
  TAG_NAMES2["DL"] = "dl";
  TAG_NAMES2["DT"] = "dt";
  TAG_NAMES2["EM"] = "em";
  TAG_NAMES2["EMBED"] = "embed";
  TAG_NAMES2["FIELDSET"] = "fieldset";
  TAG_NAMES2["FIGCAPTION"] = "figcaption";
  TAG_NAMES2["FIGURE"] = "figure";
  TAG_NAMES2["FONT"] = "font";
  TAG_NAMES2["FOOTER"] = "footer";
  TAG_NAMES2["FOREIGN_OBJECT"] = "foreignObject";
  TAG_NAMES2["FORM"] = "form";
  TAG_NAMES2["FRAME"] = "frame";
  TAG_NAMES2["FRAMESET"] = "frameset";
  TAG_NAMES2["H1"] = "h1";
  TAG_NAMES2["H2"] = "h2";
  TAG_NAMES2["H3"] = "h3";
  TAG_NAMES2["H4"] = "h4";
  TAG_NAMES2["H5"] = "h5";
  TAG_NAMES2["H6"] = "h6";
  TAG_NAMES2["HEAD"] = "head";
  TAG_NAMES2["HEADER"] = "header";
  TAG_NAMES2["HGROUP"] = "hgroup";
  TAG_NAMES2["HR"] = "hr";
  TAG_NAMES2["HTML"] = "html";
  TAG_NAMES2["I"] = "i";
  TAG_NAMES2["IMG"] = "img";
  TAG_NAMES2["IMAGE"] = "image";
  TAG_NAMES2["INPUT"] = "input";
  TAG_NAMES2["IFRAME"] = "iframe";
  TAG_NAMES2["KEYGEN"] = "keygen";
  TAG_NAMES2["LABEL"] = "label";
  TAG_NAMES2["LI"] = "li";
  TAG_NAMES2["LINK"] = "link";
  TAG_NAMES2["LISTING"] = "listing";
  TAG_NAMES2["MAIN"] = "main";
  TAG_NAMES2["MALIGNMARK"] = "malignmark";
  TAG_NAMES2["MARQUEE"] = "marquee";
  TAG_NAMES2["MATH"] = "math";
  TAG_NAMES2["MENU"] = "menu";
  TAG_NAMES2["META"] = "meta";
  TAG_NAMES2["MGLYPH"] = "mglyph";
  TAG_NAMES2["MI"] = "mi";
  TAG_NAMES2["MO"] = "mo";
  TAG_NAMES2["MN"] = "mn";
  TAG_NAMES2["MS"] = "ms";
  TAG_NAMES2["MTEXT"] = "mtext";
  TAG_NAMES2["NAV"] = "nav";
  TAG_NAMES2["NOBR"] = "nobr";
  TAG_NAMES2["NOFRAMES"] = "noframes";
  TAG_NAMES2["NOEMBED"] = "noembed";
  TAG_NAMES2["NOSCRIPT"] = "noscript";
  TAG_NAMES2["OBJECT"] = "object";
  TAG_NAMES2["OL"] = "ol";
  TAG_NAMES2["OPTGROUP"] = "optgroup";
  TAG_NAMES2["OPTION"] = "option";
  TAG_NAMES2["P"] = "p";
  TAG_NAMES2["PARAM"] = "param";
  TAG_NAMES2["PLAINTEXT"] = "plaintext";
  TAG_NAMES2["PRE"] = "pre";
  TAG_NAMES2["RB"] = "rb";
  TAG_NAMES2["RP"] = "rp";
  TAG_NAMES2["RT"] = "rt";
  TAG_NAMES2["RTC"] = "rtc";
  TAG_NAMES2["RUBY"] = "ruby";
  TAG_NAMES2["S"] = "s";
  TAG_NAMES2["SCRIPT"] = "script";
  TAG_NAMES2["SEARCH"] = "search";
  TAG_NAMES2["SECTION"] = "section";
  TAG_NAMES2["SELECT"] = "select";
  TAG_NAMES2["SOURCE"] = "source";
  TAG_NAMES2["SMALL"] = "small";
  TAG_NAMES2["SPAN"] = "span";
  TAG_NAMES2["STRIKE"] = "strike";
  TAG_NAMES2["STRONG"] = "strong";
  TAG_NAMES2["STYLE"] = "style";
  TAG_NAMES2["SUB"] = "sub";
  TAG_NAMES2["SUMMARY"] = "summary";
  TAG_NAMES2["SUP"] = "sup";
  TAG_NAMES2["TABLE"] = "table";
  TAG_NAMES2["TBODY"] = "tbody";
  TAG_NAMES2["TEMPLATE"] = "template";
  TAG_NAMES2["TEXTAREA"] = "textarea";
  TAG_NAMES2["TFOOT"] = "tfoot";
  TAG_NAMES2["TD"] = "td";
  TAG_NAMES2["TH"] = "th";
  TAG_NAMES2["THEAD"] = "thead";
  TAG_NAMES2["TITLE"] = "title";
  TAG_NAMES2["TR"] = "tr";
  TAG_NAMES2["TRACK"] = "track";
  TAG_NAMES2["TT"] = "tt";
  TAG_NAMES2["U"] = "u";
  TAG_NAMES2["UL"] = "ul";
  TAG_NAMES2["SVG"] = "svg";
  TAG_NAMES2["VAR"] = "var";
  TAG_NAMES2["WBR"] = "wbr";
  TAG_NAMES2["XMP"] = "xmp";
})(TAG_NAMES || (TAG_NAMES = {}));
var TAG_ID;
(function(TAG_ID2) {
  TAG_ID2[TAG_ID2["UNKNOWN"] = 0] = "UNKNOWN";
  TAG_ID2[TAG_ID2["A"] = 1] = "A";
  TAG_ID2[TAG_ID2["ADDRESS"] = 2] = "ADDRESS";
  TAG_ID2[TAG_ID2["ANNOTATION_XML"] = 3] = "ANNOTATION_XML";
  TAG_ID2[TAG_ID2["APPLET"] = 4] = "APPLET";
  TAG_ID2[TAG_ID2["AREA"] = 5] = "AREA";
  TAG_ID2[TAG_ID2["ARTICLE"] = 6] = "ARTICLE";
  TAG_ID2[TAG_ID2["ASIDE"] = 7] = "ASIDE";
  TAG_ID2[TAG_ID2["B"] = 8] = "B";
  TAG_ID2[TAG_ID2["BASE"] = 9] = "BASE";
  TAG_ID2[TAG_ID2["BASEFONT"] = 10] = "BASEFONT";
  TAG_ID2[TAG_ID2["BGSOUND"] = 11] = "BGSOUND";
  TAG_ID2[TAG_ID2["BIG"] = 12] = "BIG";
  TAG_ID2[TAG_ID2["BLOCKQUOTE"] = 13] = "BLOCKQUOTE";
  TAG_ID2[TAG_ID2["BODY"] = 14] = "BODY";
  TAG_ID2[TAG_ID2["BR"] = 15] = "BR";
  TAG_ID2[TAG_ID2["BUTTON"] = 16] = "BUTTON";
  TAG_ID2[TAG_ID2["CAPTION"] = 17] = "CAPTION";
  TAG_ID2[TAG_ID2["CENTER"] = 18] = "CENTER";
  TAG_ID2[TAG_ID2["CODE"] = 19] = "CODE";
  TAG_ID2[TAG_ID2["COL"] = 20] = "COL";
  TAG_ID2[TAG_ID2["COLGROUP"] = 21] = "COLGROUP";
  TAG_ID2[TAG_ID2["DD"] = 22] = "DD";
  TAG_ID2[TAG_ID2["DESC"] = 23] = "DESC";
  TAG_ID2[TAG_ID2["DETAILS"] = 24] = "DETAILS";
  TAG_ID2[TAG_ID2["DIALOG"] = 25] = "DIALOG";
  TAG_ID2[TAG_ID2["DIR"] = 26] = "DIR";
  TAG_ID2[TAG_ID2["DIV"] = 27] = "DIV";
  TAG_ID2[TAG_ID2["DL"] = 28] = "DL";
  TAG_ID2[TAG_ID2["DT"] = 29] = "DT";
  TAG_ID2[TAG_ID2["EM"] = 30] = "EM";
  TAG_ID2[TAG_ID2["EMBED"] = 31] = "EMBED";
  TAG_ID2[TAG_ID2["FIELDSET"] = 32] = "FIELDSET";
  TAG_ID2[TAG_ID2["FIGCAPTION"] = 33] = "FIGCAPTION";
  TAG_ID2[TAG_ID2["FIGURE"] = 34] = "FIGURE";
  TAG_ID2[TAG_ID2["FONT"] = 35] = "FONT";
  TAG_ID2[TAG_ID2["FOOTER"] = 36] = "FOOTER";
  TAG_ID2[TAG_ID2["FOREIGN_OBJECT"] = 37] = "FOREIGN_OBJECT";
  TAG_ID2[TAG_ID2["FORM"] = 38] = "FORM";
  TAG_ID2[TAG_ID2["FRAME"] = 39] = "FRAME";
  TAG_ID2[TAG_ID2["FRAMESET"] = 40] = "FRAMESET";
  TAG_ID2[TAG_ID2["H1"] = 41] = "H1";
  TAG_ID2[TAG_ID2["H2"] = 42] = "H2";
  TAG_ID2[TAG_ID2["H3"] = 43] = "H3";
  TAG_ID2[TAG_ID2["H4"] = 44] = "H4";
  TAG_ID2[TAG_ID2["H5"] = 45] = "H5";
  TAG_ID2[TAG_ID2["H6"] = 46] = "H6";
  TAG_ID2[TAG_ID2["HEAD"] = 47] = "HEAD";
  TAG_ID2[TAG_ID2["HEADER"] = 48] = "HEADER";
  TAG_ID2[TAG_ID2["HGROUP"] = 49] = "HGROUP";
  TAG_ID2[TAG_ID2["HR"] = 50] = "HR";
  TAG_ID2[TAG_ID2["HTML"] = 51] = "HTML";
  TAG_ID2[TAG_ID2["I"] = 52] = "I";
  TAG_ID2[TAG_ID2["IMG"] = 53] = "IMG";
  TAG_ID2[TAG_ID2["IMAGE"] = 54] = "IMAGE";
  TAG_ID2[TAG_ID2["INPUT"] = 55] = "INPUT";
  TAG_ID2[TAG_ID2["IFRAME"] = 56] = "IFRAME";
  TAG_ID2[TAG_ID2["KEYGEN"] = 57] = "KEYGEN";
  TAG_ID2[TAG_ID2["LABEL"] = 58] = "LABEL";
  TAG_ID2[TAG_ID2["LI"] = 59] = "LI";
  TAG_ID2[TAG_ID2["LINK"] = 60] = "LINK";
  TAG_ID2[TAG_ID2["LISTING"] = 61] = "LISTING";
  TAG_ID2[TAG_ID2["MAIN"] = 62] = "MAIN";
  TAG_ID2[TAG_ID2["MALIGNMARK"] = 63] = "MALIGNMARK";
  TAG_ID2[TAG_ID2["MARQUEE"] = 64] = "MARQUEE";
  TAG_ID2[TAG_ID2["MATH"] = 65] = "MATH";
  TAG_ID2[TAG_ID2["MENU"] = 66] = "MENU";
  TAG_ID2[TAG_ID2["META"] = 67] = "META";
  TAG_ID2[TAG_ID2["MGLYPH"] = 68] = "MGLYPH";
  TAG_ID2[TAG_ID2["MI"] = 69] = "MI";
  TAG_ID2[TAG_ID2["MO"] = 70] = "MO";
  TAG_ID2[TAG_ID2["MN"] = 71] = "MN";
  TAG_ID2[TAG_ID2["MS"] = 72] = "MS";
  TAG_ID2[TAG_ID2["MTEXT"] = 73] = "MTEXT";
  TAG_ID2[TAG_ID2["NAV"] = 74] = "NAV";
  TAG_ID2[TAG_ID2["NOBR"] = 75] = "NOBR";
  TAG_ID2[TAG_ID2["NOFRAMES"] = 76] = "NOFRAMES";
  TAG_ID2[TAG_ID2["NOEMBED"] = 77] = "NOEMBED";
  TAG_ID2[TAG_ID2["NOSCRIPT"] = 78] = "NOSCRIPT";
  TAG_ID2[TAG_ID2["OBJECT"] = 79] = "OBJECT";
  TAG_ID2[TAG_ID2["OL"] = 80] = "OL";
  TAG_ID2[TAG_ID2["OPTGROUP"] = 81] = "OPTGROUP";
  TAG_ID2[TAG_ID2["OPTION"] = 82] = "OPTION";
  TAG_ID2[TAG_ID2["P"] = 83] = "P";
  TAG_ID2[TAG_ID2["PARAM"] = 84] = "PARAM";
  TAG_ID2[TAG_ID2["PLAINTEXT"] = 85] = "PLAINTEXT";
  TAG_ID2[TAG_ID2["PRE"] = 86] = "PRE";
  TAG_ID2[TAG_ID2["RB"] = 87] = "RB";
  TAG_ID2[TAG_ID2["RP"] = 88] = "RP";
  TAG_ID2[TAG_ID2["RT"] = 89] = "RT";
  TAG_ID2[TAG_ID2["RTC"] = 90] = "RTC";
  TAG_ID2[TAG_ID2["RUBY"] = 91] = "RUBY";
  TAG_ID2[TAG_ID2["S"] = 92] = "S";
  TAG_ID2[TAG_ID2["SCRIPT"] = 93] = "SCRIPT";
  TAG_ID2[TAG_ID2["SEARCH"] = 94] = "SEARCH";
  TAG_ID2[TAG_ID2["SECTION"] = 95] = "SECTION";
  TAG_ID2[TAG_ID2["SELECT"] = 96] = "SELECT";
  TAG_ID2[TAG_ID2["SOURCE"] = 97] = "SOURCE";
  TAG_ID2[TAG_ID2["SMALL"] = 98] = "SMALL";
  TAG_ID2[TAG_ID2["SPAN"] = 99] = "SPAN";
  TAG_ID2[TAG_ID2["STRIKE"] = 100] = "STRIKE";
  TAG_ID2[TAG_ID2["STRONG"] = 101] = "STRONG";
  TAG_ID2[TAG_ID2["STYLE"] = 102] = "STYLE";
  TAG_ID2[TAG_ID2["SUB"] = 103] = "SUB";
  TAG_ID2[TAG_ID2["SUMMARY"] = 104] = "SUMMARY";
  TAG_ID2[TAG_ID2["SUP"] = 105] = "SUP";
  TAG_ID2[TAG_ID2["TABLE"] = 106] = "TABLE";
  TAG_ID2[TAG_ID2["TBODY"] = 107] = "TBODY";
  TAG_ID2[TAG_ID2["TEMPLATE"] = 108] = "TEMPLATE";
  TAG_ID2[TAG_ID2["TEXTAREA"] = 109] = "TEXTAREA";
  TAG_ID2[TAG_ID2["TFOOT"] = 110] = "TFOOT";
  TAG_ID2[TAG_ID2["TD"] = 111] = "TD";
  TAG_ID2[TAG_ID2["TH"] = 112] = "TH";
  TAG_ID2[TAG_ID2["THEAD"] = 113] = "THEAD";
  TAG_ID2[TAG_ID2["TITLE"] = 114] = "TITLE";
  TAG_ID2[TAG_ID2["TR"] = 115] = "TR";
  TAG_ID2[TAG_ID2["TRACK"] = 116] = "TRACK";
  TAG_ID2[TAG_ID2["TT"] = 117] = "TT";
  TAG_ID2[TAG_ID2["U"] = 118] = "U";
  TAG_ID2[TAG_ID2["UL"] = 119] = "UL";
  TAG_ID2[TAG_ID2["SVG"] = 120] = "SVG";
  TAG_ID2[TAG_ID2["VAR"] = 121] = "VAR";
  TAG_ID2[TAG_ID2["WBR"] = 122] = "WBR";
  TAG_ID2[TAG_ID2["XMP"] = 123] = "XMP";
})(TAG_ID || (TAG_ID = {}));
var TAG_NAME_TO_ID = /* @__PURE__ */ new Map([
  [TAG_NAMES.A, TAG_ID.A],
  [TAG_NAMES.ADDRESS, TAG_ID.ADDRESS],
  [TAG_NAMES.ANNOTATION_XML, TAG_ID.ANNOTATION_XML],
  [TAG_NAMES.APPLET, TAG_ID.APPLET],
  [TAG_NAMES.AREA, TAG_ID.AREA],
  [TAG_NAMES.ARTICLE, TAG_ID.ARTICLE],
  [TAG_NAMES.ASIDE, TAG_ID.ASIDE],
  [TAG_NAMES.B, TAG_ID.B],
  [TAG_NAMES.BASE, TAG_ID.BASE],
  [TAG_NAMES.BASEFONT, TAG_ID.BASEFONT],
  [TAG_NAMES.BGSOUND, TAG_ID.BGSOUND],
  [TAG_NAMES.BIG, TAG_ID.BIG],
  [TAG_NAMES.BLOCKQUOTE, TAG_ID.BLOCKQUOTE],
  [TAG_NAMES.BODY, TAG_ID.BODY],
  [TAG_NAMES.BR, TAG_ID.BR],
  [TAG_NAMES.BUTTON, TAG_ID.BUTTON],
  [TAG_NAMES.CAPTION, TAG_ID.CAPTION],
  [TAG_NAMES.CENTER, TAG_ID.CENTER],
  [TAG_NAMES.CODE, TAG_ID.CODE],
  [TAG_NAMES.COL, TAG_ID.COL],
  [TAG_NAMES.COLGROUP, TAG_ID.COLGROUP],
  [TAG_NAMES.DD, TAG_ID.DD],
  [TAG_NAMES.DESC, TAG_ID.DESC],
  [TAG_NAMES.DETAILS, TAG_ID.DETAILS],
  [TAG_NAMES.DIALOG, TAG_ID.DIALOG],
  [TAG_NAMES.DIR, TAG_ID.DIR],
  [TAG_NAMES.DIV, TAG_ID.DIV],
  [TAG_NAMES.DL, TAG_ID.DL],
  [TAG_NAMES.DT, TAG_ID.DT],
  [TAG_NAMES.EM, TAG_ID.EM],
  [TAG_NAMES.EMBED, TAG_ID.EMBED],
  [TAG_NAMES.FIELDSET, TAG_ID.FIELDSET],
  [TAG_NAMES.FIGCAPTION, TAG_ID.FIGCAPTION],
  [TAG_NAMES.FIGURE, TAG_ID.FIGURE],
  [TAG_NAMES.FONT, TAG_ID.FONT],
  [TAG_NAMES.FOOTER, TAG_ID.FOOTER],
  [TAG_NAMES.FOREIGN_OBJECT, TAG_ID.FOREIGN_OBJECT],
  [TAG_NAMES.FORM, TAG_ID.FORM],
  [TAG_NAMES.FRAME, TAG_ID.FRAME],
  [TAG_NAMES.FRAMESET, TAG_ID.FRAMESET],
  [TAG_NAMES.H1, TAG_ID.H1],
  [TAG_NAMES.H2, TAG_ID.H2],
  [TAG_NAMES.H3, TAG_ID.H3],
  [TAG_NAMES.H4, TAG_ID.H4],
  [TAG_NAMES.H5, TAG_ID.H5],
  [TAG_NAMES.H6, TAG_ID.H6],
  [TAG_NAMES.HEAD, TAG_ID.HEAD],
  [TAG_NAMES.HEADER, TAG_ID.HEADER],
  [TAG_NAMES.HGROUP, TAG_ID.HGROUP],
  [TAG_NAMES.HR, TAG_ID.HR],
  [TAG_NAMES.HTML, TAG_ID.HTML],
  [TAG_NAMES.I, TAG_ID.I],
  [TAG_NAMES.IMG, TAG_ID.IMG],
  [TAG_NAMES.IMAGE, TAG_ID.IMAGE],
  [TAG_NAMES.INPUT, TAG_ID.INPUT],
  [TAG_NAMES.IFRAME, TAG_ID.IFRAME],
  [TAG_NAMES.KEYGEN, TAG_ID.KEYGEN],
  [TAG_NAMES.LABEL, TAG_ID.LABEL],
  [TAG_NAMES.LI, TAG_ID.LI],
  [TAG_NAMES.LINK, TAG_ID.LINK],
  [TAG_NAMES.LISTING, TAG_ID.LISTING],
  [TAG_NAMES.MAIN, TAG_ID.MAIN],
  [TAG_NAMES.MALIGNMARK, TAG_ID.MALIGNMARK],
  [TAG_NAMES.MARQUEE, TAG_ID.MARQUEE],
  [TAG_NAMES.MATH, TAG_ID.MATH],
  [TAG_NAMES.MENU, TAG_ID.MENU],
  [TAG_NAMES.META, TAG_ID.META],
  [TAG_NAMES.MGLYPH, TAG_ID.MGLYPH],
  [TAG_NAMES.MI, TAG_ID.MI],
  [TAG_NAMES.MO, TAG_ID.MO],
  [TAG_NAMES.MN, TAG_ID.MN],
  [TAG_NAMES.MS, TAG_ID.MS],
  [TAG_NAMES.MTEXT, TAG_ID.MTEXT],
  [TAG_NAMES.NAV, TAG_ID.NAV],
  [TAG_NAMES.NOBR, TAG_ID.NOBR],
  [TAG_NAMES.NOFRAMES, TAG_ID.NOFRAMES],
  [TAG_NAMES.NOEMBED, TAG_ID.NOEMBED],
  [TAG_NAMES.NOSCRIPT, TAG_ID.NOSCRIPT],
  [TAG_NAMES.OBJECT, TAG_ID.OBJECT],
  [TAG_NAMES.OL, TAG_ID.OL],
  [TAG_NAMES.OPTGROUP, TAG_ID.OPTGROUP],
  [TAG_NAMES.OPTION, TAG_ID.OPTION],
  [TAG_NAMES.P, TAG_ID.P],
  [TAG_NAMES.PARAM, TAG_ID.PARAM],
  [TAG_NAMES.PLAINTEXT, TAG_ID.PLAINTEXT],
  [TAG_NAMES.PRE, TAG_ID.PRE],
  [TAG_NAMES.RB, TAG_ID.RB],
  [TAG_NAMES.RP, TAG_ID.RP],
  [TAG_NAMES.RT, TAG_ID.RT],
  [TAG_NAMES.RTC, TAG_ID.RTC],
  [TAG_NAMES.RUBY, TAG_ID.RUBY],
  [TAG_NAMES.S, TAG_ID.S],
  [TAG_NAMES.SCRIPT, TAG_ID.SCRIPT],
  [TAG_NAMES.SEARCH, TAG_ID.SEARCH],
  [TAG_NAMES.SECTION, TAG_ID.SECTION],
  [TAG_NAMES.SELECT, TAG_ID.SELECT],
  [TAG_NAMES.SOURCE, TAG_ID.SOURCE],
  [TAG_NAMES.SMALL, TAG_ID.SMALL],
  [TAG_NAMES.SPAN, TAG_ID.SPAN],
  [TAG_NAMES.STRIKE, TAG_ID.STRIKE],
  [TAG_NAMES.STRONG, TAG_ID.STRONG],
  [TAG_NAMES.STYLE, TAG_ID.STYLE],
  [TAG_NAMES.SUB, TAG_ID.SUB],
  [TAG_NAMES.SUMMARY, TAG_ID.SUMMARY],
  [TAG_NAMES.SUP, TAG_ID.SUP],
  [TAG_NAMES.TABLE, TAG_ID.TABLE],
  [TAG_NAMES.TBODY, TAG_ID.TBODY],
  [TAG_NAMES.TEMPLATE, TAG_ID.TEMPLATE],
  [TAG_NAMES.TEXTAREA, TAG_ID.TEXTAREA],
  [TAG_NAMES.TFOOT, TAG_ID.TFOOT],
  [TAG_NAMES.TD, TAG_ID.TD],
  [TAG_NAMES.TH, TAG_ID.TH],
  [TAG_NAMES.THEAD, TAG_ID.THEAD],
  [TAG_NAMES.TITLE, TAG_ID.TITLE],
  [TAG_NAMES.TR, TAG_ID.TR],
  [TAG_NAMES.TRACK, TAG_ID.TRACK],
  [TAG_NAMES.TT, TAG_ID.TT],
  [TAG_NAMES.U, TAG_ID.U],
  [TAG_NAMES.UL, TAG_ID.UL],
  [TAG_NAMES.SVG, TAG_ID.SVG],
  [TAG_NAMES.VAR, TAG_ID.VAR],
  [TAG_NAMES.WBR, TAG_ID.WBR],
  [TAG_NAMES.XMP, TAG_ID.XMP]
]);
function getTagID(tagName) {
  var _a2;
  return (_a2 = TAG_NAME_TO_ID.get(tagName)) !== null && _a2 !== void 0 ? _a2 : TAG_ID.UNKNOWN;
}
var $6 = TAG_ID;
var SPECIAL_ELEMENTS = {
  [NS.HTML]: /* @__PURE__ */ new Set([
    $6.ADDRESS,
    $6.APPLET,
    $6.AREA,
    $6.ARTICLE,
    $6.ASIDE,
    $6.BASE,
    $6.BASEFONT,
    $6.BGSOUND,
    $6.BLOCKQUOTE,
    $6.BODY,
    $6.BR,
    $6.BUTTON,
    $6.CAPTION,
    $6.CENTER,
    $6.COL,
    $6.COLGROUP,
    $6.DD,
    $6.DETAILS,
    $6.DIR,
    $6.DIV,
    $6.DL,
    $6.DT,
    $6.EMBED,
    $6.FIELDSET,
    $6.FIGCAPTION,
    $6.FIGURE,
    $6.FOOTER,
    $6.FORM,
    $6.FRAME,
    $6.FRAMESET,
    $6.H1,
    $6.H2,
    $6.H3,
    $6.H4,
    $6.H5,
    $6.H6,
    $6.HEAD,
    $6.HEADER,
    $6.HGROUP,
    $6.HR,
    $6.HTML,
    $6.IFRAME,
    $6.IMG,
    $6.INPUT,
    $6.LI,
    $6.LINK,
    $6.LISTING,
    $6.MAIN,
    $6.MARQUEE,
    $6.MENU,
    $6.META,
    $6.NAV,
    $6.NOEMBED,
    $6.NOFRAMES,
    $6.NOSCRIPT,
    $6.OBJECT,
    $6.OL,
    $6.P,
    $6.PARAM,
    $6.PLAINTEXT,
    $6.PRE,
    $6.SCRIPT,
    $6.SECTION,
    $6.SELECT,
    $6.SOURCE,
    $6.STYLE,
    $6.SUMMARY,
    $6.TABLE,
    $6.TBODY,
    $6.TD,
    $6.TEMPLATE,
    $6.TEXTAREA,
    $6.TFOOT,
    $6.TH,
    $6.THEAD,
    $6.TITLE,
    $6.TR,
    $6.TRACK,
    $6.UL,
    $6.WBR,
    $6.XMP
  ]),
  [NS.MATHML]: /* @__PURE__ */ new Set([$6.MI, $6.MO, $6.MN, $6.MS, $6.MTEXT, $6.ANNOTATION_XML]),
  [NS.SVG]: /* @__PURE__ */ new Set([$6.TITLE, $6.FOREIGN_OBJECT, $6.DESC]),
  [NS.XLINK]: /* @__PURE__ */ new Set(),
  [NS.XML]: /* @__PURE__ */ new Set(),
  [NS.XMLNS]: /* @__PURE__ */ new Set()
};
var NUMBERED_HEADERS = /* @__PURE__ */ new Set([$6.H1, $6.H2, $6.H3, $6.H4, $6.H5, $6.H6]);
var UNESCAPED_TEXT = /* @__PURE__ */ new Set([
  TAG_NAMES.STYLE,
  TAG_NAMES.SCRIPT,
  TAG_NAMES.XMP,
  TAG_NAMES.IFRAME,
  TAG_NAMES.NOEMBED,
  TAG_NAMES.NOFRAMES,
  TAG_NAMES.PLAINTEXT
]);
function hasUnescapedText(tn, scriptingEnabled) {
  return UNESCAPED_TEXT.has(tn) || scriptingEnabled && tn === TAG_NAMES.NOSCRIPT;
}

// node_modules/parse5/dist/tokenizer/index.js
var State;
(function(State2) {
  State2[State2["DATA"] = 0] = "DATA";
  State2[State2["RCDATA"] = 1] = "RCDATA";
  State2[State2["RAWTEXT"] = 2] = "RAWTEXT";
  State2[State2["SCRIPT_DATA"] = 3] = "SCRIPT_DATA";
  State2[State2["PLAINTEXT"] = 4] = "PLAINTEXT";
  State2[State2["TAG_OPEN"] = 5] = "TAG_OPEN";
  State2[State2["END_TAG_OPEN"] = 6] = "END_TAG_OPEN";
  State2[State2["TAG_NAME"] = 7] = "TAG_NAME";
  State2[State2["RCDATA_LESS_THAN_SIGN"] = 8] = "RCDATA_LESS_THAN_SIGN";
  State2[State2["RCDATA_END_TAG_OPEN"] = 9] = "RCDATA_END_TAG_OPEN";
  State2[State2["RCDATA_END_TAG_NAME"] = 10] = "RCDATA_END_TAG_NAME";
  State2[State2["RAWTEXT_LESS_THAN_SIGN"] = 11] = "RAWTEXT_LESS_THAN_SIGN";
  State2[State2["RAWTEXT_END_TAG_OPEN"] = 12] = "RAWTEXT_END_TAG_OPEN";
  State2[State2["RAWTEXT_END_TAG_NAME"] = 13] = "RAWTEXT_END_TAG_NAME";
  State2[State2["SCRIPT_DATA_LESS_THAN_SIGN"] = 14] = "SCRIPT_DATA_LESS_THAN_SIGN";
  State2[State2["SCRIPT_DATA_END_TAG_OPEN"] = 15] = "SCRIPT_DATA_END_TAG_OPEN";
  State2[State2["SCRIPT_DATA_END_TAG_NAME"] = 16] = "SCRIPT_DATA_END_TAG_NAME";
  State2[State2["SCRIPT_DATA_ESCAPE_START"] = 17] = "SCRIPT_DATA_ESCAPE_START";
  State2[State2["SCRIPT_DATA_ESCAPE_START_DASH"] = 18] = "SCRIPT_DATA_ESCAPE_START_DASH";
  State2[State2["SCRIPT_DATA_ESCAPED"] = 19] = "SCRIPT_DATA_ESCAPED";
  State2[State2["SCRIPT_DATA_ESCAPED_DASH"] = 20] = "SCRIPT_DATA_ESCAPED_DASH";
  State2[State2["SCRIPT_DATA_ESCAPED_DASH_DASH"] = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH";
  State2[State2["SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"] = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN";
  State2[State2["SCRIPT_DATA_ESCAPED_END_TAG_OPEN"] = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN";
  State2[State2["SCRIPT_DATA_ESCAPED_END_TAG_NAME"] = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPE_START"] = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED"] = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED_DASH"] = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"] = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"] = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPE_END"] = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END";
  State2[State2["BEFORE_ATTRIBUTE_NAME"] = 31] = "BEFORE_ATTRIBUTE_NAME";
  State2[State2["ATTRIBUTE_NAME"] = 32] = "ATTRIBUTE_NAME";
  State2[State2["AFTER_ATTRIBUTE_NAME"] = 33] = "AFTER_ATTRIBUTE_NAME";
  State2[State2["BEFORE_ATTRIBUTE_VALUE"] = 34] = "BEFORE_ATTRIBUTE_VALUE";
  State2[State2["ATTRIBUTE_VALUE_DOUBLE_QUOTED"] = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED";
  State2[State2["ATTRIBUTE_VALUE_SINGLE_QUOTED"] = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED";
  State2[State2["ATTRIBUTE_VALUE_UNQUOTED"] = 37] = "ATTRIBUTE_VALUE_UNQUOTED";
  State2[State2["AFTER_ATTRIBUTE_VALUE_QUOTED"] = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED";
  State2[State2["SELF_CLOSING_START_TAG"] = 39] = "SELF_CLOSING_START_TAG";
  State2[State2["BOGUS_COMMENT"] = 40] = "BOGUS_COMMENT";
  State2[State2["MARKUP_DECLARATION_OPEN"] = 41] = "MARKUP_DECLARATION_OPEN";
  State2[State2["COMMENT_START"] = 42] = "COMMENT_START";
  State2[State2["COMMENT_START_DASH"] = 43] = "COMMENT_START_DASH";
  State2[State2["COMMENT"] = 44] = "COMMENT";
  State2[State2["COMMENT_LESS_THAN_SIGN"] = 45] = "COMMENT_LESS_THAN_SIGN";
  State2[State2["COMMENT_LESS_THAN_SIGN_BANG"] = 46] = "COMMENT_LESS_THAN_SIGN_BANG";
  State2[State2["COMMENT_LESS_THAN_SIGN_BANG_DASH"] = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH";
  State2[State2["COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"] = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH";
  State2[State2["COMMENT_END_DASH"] = 49] = "COMMENT_END_DASH";
  State2[State2["COMMENT_END"] = 50] = "COMMENT_END";
  State2[State2["COMMENT_END_BANG"] = 51] = "COMMENT_END_BANG";
  State2[State2["DOCTYPE"] = 52] = "DOCTYPE";
  State2[State2["BEFORE_DOCTYPE_NAME"] = 53] = "BEFORE_DOCTYPE_NAME";
  State2[State2["DOCTYPE_NAME"] = 54] = "DOCTYPE_NAME";
  State2[State2["AFTER_DOCTYPE_NAME"] = 55] = "AFTER_DOCTYPE_NAME";
  State2[State2["AFTER_DOCTYPE_PUBLIC_KEYWORD"] = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD";
  State2[State2["BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"] = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER";
  State2[State2["DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"] = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED";
  State2[State2["DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"] = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED";
  State2[State2["AFTER_DOCTYPE_PUBLIC_IDENTIFIER"] = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER";
  State2[State2["BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"] = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS";
  State2[State2["AFTER_DOCTYPE_SYSTEM_KEYWORD"] = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD";
  State2[State2["BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"] = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER";
  State2[State2["DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"] = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED";
  State2[State2["DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"] = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED";
  State2[State2["AFTER_DOCTYPE_SYSTEM_IDENTIFIER"] = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER";
  State2[State2["BOGUS_DOCTYPE"] = 67] = "BOGUS_DOCTYPE";
  State2[State2["CDATA_SECTION"] = 68] = "CDATA_SECTION";
  State2[State2["CDATA_SECTION_BRACKET"] = 69] = "CDATA_SECTION_BRACKET";
  State2[State2["CDATA_SECTION_END"] = 70] = "CDATA_SECTION_END";
  State2[State2["CHARACTER_REFERENCE"] = 71] = "CHARACTER_REFERENCE";
  State2[State2["AMBIGUOUS_AMPERSAND"] = 72] = "AMBIGUOUS_AMPERSAND";
})(State || (State = {}));
var TokenizerMode = {
  DATA: State.DATA,
  RCDATA: State.RCDATA,
  RAWTEXT: State.RAWTEXT,
  SCRIPT_DATA: State.SCRIPT_DATA,
  PLAINTEXT: State.PLAINTEXT,
  CDATA_SECTION: State.CDATA_SECTION
};
function isAsciiDigit(cp) {
  return cp >= CODE_POINTS.DIGIT_0 && cp <= CODE_POINTS.DIGIT_9;
}
function isAsciiUpper(cp) {
  return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_Z;
}
function isAsciiLower(cp) {
  return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_Z;
}
function isAsciiLetter(cp) {
  return isAsciiLower(cp) || isAsciiUpper(cp);
}
function isAsciiAlphaNumeric2(cp) {
  return isAsciiLetter(cp) || isAsciiDigit(cp);
}
function toAsciiLower(cp) {
  return cp + 32;
}
function isWhitespace(cp) {
  return cp === CODE_POINTS.SPACE || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.TABULATION || cp === CODE_POINTS.FORM_FEED;
}
function isScriptDataDoubleEscapeSequenceEnd(cp) {
  return isWhitespace(cp) || cp === CODE_POINTS.SOLIDUS || cp === CODE_POINTS.GREATER_THAN_SIGN;
}
function getErrorForNumericCharacterReference(code4) {
  if (code4 === CODE_POINTS.NULL) {
    return ERR.nullCharacterReference;
  } else if (code4 > 1114111) {
    return ERR.characterReferenceOutsideUnicodeRange;
  } else if (isSurrogate(code4)) {
    return ERR.surrogateCharacterReference;
  } else if (isUndefinedCodePoint(code4)) {
    return ERR.noncharacterCharacterReference;
  } else if (isControlCodePoint(code4) || code4 === CODE_POINTS.CARRIAGE_RETURN) {
    return ERR.controlCharacterReference;
  }
  return null;
}
var Tokenizer = class {
  constructor(options, handler) {
    this.options = options;
    this.handler = handler;
    this.paused = false;
    this.inLoop = false;
    this.inForeignNode = false;
    this.lastStartTagName = "";
    this.active = false;
    this.state = State.DATA;
    this.returnState = State.DATA;
    this.entityStartPos = 0;
    this.consumedAfterSnapshot = -1;
    this.currentCharacterToken = null;
    this.currentToken = null;
    this.currentAttr = { name: "", value: "" };
    this.preprocessor = new Preprocessor(handler);
    this.currentLocation = this.getCurrentLocation(-1);
    this.entityDecoder = new EntityDecoder(htmlDecodeTree, (cp, consumed) => {
      this.preprocessor.pos = this.entityStartPos + consumed - 1;
      this._flushCodePointConsumedAsCharacterReference(cp);
    }, handler.onParseError ? {
      missingSemicolonAfterCharacterReference: () => {
        this._err(ERR.missingSemicolonAfterCharacterReference, 1);
      },
      absenceOfDigitsInNumericCharacterReference: (consumed) => {
        this._err(ERR.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + consumed);
      },
      validateNumericCharacterReference: (code4) => {
        const error2 = getErrorForNumericCharacterReference(code4);
        if (error2)
          this._err(error2, 1);
      }
    } : void 0);
  }
  //Errors
  _err(code4, cpOffset = 0) {
    var _a2, _b;
    (_b = (_a2 = this.handler).onParseError) === null || _b === void 0 ? void 0 : _b.call(_a2, this.preprocessor.getError(code4, cpOffset));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(offset4) {
    if (!this.options.sourceCodeLocationInfo) {
      return null;
    }
    return {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - offset4,
      startOffset: this.preprocessor.offset - offset4,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
  }
  _runParsingLoop() {
    if (this.inLoop)
      return;
    this.inLoop = true;
    while (this.active && !this.paused) {
      this.consumedAfterSnapshot = 0;
      const cp = this._consume();
      if (!this._ensureHibernation()) {
        this._callState(cp);
      }
    }
    this.inLoop = false;
  }
  //API
  pause() {
    this.paused = true;
  }
  resume(writeCallback) {
    if (!this.paused) {
      throw new Error("Parser was already resumed");
    }
    this.paused = false;
    if (this.inLoop)
      return;
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
    }
  }
  write(chunk, isLastChunk, writeCallback) {
    this.active = true;
    this.preprocessor.write(chunk, isLastChunk);
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
    }
  }
  insertHtmlAtCurrentPos(chunk) {
    this.active = true;
    this.preprocessor.insertHtmlAtCurrentPos(chunk);
    this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    if (this.preprocessor.endOfChunkHit) {
      this.preprocessor.retreat(this.consumedAfterSnapshot);
      this.consumedAfterSnapshot = 0;
      this.active = false;
      return true;
    }
    return false;
  }
  //Consumption
  _consume() {
    this.consumedAfterSnapshot++;
    return this.preprocessor.advance();
  }
  _advanceBy(count2) {
    this.consumedAfterSnapshot += count2;
    for (let i16 = 0; i16 < count2; i16++) {
      this.preprocessor.advance();
    }
  }
  _consumeSequenceIfMatch(pattern, caseSensitive) {
    if (this.preprocessor.startsWith(pattern, caseSensitive)) {
      this._advanceBy(pattern.length - 1);
      return true;
    }
    return false;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: TokenType.START_TAG,
      tagName: "",
      tagID: TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: TokenType.END_TAG,
      tagName: "",
      tagID: TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(offset4) {
    this.currentToken = {
      type: TokenType.COMMENT,
      data: "",
      location: this.getCurrentLocation(offset4)
    };
  }
  _createDoctypeToken(initialName) {
    this.currentToken = {
      type: TokenType.DOCTYPE,
      name: initialName,
      forceQuirks: false,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(type, chars) {
    this.currentCharacterToken = {
      type,
      chars,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(attrNameFirstCh) {
    this.currentAttr = {
      name: attrNameFirstCh,
      value: ""
    };
    this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var _a2;
    var _b;
    const token = this.currentToken;
    if (getTokenAttr(token, this.currentAttr.name) === null) {
      token.attrs.push(this.currentAttr);
      if (token.location && this.currentLocation) {
        const attrLocations = (_a2 = (_b = token.location).attrs) !== null && _a2 !== void 0 ? _a2 : _b.attrs = /* @__PURE__ */ Object.create(null);
        attrLocations[this.currentAttr.name] = this.currentLocation;
        this._leaveAttrValue();
      }
    } else {
      this._err(ERR.duplicateAttribute);
    }
  }
  _leaveAttrValue() {
    if (this.currentLocation) {
      this.currentLocation.endLine = this.preprocessor.line;
      this.currentLocation.endCol = this.preprocessor.col;
      this.currentLocation.endOffset = this.preprocessor.offset;
    }
  }
  //Token emission
  prepareToken(ct2) {
    this._emitCurrentCharacterToken(ct2.location);
    this.currentToken = null;
    if (ct2.location) {
      ct2.location.endLine = this.preprocessor.line;
      ct2.location.endCol = this.preprocessor.col + 1;
      ct2.location.endOffset = this.preprocessor.offset + 1;
    }
    this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const ct2 = this.currentToken;
    this.prepareToken(ct2);
    ct2.tagID = getTagID(ct2.tagName);
    if (ct2.type === TokenType.START_TAG) {
      this.lastStartTagName = ct2.tagName;
      this.handler.onStartTag(ct2);
    } else {
      if (ct2.attrs.length > 0) {
        this._err(ERR.endTagWithAttributes);
      }
      if (ct2.selfClosing) {
        this._err(ERR.endTagWithTrailingSolidus);
      }
      this.handler.onEndTag(ct2);
    }
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(ct2) {
    this.prepareToken(ct2);
    this.handler.onComment(ct2);
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(ct2) {
    this.prepareToken(ct2);
    this.handler.onDoctype(ct2);
    this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(nextLocation) {
    if (this.currentCharacterToken) {
      if (nextLocation && this.currentCharacterToken.location) {
        this.currentCharacterToken.location.endLine = nextLocation.startLine;
        this.currentCharacterToken.location.endCol = nextLocation.startCol;
        this.currentCharacterToken.location.endOffset = nextLocation.startOffset;
      }
      switch (this.currentCharacterToken.type) {
        case TokenType.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case TokenType.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case TokenType.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const location3 = this.getCurrentLocation(0);
    if (location3) {
      location3.endLine = location3.startLine;
      location3.endCol = location3.startCol;
      location3.endOffset = location3.startOffset;
    }
    this._emitCurrentCharacterToken(location3);
    this.handler.onEof({ type: TokenType.EOF, location: location3 });
    this.active = false;
  }
  //Characters emission
  //OPTIMIZATION: The specification uses only one type of character token (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(type, ch) {
    if (this.currentCharacterToken) {
      if (this.currentCharacterToken.type === type) {
        this.currentCharacterToken.chars += ch;
        return;
      } else {
        this.currentLocation = this.getCurrentLocation(0);
        this._emitCurrentCharacterToken(this.currentLocation);
        this.preprocessor.dropParsedChunk();
      }
    }
    this._createCharacterToken(type, ch);
  }
  _emitCodePoint(cp) {
    const type = isWhitespace(cp) ? TokenType.WHITESPACE_CHARACTER : cp === CODE_POINTS.NULL ? TokenType.NULL_CHARACTER : TokenType.CHARACTER;
    this._appendCharToCurrentCharacterToken(type, String.fromCodePoint(cp));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(ch) {
    this._appendCharToCurrentCharacterToken(TokenType.CHARACTER, ch);
  }
  // Character reference helpers
  _startCharacterReference() {
    this.returnState = this.state;
    this.state = State.CHARACTER_REFERENCE;
    this.entityStartPos = this.preprocessor.pos;
    this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? DecodingMode.Attribute : DecodingMode.Legacy);
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === State.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(cp) {
    if (this._isCharacterReferenceInAttribute()) {
      this.currentAttr.value += String.fromCodePoint(cp);
    } else {
      this._emitCodePoint(cp);
    }
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(cp) {
    switch (this.state) {
      case State.DATA: {
        this._stateData(cp);
        break;
      }
      case State.RCDATA: {
        this._stateRcdata(cp);
        break;
      }
      case State.RAWTEXT: {
        this._stateRawtext(cp);
        break;
      }
      case State.SCRIPT_DATA: {
        this._stateScriptData(cp);
        break;
      }
      case State.PLAINTEXT: {
        this._statePlaintext(cp);
        break;
      }
      case State.TAG_OPEN: {
        this._stateTagOpen(cp);
        break;
      }
      case State.END_TAG_OPEN: {
        this._stateEndTagOpen(cp);
        break;
      }
      case State.TAG_NAME: {
        this._stateTagName(cp);
        break;
      }
      case State.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(cp);
        break;
      }
      case State.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(cp);
        break;
      }
      case State.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(cp);
        break;
      }
      case State.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(cp);
        break;
      }
      case State.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(cp);
        break;
      }
      case State.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(cp);
        break;
      }
      case State.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(cp);
        break;
      }
      case State.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(cp);
        break;
      }
      case State.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(cp);
        break;
      }
      case State.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(cp);
        break;
      }
      case State.ATTRIBUTE_NAME: {
        this._stateAttributeName(cp);
        break;
      }
      case State.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(cp);
        break;
      }
      case State.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(cp);
        break;
      }
      case State.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(cp);
        break;
      }
      case State.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(cp);
        break;
      }
      case State.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(cp);
        break;
      }
      case State.BOGUS_COMMENT: {
        this._stateBogusComment(cp);
        break;
      }
      case State.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(cp);
        break;
      }
      case State.COMMENT_START: {
        this._stateCommentStart(cp);
        break;
      }
      case State.COMMENT_START_DASH: {
        this._stateCommentStartDash(cp);
        break;
      }
      case State.COMMENT: {
        this._stateComment(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(cp);
        break;
      }
      case State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(cp);
        break;
      }
      case State.COMMENT_END_DASH: {
        this._stateCommentEndDash(cp);
        break;
      }
      case State.COMMENT_END: {
        this._stateCommentEnd(cp);
        break;
      }
      case State.COMMENT_END_BANG: {
        this._stateCommentEndBang(cp);
        break;
      }
      case State.DOCTYPE: {
        this._stateDoctype(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(cp);
        break;
      }
      case State.DOCTYPE_NAME: {
        this._stateDoctypeName(cp);
        break;
      }
      case State.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(cp);
        break;
      }
      case State.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(cp);
        break;
      }
      case State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(cp);
        break;
      }
      case State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(cp);
        break;
      }
      case State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(cp);
        break;
      }
      case State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(cp);
        break;
      }
      case State.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(cp);
        break;
      }
      case State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(cp);
        break;
      }
      case State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(cp);
        break;
      }
      case State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(cp);
        break;
      }
      case State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(cp);
        break;
      }
      case State.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(cp);
        break;
      }
      case State.CDATA_SECTION: {
        this._stateCdataSection(cp);
        break;
      }
      case State.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(cp);
        break;
      }
      case State.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(cp);
        break;
      }
      case State.CHARACTER_REFERENCE: {
        this._stateCharacterReference();
        break;
      }
      case State.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(cp);
        break;
      }
      default: {
        throw new Error("Unknown state");
      }
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.TAG_OPEN;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitCodePoint(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(cp) {
    switch (cp) {
      case CODE_POINTS.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(cp) {
    switch (cp) {
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this._createStartTagToken();
      this.state = State.TAG_NAME;
      this._stateTagName(cp);
    } else
      switch (cp) {
        case CODE_POINTS.EXCLAMATION_MARK: {
          this.state = State.MARKUP_DECLARATION_OPEN;
          break;
        }
        case CODE_POINTS.SOLIDUS: {
          this.state = State.END_TAG_OPEN;
          break;
        }
        case CODE_POINTS.QUESTION_MARK: {
          this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);
          this._createCommentToken(1);
          this.state = State.BOGUS_COMMENT;
          this._stateBogusComment(cp);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofBeforeTagName);
          this._emitChars("<");
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.invalidFirstCharacterOfTagName);
          this._emitChars("<");
          this.state = State.DATA;
          this._stateData(cp);
        }
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this._createEndTagToken();
      this.state = State.TAG_NAME;
      this._stateTagName(cp);
    } else
      switch (cp) {
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.missingEndTagName);
          this.state = State.DATA;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofBeforeTagName);
          this._emitChars("</");
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.invalidFirstCharacterOfTagName);
          this._createCommentToken(2);
          this.state = State.BOGUS_COMMENT;
          this._stateBogusComment(cp);
        }
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.tagName += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        token.tagName += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.RCDATA_END_TAG_OPEN;
    } else {
      this._emitChars("<");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.RCDATA_END_TAG_NAME;
      this._stateRcdataEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  handleSpecialEndTag(_cp) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, false)) {
      return !this._ensureHibernation();
    }
    this._createEndTagToken();
    const token = this.currentToken;
    token.tagName = this.lastStartTagName;
    const cp = this.preprocessor.peek(this.lastStartTagName.length);
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._advanceBy(this.lastStartTagName.length);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        return false;
      }
      case CODE_POINTS.SOLIDUS: {
        this._advanceBy(this.lastStartTagName.length);
        this.state = State.SELF_CLOSING_START_TAG;
        return false;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._advanceBy(this.lastStartTagName.length);
        this.emitCurrentTagToken();
        this.state = State.DATA;
        return false;
      }
      default: {
        return !this._ensureHibernation();
      }
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.RCDATA;
      this._stateRcdata(cp);
    }
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.RAWTEXT_END_TAG_OPEN;
    } else {
      this._emitChars("<");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.RAWTEXT_END_TAG_NAME;
      this._stateRawtextEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(cp) {
    switch (cp) {
      case CODE_POINTS.SOLIDUS: {
        this.state = State.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State.SCRIPT_DATA_ESCAPE_START;
        this._emitChars("<!");
        break;
      }
      default: {
        this._emitChars("<");
        this.state = State.SCRIPT_DATA;
        this._stateScriptData(cp);
      }
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.SCRIPT_DATA_END_TAG_NAME;
      this._stateScriptDataEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.SCRIPT_DATA_ESCAPE_START_DASH;
      this._emitChars("-");
    } else {
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
      this._emitChars("-");
    } else {
      this.state = State.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_ESCAPED_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.SCRIPT_DATA;
        this._emitChars(">");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN;
    } else if (isAsciiLetter(cp)) {
      this._emitChars("<");
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_START;
      this._stateScriptDataDoubleEscapeStart(cp);
    } else {
      this._emitChars("<");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(cp) {
    if (isAsciiLetter(cp)) {
      this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_NAME;
      this._stateScriptDataEscapedEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(cp) {
    if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(cp);
      for (let i16 = 0; i16 < SEQUENCES.SCRIPT.length; i16++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.SCRIPT_DATA;
        this._emitChars(">");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_END;
      this._emitChars("/");
    } else {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(cp) {
    if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(cp);
      for (let i16 = 0; i16 < SEQUENCES.SCRIPT.length; i16++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State.SCRIPT_DATA_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.SOLIDUS:
      case CODE_POINTS.GREATER_THAN_SIGN:
      case CODE_POINTS.EOF: {
        this.state = State.AFTER_ATTRIBUTE_NAME;
        this._stateAfterAttributeName(cp);
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this._err(ERR.unexpectedEqualsSignBeforeAttributeName);
        this._createAttr("=");
        this.state = State.ATTRIBUTE_NAME;
        break;
      }
      default: {
        this._createAttr("");
        this.state = State.ATTRIBUTE_NAME;
        this._stateAttributeName(cp);
      }
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED:
      case CODE_POINTS.SOLIDUS:
      case CODE_POINTS.GREATER_THAN_SIGN:
      case CODE_POINTS.EOF: {
        this._leaveAttrName();
        this.state = State.AFTER_ATTRIBUTE_NAME;
        this._stateAfterAttributeName(cp);
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this._leaveAttrName();
        this.state = State.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK:
      case CODE_POINTS.APOSTROPHE:
      case CODE_POINTS.LESS_THAN_SIGN: {
        this._err(ERR.unexpectedCharacterInAttributeName);
        this.currentAttr.name += String.fromCodePoint(cp);
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.name += REPLACEMENT_CHARACTER;
        break;
      }
      default: {
        this.currentAttr.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this.state = State.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._createAttr("");
        this.state = State.ATTRIBUTE_NAME;
        this._stateAttributeName(cp);
      }
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingAttributeValue);
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      default: {
        this.state = State.ATTRIBUTE_VALUE_UNQUOTED;
        this._stateAttributeValueUnquoted(cp);
      }
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue();
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue();
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK:
      case CODE_POINTS.APOSTROPHE:
      case CODE_POINTS.LESS_THAN_SIGN:
      case CODE_POINTS.EQUALS_SIGN:
      case CODE_POINTS.GRAVE_ACCENT: {
        this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);
        this.currentAttr.value += String.fromCodePoint(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue();
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this._leaveAttrValue();
        this.state = State.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue();
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingWhitespaceBetweenAttributes);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        this._stateBeforeAttributeName(cp);
      }
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(cp) {
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        const token = this.currentToken;
        token.selfClosing = true;
        this.state = State.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.unexpectedSolidusInTag);
        this.state = State.BEFORE_ATTRIBUTE_NAME;
        this._stateBeforeAttributeName(cp);
      }
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.data += REPLACEMENT_CHARACTER;
        break;
      }
      default: {
        token.data += String.fromCodePoint(cp);
      }
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(cp) {
    if (this._consumeSequenceIfMatch(SEQUENCES.DASH_DASH, true)) {
      this._createCommentToken(SEQUENCES.DASH_DASH.length + 1);
      this.state = State.COMMENT_START;
    } else if (this._consumeSequenceIfMatch(SEQUENCES.DOCTYPE, false)) {
      this.currentLocation = this.getCurrentLocation(SEQUENCES.DOCTYPE.length + 1);
      this.state = State.DOCTYPE;
    } else if (this._consumeSequenceIfMatch(SEQUENCES.CDATA_START, true)) {
      if (this.inForeignNode) {
        this.state = State.CDATA_SECTION;
      } else {
        this._err(ERR.cdataInHtmlContent);
        this._createCommentToken(SEQUENCES.CDATA_START.length + 1);
        this.currentToken.data = "[CDATA[";
        this.state = State.BOGUS_COMMENT;
      }
    } else if (!this._ensureHibernation()) {
      this._err(ERR.incorrectlyOpenedComment);
      this._createCommentToken(2);
      this.state = State.BOGUS_COMMENT;
      this._stateBogusComment(cp);
    }
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_START_DASH;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptClosingOfEmptyComment);
        this.state = State.DATA;
        const token = this.currentToken;
        this.emitCurrentComment(token);
        break;
      }
      default: {
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptClosingOfEmptyComment);
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "-";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END_DASH;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        token.data += "<";
        this.state = State.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.data += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += String.fromCodePoint(cp);
      }
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.EXCLAMATION_MARK: {
        token.data += "!";
        this.state = State.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        token.data += "<";
        break;
      }
      default: {
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH;
    } else {
      this.state = State.COMMENT;
      this._stateComment(cp);
    }
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;
    } else {
      this.state = State.COMMENT_END_DASH;
      this._stateCommentEndDash(cp);
    }
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(cp) {
    if (cp !== CODE_POINTS.GREATER_THAN_SIGN && cp !== CODE_POINTS.EOF) {
      this._err(ERR.nestedComment);
    }
    this.state = State.COMMENT_END;
    this._stateCommentEnd(cp);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State.COMMENT_END;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "-";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State.COMMENT_END_BANG;
        break;
      }
      case CODE_POINTS.HYPHEN_MINUS: {
        token.data += "-";
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "--";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        token.data += "--!";
        this.state = State.COMMENT_END_DASH;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.incorrectlyClosedComment);
        this.state = State.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "--!";
        this.state = State.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_NAME;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.BEFORE_DOCTYPE_NAME;
        this._stateBeforeDoctypeName(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        this._createDoctypeToken(null);
        const token = this.currentToken;
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingWhitespaceBeforeDoctypeName);
        this.state = State.BEFORE_DOCTYPE_NAME;
        this._stateBeforeDoctypeName(cp);
      }
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(cp) {
    if (isAsciiUpper(cp)) {
      this._createDoctypeToken(String.fromCharCode(toAsciiLower(cp)));
      this.state = State.DOCTYPE_NAME;
    } else
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this._createDoctypeToken(REPLACEMENT_CHARACTER);
          this.state = State.DOCTYPE_NAME;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.missingDoctypeName);
          this._createDoctypeToken(null);
          const token = this.currentToken;
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this.state = State.DATA;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          this._createDoctypeToken(null);
          const token = this.currentToken;
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          this._createDoctypeToken(String.fromCodePoint(cp));
          this.state = State.DOCTYPE_NAME;
        }
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.AFTER_DOCTYPE_NAME;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.name += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        if (this._consumeSequenceIfMatch(SEQUENCES.PUBLIC, false)) {
          this.state = State.AFTER_DOCTYPE_PUBLIC_KEYWORD;
        } else if (this._consumeSequenceIfMatch(SEQUENCES.SYSTEM, false)) {
          this.state = State.AFTER_DOCTYPE_SYSTEM_KEYWORD;
        } else if (!this._ensureHibernation()) {
          this._err(ERR.invalidCharacterSequenceAfterDoctypeName);
          token.forceQuirks = true;
          this.state = State.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
      }
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.publicId = "";
        this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.publicId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.publicId += String.fromCodePoint(cp);
      }
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.publicId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.publicId += String.fromCodePoint(cp);
      }
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.systemId = "";
        this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.systemId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.systemId += String.fromCodePoint(cp);
      }
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.systemId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.systemId += String.fromCodePoint(cp);
      }
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
        this.state = State.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        break;
      }
      case CODE_POINTS.EOF: {
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default:
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(cp) {
    switch (cp) {
      case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this.state = State.CDATA_SECTION_BRACKET;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInCdata);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(cp) {
    if (cp === CODE_POINTS.RIGHT_SQUARE_BRACKET) {
      this.state = State.CDATA_SECTION_END;
    } else {
      this._emitChars("]");
      this.state = State.CDATA_SECTION;
      this._stateCdataSection(cp);
    }
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(cp) {
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State.DATA;
        break;
      }
      case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default: {
        this._emitChars("]]");
        this.state = State.CDATA_SECTION;
        this._stateCdataSection(cp);
      }
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference() {
    let length = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos);
    if (length < 0) {
      if (this.preprocessor.lastChunkWritten) {
        length = this.entityDecoder.end();
      } else {
        this.active = false;
        this.preprocessor.pos = this.preprocessor.html.length - 1;
        this.consumedAfterSnapshot = 0;
        this.preprocessor.endOfChunkHit = true;
        return;
      }
    }
    if (length === 0) {
      this.preprocessor.pos = this.entityStartPos;
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this.state = !this._isCharacterReferenceInAttribute() && isAsciiAlphaNumeric2(this.preprocessor.peek(1)) ? State.AMBIGUOUS_AMPERSAND : this.returnState;
    } else {
      this.state = this.returnState;
    }
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(cp) {
    if (isAsciiAlphaNumeric2(cp)) {
      this._flushCodePointConsumedAsCharacterReference(cp);
    } else {
      if (cp === CODE_POINTS.SEMICOLON) {
        this._err(ERR.unknownNamedCharacterReference);
      }
      this.state = this.returnState;
      this._callState(cp);
    }
  }
};

// node_modules/parse5/dist/parser/open-element-stack.js
var IMPLICIT_END_TAG_REQUIRED = /* @__PURE__ */ new Set([TAG_ID.DD, TAG_ID.DT, TAG_ID.LI, TAG_ID.OPTGROUP, TAG_ID.OPTION, TAG_ID.P, TAG_ID.RB, TAG_ID.RP, TAG_ID.RT, TAG_ID.RTC]);
var IMPLICIT_END_TAG_REQUIRED_THOROUGHLY = /* @__PURE__ */ new Set([
  ...IMPLICIT_END_TAG_REQUIRED,
  TAG_ID.CAPTION,
  TAG_ID.COLGROUP,
  TAG_ID.TBODY,
  TAG_ID.TD,
  TAG_ID.TFOOT,
  TAG_ID.TH,
  TAG_ID.THEAD,
  TAG_ID.TR
]);
var SCOPING_ELEMENTS_HTML = /* @__PURE__ */ new Set([
  TAG_ID.APPLET,
  TAG_ID.CAPTION,
  TAG_ID.HTML,
  TAG_ID.MARQUEE,
  TAG_ID.OBJECT,
  TAG_ID.TABLE,
  TAG_ID.TD,
  TAG_ID.TEMPLATE,
  TAG_ID.TH
]);
var SCOPING_ELEMENTS_HTML_LIST = /* @__PURE__ */ new Set([...SCOPING_ELEMENTS_HTML, TAG_ID.OL, TAG_ID.UL]);
var SCOPING_ELEMENTS_HTML_BUTTON = /* @__PURE__ */ new Set([...SCOPING_ELEMENTS_HTML, TAG_ID.BUTTON]);
var SCOPING_ELEMENTS_MATHML = /* @__PURE__ */ new Set([TAG_ID.ANNOTATION_XML, TAG_ID.MI, TAG_ID.MN, TAG_ID.MO, TAG_ID.MS, TAG_ID.MTEXT]);
var SCOPING_ELEMENTS_SVG = /* @__PURE__ */ new Set([TAG_ID.DESC, TAG_ID.FOREIGN_OBJECT, TAG_ID.TITLE]);
var TABLE_ROW_CONTEXT = /* @__PURE__ */ new Set([TAG_ID.TR, TAG_ID.TEMPLATE, TAG_ID.HTML]);
var TABLE_BODY_CONTEXT = /* @__PURE__ */ new Set([TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TEMPLATE, TAG_ID.HTML]);
var TABLE_CONTEXT = /* @__PURE__ */ new Set([TAG_ID.TABLE, TAG_ID.TEMPLATE, TAG_ID.HTML]);
var TABLE_CELLS = /* @__PURE__ */ new Set([TAG_ID.TD, TAG_ID.TH]);
var OpenElementStack = class {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(document4, treeAdapter, handler) {
    this.treeAdapter = treeAdapter;
    this.handler = handler;
    this.items = [];
    this.tagIDs = [];
    this.stackTop = -1;
    this.tmplCount = 0;
    this.currentTagId = TAG_ID.UNKNOWN;
    this.current = document4;
  }
  //Index of element
  _indexOf(element5) {
    return this.items.lastIndexOf(element5, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === TAG_ID.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop];
    this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(element5, tagID) {
    this.stackTop++;
    this.items[this.stackTop] = element5;
    this.current = element5;
    this.tagIDs[this.stackTop] = tagID;
    this.currentTagId = tagID;
    if (this._isInTemplate()) {
      this.tmplCount++;
    }
    this.handler.onItemPush(element5, tagID, true);
  }
  pop() {
    const popped = this.current;
    if (this.tmplCount > 0 && this._isInTemplate()) {
      this.tmplCount--;
    }
    this.stackTop--;
    this._updateCurrentElement();
    this.handler.onItemPop(popped, true);
  }
  replace(oldElement, newElement) {
    const idx = this._indexOf(oldElement);
    this.items[idx] = newElement;
    if (idx === this.stackTop) {
      this.current = newElement;
    }
  }
  insertAfter(referenceElement, newElement, newElementID) {
    const insertionIdx = this._indexOf(referenceElement) + 1;
    this.items.splice(insertionIdx, 0, newElement);
    this.tagIDs.splice(insertionIdx, 0, newElementID);
    this.stackTop++;
    if (insertionIdx === this.stackTop) {
      this._updateCurrentElement();
    }
    if (this.current && this.currentTagId !== void 0) {
      this.handler.onItemPush(this.current, this.currentTagId, insertionIdx === this.stackTop);
    }
  }
  popUntilTagNamePopped(tagName) {
    let targetIdx = this.stackTop + 1;
    do {
      targetIdx = this.tagIDs.lastIndexOf(tagName, targetIdx - 1);
    } while (targetIdx > 0 && this.treeAdapter.getNamespaceURI(this.items[targetIdx]) !== NS.HTML);
    this.shortenToLength(Math.max(targetIdx, 0));
  }
  shortenToLength(idx) {
    while (this.stackTop >= idx) {
      const popped = this.current;
      if (this.tmplCount > 0 && this._isInTemplate()) {
        this.tmplCount -= 1;
      }
      this.stackTop--;
      this._updateCurrentElement();
      this.handler.onItemPop(popped, this.stackTop < idx);
    }
  }
  popUntilElementPopped(element5) {
    const idx = this._indexOf(element5);
    this.shortenToLength(Math.max(idx, 0));
  }
  popUntilPopped(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(Math.max(idx, 0));
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(NUMBERED_HEADERS, NS.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(TABLE_CELLS, NS.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0;
    this.shortenToLength(1);
  }
  _indexOfTagNames(tagNames, namespace) {
    for (let i16 = this.stackTop; i16 >= 0; i16--) {
      if (tagNames.has(this.tagIDs[i16]) && this.treeAdapter.getNamespaceURI(this.items[i16]) === namespace) {
        return i16;
      }
    }
    return -1;
  }
  clearBackTo(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(idx + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(TABLE_CONTEXT, NS.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(TABLE_BODY_CONTEXT, NS.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(TABLE_ROW_CONTEXT, NS.HTML);
  }
  remove(element5) {
    const idx = this._indexOf(element5);
    if (idx >= 0) {
      if (idx === this.stackTop) {
        this.pop();
      } else {
        this.items.splice(idx, 1);
        this.tagIDs.splice(idx, 1);
        this.stackTop--;
        this._updateCurrentElement();
        this.handler.onItemPop(element5, false);
      }
    }
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === TAG_ID.BODY ? this.items[1] : null;
  }
  contains(element5) {
    return this._indexOf(element5) > -1;
  }
  getCommonAncestor(element5) {
    const elementIdx = this._indexOf(element5) - 1;
    return elementIdx >= 0 ? this.items[elementIdx] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === TAG_ID.HTML;
  }
  //Element in scope
  hasInDynamicScope(tagName, htmlScope) {
    for (let i16 = this.stackTop; i16 >= 0; i16--) {
      const tn = this.tagIDs[i16];
      switch (this.treeAdapter.getNamespaceURI(this.items[i16])) {
        case NS.HTML: {
          if (tn === tagName)
            return true;
          if (htmlScope.has(tn))
            return false;
          break;
        }
        case NS.SVG: {
          if (SCOPING_ELEMENTS_SVG.has(tn))
            return false;
          break;
        }
        case NS.MATHML: {
          if (SCOPING_ELEMENTS_MATHML.has(tn))
            return false;
          break;
        }
      }
    }
    return true;
  }
  hasInScope(tagName) {
    return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML);
  }
  hasInListItemScope(tagName) {
    return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML_LIST);
  }
  hasInButtonScope(tagName) {
    return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML_BUTTON);
  }
  hasNumberedHeaderInScope() {
    for (let i16 = this.stackTop; i16 >= 0; i16--) {
      const tn = this.tagIDs[i16];
      switch (this.treeAdapter.getNamespaceURI(this.items[i16])) {
        case NS.HTML: {
          if (NUMBERED_HEADERS.has(tn))
            return true;
          if (SCOPING_ELEMENTS_HTML.has(tn))
            return false;
          break;
        }
        case NS.SVG: {
          if (SCOPING_ELEMENTS_SVG.has(tn))
            return false;
          break;
        }
        case NS.MATHML: {
          if (SCOPING_ELEMENTS_MATHML.has(tn))
            return false;
          break;
        }
      }
    }
    return true;
  }
  hasInTableScope(tagName) {
    for (let i16 = this.stackTop; i16 >= 0; i16--) {
      if (this.treeAdapter.getNamespaceURI(this.items[i16]) !== NS.HTML) {
        continue;
      }
      switch (this.tagIDs[i16]) {
        case tagName: {
          return true;
        }
        case TAG_ID.TABLE:
        case TAG_ID.HTML: {
          return false;
        }
      }
    }
    return true;
  }
  hasTableBodyContextInTableScope() {
    for (let i16 = this.stackTop; i16 >= 0; i16--) {
      if (this.treeAdapter.getNamespaceURI(this.items[i16]) !== NS.HTML) {
        continue;
      }
      switch (this.tagIDs[i16]) {
        case TAG_ID.TBODY:
        case TAG_ID.THEAD:
        case TAG_ID.TFOOT: {
          return true;
        }
        case TAG_ID.TABLE:
        case TAG_ID.HTML: {
          return false;
        }
      }
    }
    return true;
  }
  hasInSelectScope(tagName) {
    for (let i16 = this.stackTop; i16 >= 0; i16--) {
      if (this.treeAdapter.getNamespaceURI(this.items[i16]) !== NS.HTML) {
        continue;
      }
      switch (this.tagIDs[i16]) {
        case tagName: {
          return true;
        }
        case TAG_ID.OPTION:
        case TAG_ID.OPTGROUP: {
          break;
        }
        default: {
          return false;
        }
      }
    }
    return true;
  }
  //Implied end tags
  generateImpliedEndTags() {
    while (this.currentTagId !== void 0 && IMPLICIT_END_TAG_REQUIRED.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsThoroughly() {
    while (this.currentTagId !== void 0 && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsWithExclusion(exclusionId) {
    while (this.currentTagId !== void 0 && this.currentTagId !== exclusionId && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
      this.pop();
    }
  }
};

// node_modules/parse5/dist/parser/formatting-element-list.js
var NOAH_ARK_CAPACITY = 3;
var EntryType;
(function(EntryType2) {
  EntryType2[EntryType2["Marker"] = 0] = "Marker";
  EntryType2[EntryType2["Element"] = 1] = "Element";
})(EntryType || (EntryType = {}));
var MARKER = { type: EntryType.Marker };
var FormattingElementList = class {
  constructor(treeAdapter) {
    this.treeAdapter = treeAdapter;
    this.entries = [];
    this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(newElement, neAttrs) {
    const candidates = [];
    const neAttrsLength = neAttrs.length;
    const neTagName = this.treeAdapter.getTagName(newElement);
    const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
    for (let i16 = 0; i16 < this.entries.length; i16++) {
      const entry = this.entries[i16];
      if (entry.type === EntryType.Marker) {
        break;
      }
      const { element: element5 } = entry;
      if (this.treeAdapter.getTagName(element5) === neTagName && this.treeAdapter.getNamespaceURI(element5) === neNamespaceURI) {
        const elementAttrs = this.treeAdapter.getAttrList(element5);
        if (elementAttrs.length === neAttrsLength) {
          candidates.push({ idx: i16, attrs: elementAttrs });
        }
      }
    }
    return candidates;
  }
  _ensureNoahArkCondition(newElement) {
    if (this.entries.length < NOAH_ARK_CAPACITY)
      return;
    const neAttrs = this.treeAdapter.getAttrList(newElement);
    const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);
    if (candidates.length < NOAH_ARK_CAPACITY)
      return;
    const neAttrsMap = new Map(neAttrs.map((neAttr) => [neAttr.name, neAttr.value]));
    let validCandidates = 0;
    for (let i16 = 0; i16 < candidates.length; i16++) {
      const candidate = candidates[i16];
      if (candidate.attrs.every((cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value)) {
        validCandidates += 1;
        if (validCandidates >= NOAH_ARK_CAPACITY) {
          this.entries.splice(candidate.idx, 1);
        }
      }
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(MARKER);
  }
  pushElement(element5, token) {
    this._ensureNoahArkCondition(element5);
    this.entries.unshift({
      type: EntryType.Element,
      element: element5,
      token
    });
  }
  insertElementAfterBookmark(element5, token) {
    const bookmarkIdx = this.entries.indexOf(this.bookmark);
    this.entries.splice(bookmarkIdx, 0, {
      type: EntryType.Element,
      element: element5,
      token
    });
  }
  removeEntry(entry) {
    const entryIndex = this.entries.indexOf(entry);
    if (entryIndex !== -1) {
      this.entries.splice(entryIndex, 1);
    }
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const markerIdx = this.entries.indexOf(MARKER);
    if (markerIdx === -1) {
      this.entries.length = 0;
    } else {
      this.entries.splice(0, markerIdx + 1);
    }
  }
  //Search
  getElementEntryInScopeWithTagName(tagName) {
    const entry = this.entries.find((entry2) => entry2.type === EntryType.Marker || this.treeAdapter.getTagName(entry2.element) === tagName);
    return entry && entry.type === EntryType.Element ? entry : null;
  }
  getElementEntry(element5) {
    return this.entries.find((entry) => entry.type === EntryType.Element && entry.element === element5);
  }
};

// node_modules/parse5/dist/tree-adapters/default.js
var defaultTreeAdapter = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: DOCUMENT_MODE.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(tagName, namespaceURI, attrs) {
    return {
      nodeName: tagName,
      tagName,
      attrs,
      namespaceURI,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(data) {
    return {
      nodeName: "#comment",
      data,
      parentNode: null
    };
  },
  createTextNode(value) {
    return {
      nodeName: "#text",
      value,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(parentNode, newNode) {
    parentNode.childNodes.push(newNode);
    newNode.parentNode = parentNode;
  },
  insertBefore(parentNode, newNode, referenceNode) {
    const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
    parentNode.childNodes.splice(insertionIdx, 0, newNode);
    newNode.parentNode = parentNode;
  },
  setTemplateContent(templateElement, contentElement) {
    templateElement.content = contentElement;
  },
  getTemplateContent(templateElement) {
    return templateElement.content;
  },
  setDocumentType(document4, name2, publicId, systemId) {
    const doctypeNode = document4.childNodes.find((node2) => node2.nodeName === "#documentType");
    if (doctypeNode) {
      doctypeNode.name = name2;
      doctypeNode.publicId = publicId;
      doctypeNode.systemId = systemId;
    } else {
      const node2 = {
        nodeName: "#documentType",
        name: name2,
        publicId,
        systemId,
        parentNode: null
      };
      defaultTreeAdapter.appendChild(document4, node2);
    }
  },
  setDocumentMode(document4, mode) {
    document4.mode = mode;
  },
  getDocumentMode(document4) {
    return document4.mode;
  },
  detachNode(node2) {
    if (node2.parentNode) {
      const idx = node2.parentNode.childNodes.indexOf(node2);
      node2.parentNode.childNodes.splice(idx, 1);
      node2.parentNode = null;
    }
  },
  insertText(parentNode, text10) {
    if (parentNode.childNodes.length > 0) {
      const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
      if (defaultTreeAdapter.isTextNode(prevNode)) {
        prevNode.value += text10;
        return;
      }
    }
    defaultTreeAdapter.appendChild(parentNode, defaultTreeAdapter.createTextNode(text10));
  },
  insertTextBefore(parentNode, text10, referenceNode) {
    const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
    if (prevNode && defaultTreeAdapter.isTextNode(prevNode)) {
      prevNode.value += text10;
    } else {
      defaultTreeAdapter.insertBefore(parentNode, defaultTreeAdapter.createTextNode(text10), referenceNode);
    }
  },
  adoptAttributes(recipient, attrs) {
    const recipientAttrsMap = new Set(recipient.attrs.map((attr2) => attr2.name));
    for (let j11 = 0; j11 < attrs.length; j11++) {
      if (!recipientAttrsMap.has(attrs[j11].name)) {
        recipient.attrs.push(attrs[j11]);
      }
    }
  },
  //Tree traversing
  getFirstChild(node2) {
    return node2.childNodes[0];
  },
  getChildNodes(node2) {
    return node2.childNodes;
  },
  getParentNode(node2) {
    return node2.parentNode;
  },
  getAttrList(element5) {
    return element5.attrs;
  },
  //Node data
  getTagName(element5) {
    return element5.tagName;
  },
  getNamespaceURI(element5) {
    return element5.namespaceURI;
  },
  getTextNodeContent(textNode) {
    return textNode.value;
  },
  getCommentNodeContent(commentNode) {
    return commentNode.data;
  },
  getDocumentTypeNodeName(doctypeNode) {
    return doctypeNode.name;
  },
  getDocumentTypeNodePublicId(doctypeNode) {
    return doctypeNode.publicId;
  },
  getDocumentTypeNodeSystemId(doctypeNode) {
    return doctypeNode.systemId;
  },
  //Node types
  isTextNode(node2) {
    return node2.nodeName === "#text";
  },
  isCommentNode(node2) {
    return node2.nodeName === "#comment";
  },
  isDocumentTypeNode(node2) {
    return node2.nodeName === "#documentType";
  },
  isElementNode(node2) {
    return Object.prototype.hasOwnProperty.call(node2, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(node2, location3) {
    node2.sourceCodeLocation = location3;
  },
  getNodeSourceCodeLocation(node2) {
    return node2.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(node2, endLocation) {
    node2.sourceCodeLocation = { ...node2.sourceCodeLocation, ...endLocation };
  }
};

// node_modules/parse5/dist/common/doctype.js
var VALID_DOCTYPE_NAME = "html";
var VALID_SYSTEM_ID = "about:legacy-compat";
var QUIRKS_MODE_SYSTEM_ID = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
var QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
];
var QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
  ...QUIRKS_MODE_PUBLIC_ID_PREFIXES,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
var QUIRKS_MODE_PUBLIC_IDS = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]);
var LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"];
var LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
  ...LIMITED_QUIRKS_PUBLIC_ID_PREFIXES,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function hasPrefix(publicId, prefixes) {
  return prefixes.some((prefix) => publicId.startsWith(prefix));
}
function isConforming(token) {
  return token.name === VALID_DOCTYPE_NAME && token.publicId === null && (token.systemId === null || token.systemId === VALID_SYSTEM_ID);
}
function getDocumentMode(token) {
  if (token.name !== VALID_DOCTYPE_NAME) {
    return DOCUMENT_MODE.QUIRKS;
  }
  const { systemId } = token;
  if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
    return DOCUMENT_MODE.QUIRKS;
  }
  let { publicId } = token;
  if (publicId !== null) {
    publicId = publicId.toLowerCase();
    if (QUIRKS_MODE_PUBLIC_IDS.has(publicId)) {
      return DOCUMENT_MODE.QUIRKS;
    }
    let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return DOCUMENT_MODE.QUIRKS;
    }
    prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes)) {
      return DOCUMENT_MODE.LIMITED_QUIRKS;
    }
  }
  return DOCUMENT_MODE.NO_QUIRKS;
}

// node_modules/parse5/dist/common/foreign-content.js
var foreign_content_exports = {};
__export(foreign_content_exports, {
  SVG_TAG_NAMES_ADJUSTMENT_MAP: () => SVG_TAG_NAMES_ADJUSTMENT_MAP,
  adjustTokenMathMLAttrs: () => adjustTokenMathMLAttrs,
  adjustTokenSVGAttrs: () => adjustTokenSVGAttrs,
  adjustTokenSVGTagName: () => adjustTokenSVGTagName,
  adjustTokenXMLAttrs: () => adjustTokenXMLAttrs,
  causesExit: () => causesExit,
  isIntegrationPoint: () => isIntegrationPoint
});
var MIME_TYPES = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
};
var DEFINITION_URL_ATTR = "definitionurl";
var ADJUSTED_DEFINITION_URL_ATTR = "definitionURL";
var SVG_ATTRS_ADJUSTMENT_MAP = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((attr2) => [attr2.toLowerCase(), attr2]));
var XML_ATTRS_ADJUSTMENT_MAP = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: NS.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: NS.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: NS.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: NS.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: NS.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: NS.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: NS.XLINK }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: NS.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: NS.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: NS.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: NS.XMLNS }]
]);
var SVG_TAG_NAMES_ADJUSTMENT_MAP = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((tn) => [tn.toLowerCase(), tn]));
var EXITS_FOREIGN_CONTENT = /* @__PURE__ */ new Set([
  TAG_ID.B,
  TAG_ID.BIG,
  TAG_ID.BLOCKQUOTE,
  TAG_ID.BODY,
  TAG_ID.BR,
  TAG_ID.CENTER,
  TAG_ID.CODE,
  TAG_ID.DD,
  TAG_ID.DIV,
  TAG_ID.DL,
  TAG_ID.DT,
  TAG_ID.EM,
  TAG_ID.EMBED,
  TAG_ID.H1,
  TAG_ID.H2,
  TAG_ID.H3,
  TAG_ID.H4,
  TAG_ID.H5,
  TAG_ID.H6,
  TAG_ID.HEAD,
  TAG_ID.HR,
  TAG_ID.I,
  TAG_ID.IMG,
  TAG_ID.LI,
  TAG_ID.LISTING,
  TAG_ID.MENU,
  TAG_ID.META,
  TAG_ID.NOBR,
  TAG_ID.OL,
  TAG_ID.P,
  TAG_ID.PRE,
  TAG_ID.RUBY,
  TAG_ID.S,
  TAG_ID.SMALL,
  TAG_ID.SPAN,
  TAG_ID.STRONG,
  TAG_ID.STRIKE,
  TAG_ID.SUB,
  TAG_ID.SUP,
  TAG_ID.TABLE,
  TAG_ID.TT,
  TAG_ID.U,
  TAG_ID.UL,
  TAG_ID.VAR
]);
function causesExit(startTagToken) {
  const tn = startTagToken.tagID;
  const isFontWithAttrs = tn === TAG_ID.FONT && startTagToken.attrs.some(({ name: name2 }) => name2 === ATTRS.COLOR || name2 === ATTRS.SIZE || name2 === ATTRS.FACE);
  return isFontWithAttrs || EXITS_FOREIGN_CONTENT.has(tn);
}
function adjustTokenMathMLAttrs(token) {
  for (let i16 = 0; i16 < token.attrs.length; i16++) {
    if (token.attrs[i16].name === DEFINITION_URL_ATTR) {
      token.attrs[i16].name = ADJUSTED_DEFINITION_URL_ATTR;
      break;
    }
  }
}
function adjustTokenSVGAttrs(token) {
  for (let i16 = 0; i16 < token.attrs.length; i16++) {
    const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i16].name);
    if (adjustedAttrName != null) {
      token.attrs[i16].name = adjustedAttrName;
    }
  }
}
function adjustTokenXMLAttrs(token) {
  for (let i16 = 0; i16 < token.attrs.length; i16++) {
    const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i16].name);
    if (adjustedAttrEntry) {
      token.attrs[i16].prefix = adjustedAttrEntry.prefix;
      token.attrs[i16].name = adjustedAttrEntry.name;
      token.attrs[i16].namespace = adjustedAttrEntry.namespace;
    }
  }
}
function adjustTokenSVGTagName(token) {
  const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP.get(token.tagName);
  if (adjustedTagName != null) {
    token.tagName = adjustedTagName;
    token.tagID = getTagID(token.tagName);
  }
}
function isMathMLTextIntegrationPoint(tn, ns) {
  return ns === NS.MATHML && (tn === TAG_ID.MI || tn === TAG_ID.MO || tn === TAG_ID.MN || tn === TAG_ID.MS || tn === TAG_ID.MTEXT);
}
function isHtmlIntegrationPoint(tn, ns, attrs) {
  if (ns === NS.MATHML && tn === TAG_ID.ANNOTATION_XML) {
    for (let i16 = 0; i16 < attrs.length; i16++) {
      if (attrs[i16].name === ATTRS.ENCODING) {
        const value = attrs[i16].value.toLowerCase();
        return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
      }
    }
  }
  return ns === NS.SVG && (tn === TAG_ID.FOREIGN_OBJECT || tn === TAG_ID.DESC || tn === TAG_ID.TITLE);
}
function isIntegrationPoint(tn, ns, attrs, foreignNS) {
  return (!foreignNS || foreignNS === NS.HTML) && isHtmlIntegrationPoint(tn, ns, attrs) || (!foreignNS || foreignNS === NS.MATHML) && isMathMLTextIntegrationPoint(tn, ns);
}

// node_modules/parse5/dist/parser/index.js
var HIDDEN_INPUT_TYPE = "hidden";
var AA_OUTER_LOOP_ITER = 8;
var AA_INNER_LOOP_ITER = 3;
var InsertionMode;
(function(InsertionMode2) {
  InsertionMode2[InsertionMode2["INITIAL"] = 0] = "INITIAL";
  InsertionMode2[InsertionMode2["BEFORE_HTML"] = 1] = "BEFORE_HTML";
  InsertionMode2[InsertionMode2["BEFORE_HEAD"] = 2] = "BEFORE_HEAD";
  InsertionMode2[InsertionMode2["IN_HEAD"] = 3] = "IN_HEAD";
  InsertionMode2[InsertionMode2["IN_HEAD_NO_SCRIPT"] = 4] = "IN_HEAD_NO_SCRIPT";
  InsertionMode2[InsertionMode2["AFTER_HEAD"] = 5] = "AFTER_HEAD";
  InsertionMode2[InsertionMode2["IN_BODY"] = 6] = "IN_BODY";
  InsertionMode2[InsertionMode2["TEXT"] = 7] = "TEXT";
  InsertionMode2[InsertionMode2["IN_TABLE"] = 8] = "IN_TABLE";
  InsertionMode2[InsertionMode2["IN_TABLE_TEXT"] = 9] = "IN_TABLE_TEXT";
  InsertionMode2[InsertionMode2["IN_CAPTION"] = 10] = "IN_CAPTION";
  InsertionMode2[InsertionMode2["IN_COLUMN_GROUP"] = 11] = "IN_COLUMN_GROUP";
  InsertionMode2[InsertionMode2["IN_TABLE_BODY"] = 12] = "IN_TABLE_BODY";
  InsertionMode2[InsertionMode2["IN_ROW"] = 13] = "IN_ROW";
  InsertionMode2[InsertionMode2["IN_CELL"] = 14] = "IN_CELL";
  InsertionMode2[InsertionMode2["IN_SELECT"] = 15] = "IN_SELECT";
  InsertionMode2[InsertionMode2["IN_SELECT_IN_TABLE"] = 16] = "IN_SELECT_IN_TABLE";
  InsertionMode2[InsertionMode2["IN_TEMPLATE"] = 17] = "IN_TEMPLATE";
  InsertionMode2[InsertionMode2["AFTER_BODY"] = 18] = "AFTER_BODY";
  InsertionMode2[InsertionMode2["IN_FRAMESET"] = 19] = "IN_FRAMESET";
  InsertionMode2[InsertionMode2["AFTER_FRAMESET"] = 20] = "AFTER_FRAMESET";
  InsertionMode2[InsertionMode2["AFTER_AFTER_BODY"] = 21] = "AFTER_AFTER_BODY";
  InsertionMode2[InsertionMode2["AFTER_AFTER_FRAMESET"] = 22] = "AFTER_AFTER_FRAMESET";
})(InsertionMode || (InsertionMode = {}));
var BASE_LOC = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
};
var TABLE_STRUCTURE_TAGS = /* @__PURE__ */ new Set([TAG_ID.TABLE, TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TR]);
var defaultParserOptions = {
  scriptingEnabled: true,
  sourceCodeLocationInfo: false,
  treeAdapter: defaultTreeAdapter,
  onParseError: null
};
var Parser2 = class {
  constructor(options, document4, fragmentContext = null, scriptHandler = null) {
    this.fragmentContext = fragmentContext;
    this.scriptHandler = scriptHandler;
    this.currentToken = null;
    this.stopped = false;
    this.insertionMode = InsertionMode.INITIAL;
    this.originalInsertionMode = InsertionMode.INITIAL;
    this.headElement = null;
    this.formElement = null;
    this.currentNotInHTML = false;
    this.tmplInsertionModeStack = [];
    this.pendingCharacterTokens = [];
    this.hasNonWhitespacePendingCharacterToken = false;
    this.framesetOk = true;
    this.skipNextNewLine = false;
    this.fosterParentingEnabled = false;
    this.options = {
      ...defaultParserOptions,
      ...options
    };
    this.treeAdapter = this.options.treeAdapter;
    this.onParseError = this.options.onParseError;
    if (this.onParseError) {
      this.options.sourceCodeLocationInfo = true;
    }
    this.document = document4 !== null && document4 !== void 0 ? document4 : this.treeAdapter.createDocument();
    this.tokenizer = new Tokenizer(this.options, this);
    this.activeFormattingElements = new FormattingElementList(this.treeAdapter);
    this.fragmentContextID = fragmentContext ? getTagID(this.treeAdapter.getTagName(fragmentContext)) : TAG_ID.UNKNOWN;
    this._setContextModes(fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : this.document, this.fragmentContextID);
    this.openElements = new OpenElementStack(this.document, this.treeAdapter, this);
  }
  // API
  static parse(html8, options) {
    const parser = new this(options);
    parser.tokenizer.write(html8, true);
    return parser.document;
  }
  static getFragmentParser(fragmentContext, options) {
    const opts = {
      ...defaultParserOptions,
      ...options
    };
    fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : fragmentContext = opts.treeAdapter.createElement(TAG_NAMES.TEMPLATE, NS.HTML, []);
    const documentMock = opts.treeAdapter.createElement("documentmock", NS.HTML, []);
    const parser = new this(opts, documentMock, fragmentContext);
    if (parser.fragmentContextID === TAG_ID.TEMPLATE) {
      parser.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
    }
    parser._initTokenizerForFragmentParsing();
    parser._insertFakeRootElement();
    parser._resetInsertionMode();
    parser._findFormInFragmentContext();
    return parser;
  }
  getFragment() {
    const rootElement = this.treeAdapter.getFirstChild(this.document);
    const fragment2 = this.treeAdapter.createDocumentFragment();
    this._adoptNodes(rootElement, fragment2);
    return fragment2;
  }
  //Errors
  /** @internal */
  _err(token, code4, beforeToken) {
    var _a2;
    if (!this.onParseError)
      return;
    const loc = (_a2 = token.location) !== null && _a2 !== void 0 ? _a2 : BASE_LOC;
    const err = {
      code: code4,
      startLine: loc.startLine,
      startCol: loc.startCol,
      startOffset: loc.startOffset,
      endLine: beforeToken ? loc.startLine : loc.endLine,
      endCol: beforeToken ? loc.startCol : loc.endCol,
      endOffset: beforeToken ? loc.startOffset : loc.endOffset
    };
    this.onParseError(err);
  }
  //Stack events
  /** @internal */
  onItemPush(node2, tid, isTop) {
    var _a2, _b;
    (_b = (_a2 = this.treeAdapter).onItemPush) === null || _b === void 0 ? void 0 : _b.call(_a2, node2);
    if (isTop && this.openElements.stackTop > 0)
      this._setContextModes(node2, tid);
  }
  /** @internal */
  onItemPop(node2, isTop) {
    var _a2, _b;
    if (this.options.sourceCodeLocationInfo) {
      this._setEndLocation(node2, this.currentToken);
    }
    (_b = (_a2 = this.treeAdapter).onItemPop) === null || _b === void 0 ? void 0 : _b.call(_a2, node2, this.openElements.current);
    if (isTop) {
      let current;
      let currentTagId;
      if (this.openElements.stackTop === 0 && this.fragmentContext) {
        current = this.fragmentContext;
        currentTagId = this.fragmentContextID;
      } else {
        ({ current, currentTagId } = this.openElements);
      }
      this._setContextModes(current, currentTagId);
    }
  }
  _setContextModes(current, tid) {
    const isHTML = current === this.document || current && this.treeAdapter.getNamespaceURI(current) === NS.HTML;
    this.currentNotInHTML = !isHTML;
    this.tokenizer.inForeignNode = !isHTML && current !== void 0 && tid !== void 0 && !this._isIntegrationPoint(tid, current);
  }
  /** @protected */
  _switchToTextParsing(currentToken, nextTokenizerState) {
    this._insertElement(currentToken, NS.HTML);
    this.tokenizer.state = nextTokenizerState;
    this.originalInsertionMode = this.insertionMode;
    this.insertionMode = InsertionMode.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = InsertionMode.TEXT;
    this.originalInsertionMode = InsertionMode.IN_BODY;
    this.tokenizer.state = TokenizerMode.PLAINTEXT;
  }
  //Fragment parsing
  /** @protected */
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  /** @protected */
  _findFormInFragmentContext() {
    let node2 = this.fragmentContext;
    while (node2) {
      if (this.treeAdapter.getTagName(node2) === TAG_NAMES.FORM) {
        this.formElement = node2;
        break;
      }
      node2 = this.treeAdapter.getParentNode(node2);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== NS.HTML) {
      return;
    }
    switch (this.fragmentContextID) {
      case TAG_ID.TITLE:
      case TAG_ID.TEXTAREA: {
        this.tokenizer.state = TokenizerMode.RCDATA;
        break;
      }
      case TAG_ID.STYLE:
      case TAG_ID.XMP:
      case TAG_ID.IFRAME:
      case TAG_ID.NOEMBED:
      case TAG_ID.NOFRAMES:
      case TAG_ID.NOSCRIPT: {
        this.tokenizer.state = TokenizerMode.RAWTEXT;
        break;
      }
      case TAG_ID.SCRIPT: {
        this.tokenizer.state = TokenizerMode.SCRIPT_DATA;
        break;
      }
      case TAG_ID.PLAINTEXT: {
        this.tokenizer.state = TokenizerMode.PLAINTEXT;
        break;
      }
      default:
    }
  }
  //Tree mutation
  /** @protected */
  _setDocumentType(token) {
    const name2 = token.name || "";
    const publicId = token.publicId || "";
    const systemId = token.systemId || "";
    this.treeAdapter.setDocumentType(this.document, name2, publicId, systemId);
    if (token.location) {
      const documentChildren = this.treeAdapter.getChildNodes(this.document);
      const docTypeNode = documentChildren.find((node2) => this.treeAdapter.isDocumentTypeNode(node2));
      if (docTypeNode) {
        this.treeAdapter.setNodeSourceCodeLocation(docTypeNode, token.location);
      }
    }
  }
  /** @protected */
  _attachElementToTree(element5, location3) {
    if (this.options.sourceCodeLocationInfo) {
      const loc = location3 && {
        ...location3,
        startTag: location3
      };
      this.treeAdapter.setNodeSourceCodeLocation(element5, loc);
    }
    if (this._shouldFosterParentOnInsertion()) {
      this._fosterParentElement(element5);
    } else {
      const parent = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(parent !== null && parent !== void 0 ? parent : this.document, element5);
    }
  }
  /**
   * For self-closing tags. Add an element to the tree, but skip adding it
   * to the stack.
   */
  /** @protected */
  _appendElement(token, namespaceURI) {
    const element5 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
    this._attachElementToTree(element5, token.location);
  }
  /** @protected */
  _insertElement(token, namespaceURI) {
    const element5 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
    this._attachElementToTree(element5, token.location);
    this.openElements.push(element5, token.tagID);
  }
  /** @protected */
  _insertFakeElement(tagName, tagID) {
    const element5 = this.treeAdapter.createElement(tagName, NS.HTML, []);
    this._attachElementToTree(element5, null);
    this.openElements.push(element5, tagID);
  }
  /** @protected */
  _insertTemplate(token) {
    const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);
    const content3 = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(tmpl, content3);
    this._attachElementToTree(tmpl, token.location);
    this.openElements.push(tmpl, token.tagID);
    if (this.options.sourceCodeLocationInfo)
      this.treeAdapter.setNodeSourceCodeLocation(content3, null);
  }
  /** @protected */
  _insertFakeRootElement() {
    const element5 = this.treeAdapter.createElement(TAG_NAMES.HTML, NS.HTML, []);
    if (this.options.sourceCodeLocationInfo)
      this.treeAdapter.setNodeSourceCodeLocation(element5, null);
    this.treeAdapter.appendChild(this.openElements.current, element5);
    this.openElements.push(element5, TAG_ID.HTML);
  }
  /** @protected */
  _appendCommentNode(token, parent) {
    const commentNode = this.treeAdapter.createCommentNode(token.data);
    this.treeAdapter.appendChild(parent, commentNode);
    if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
    }
  }
  /** @protected */
  _insertCharacters(token) {
    let parent;
    let beforeElement;
    if (this._shouldFosterParentOnInsertion()) {
      ({ parent, beforeElement } = this._findFosterParentingLocation());
      if (beforeElement) {
        this.treeAdapter.insertTextBefore(parent, token.chars, beforeElement);
      } else {
        this.treeAdapter.insertText(parent, token.chars);
      }
    } else {
      parent = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.insertText(parent, token.chars);
    }
    if (!token.location)
      return;
    const siblings = this.treeAdapter.getChildNodes(parent);
    const textNodeIdx = beforeElement ? siblings.lastIndexOf(beforeElement) : siblings.length;
    const textNode = siblings[textNodeIdx - 1];
    const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
    if (tnLoc) {
      const { endLine, endCol, endOffset } = token.location;
      this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
    } else if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
    }
  }
  /** @protected */
  _adoptNodes(donor, recipient) {
    for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
      this.treeAdapter.detachNode(child);
      this.treeAdapter.appendChild(recipient, child);
    }
  }
  /** @protected */
  _setEndLocation(element5, closingToken) {
    if (this.treeAdapter.getNodeSourceCodeLocation(element5) && closingToken.location) {
      const ctLoc = closingToken.location;
      const tn = this.treeAdapter.getTagName(element5);
      const endLoc = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        closingToken.type === TokenType.END_TAG && tn === closingToken.tagName ? {
          endTag: { ...ctLoc },
          endLine: ctLoc.endLine,
          endCol: ctLoc.endCol,
          endOffset: ctLoc.endOffset
        } : {
          endLine: ctLoc.startLine,
          endCol: ctLoc.startCol,
          endOffset: ctLoc.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(element5, endLoc);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(token) {
    if (!this.currentNotInHTML)
      return false;
    let current;
    let currentTagId;
    if (this.openElements.stackTop === 0 && this.fragmentContext) {
      current = this.fragmentContext;
      currentTagId = this.fragmentContextID;
    } else {
      ({ current, currentTagId } = this.openElements);
    }
    if (token.tagID === TAG_ID.SVG && this.treeAdapter.getTagName(current) === TAG_NAMES.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(current) === NS.MATHML) {
      return false;
    }
    return (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (token.tagID === TAG_ID.MGLYPH || token.tagID === TAG_ID.MALIGNMARK) && currentTagId !== void 0 && !this._isIntegrationPoint(currentTagId, current, NS.HTML)
    );
  }
  /** @protected */
  _processToken(token) {
    switch (token.type) {
      case TokenType.CHARACTER: {
        this.onCharacter(token);
        break;
      }
      case TokenType.NULL_CHARACTER: {
        this.onNullCharacter(token);
        break;
      }
      case TokenType.COMMENT: {
        this.onComment(token);
        break;
      }
      case TokenType.DOCTYPE: {
        this.onDoctype(token);
        break;
      }
      case TokenType.START_TAG: {
        this._processStartTag(token);
        break;
      }
      case TokenType.END_TAG: {
        this.onEndTag(token);
        break;
      }
      case TokenType.EOF: {
        this.onEof(token);
        break;
      }
      case TokenType.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(token);
        break;
      }
    }
  }
  //Integration points
  /** @protected */
  _isIntegrationPoint(tid, element5, foreignNS) {
    const ns = this.treeAdapter.getNamespaceURI(element5);
    const attrs = this.treeAdapter.getAttrList(element5);
    return isIntegrationPoint(tid, ns, attrs, foreignNS);
  }
  //Active formatting elements reconstruction
  /** @protected */
  _reconstructActiveFormattingElements() {
    const listLength = this.activeFormattingElements.entries.length;
    if (listLength) {
      const endIndex = this.activeFormattingElements.entries.findIndex((entry) => entry.type === EntryType.Marker || this.openElements.contains(entry.element));
      const unopenIdx = endIndex === -1 ? listLength - 1 : endIndex - 1;
      for (let i16 = unopenIdx; i16 >= 0; i16--) {
        const entry = this.activeFormattingElements.entries[i16];
        this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
        entry.element = this.openElements.current;
      }
    }
  }
  //Close elements
  /** @protected */
  _closeTableCell() {
    this.openElements.generateImpliedEndTags();
    this.openElements.popUntilTableCellPopped();
    this.activeFormattingElements.clearToLastMarker();
    this.insertionMode = InsertionMode.IN_ROW;
  }
  /** @protected */
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.P);
    this.openElements.popUntilTagNamePopped(TAG_ID.P);
  }
  //Insertion modes
  /** @protected */
  _resetInsertionMode() {
    for (let i16 = this.openElements.stackTop; i16 >= 0; i16--) {
      switch (i16 === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[i16]) {
        case TAG_ID.TR: {
          this.insertionMode = InsertionMode.IN_ROW;
          return;
        }
        case TAG_ID.TBODY:
        case TAG_ID.THEAD:
        case TAG_ID.TFOOT: {
          this.insertionMode = InsertionMode.IN_TABLE_BODY;
          return;
        }
        case TAG_ID.CAPTION: {
          this.insertionMode = InsertionMode.IN_CAPTION;
          return;
        }
        case TAG_ID.COLGROUP: {
          this.insertionMode = InsertionMode.IN_COLUMN_GROUP;
          return;
        }
        case TAG_ID.TABLE: {
          this.insertionMode = InsertionMode.IN_TABLE;
          return;
        }
        case TAG_ID.BODY: {
          this.insertionMode = InsertionMode.IN_BODY;
          return;
        }
        case TAG_ID.FRAMESET: {
          this.insertionMode = InsertionMode.IN_FRAMESET;
          return;
        }
        case TAG_ID.SELECT: {
          this._resetInsertionModeForSelect(i16);
          return;
        }
        case TAG_ID.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case TAG_ID.HTML: {
          this.insertionMode = this.headElement ? InsertionMode.AFTER_HEAD : InsertionMode.BEFORE_HEAD;
          return;
        }
        case TAG_ID.TD:
        case TAG_ID.TH: {
          if (i16 > 0) {
            this.insertionMode = InsertionMode.IN_CELL;
            return;
          }
          break;
        }
        case TAG_ID.HEAD: {
          if (i16 > 0) {
            this.insertionMode = InsertionMode.IN_HEAD;
            return;
          }
          break;
        }
      }
    }
    this.insertionMode = InsertionMode.IN_BODY;
  }
  /** @protected */
  _resetInsertionModeForSelect(selectIdx) {
    if (selectIdx > 0) {
      for (let i16 = selectIdx - 1; i16 > 0; i16--) {
        const tn = this.openElements.tagIDs[i16];
        if (tn === TAG_ID.TEMPLATE) {
          break;
        } else if (tn === TAG_ID.TABLE) {
          this.insertionMode = InsertionMode.IN_SELECT_IN_TABLE;
          return;
        }
      }
    }
    this.insertionMode = InsertionMode.IN_SELECT;
  }
  //Foster parenting
  /** @protected */
  _isElementCausesFosterParenting(tn) {
    return TABLE_STRUCTURE_TAGS.has(tn);
  }
  /** @protected */
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this.openElements.currentTagId !== void 0 && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  /** @protected */
  _findFosterParentingLocation() {
    for (let i16 = this.openElements.stackTop; i16 >= 0; i16--) {
      const openElement = this.openElements.items[i16];
      switch (this.openElements.tagIDs[i16]) {
        case TAG_ID.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(openElement) === NS.HTML) {
            return { parent: this.treeAdapter.getTemplateContent(openElement), beforeElement: null };
          }
          break;
        }
        case TAG_ID.TABLE: {
          const parent = this.treeAdapter.getParentNode(openElement);
          if (parent) {
            return { parent, beforeElement: openElement };
          }
          return { parent: this.openElements.items[i16 - 1], beforeElement: null };
        }
        default:
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  /** @protected */
  _fosterParentElement(element5) {
    const location3 = this._findFosterParentingLocation();
    if (location3.beforeElement) {
      this.treeAdapter.insertBefore(location3.parent, element5, location3.beforeElement);
    } else {
      this.treeAdapter.appendChild(location3.parent, element5);
    }
  }
  //Special elements
  /** @protected */
  _isSpecialElement(element5, id) {
    const ns = this.treeAdapter.getNamespaceURI(element5);
    return SPECIAL_ELEMENTS[ns].has(id);
  }
  /** @internal */
  onCharacter(token) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      characterInForeignContent(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE: {
        characterInBody(this, token);
        break;
      }
      case InsertionMode.TEXT:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        characterInTableText(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token);
        break;
      }
      default:
    }
  }
  /** @internal */
  onNullCharacter(token) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      nullCharacterInForeignContent(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token);
        break;
      }
      default:
    }
  }
  /** @internal */
  onComment(token) {
    this.skipNextNewLine = false;
    if (this.currentNotInHTML) {
      appendComment(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL:
      case InsertionMode.BEFORE_HTML:
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        appendComment(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        appendCommentToRootHtmlElement(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        appendCommentToDocument(this, token);
        break;
      }
      default:
    }
  }
  /** @internal */
  onDoctype(token) {
    this.skipNextNewLine = false;
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        doctypeInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD: {
        this._err(token, ERR.misplacedDoctype);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      default:
    }
  }
  /** @internal */
  onStartTag(token) {
    this.skipNextNewLine = false;
    this.currentToken = token;
    this._processStartTag(token);
    if (token.selfClosing && !token.ackSelfClosing) {
      this._err(token, ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
    }
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   * @protected
   */
  _processStartTag(token) {
    if (this.shouldProcessStartTagTokenInForeignContent(token)) {
      startTagInForeignContent(this, token);
    } else {
      this._startTagOutsideForeignContent(token);
    }
  }
  /** @protected */
  _startTagOutsideForeignContent(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        startTagBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        startTagBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        startTagInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        startTagInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        startTagAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY: {
        startTagInBody(this, token);
        break;
      }
      case InsertionMode.IN_TABLE: {
        startTagInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        startTagInCaption(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        startTagInColumnGroup(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        startTagInTableBody(this, token);
        break;
      }
      case InsertionMode.IN_ROW: {
        startTagInRow(this, token);
        break;
      }
      case InsertionMode.IN_CELL: {
        startTagInCell(this, token);
        break;
      }
      case InsertionMode.IN_SELECT: {
        startTagInSelect(this, token);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        startTagInSelectInTable(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        startTagInTemplate(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        startTagAfterBody(this, token);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        startTagInFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        startTagAfterFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        startTagAfterAfterBody(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        startTagAfterAfterFrameset(this, token);
        break;
      }
      default:
    }
  }
  /** @internal */
  onEndTag(token) {
    this.skipNextNewLine = false;
    this.currentToken = token;
    if (this.currentNotInHTML) {
      endTagInForeignContent(this, token);
    } else {
      this._endTagOutsideForeignContent(token);
    }
  }
  /** @protected */
  _endTagOutsideForeignContent(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        endTagBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        endTagBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        endTagInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        endTagInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        endTagAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY: {
        endTagInBody(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        endTagInText(this, token);
        break;
      }
      case InsertionMode.IN_TABLE: {
        endTagInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        endTagInCaption(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        endTagInColumnGroup(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        endTagInTableBody(this, token);
        break;
      }
      case InsertionMode.IN_ROW: {
        endTagInRow(this, token);
        break;
      }
      case InsertionMode.IN_CELL: {
        endTagInCell(this, token);
        break;
      }
      case InsertionMode.IN_SELECT: {
        endTagInSelect(this, token);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        endTagInSelectInTable(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        endTagInTemplate(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        endTagAfterBody(this, token);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        endTagInFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        endTagAfterFrameset(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody(this, token);
        break;
      }
      default:
    }
  }
  /** @internal */
  onEof(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead(this, token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        eofInBody(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        eofInText(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        eofInTemplate(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        stopParsing(this, token);
        break;
      }
      default:
    }
  }
  /** @internal */
  onWhitespaceCharacter(token) {
    if (this.skipNextNewLine) {
      this.skipNextNewLine = false;
      if (token.chars.charCodeAt(0) === CODE_POINTS.LINE_FEED) {
        if (token.chars.length === 1) {
          return;
        }
        token.chars = token.chars.substr(1);
      }
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.TEXT:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.AFTER_BODY:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        whitespaceCharacterInBody(this, token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        whitespaceCharacterInTableText(this, token);
        break;
      }
      default:
    }
  }
};
function aaObtainFormattingElementEntry(p13, token) {
  let formattingElementEntry = p13.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
  if (formattingElementEntry) {
    if (!p13.openElements.contains(formattingElementEntry.element)) {
      p13.activeFormattingElements.removeEntry(formattingElementEntry);
      formattingElementEntry = null;
    } else if (!p13.openElements.hasInScope(token.tagID)) {
      formattingElementEntry = null;
    }
  } else {
    genericEndTagInBody(p13, token);
  }
  return formattingElementEntry;
}
function aaObtainFurthestBlock(p13, formattingElementEntry) {
  let furthestBlock = null;
  let idx = p13.openElements.stackTop;
  for (; idx >= 0; idx--) {
    const element5 = p13.openElements.items[idx];
    if (element5 === formattingElementEntry.element) {
      break;
    }
    if (p13._isSpecialElement(element5, p13.openElements.tagIDs[idx])) {
      furthestBlock = element5;
    }
  }
  if (!furthestBlock) {
    p13.openElements.shortenToLength(Math.max(idx, 0));
    p13.activeFormattingElements.removeEntry(formattingElementEntry);
  }
  return furthestBlock;
}
function aaInnerLoop(p13, furthestBlock, formattingElement) {
  let lastElement = furthestBlock;
  let nextElement = p13.openElements.getCommonAncestor(furthestBlock);
  for (let i16 = 0, element5 = nextElement; element5 !== formattingElement; i16++, element5 = nextElement) {
    nextElement = p13.openElements.getCommonAncestor(element5);
    const elementEntry = p13.activeFormattingElements.getElementEntry(element5);
    const counterOverflow = elementEntry && i16 >= AA_INNER_LOOP_ITER;
    const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
    if (shouldRemoveFromOpenElements) {
      if (counterOverflow) {
        p13.activeFormattingElements.removeEntry(elementEntry);
      }
      p13.openElements.remove(element5);
    } else {
      element5 = aaRecreateElementFromEntry(p13, elementEntry);
      if (lastElement === furthestBlock) {
        p13.activeFormattingElements.bookmark = elementEntry;
      }
      p13.treeAdapter.detachNode(lastElement);
      p13.treeAdapter.appendChild(element5, lastElement);
      lastElement = element5;
    }
  }
  return lastElement;
}
function aaRecreateElementFromEntry(p13, elementEntry) {
  const ns = p13.treeAdapter.getNamespaceURI(elementEntry.element);
  const newElement = p13.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
  p13.openElements.replace(elementEntry.element, newElement);
  elementEntry.element = newElement;
  return newElement;
}
function aaInsertLastNodeInCommonAncestor(p13, commonAncestor, lastElement) {
  const tn = p13.treeAdapter.getTagName(commonAncestor);
  const tid = getTagID(tn);
  if (p13._isElementCausesFosterParenting(tid)) {
    p13._fosterParentElement(lastElement);
  } else {
    const ns = p13.treeAdapter.getNamespaceURI(commonAncestor);
    if (tid === TAG_ID.TEMPLATE && ns === NS.HTML) {
      commonAncestor = p13.treeAdapter.getTemplateContent(commonAncestor);
    }
    p13.treeAdapter.appendChild(commonAncestor, lastElement);
  }
}
function aaReplaceFormattingElement(p13, furthestBlock, formattingElementEntry) {
  const ns = p13.treeAdapter.getNamespaceURI(formattingElementEntry.element);
  const { token } = formattingElementEntry;
  const newElement = p13.treeAdapter.createElement(token.tagName, ns, token.attrs);
  p13._adoptNodes(furthestBlock, newElement);
  p13.treeAdapter.appendChild(furthestBlock, newElement);
  p13.activeFormattingElements.insertElementAfterBookmark(newElement, token);
  p13.activeFormattingElements.removeEntry(formattingElementEntry);
  p13.openElements.remove(formattingElementEntry.element);
  p13.openElements.insertAfter(furthestBlock, newElement, token.tagID);
}
function callAdoptionAgency(p13, token) {
  for (let i16 = 0; i16 < AA_OUTER_LOOP_ITER; i16++) {
    const formattingElementEntry = aaObtainFormattingElementEntry(p13, token);
    if (!formattingElementEntry) {
      break;
    }
    const furthestBlock = aaObtainFurthestBlock(p13, formattingElementEntry);
    if (!furthestBlock) {
      break;
    }
    p13.activeFormattingElements.bookmark = formattingElementEntry;
    const lastElement = aaInnerLoop(p13, furthestBlock, formattingElementEntry.element);
    const commonAncestor = p13.openElements.getCommonAncestor(formattingElementEntry.element);
    p13.treeAdapter.detachNode(lastElement);
    if (commonAncestor)
      aaInsertLastNodeInCommonAncestor(p13, commonAncestor, lastElement);
    aaReplaceFormattingElement(p13, furthestBlock, formattingElementEntry);
  }
}
function appendComment(p13, token) {
  p13._appendCommentNode(token, p13.openElements.currentTmplContentOrNode);
}
function appendCommentToRootHtmlElement(p13, token) {
  p13._appendCommentNode(token, p13.openElements.items[0]);
}
function appendCommentToDocument(p13, token) {
  p13._appendCommentNode(token, p13.document);
}
function stopParsing(p13, token) {
  p13.stopped = true;
  if (token.location) {
    const target = p13.fragmentContext ? 0 : 2;
    for (let i16 = p13.openElements.stackTop; i16 >= target; i16--) {
      p13._setEndLocation(p13.openElements.items[i16], token);
    }
    if (!p13.fragmentContext && p13.openElements.stackTop >= 0) {
      const htmlElement = p13.openElements.items[0];
      const htmlLocation = p13.treeAdapter.getNodeSourceCodeLocation(htmlElement);
      if (htmlLocation && !htmlLocation.endTag) {
        p13._setEndLocation(htmlElement, token);
        if (p13.openElements.stackTop >= 1) {
          const bodyElement = p13.openElements.items[1];
          const bodyLocation = p13.treeAdapter.getNodeSourceCodeLocation(bodyElement);
          if (bodyLocation && !bodyLocation.endTag) {
            p13._setEndLocation(bodyElement, token);
          }
        }
      }
    }
  }
}
function doctypeInInitialMode(p13, token) {
  p13._setDocumentType(token);
  const mode = token.forceQuirks ? DOCUMENT_MODE.QUIRKS : getDocumentMode(token);
  if (!isConforming(token)) {
    p13._err(token, ERR.nonConformingDoctype);
  }
  p13.treeAdapter.setDocumentMode(p13.document, mode);
  p13.insertionMode = InsertionMode.BEFORE_HTML;
}
function tokenInInitialMode(p13, token) {
  p13._err(token, ERR.missingDoctype, true);
  p13.treeAdapter.setDocumentMode(p13.document, DOCUMENT_MODE.QUIRKS);
  p13.insertionMode = InsertionMode.BEFORE_HTML;
  p13._processToken(token);
}
function startTagBeforeHtml(p13, token) {
  if (token.tagID === TAG_ID.HTML) {
    p13._insertElement(token, NS.HTML);
    p13.insertionMode = InsertionMode.BEFORE_HEAD;
  } else {
    tokenBeforeHtml(p13, token);
  }
}
function endTagBeforeHtml(p13, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.HTML || tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.BR) {
    tokenBeforeHtml(p13, token);
  }
}
function tokenBeforeHtml(p13, token) {
  p13._insertFakeRootElement();
  p13.insertionMode = InsertionMode.BEFORE_HEAD;
  p13._processToken(token);
}
function startTagBeforeHead(p13, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p13, token);
      break;
    }
    case TAG_ID.HEAD: {
      p13._insertElement(token, NS.HTML);
      p13.headElement = p13.openElements.current;
      p13.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    default: {
      tokenBeforeHead(p13, token);
    }
  }
}
function endTagBeforeHead(p13, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.HTML || tn === TAG_ID.BR) {
    tokenBeforeHead(p13, token);
  } else {
    p13._err(token, ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenBeforeHead(p13, token) {
  p13._insertFakeElement(TAG_NAMES.HEAD, TAG_ID.HEAD);
  p13.headElement = p13.openElements.current;
  p13.insertionMode = InsertionMode.IN_HEAD;
  p13._processToken(token);
}
function startTagInHead(p13, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p13, token);
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META: {
      p13._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.TITLE: {
      p13._switchToTextParsing(token, TokenizerMode.RCDATA);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      if (p13.options.scriptingEnabled) {
        p13._switchToTextParsing(token, TokenizerMode.RAWTEXT);
      } else {
        p13._insertElement(token, NS.HTML);
        p13.insertionMode = InsertionMode.IN_HEAD_NO_SCRIPT;
      }
      break;
    }
    case TAG_ID.NOFRAMES:
    case TAG_ID.STYLE: {
      p13._switchToTextParsing(token, TokenizerMode.RAWTEXT);
      break;
    }
    case TAG_ID.SCRIPT: {
      p13._switchToTextParsing(token, TokenizerMode.SCRIPT_DATA);
      break;
    }
    case TAG_ID.TEMPLATE: {
      p13._insertTemplate(token);
      p13.activeFormattingElements.insertMarker();
      p13.framesetOk = false;
      p13.insertionMode = InsertionMode.IN_TEMPLATE;
      p13.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
      break;
    }
    case TAG_ID.HEAD: {
      p13._err(token, ERR.misplacedStartTagForHeadElement);
      break;
    }
    default: {
      tokenInHead(p13, token);
    }
  }
}
function endTagInHead(p13, token) {
  switch (token.tagID) {
    case TAG_ID.HEAD: {
      p13.openElements.pop();
      p13.insertionMode = InsertionMode.AFTER_HEAD;
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.BR:
    case TAG_ID.HTML: {
      tokenInHead(p13, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p13, token);
      break;
    }
    default: {
      p13._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function templateEndTagInHead(p13, token) {
  if (p13.openElements.tmplCount > 0) {
    p13.openElements.generateImpliedEndTagsThoroughly();
    if (p13.openElements.currentTagId !== TAG_ID.TEMPLATE) {
      p13._err(token, ERR.closingOfElementWithOpenChildElements);
    }
    p13.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
    p13.activeFormattingElements.clearToLastMarker();
    p13.tmplInsertionModeStack.shift();
    p13._resetInsertionMode();
  } else {
    p13._err(token, ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenInHead(p13, token) {
  p13.openElements.pop();
  p13.insertionMode = InsertionMode.AFTER_HEAD;
  p13._processToken(token);
}
function startTagInHeadNoScript(p13, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p13, token);
      break;
    }
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.HEAD:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.STYLE: {
      startTagInHead(p13, token);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      p13._err(token, ERR.nestedNoscriptInHead);
      break;
    }
    default: {
      tokenInHeadNoScript(p13, token);
    }
  }
}
function endTagInHeadNoScript(p13, token) {
  switch (token.tagID) {
    case TAG_ID.NOSCRIPT: {
      p13.openElements.pop();
      p13.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    case TAG_ID.BR: {
      tokenInHeadNoScript(p13, token);
      break;
    }
    default: {
      p13._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function tokenInHeadNoScript(p13, token) {
  const errCode = token.type === TokenType.EOF ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;
  p13._err(token, errCode);
  p13.openElements.pop();
  p13.insertionMode = InsertionMode.IN_HEAD;
  p13._processToken(token);
}
function startTagAfterHead(p13, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p13, token);
      break;
    }
    case TAG_ID.BODY: {
      p13._insertElement(token, NS.HTML);
      p13.framesetOk = false;
      p13.insertionMode = InsertionMode.IN_BODY;
      break;
    }
    case TAG_ID.FRAMESET: {
      p13._insertElement(token, NS.HTML);
      p13.insertionMode = InsertionMode.IN_FRAMESET;
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.SCRIPT:
    case TAG_ID.STYLE:
    case TAG_ID.TEMPLATE:
    case TAG_ID.TITLE: {
      p13._err(token, ERR.abandonedHeadElementChild);
      p13.openElements.push(p13.headElement, TAG_ID.HEAD);
      startTagInHead(p13, token);
      p13.openElements.remove(p13.headElement);
      break;
    }
    case TAG_ID.HEAD: {
      p13._err(token, ERR.misplacedStartTagForHeadElement);
      break;
    }
    default: {
      tokenAfterHead(p13, token);
    }
  }
}
function endTagAfterHead(p13, token) {
  switch (token.tagID) {
    case TAG_ID.BODY:
    case TAG_ID.HTML:
    case TAG_ID.BR: {
      tokenAfterHead(p13, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p13, token);
      break;
    }
    default: {
      p13._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function tokenAfterHead(p13, token) {
  p13._insertFakeElement(TAG_NAMES.BODY, TAG_ID.BODY);
  p13.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p13, token);
}
function modeInBody(p13, token) {
  switch (token.type) {
    case TokenType.CHARACTER: {
      characterInBody(p13, token);
      break;
    }
    case TokenType.WHITESPACE_CHARACTER: {
      whitespaceCharacterInBody(p13, token);
      break;
    }
    case TokenType.COMMENT: {
      appendComment(p13, token);
      break;
    }
    case TokenType.START_TAG: {
      startTagInBody(p13, token);
      break;
    }
    case TokenType.END_TAG: {
      endTagInBody(p13, token);
      break;
    }
    case TokenType.EOF: {
      eofInBody(p13, token);
      break;
    }
    default:
  }
}
function whitespaceCharacterInBody(p13, token) {
  p13._reconstructActiveFormattingElements();
  p13._insertCharacters(token);
}
function characterInBody(p13, token) {
  p13._reconstructActiveFormattingElements();
  p13._insertCharacters(token);
  p13.framesetOk = false;
}
function htmlStartTagInBody(p13, token) {
  if (p13.openElements.tmplCount === 0) {
    p13.treeAdapter.adoptAttributes(p13.openElements.items[0], token.attrs);
  }
}
function bodyStartTagInBody(p13, token) {
  const bodyElement = p13.openElements.tryPeekProperlyNestedBodyElement();
  if (bodyElement && p13.openElements.tmplCount === 0) {
    p13.framesetOk = false;
    p13.treeAdapter.adoptAttributes(bodyElement, token.attrs);
  }
}
function framesetStartTagInBody(p13, token) {
  const bodyElement = p13.openElements.tryPeekProperlyNestedBodyElement();
  if (p13.framesetOk && bodyElement) {
    p13.treeAdapter.detachNode(bodyElement);
    p13.openElements.popAllUpToHtmlElement();
    p13._insertElement(token, NS.HTML);
    p13.insertionMode = InsertionMode.IN_FRAMESET;
  }
}
function addressStartTagInBody(p13, token) {
  if (p13.openElements.hasInButtonScope(TAG_ID.P)) {
    p13._closePElement();
  }
  p13._insertElement(token, NS.HTML);
}
function numberedHeaderStartTagInBody(p13, token) {
  if (p13.openElements.hasInButtonScope(TAG_ID.P)) {
    p13._closePElement();
  }
  if (p13.openElements.currentTagId !== void 0 && NUMBERED_HEADERS.has(p13.openElements.currentTagId)) {
    p13.openElements.pop();
  }
  p13._insertElement(token, NS.HTML);
}
function preStartTagInBody(p13, token) {
  if (p13.openElements.hasInButtonScope(TAG_ID.P)) {
    p13._closePElement();
  }
  p13._insertElement(token, NS.HTML);
  p13.skipNextNewLine = true;
  p13.framesetOk = false;
}
function formStartTagInBody(p13, token) {
  const inTemplate = p13.openElements.tmplCount > 0;
  if (!p13.formElement || inTemplate) {
    if (p13.openElements.hasInButtonScope(TAG_ID.P)) {
      p13._closePElement();
    }
    p13._insertElement(token, NS.HTML);
    if (!inTemplate) {
      p13.formElement = p13.openElements.current;
    }
  }
}
function listItemStartTagInBody(p13, token) {
  p13.framesetOk = false;
  const tn = token.tagID;
  for (let i16 = p13.openElements.stackTop; i16 >= 0; i16--) {
    const elementId = p13.openElements.tagIDs[i16];
    if (tn === TAG_ID.LI && elementId === TAG_ID.LI || (tn === TAG_ID.DD || tn === TAG_ID.DT) && (elementId === TAG_ID.DD || elementId === TAG_ID.DT)) {
      p13.openElements.generateImpliedEndTagsWithExclusion(elementId);
      p13.openElements.popUntilTagNamePopped(elementId);
      break;
    }
    if (elementId !== TAG_ID.ADDRESS && elementId !== TAG_ID.DIV && elementId !== TAG_ID.P && p13._isSpecialElement(p13.openElements.items[i16], elementId)) {
      break;
    }
  }
  if (p13.openElements.hasInButtonScope(TAG_ID.P)) {
    p13._closePElement();
  }
  p13._insertElement(token, NS.HTML);
}
function plaintextStartTagInBody(p13, token) {
  if (p13.openElements.hasInButtonScope(TAG_ID.P)) {
    p13._closePElement();
  }
  p13._insertElement(token, NS.HTML);
  p13.tokenizer.state = TokenizerMode.PLAINTEXT;
}
function buttonStartTagInBody(p13, token) {
  if (p13.openElements.hasInScope(TAG_ID.BUTTON)) {
    p13.openElements.generateImpliedEndTags();
    p13.openElements.popUntilTagNamePopped(TAG_ID.BUTTON);
  }
  p13._reconstructActiveFormattingElements();
  p13._insertElement(token, NS.HTML);
  p13.framesetOk = false;
}
function aStartTagInBody(p13, token) {
  const activeElementEntry = p13.activeFormattingElements.getElementEntryInScopeWithTagName(TAG_NAMES.A);
  if (activeElementEntry) {
    callAdoptionAgency(p13, token);
    p13.openElements.remove(activeElementEntry.element);
    p13.activeFormattingElements.removeEntry(activeElementEntry);
  }
  p13._reconstructActiveFormattingElements();
  p13._insertElement(token, NS.HTML);
  p13.activeFormattingElements.pushElement(p13.openElements.current, token);
}
function bStartTagInBody(p13, token) {
  p13._reconstructActiveFormattingElements();
  p13._insertElement(token, NS.HTML);
  p13.activeFormattingElements.pushElement(p13.openElements.current, token);
}
function nobrStartTagInBody(p13, token) {
  p13._reconstructActiveFormattingElements();
  if (p13.openElements.hasInScope(TAG_ID.NOBR)) {
    callAdoptionAgency(p13, token);
    p13._reconstructActiveFormattingElements();
  }
  p13._insertElement(token, NS.HTML);
  p13.activeFormattingElements.pushElement(p13.openElements.current, token);
}
function appletStartTagInBody(p13, token) {
  p13._reconstructActiveFormattingElements();
  p13._insertElement(token, NS.HTML);
  p13.activeFormattingElements.insertMarker();
  p13.framesetOk = false;
}
function tableStartTagInBody(p13, token) {
  if (p13.treeAdapter.getDocumentMode(p13.document) !== DOCUMENT_MODE.QUIRKS && p13.openElements.hasInButtonScope(TAG_ID.P)) {
    p13._closePElement();
  }
  p13._insertElement(token, NS.HTML);
  p13.framesetOk = false;
  p13.insertionMode = InsertionMode.IN_TABLE;
}
function areaStartTagInBody(p13, token) {
  p13._reconstructActiveFormattingElements();
  p13._appendElement(token, NS.HTML);
  p13.framesetOk = false;
  token.ackSelfClosing = true;
}
function isHiddenInput(token) {
  const inputType = getTokenAttr(token, ATTRS.TYPE);
  return inputType != null && inputType.toLowerCase() === HIDDEN_INPUT_TYPE;
}
function inputStartTagInBody(p13, token) {
  p13._reconstructActiveFormattingElements();
  p13._appendElement(token, NS.HTML);
  if (!isHiddenInput(token)) {
    p13.framesetOk = false;
  }
  token.ackSelfClosing = true;
}
function paramStartTagInBody(p13, token) {
  p13._appendElement(token, NS.HTML);
  token.ackSelfClosing = true;
}
function hrStartTagInBody(p13, token) {
  if (p13.openElements.hasInButtonScope(TAG_ID.P)) {
    p13._closePElement();
  }
  p13._appendElement(token, NS.HTML);
  p13.framesetOk = false;
  token.ackSelfClosing = true;
}
function imageStartTagInBody(p13, token) {
  token.tagName = TAG_NAMES.IMG;
  token.tagID = TAG_ID.IMG;
  areaStartTagInBody(p13, token);
}
function textareaStartTagInBody(p13, token) {
  p13._insertElement(token, NS.HTML);
  p13.skipNextNewLine = true;
  p13.tokenizer.state = TokenizerMode.RCDATA;
  p13.originalInsertionMode = p13.insertionMode;
  p13.framesetOk = false;
  p13.insertionMode = InsertionMode.TEXT;
}
function xmpStartTagInBody(p13, token) {
  if (p13.openElements.hasInButtonScope(TAG_ID.P)) {
    p13._closePElement();
  }
  p13._reconstructActiveFormattingElements();
  p13.framesetOk = false;
  p13._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function iframeStartTagInBody(p13, token) {
  p13.framesetOk = false;
  p13._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function rawTextStartTagInBody(p13, token) {
  p13._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function selectStartTagInBody(p13, token) {
  p13._reconstructActiveFormattingElements();
  p13._insertElement(token, NS.HTML);
  p13.framesetOk = false;
  p13.insertionMode = p13.insertionMode === InsertionMode.IN_TABLE || p13.insertionMode === InsertionMode.IN_CAPTION || p13.insertionMode === InsertionMode.IN_TABLE_BODY || p13.insertionMode === InsertionMode.IN_ROW || p13.insertionMode === InsertionMode.IN_CELL ? InsertionMode.IN_SELECT_IN_TABLE : InsertionMode.IN_SELECT;
}
function optgroupStartTagInBody(p13, token) {
  if (p13.openElements.currentTagId === TAG_ID.OPTION) {
    p13.openElements.pop();
  }
  p13._reconstructActiveFormattingElements();
  p13._insertElement(token, NS.HTML);
}
function rbStartTagInBody(p13, token) {
  if (p13.openElements.hasInScope(TAG_ID.RUBY)) {
    p13.openElements.generateImpliedEndTags();
  }
  p13._insertElement(token, NS.HTML);
}
function rtStartTagInBody(p13, token) {
  if (p13.openElements.hasInScope(TAG_ID.RUBY)) {
    p13.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.RTC);
  }
  p13._insertElement(token, NS.HTML);
}
function mathStartTagInBody(p13, token) {
  p13._reconstructActiveFormattingElements();
  adjustTokenMathMLAttrs(token);
  adjustTokenXMLAttrs(token);
  if (token.selfClosing) {
    p13._appendElement(token, NS.MATHML);
  } else {
    p13._insertElement(token, NS.MATHML);
  }
  token.ackSelfClosing = true;
}
function svgStartTagInBody(p13, token) {
  p13._reconstructActiveFormattingElements();
  adjustTokenSVGAttrs(token);
  adjustTokenXMLAttrs(token);
  if (token.selfClosing) {
    p13._appendElement(token, NS.SVG);
  } else {
    p13._insertElement(token, NS.SVG);
  }
  token.ackSelfClosing = true;
}
function genericStartTagInBody(p13, token) {
  p13._reconstructActiveFormattingElements();
  p13._insertElement(token, NS.HTML);
}
function startTagInBody(p13, token) {
  switch (token.tagID) {
    case TAG_ID.I:
    case TAG_ID.S:
    case TAG_ID.B:
    case TAG_ID.U:
    case TAG_ID.EM:
    case TAG_ID.TT:
    case TAG_ID.BIG:
    case TAG_ID.CODE:
    case TAG_ID.FONT:
    case TAG_ID.SMALL:
    case TAG_ID.STRIKE:
    case TAG_ID.STRONG: {
      bStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.A: {
      aStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.H1:
    case TAG_ID.H2:
    case TAG_ID.H3:
    case TAG_ID.H4:
    case TAG_ID.H5:
    case TAG_ID.H6: {
      numberedHeaderStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.P:
    case TAG_ID.DL:
    case TAG_ID.OL:
    case TAG_ID.UL:
    case TAG_ID.DIV:
    case TAG_ID.DIR:
    case TAG_ID.NAV:
    case TAG_ID.MAIN:
    case TAG_ID.MENU:
    case TAG_ID.ASIDE:
    case TAG_ID.CENTER:
    case TAG_ID.FIGURE:
    case TAG_ID.FOOTER:
    case TAG_ID.HEADER:
    case TAG_ID.HGROUP:
    case TAG_ID.DIALOG:
    case TAG_ID.DETAILS:
    case TAG_ID.ADDRESS:
    case TAG_ID.ARTICLE:
    case TAG_ID.SEARCH:
    case TAG_ID.SECTION:
    case TAG_ID.SUMMARY:
    case TAG_ID.FIELDSET:
    case TAG_ID.BLOCKQUOTE:
    case TAG_ID.FIGCAPTION: {
      addressStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.LI:
    case TAG_ID.DD:
    case TAG_ID.DT: {
      listItemStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.BR:
    case TAG_ID.IMG:
    case TAG_ID.WBR:
    case TAG_ID.AREA:
    case TAG_ID.EMBED:
    case TAG_ID.KEYGEN: {
      areaStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.HR: {
      hrStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.RB:
    case TAG_ID.RTC: {
      rbStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.RT:
    case TAG_ID.RP: {
      rtStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.PRE:
    case TAG_ID.LISTING: {
      preStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.XMP: {
      xmpStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.SVG: {
      svgStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.HTML: {
      htmlStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.STYLE:
    case TAG_ID.TITLE:
    case TAG_ID.SCRIPT:
    case TAG_ID.BGSOUND:
    case TAG_ID.BASEFONT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(p13, token);
      break;
    }
    case TAG_ID.BODY: {
      bodyStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.FORM: {
      formStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.NOBR: {
      nobrStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.MATH: {
      mathStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.TABLE: {
      tableStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.INPUT: {
      inputStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.PARAM:
    case TAG_ID.TRACK:
    case TAG_ID.SOURCE: {
      paramStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.IMAGE: {
      imageStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.BUTTON: {
      buttonStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.APPLET:
    case TAG_ID.OBJECT:
    case TAG_ID.MARQUEE: {
      appletStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.IFRAME: {
      iframeStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.SELECT: {
      selectStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.OPTION:
    case TAG_ID.OPTGROUP: {
      optgroupStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.NOEMBED:
    case TAG_ID.NOFRAMES: {
      rawTextStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.FRAMESET: {
      framesetStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.TEXTAREA: {
      textareaStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      if (p13.options.scriptingEnabled) {
        rawTextStartTagInBody(p13, token);
      } else {
        genericStartTagInBody(p13, token);
      }
      break;
    }
    case TAG_ID.PLAINTEXT: {
      plaintextStartTagInBody(p13, token);
      break;
    }
    case TAG_ID.COL:
    case TAG_ID.TH:
    case TAG_ID.TD:
    case TAG_ID.TR:
    case TAG_ID.HEAD:
    case TAG_ID.FRAME:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.CAPTION:
    case TAG_ID.COLGROUP: {
      break;
    }
    default: {
      genericStartTagInBody(p13, token);
    }
  }
}
function bodyEndTagInBody(p13, token) {
  if (p13.openElements.hasInScope(TAG_ID.BODY)) {
    p13.insertionMode = InsertionMode.AFTER_BODY;
    if (p13.options.sourceCodeLocationInfo) {
      const bodyElement = p13.openElements.tryPeekProperlyNestedBodyElement();
      if (bodyElement) {
        p13._setEndLocation(bodyElement, token);
      }
    }
  }
}
function htmlEndTagInBody(p13, token) {
  if (p13.openElements.hasInScope(TAG_ID.BODY)) {
    p13.insertionMode = InsertionMode.AFTER_BODY;
    endTagAfterBody(p13, token);
  }
}
function addressEndTagInBody(p13, token) {
  const tn = token.tagID;
  if (p13.openElements.hasInScope(tn)) {
    p13.openElements.generateImpliedEndTags();
    p13.openElements.popUntilTagNamePopped(tn);
  }
}
function formEndTagInBody(p13) {
  const inTemplate = p13.openElements.tmplCount > 0;
  const { formElement } = p13;
  if (!inTemplate) {
    p13.formElement = null;
  }
  if ((formElement || inTemplate) && p13.openElements.hasInScope(TAG_ID.FORM)) {
    p13.openElements.generateImpliedEndTags();
    if (inTemplate) {
      p13.openElements.popUntilTagNamePopped(TAG_ID.FORM);
    } else if (formElement) {
      p13.openElements.remove(formElement);
    }
  }
}
function pEndTagInBody(p13) {
  if (!p13.openElements.hasInButtonScope(TAG_ID.P)) {
    p13._insertFakeElement(TAG_NAMES.P, TAG_ID.P);
  }
  p13._closePElement();
}
function liEndTagInBody(p13) {
  if (p13.openElements.hasInListItemScope(TAG_ID.LI)) {
    p13.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.LI);
    p13.openElements.popUntilTagNamePopped(TAG_ID.LI);
  }
}
function ddEndTagInBody(p13, token) {
  const tn = token.tagID;
  if (p13.openElements.hasInScope(tn)) {
    p13.openElements.generateImpliedEndTagsWithExclusion(tn);
    p13.openElements.popUntilTagNamePopped(tn);
  }
}
function numberedHeaderEndTagInBody(p13) {
  if (p13.openElements.hasNumberedHeaderInScope()) {
    p13.openElements.generateImpliedEndTags();
    p13.openElements.popUntilNumberedHeaderPopped();
  }
}
function appletEndTagInBody(p13, token) {
  const tn = token.tagID;
  if (p13.openElements.hasInScope(tn)) {
    p13.openElements.generateImpliedEndTags();
    p13.openElements.popUntilTagNamePopped(tn);
    p13.activeFormattingElements.clearToLastMarker();
  }
}
function brEndTagInBody(p13) {
  p13._reconstructActiveFormattingElements();
  p13._insertFakeElement(TAG_NAMES.BR, TAG_ID.BR);
  p13.openElements.pop();
  p13.framesetOk = false;
}
function genericEndTagInBody(p13, token) {
  const tn = token.tagName;
  const tid = token.tagID;
  for (let i16 = p13.openElements.stackTop; i16 > 0; i16--) {
    const element5 = p13.openElements.items[i16];
    const elementId = p13.openElements.tagIDs[i16];
    if (tid === elementId && (tid !== TAG_ID.UNKNOWN || p13.treeAdapter.getTagName(element5) === tn)) {
      p13.openElements.generateImpliedEndTagsWithExclusion(tid);
      if (p13.openElements.stackTop >= i16)
        p13.openElements.shortenToLength(i16);
      break;
    }
    if (p13._isSpecialElement(element5, elementId)) {
      break;
    }
  }
}
function endTagInBody(p13, token) {
  switch (token.tagID) {
    case TAG_ID.A:
    case TAG_ID.B:
    case TAG_ID.I:
    case TAG_ID.S:
    case TAG_ID.U:
    case TAG_ID.EM:
    case TAG_ID.TT:
    case TAG_ID.BIG:
    case TAG_ID.CODE:
    case TAG_ID.FONT:
    case TAG_ID.NOBR:
    case TAG_ID.SMALL:
    case TAG_ID.STRIKE:
    case TAG_ID.STRONG: {
      callAdoptionAgency(p13, token);
      break;
    }
    case TAG_ID.P: {
      pEndTagInBody(p13);
      break;
    }
    case TAG_ID.DL:
    case TAG_ID.UL:
    case TAG_ID.OL:
    case TAG_ID.DIR:
    case TAG_ID.DIV:
    case TAG_ID.NAV:
    case TAG_ID.PRE:
    case TAG_ID.MAIN:
    case TAG_ID.MENU:
    case TAG_ID.ASIDE:
    case TAG_ID.BUTTON:
    case TAG_ID.CENTER:
    case TAG_ID.FIGURE:
    case TAG_ID.FOOTER:
    case TAG_ID.HEADER:
    case TAG_ID.HGROUP:
    case TAG_ID.DIALOG:
    case TAG_ID.ADDRESS:
    case TAG_ID.ARTICLE:
    case TAG_ID.DETAILS:
    case TAG_ID.SEARCH:
    case TAG_ID.SECTION:
    case TAG_ID.SUMMARY:
    case TAG_ID.LISTING:
    case TAG_ID.FIELDSET:
    case TAG_ID.BLOCKQUOTE:
    case TAG_ID.FIGCAPTION: {
      addressEndTagInBody(p13, token);
      break;
    }
    case TAG_ID.LI: {
      liEndTagInBody(p13);
      break;
    }
    case TAG_ID.DD:
    case TAG_ID.DT: {
      ddEndTagInBody(p13, token);
      break;
    }
    case TAG_ID.H1:
    case TAG_ID.H2:
    case TAG_ID.H3:
    case TAG_ID.H4:
    case TAG_ID.H5:
    case TAG_ID.H6: {
      numberedHeaderEndTagInBody(p13);
      break;
    }
    case TAG_ID.BR: {
      brEndTagInBody(p13);
      break;
    }
    case TAG_ID.BODY: {
      bodyEndTagInBody(p13, token);
      break;
    }
    case TAG_ID.HTML: {
      htmlEndTagInBody(p13, token);
      break;
    }
    case TAG_ID.FORM: {
      formEndTagInBody(p13);
      break;
    }
    case TAG_ID.APPLET:
    case TAG_ID.OBJECT:
    case TAG_ID.MARQUEE: {
      appletEndTagInBody(p13, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p13, token);
      break;
    }
    default: {
      genericEndTagInBody(p13, token);
    }
  }
}
function eofInBody(p13, token) {
  if (p13.tmplInsertionModeStack.length > 0) {
    eofInTemplate(p13, token);
  } else {
    stopParsing(p13, token);
  }
}
function endTagInText(p13, token) {
  var _a2;
  if (token.tagID === TAG_ID.SCRIPT) {
    (_a2 = p13.scriptHandler) === null || _a2 === void 0 ? void 0 : _a2.call(p13, p13.openElements.current);
  }
  p13.openElements.pop();
  p13.insertionMode = p13.originalInsertionMode;
}
function eofInText(p13, token) {
  p13._err(token, ERR.eofInElementThatCanContainOnlyText);
  p13.openElements.pop();
  p13.insertionMode = p13.originalInsertionMode;
  p13.onEof(token);
}
function characterInTable(p13, token) {
  if (p13.openElements.currentTagId !== void 0 && TABLE_STRUCTURE_TAGS.has(p13.openElements.currentTagId)) {
    p13.pendingCharacterTokens.length = 0;
    p13.hasNonWhitespacePendingCharacterToken = false;
    p13.originalInsertionMode = p13.insertionMode;
    p13.insertionMode = InsertionMode.IN_TABLE_TEXT;
    switch (token.type) {
      case TokenType.CHARACTER: {
        characterInTableText(p13, token);
        break;
      }
      case TokenType.WHITESPACE_CHARACTER: {
        whitespaceCharacterInTableText(p13, token);
        break;
      }
    }
  } else {
    tokenInTable(p13, token);
  }
}
function captionStartTagInTable(p13, token) {
  p13.openElements.clearBackToTableContext();
  p13.activeFormattingElements.insertMarker();
  p13._insertElement(token, NS.HTML);
  p13.insertionMode = InsertionMode.IN_CAPTION;
}
function colgroupStartTagInTable(p13, token) {
  p13.openElements.clearBackToTableContext();
  p13._insertElement(token, NS.HTML);
  p13.insertionMode = InsertionMode.IN_COLUMN_GROUP;
}
function colStartTagInTable(p13, token) {
  p13.openElements.clearBackToTableContext();
  p13._insertFakeElement(TAG_NAMES.COLGROUP, TAG_ID.COLGROUP);
  p13.insertionMode = InsertionMode.IN_COLUMN_GROUP;
  startTagInColumnGroup(p13, token);
}
function tbodyStartTagInTable(p13, token) {
  p13.openElements.clearBackToTableContext();
  p13._insertElement(token, NS.HTML);
  p13.insertionMode = InsertionMode.IN_TABLE_BODY;
}
function tdStartTagInTable(p13, token) {
  p13.openElements.clearBackToTableContext();
  p13._insertFakeElement(TAG_NAMES.TBODY, TAG_ID.TBODY);
  p13.insertionMode = InsertionMode.IN_TABLE_BODY;
  startTagInTableBody(p13, token);
}
function tableStartTagInTable(p13, token) {
  if (p13.openElements.hasInTableScope(TAG_ID.TABLE)) {
    p13.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
    p13._resetInsertionMode();
    p13._processStartTag(token);
  }
}
function inputStartTagInTable(p13, token) {
  if (isHiddenInput(token)) {
    p13._appendElement(token, NS.HTML);
  } else {
    tokenInTable(p13, token);
  }
  token.ackSelfClosing = true;
}
function formStartTagInTable(p13, token) {
  if (!p13.formElement && p13.openElements.tmplCount === 0) {
    p13._insertElement(token, NS.HTML);
    p13.formElement = p13.openElements.current;
    p13.openElements.pop();
  }
}
function startTagInTable(p13, token) {
  switch (token.tagID) {
    case TAG_ID.TD:
    case TAG_ID.TH:
    case TAG_ID.TR: {
      tdStartTagInTable(p13, token);
      break;
    }
    case TAG_ID.STYLE:
    case TAG_ID.SCRIPT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(p13, token);
      break;
    }
    case TAG_ID.COL: {
      colStartTagInTable(p13, token);
      break;
    }
    case TAG_ID.FORM: {
      formStartTagInTable(p13, token);
      break;
    }
    case TAG_ID.TABLE: {
      tableStartTagInTable(p13, token);
      break;
    }
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      tbodyStartTagInTable(p13, token);
      break;
    }
    case TAG_ID.INPUT: {
      inputStartTagInTable(p13, token);
      break;
    }
    case TAG_ID.CAPTION: {
      captionStartTagInTable(p13, token);
      break;
    }
    case TAG_ID.COLGROUP: {
      colgroupStartTagInTable(p13, token);
      break;
    }
    default: {
      tokenInTable(p13, token);
    }
  }
}
function endTagInTable(p13, token) {
  switch (token.tagID) {
    case TAG_ID.TABLE: {
      if (p13.openElements.hasInTableScope(TAG_ID.TABLE)) {
        p13.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
        p13._resetInsertionMode();
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p13, token);
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TBODY:
    case TAG_ID.TD:
    case TAG_ID.TFOOT:
    case TAG_ID.TH:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      break;
    }
    default: {
      tokenInTable(p13, token);
    }
  }
}
function tokenInTable(p13, token) {
  const savedFosterParentingState = p13.fosterParentingEnabled;
  p13.fosterParentingEnabled = true;
  modeInBody(p13, token);
  p13.fosterParentingEnabled = savedFosterParentingState;
}
function whitespaceCharacterInTableText(p13, token) {
  p13.pendingCharacterTokens.push(token);
}
function characterInTableText(p13, token) {
  p13.pendingCharacterTokens.push(token);
  p13.hasNonWhitespacePendingCharacterToken = true;
}
function tokenInTableText(p13, token) {
  let i16 = 0;
  if (p13.hasNonWhitespacePendingCharacterToken) {
    for (; i16 < p13.pendingCharacterTokens.length; i16++) {
      tokenInTable(p13, p13.pendingCharacterTokens[i16]);
    }
  } else {
    for (; i16 < p13.pendingCharacterTokens.length; i16++) {
      p13._insertCharacters(p13.pendingCharacterTokens[i16]);
    }
  }
  p13.insertionMode = p13.originalInsertionMode;
  p13._processToken(token);
}
var TABLE_VOID_ELEMENTS = /* @__PURE__ */ new Set([TAG_ID.CAPTION, TAG_ID.COL, TAG_ID.COLGROUP, TAG_ID.TBODY, TAG_ID.TD, TAG_ID.TFOOT, TAG_ID.TH, TAG_ID.THEAD, TAG_ID.TR]);
function startTagInCaption(p13, token) {
  const tn = token.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn)) {
    if (p13.openElements.hasInTableScope(TAG_ID.CAPTION)) {
      p13.openElements.generateImpliedEndTags();
      p13.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
      p13.activeFormattingElements.clearToLastMarker();
      p13.insertionMode = InsertionMode.IN_TABLE;
      startTagInTable(p13, token);
    }
  } else {
    startTagInBody(p13, token);
  }
}
function endTagInCaption(p13, token) {
  const tn = token.tagID;
  switch (tn) {
    case TAG_ID.CAPTION:
    case TAG_ID.TABLE: {
      if (p13.openElements.hasInTableScope(TAG_ID.CAPTION)) {
        p13.openElements.generateImpliedEndTags();
        p13.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
        p13.activeFormattingElements.clearToLastMarker();
        p13.insertionMode = InsertionMode.IN_TABLE;
        if (tn === TAG_ID.TABLE) {
          endTagInTable(p13, token);
        }
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TBODY:
    case TAG_ID.TD:
    case TAG_ID.TFOOT:
    case TAG_ID.TH:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      break;
    }
    default: {
      endTagInBody(p13, token);
    }
  }
}
function startTagInColumnGroup(p13, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p13, token);
      break;
    }
    case TAG_ID.COL: {
      p13._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.TEMPLATE: {
      startTagInHead(p13, token);
      break;
    }
    default: {
      tokenInColumnGroup(p13, token);
    }
  }
}
function endTagInColumnGroup(p13, token) {
  switch (token.tagID) {
    case TAG_ID.COLGROUP: {
      if (p13.openElements.currentTagId === TAG_ID.COLGROUP) {
        p13.openElements.pop();
        p13.insertionMode = InsertionMode.IN_TABLE;
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p13, token);
      break;
    }
    case TAG_ID.COL: {
      break;
    }
    default: {
      tokenInColumnGroup(p13, token);
    }
  }
}
function tokenInColumnGroup(p13, token) {
  if (p13.openElements.currentTagId === TAG_ID.COLGROUP) {
    p13.openElements.pop();
    p13.insertionMode = InsertionMode.IN_TABLE;
    p13._processToken(token);
  }
}
function startTagInTableBody(p13, token) {
  switch (token.tagID) {
    case TAG_ID.TR: {
      p13.openElements.clearBackToTableBodyContext();
      p13._insertElement(token, NS.HTML);
      p13.insertionMode = InsertionMode.IN_ROW;
      break;
    }
    case TAG_ID.TH:
    case TAG_ID.TD: {
      p13.openElements.clearBackToTableBodyContext();
      p13._insertFakeElement(TAG_NAMES.TR, TAG_ID.TR);
      p13.insertionMode = InsertionMode.IN_ROW;
      startTagInRow(p13, token);
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p13.openElements.hasTableBodyContextInTableScope()) {
        p13.openElements.clearBackToTableBodyContext();
        p13.openElements.pop();
        p13.insertionMode = InsertionMode.IN_TABLE;
        startTagInTable(p13, token);
      }
      break;
    }
    default: {
      startTagInTable(p13, token);
    }
  }
}
function endTagInTableBody(p13, token) {
  const tn = token.tagID;
  switch (token.tagID) {
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p13.openElements.hasInTableScope(tn)) {
        p13.openElements.clearBackToTableBodyContext();
        p13.openElements.pop();
        p13.insertionMode = InsertionMode.IN_TABLE;
      }
      break;
    }
    case TAG_ID.TABLE: {
      if (p13.openElements.hasTableBodyContextInTableScope()) {
        p13.openElements.clearBackToTableBodyContext();
        p13.openElements.pop();
        p13.insertionMode = InsertionMode.IN_TABLE;
        endTagInTable(p13, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TD:
    case TAG_ID.TH:
    case TAG_ID.TR: {
      break;
    }
    default: {
      endTagInTable(p13, token);
    }
  }
}
function startTagInRow(p13, token) {
  switch (token.tagID) {
    case TAG_ID.TH:
    case TAG_ID.TD: {
      p13.openElements.clearBackToTableRowContext();
      p13._insertElement(token, NS.HTML);
      p13.insertionMode = InsertionMode.IN_CELL;
      p13.activeFormattingElements.insertMarker();
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      if (p13.openElements.hasInTableScope(TAG_ID.TR)) {
        p13.openElements.clearBackToTableRowContext();
        p13.openElements.pop();
        p13.insertionMode = InsertionMode.IN_TABLE_BODY;
        startTagInTableBody(p13, token);
      }
      break;
    }
    default: {
      startTagInTable(p13, token);
    }
  }
}
function endTagInRow(p13, token) {
  switch (token.tagID) {
    case TAG_ID.TR: {
      if (p13.openElements.hasInTableScope(TAG_ID.TR)) {
        p13.openElements.clearBackToTableRowContext();
        p13.openElements.pop();
        p13.insertionMode = InsertionMode.IN_TABLE_BODY;
      }
      break;
    }
    case TAG_ID.TABLE: {
      if (p13.openElements.hasInTableScope(TAG_ID.TR)) {
        p13.openElements.clearBackToTableRowContext();
        p13.openElements.pop();
        p13.insertionMode = InsertionMode.IN_TABLE_BODY;
        endTagInTableBody(p13, token);
      }
      break;
    }
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p13.openElements.hasInTableScope(token.tagID) || p13.openElements.hasInTableScope(TAG_ID.TR)) {
        p13.openElements.clearBackToTableRowContext();
        p13.openElements.pop();
        p13.insertionMode = InsertionMode.IN_TABLE_BODY;
        endTagInTableBody(p13, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TD:
    case TAG_ID.TH: {
      break;
    }
    default: {
      endTagInTable(p13, token);
    }
  }
}
function startTagInCell(p13, token) {
  const tn = token.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn)) {
    if (p13.openElements.hasInTableScope(TAG_ID.TD) || p13.openElements.hasInTableScope(TAG_ID.TH)) {
      p13._closeTableCell();
      startTagInRow(p13, token);
    }
  } else {
    startTagInBody(p13, token);
  }
}
function endTagInCell(p13, token) {
  const tn = token.tagID;
  switch (tn) {
    case TAG_ID.TD:
    case TAG_ID.TH: {
      if (p13.openElements.hasInTableScope(tn)) {
        p13.openElements.generateImpliedEndTags();
        p13.openElements.popUntilTagNamePopped(tn);
        p13.activeFormattingElements.clearToLastMarker();
        p13.insertionMode = InsertionMode.IN_ROW;
      }
      break;
    }
    case TAG_ID.TABLE:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      if (p13.openElements.hasInTableScope(tn)) {
        p13._closeTableCell();
        endTagInRow(p13, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML: {
      break;
    }
    default: {
      endTagInBody(p13, token);
    }
  }
}
function startTagInSelect(p13, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p13, token);
      break;
    }
    case TAG_ID.OPTION: {
      if (p13.openElements.currentTagId === TAG_ID.OPTION) {
        p13.openElements.pop();
      }
      p13._insertElement(token, NS.HTML);
      break;
    }
    case TAG_ID.OPTGROUP: {
      if (p13.openElements.currentTagId === TAG_ID.OPTION) {
        p13.openElements.pop();
      }
      if (p13.openElements.currentTagId === TAG_ID.OPTGROUP) {
        p13.openElements.pop();
      }
      p13._insertElement(token, NS.HTML);
      break;
    }
    case TAG_ID.HR: {
      if (p13.openElements.currentTagId === TAG_ID.OPTION) {
        p13.openElements.pop();
      }
      if (p13.openElements.currentTagId === TAG_ID.OPTGROUP) {
        p13.openElements.pop();
      }
      p13._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.INPUT:
    case TAG_ID.KEYGEN:
    case TAG_ID.TEXTAREA:
    case TAG_ID.SELECT: {
      if (p13.openElements.hasInSelectScope(TAG_ID.SELECT)) {
        p13.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
        p13._resetInsertionMode();
        if (token.tagID !== TAG_ID.SELECT) {
          p13._processStartTag(token);
        }
      }
      break;
    }
    case TAG_ID.SCRIPT:
    case TAG_ID.TEMPLATE: {
      startTagInHead(p13, token);
      break;
    }
    default:
  }
}
function endTagInSelect(p13, token) {
  switch (token.tagID) {
    case TAG_ID.OPTGROUP: {
      if (p13.openElements.stackTop > 0 && p13.openElements.currentTagId === TAG_ID.OPTION && p13.openElements.tagIDs[p13.openElements.stackTop - 1] === TAG_ID.OPTGROUP) {
        p13.openElements.pop();
      }
      if (p13.openElements.currentTagId === TAG_ID.OPTGROUP) {
        p13.openElements.pop();
      }
      break;
    }
    case TAG_ID.OPTION: {
      if (p13.openElements.currentTagId === TAG_ID.OPTION) {
        p13.openElements.pop();
      }
      break;
    }
    case TAG_ID.SELECT: {
      if (p13.openElements.hasInSelectScope(TAG_ID.SELECT)) {
        p13.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
        p13._resetInsertionMode();
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p13, token);
      break;
    }
    default:
  }
}
function startTagInSelectInTable(p13, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.CAPTION || tn === TAG_ID.TABLE || tn === TAG_ID.TBODY || tn === TAG_ID.TFOOT || tn === TAG_ID.THEAD || tn === TAG_ID.TR || tn === TAG_ID.TD || tn === TAG_ID.TH) {
    p13.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
    p13._resetInsertionMode();
    p13._processStartTag(token);
  } else {
    startTagInSelect(p13, token);
  }
}
function endTagInSelectInTable(p13, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.CAPTION || tn === TAG_ID.TABLE || tn === TAG_ID.TBODY || tn === TAG_ID.TFOOT || tn === TAG_ID.THEAD || tn === TAG_ID.TR || tn === TAG_ID.TD || tn === TAG_ID.TH) {
    if (p13.openElements.hasInTableScope(tn)) {
      p13.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
      p13._resetInsertionMode();
      p13.onEndTag(token);
    }
  } else {
    endTagInSelect(p13, token);
  }
}
function startTagInTemplate(p13, token) {
  switch (token.tagID) {
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.SCRIPT:
    case TAG_ID.STYLE:
    case TAG_ID.TEMPLATE:
    case TAG_ID.TITLE: {
      startTagInHead(p13, token);
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      p13.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE;
      p13.insertionMode = InsertionMode.IN_TABLE;
      startTagInTable(p13, token);
      break;
    }
    case TAG_ID.COL: {
      p13.tmplInsertionModeStack[0] = InsertionMode.IN_COLUMN_GROUP;
      p13.insertionMode = InsertionMode.IN_COLUMN_GROUP;
      startTagInColumnGroup(p13, token);
      break;
    }
    case TAG_ID.TR: {
      p13.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE_BODY;
      p13.insertionMode = InsertionMode.IN_TABLE_BODY;
      startTagInTableBody(p13, token);
      break;
    }
    case TAG_ID.TD:
    case TAG_ID.TH: {
      p13.tmplInsertionModeStack[0] = InsertionMode.IN_ROW;
      p13.insertionMode = InsertionMode.IN_ROW;
      startTagInRow(p13, token);
      break;
    }
    default: {
      p13.tmplInsertionModeStack[0] = InsertionMode.IN_BODY;
      p13.insertionMode = InsertionMode.IN_BODY;
      startTagInBody(p13, token);
    }
  }
}
function endTagInTemplate(p13, token) {
  if (token.tagID === TAG_ID.TEMPLATE) {
    templateEndTagInHead(p13, token);
  }
}
function eofInTemplate(p13, token) {
  if (p13.openElements.tmplCount > 0) {
    p13.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
    p13.activeFormattingElements.clearToLastMarker();
    p13.tmplInsertionModeStack.shift();
    p13._resetInsertionMode();
    p13.onEof(token);
  } else {
    stopParsing(p13, token);
  }
}
function startTagAfterBody(p13, token) {
  if (token.tagID === TAG_ID.HTML) {
    startTagInBody(p13, token);
  } else {
    tokenAfterBody(p13, token);
  }
}
function endTagAfterBody(p13, token) {
  var _a2;
  if (token.tagID === TAG_ID.HTML) {
    if (!p13.fragmentContext) {
      p13.insertionMode = InsertionMode.AFTER_AFTER_BODY;
    }
    if (p13.options.sourceCodeLocationInfo && p13.openElements.tagIDs[0] === TAG_ID.HTML) {
      p13._setEndLocation(p13.openElements.items[0], token);
      const bodyElement = p13.openElements.items[1];
      if (bodyElement && !((_a2 = p13.treeAdapter.getNodeSourceCodeLocation(bodyElement)) === null || _a2 === void 0 ? void 0 : _a2.endTag)) {
        p13._setEndLocation(bodyElement, token);
      }
    }
  } else {
    tokenAfterBody(p13, token);
  }
}
function tokenAfterBody(p13, token) {
  p13.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p13, token);
}
function startTagInFrameset(p13, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p13, token);
      break;
    }
    case TAG_ID.FRAMESET: {
      p13._insertElement(token, NS.HTML);
      break;
    }
    case TAG_ID.FRAME: {
      p13._appendElement(token, NS.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(p13, token);
      break;
    }
    default:
  }
}
function endTagInFrameset(p13, token) {
  if (token.tagID === TAG_ID.FRAMESET && !p13.openElements.isRootHtmlElementCurrent()) {
    p13.openElements.pop();
    if (!p13.fragmentContext && p13.openElements.currentTagId !== TAG_ID.FRAMESET) {
      p13.insertionMode = InsertionMode.AFTER_FRAMESET;
    }
  }
}
function startTagAfterFrameset(p13, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p13, token);
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(p13, token);
      break;
    }
    default:
  }
}
function endTagAfterFrameset(p13, token) {
  if (token.tagID === TAG_ID.HTML) {
    p13.insertionMode = InsertionMode.AFTER_AFTER_FRAMESET;
  }
}
function startTagAfterAfterBody(p13, token) {
  if (token.tagID === TAG_ID.HTML) {
    startTagInBody(p13, token);
  } else {
    tokenAfterAfterBody(p13, token);
  }
}
function tokenAfterAfterBody(p13, token) {
  p13.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p13, token);
}
function startTagAfterAfterFrameset(p13, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody(p13, token);
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead(p13, token);
      break;
    }
    default:
  }
}
function nullCharacterInForeignContent(p13, token) {
  token.chars = REPLACEMENT_CHARACTER;
  p13._insertCharacters(token);
}
function characterInForeignContent(p13, token) {
  p13._insertCharacters(token);
  p13.framesetOk = false;
}
function popUntilHtmlOrIntegrationPoint(p13) {
  while (p13.treeAdapter.getNamespaceURI(p13.openElements.current) !== NS.HTML && p13.openElements.currentTagId !== void 0 && !p13._isIntegrationPoint(p13.openElements.currentTagId, p13.openElements.current)) {
    p13.openElements.pop();
  }
}
function startTagInForeignContent(p13, token) {
  if (causesExit(token)) {
    popUntilHtmlOrIntegrationPoint(p13);
    p13._startTagOutsideForeignContent(token);
  } else {
    const current = p13._getAdjustedCurrentElement();
    const currentNs = p13.treeAdapter.getNamespaceURI(current);
    if (currentNs === NS.MATHML) {
      adjustTokenMathMLAttrs(token);
    } else if (currentNs === NS.SVG) {
      adjustTokenSVGTagName(token);
      adjustTokenSVGAttrs(token);
    }
    adjustTokenXMLAttrs(token);
    if (token.selfClosing) {
      p13._appendElement(token, currentNs);
    } else {
      p13._insertElement(token, currentNs);
    }
    token.ackSelfClosing = true;
  }
}
function endTagInForeignContent(p13, token) {
  if (token.tagID === TAG_ID.P || token.tagID === TAG_ID.BR) {
    popUntilHtmlOrIntegrationPoint(p13);
    p13._endTagOutsideForeignContent(token);
    return;
  }
  for (let i16 = p13.openElements.stackTop; i16 > 0; i16--) {
    const element5 = p13.openElements.items[i16];
    if (p13.treeAdapter.getNamespaceURI(element5) === NS.HTML) {
      p13._endTagOutsideForeignContent(token);
      break;
    }
    const tagName = p13.treeAdapter.getTagName(element5);
    if (tagName.toLowerCase() === token.tagName) {
      token.tagName = tagName;
      p13.openElements.shortenToLength(i16);
      break;
    }
  }
}

// node_modules/entities/dist/esm/escape.js
var xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt == null ? (c21, index4) => (c21.charCodeAt(index4) & 64512) === 55296 ? (c21.charCodeAt(index4) - 55296) * 1024 + c21.charCodeAt(index4 + 1) - 56320 + 65536 : c21.charCodeAt(index4) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (input, index4) => input.codePointAt(index4)
  )
);
function getEscaper(regex, map3) {
  return function escape2(data) {
    let match;
    let lastIndex = 0;
    let result = "";
    while (match = regex.exec(data)) {
      if (lastIndex !== match.index) {
        result += data.substring(lastIndex, match.index);
      }
      result += map3.get(match[0].charCodeAt(0));
      lastIndex = match.index + 1;
    }
    return result + data.substring(lastIndex);
  };
}
var escapeUTF8 = getEscaper(/["&'<>]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));

// node_modules/parse5/dist/serializer/index.js
var VOID_ELEMENTS = /* @__PURE__ */ new Set([
  TAG_NAMES.AREA,
  TAG_NAMES.BASE,
  TAG_NAMES.BASEFONT,
  TAG_NAMES.BGSOUND,
  TAG_NAMES.BR,
  TAG_NAMES.COL,
  TAG_NAMES.EMBED,
  TAG_NAMES.FRAME,
  TAG_NAMES.HR,
  TAG_NAMES.IMG,
  TAG_NAMES.INPUT,
  TAG_NAMES.KEYGEN,
  TAG_NAMES.LINK,
  TAG_NAMES.META,
  TAG_NAMES.PARAM,
  TAG_NAMES.SOURCE,
  TAG_NAMES.TRACK,
  TAG_NAMES.WBR
]);

// node_modules/hast-util-raw/node_modules/unist-util-visit/lib/index.js
function visit4(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
  let reverse;
  let test;
  let visitor;
  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
    test = void 0;
    visitor = testOrVisitor;
    reverse = visitorOrReverse;
  } else {
    test = testOrVisitor;
    visitor = visitorOrReverse;
    reverse = maybeReverse;
  }
  visitParents(tree, test, overload, reverse);
  function overload(node2, parents) {
    const parent = parents[parents.length - 1];
    const index4 = parent ? parent.children.indexOf(node2) : void 0;
    return visitor(node2, index4, parent);
  }
}

// node_modules/hast-util-raw/lib/index.js
var gfmTagfilterExpression = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|textarea|title|xmp)(?=[\t\n\f\r />])/gi;
var knownMdxNames = /* @__PURE__ */ new Set([
  "mdxFlowExpression",
  "mdxJsxFlowElement",
  "mdxJsxTextElement",
  "mdxTextExpression",
  "mdxjsEsm"
]);
var parseOptions = { sourceCodeLocationInfo: true, scriptingEnabled: false };
function raw(tree, options) {
  const document4 = documentMode(tree);
  const one5 = zwitch("type", {
    handlers: { root: root5, element: element4, text: text9, comment: comment2, doctype: doctype2, raw: handleRaw },
    unknown
  });
  const state = {
    parser: document4 ? new Parser2(parseOptions) : Parser2.getFragmentParser(void 0, parseOptions),
    handle(node2) {
      one5(node2, state);
    },
    stitches: false,
    options: options || {}
  };
  one5(tree, state);
  resetTokenizer(state, pointStart());
  const p52 = document4 ? state.parser.document : state.parser.getFragment();
  const result = fromParse5(p52, {
    // To do: support `space`?
    file: state.options.file
  });
  if (state.stitches) {
    visit4(result, "comment", function(node2, index4, parent) {
      const stitch2 = (
        /** @type {Stitch} */
        /** @type {unknown} */
        node2
      );
      if (stitch2.value.stitch && parent && index4 !== void 0) {
        const siblings = parent.children;
        siblings[index4] = stitch2.value.stitch;
        return index4;
      }
    });
  }
  if (result.type === "root" && result.children.length === 1 && result.children[0].type === tree.type) {
    return result.children[0];
  }
  return result;
}
function all4(nodes, state) {
  let index4 = -1;
  if (nodes) {
    while (++index4 < nodes.length) {
      state.handle(nodes[index4]);
    }
  }
}
function root5(node2, state) {
  all4(node2.children, state);
}
function element4(node2, state) {
  startTag(node2, state);
  all4(node2.children, state);
  endTag(node2, state);
}
function text9(node2, state) {
  if (state.parser.tokenizer.state > 4) {
    state.parser.tokenizer.state = 0;
  }
  const token = {
    type: token_exports.TokenType.CHARACTER,
    chars: node2.value,
    location: createParse5Location(node2)
  };
  resetTokenizer(state, pointStart(node2));
  state.parser.currentToken = token;
  state.parser._processToken(state.parser.currentToken);
}
function doctype2(node2, state) {
  const token = {
    type: token_exports.TokenType.DOCTYPE,
    name: "html",
    forceQuirks: false,
    publicId: "",
    systemId: "",
    location: createParse5Location(node2)
  };
  resetTokenizer(state, pointStart(node2));
  state.parser.currentToken = token;
  state.parser._processToken(state.parser.currentToken);
}
function stitch(node2, state) {
  state.stitches = true;
  const clone = cloneWithoutChildren(node2);
  if ("children" in node2 && "children" in clone) {
    const fakeRoot = (
      /** @type {Root} */
      raw({ type: "root", children: node2.children }, state.options)
    );
    clone.children = fakeRoot.children;
  }
  comment2({ type: "comment", value: { stitch: clone } }, state);
}
function comment2(node2, state) {
  const data = node2.value;
  const token = {
    type: token_exports.TokenType.COMMENT,
    data,
    location: createParse5Location(node2)
  };
  resetTokenizer(state, pointStart(node2));
  state.parser.currentToken = token;
  state.parser._processToken(state.parser.currentToken);
}
function handleRaw(node2, state) {
  state.parser.tokenizer.preprocessor.html = "";
  state.parser.tokenizer.preprocessor.pos = -1;
  state.parser.tokenizer.preprocessor.lastGapPos = -2;
  state.parser.tokenizer.preprocessor.gapStack = [];
  state.parser.tokenizer.preprocessor.skipNextNewLine = false;
  state.parser.tokenizer.preprocessor.lastChunkWritten = false;
  state.parser.tokenizer.preprocessor.endOfChunkHit = false;
  state.parser.tokenizer.preprocessor.isEol = false;
  setPoint(state, pointStart(node2));
  state.parser.tokenizer.write(
    state.options.tagfilter ? node2.value.replace(gfmTagfilterExpression, "&lt;$1$2") : node2.value,
    false
  );
  state.parser.tokenizer._runParsingLoop();
  if (state.parser.tokenizer.state === 72 || // @ts-expect-error: removed.
  state.parser.tokenizer.state === 78) {
    state.parser.tokenizer.preprocessor.lastChunkWritten = true;
    const cp = state.parser.tokenizer._consume();
    state.parser.tokenizer._callState(cp);
  }
}
function unknown(node_, state) {
  const node2 = (
    /** @type {Nodes} */
    node_
  );
  if (state.options.passThrough && state.options.passThrough.includes(node2.type)) {
    stitch(node2, state);
  } else {
    let extra = "";
    if (knownMdxNames.has(node2.type)) {
      extra = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax";
    }
    throw new Error("Cannot compile `" + node2.type + "` node" + extra);
  }
}
function resetTokenizer(state, point5) {
  setPoint(state, point5);
  const token = state.parser.tokenizer.currentCharacterToken;
  if (token && token.location) {
    token.location.endLine = state.parser.tokenizer.preprocessor.line;
    token.location.endCol = state.parser.tokenizer.preprocessor.col + 1;
    token.location.endOffset = state.parser.tokenizer.preprocessor.offset + 1;
    state.parser.currentToken = token;
    state.parser._processToken(state.parser.currentToken);
  }
  state.parser.tokenizer.paused = false;
  state.parser.tokenizer.inLoop = false;
  state.parser.tokenizer.active = false;
  state.parser.tokenizer.returnState = TokenizerMode.DATA;
  state.parser.tokenizer.charRefCode = -1;
  state.parser.tokenizer.consumedAfterSnapshot = -1;
  state.parser.tokenizer.currentLocation = null;
  state.parser.tokenizer.currentCharacterToken = null;
  state.parser.tokenizer.currentToken = null;
  state.parser.tokenizer.currentAttr = { name: "", value: "" };
}
function setPoint(state, point5) {
  if (point5 && point5.offset !== void 0) {
    const location3 = {
      startLine: point5.line,
      startCol: point5.column,
      startOffset: point5.offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
    state.parser.tokenizer.preprocessor.lineStartPos = -point5.column + 1;
    state.parser.tokenizer.preprocessor.droppedBufferSize = point5.offset;
    state.parser.tokenizer.preprocessor.line = point5.line;
    state.parser.tokenizer.currentLocation = location3;
  }
}
function startTag(node2, state) {
  const tagName = node2.tagName.toLowerCase();
  if (state.parser.tokenizer.state === TokenizerMode.PLAINTEXT) return;
  resetTokenizer(state, pointStart(node2));
  const current = state.parser.openElements.current;
  let ns = "namespaceURI" in current ? current.namespaceURI : webNamespaces.html;
  if (ns === webNamespaces.html && tagName === "svg") {
    ns = webNamespaces.svg;
  }
  const result = toParse5(
    // Shallow clone to not delve into `children`: we only need the attributes.
    { ...node2, children: [] },
    { space: ns === webNamespaces.svg ? "svg" : "html" }
  );
  const tag = {
    type: token_exports.TokenType.START_TAG,
    tagName,
    tagID: html_exports.getTagID(tagName),
    // We always send start and end tags.
    selfClosing: false,
    ackSelfClosing: false,
    // Always element.
    /* c8 ignore next */
    attrs: "attrs" in result ? result.attrs : [],
    location: createParse5Location(node2)
  };
  state.parser.currentToken = tag;
  state.parser._processToken(state.parser.currentToken);
  state.parser.tokenizer.lastStartTagName = tagName;
}
function endTag(node2, state) {
  const tagName = node2.tagName.toLowerCase();
  if (!state.parser.tokenizer.inForeignNode && htmlVoidElements.includes(tagName)) {
    return;
  }
  if (state.parser.tokenizer.state === TokenizerMode.PLAINTEXT) return;
  resetTokenizer(state, pointEnd(node2));
  const tag = {
    type: token_exports.TokenType.END_TAG,
    tagName,
    tagID: html_exports.getTagID(tagName),
    selfClosing: false,
    ackSelfClosing: false,
    attrs: [],
    location: createParse5Location(node2)
  };
  state.parser.currentToken = tag;
  state.parser._processToken(state.parser.currentToken);
  if (
    // Current element is closed.
    tagName === state.parser.tokenizer.lastStartTagName && // `<textarea>` and `<title>`
    (state.parser.tokenizer.state === TokenizerMode.RCDATA || // `<iframe>`, `<noembed>`, `<noframes>`, `<style>`, `<xmp>`
    state.parser.tokenizer.state === TokenizerMode.RAWTEXT || // `<script>`
    state.parser.tokenizer.state === TokenizerMode.SCRIPT_DATA)
  ) {
    state.parser.tokenizer.state = TokenizerMode.DATA;
  }
}
function documentMode(node2) {
  const head = node2.type === "root" ? node2.children[0] : node2;
  return Boolean(
    head && (head.type === "doctype" || head.type === "element" && head.tagName.toLowerCase() === "html")
  );
}
function createParse5Location(node2) {
  const start2 = pointStart(node2) || {
    line: void 0,
    column: void 0,
    offset: void 0
  };
  const end = pointEnd(node2) || {
    line: void 0,
    column: void 0,
    offset: void 0
  };
  const location3 = {
    startLine: start2.line,
    startCol: start2.column,
    startOffset: start2.offset,
    endLine: end.line,
    endCol: end.column,
    endOffset: end.offset
  };
  return location3;
}
function cloneWithoutChildren(node2) {
  return "children" in node2 ? esm_default({ ...node2, children: [] }) : esm_default(node2);
}

// node_modules/rehype-raw/lib/index.js
function rehypeRaw(options) {
  return function(tree, file) {
    const result = (
      /** @type {Root} */
      raw(tree, { ...options, file })
    );
    return result;
  };
}

// node_modules/@copilotkit/react-ui/dist/chunk-JZ3RFQQ6.mjs
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var defaultComponents = {
  a(_a2) {
    var _b = _a2, { children } = _b, props = __objRest(_b, ["children"]);
    return (0, import_jsx_runtime18.jsx)("a", __spreadProps(__spreadValues({ className: "copilotKitMarkdownElement" }, props), { target: "_blank", rel: "noopener noreferrer", children }));
  },
  // @ts-expect-error -- inline
  code(_c) {
    var _d = _c, { children, className, inline: inline4 } = _d, props = __objRest(_d, ["children", "className", "inline"]);
    if (Array.isArray(children) && children.length) {
      if (children[0] == "") {
        return (0, import_jsx_runtime18.jsx)(
          "span",
          {
            style: {
              animation: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
              marginTop: "0.25rem"
            },
            children: ""
          }
        );
      }
      children[0] = (children == null ? void 0 : children[0]).replace("``", "");
    }
    const match = /language-(\w+)/.exec(className || "");
    const hasLanguage = match && match[1];
    const content3 = String(children);
    const hasNewlines = content3.includes("\n");
    const isInline = !hasLanguage && !hasNewlines;
    if (isInline) {
      return (0, import_jsx_runtime18.jsx)(
        "code",
        __spreadProps(__spreadValues({
          className: `copilotKitMarkdownElement copilotKitInlineCode ${className || ""}`
        }, props), {
          children
        })
      );
    }
    return (0, import_jsx_runtime18.jsx)(
      CodeBlock,
      __spreadValues({
        language: match && match[1] || "",
        value: String(children).replace(/\n$/, "")
      }, props),
      Math.random()
    );
  },
  h1: (_e4) => {
    var _f = _e4, { children } = _f, props = __objRest(_f, ["children"]);
    return (0, import_jsx_runtime18.jsx)("h1", __spreadProps(__spreadValues({ className: "copilotKitMarkdownElement" }, props), { children }));
  },
  h2: (_g) => {
    var _h = _g, { children } = _h, props = __objRest(_h, ["children"]);
    return (0, import_jsx_runtime18.jsx)("h2", __spreadProps(__spreadValues({ className: "copilotKitMarkdownElement" }, props), { children }));
  },
  h3: (_i) => {
    var _j = _i, { children } = _j, props = __objRest(_j, ["children"]);
    return (0, import_jsx_runtime18.jsx)("h3", __spreadProps(__spreadValues({ className: "copilotKitMarkdownElement" }, props), { children }));
  },
  h4: (_k) => {
    var _l = _k, { children } = _l, props = __objRest(_l, ["children"]);
    return (0, import_jsx_runtime18.jsx)("h4", __spreadProps(__spreadValues({ className: "copilotKitMarkdownElement" }, props), { children }));
  },
  h5: (_m) => {
    var _n = _m, { children } = _n, props = __objRest(_n, ["children"]);
    return (0, import_jsx_runtime18.jsx)("h5", __spreadProps(__spreadValues({ className: "copilotKitMarkdownElement" }, props), { children }));
  },
  h6: (_o2) => {
    var _p = _o2, { children } = _p, props = __objRest(_p, ["children"]);
    return (0, import_jsx_runtime18.jsx)("h6", __spreadProps(__spreadValues({ className: "copilotKitMarkdownElement" }, props), { children }));
  },
  p: (_q) => {
    var _r = _q, { children } = _r, props = __objRest(_r, ["children"]);
    return (0, import_jsx_runtime18.jsx)("p", __spreadProps(__spreadValues({ className: "copilotKitMarkdownElement" }, props), { children }));
  },
  pre: (_s) => {
    var _t3 = _s, { children } = _t3, props = __objRest(_t3, ["children"]);
    return (0, import_jsx_runtime18.jsx)("pre", __spreadProps(__spreadValues({ className: "copilotKitMarkdownElement" }, props), { children }));
  },
  blockquote: (_u) => {
    var _v = _u, { children } = _v, props = __objRest(_v, ["children"]);
    return (0, import_jsx_runtime18.jsx)("blockquote", __spreadProps(__spreadValues({ className: "copilotKitMarkdownElement" }, props), { children }));
  },
  ul: (_w) => {
    var _x = _w, { children } = _x, props = __objRest(_x, ["children"]);
    return (0, import_jsx_runtime18.jsx)("ul", __spreadProps(__spreadValues({ className: "copilotKitMarkdownElement" }, props), { children }));
  },
  li: (_y) => {
    var _z = _y, { children } = _z, props = __objRest(_z, ["children"]);
    return (0, import_jsx_runtime18.jsx)("li", __spreadProps(__spreadValues({ className: "copilotKitMarkdownElement" }, props), { children }));
  }
};
var MemoizedReactMarkdown = (0, import_react150.memo)(
  Markdown,
  (prevProps, nextProps) => prevProps.children === nextProps.children && prevProps.components === nextProps.components
);
var Markdown2 = ({ content: content3, components }) => {
  return (0, import_jsx_runtime18.jsx)("div", { className: "copilotKitMarkdown", children: (0, import_jsx_runtime18.jsx)(
    MemoizedReactMarkdown,
    {
      components: __spreadValues(__spreadValues({}, defaultComponents), components),
      remarkPlugins: [remarkGfm, [remarkMath, { singleDollarTextMath: false }]],
      rehypePlugins: [rehypeRaw],
      children: content3
    }
  ) });
};

// node_modules/@copilotkit/react-ui/dist/chunk-3QYTKBWC.mjs
var import_react151 = __toESM(require_react(), 1);
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var AssistantMessage = (props) => {
  var _a2;
  const { icons, labels } = useChatContext();
  const {
    message,
    isLoading,
    onRegenerate,
    onCopy,
    onThumbsUp,
    onThumbsDown,
    isCurrentMessage,
    markdownTagRenderers
  } = props;
  const [copied, setCopied] = (0, import_react151.useState)(false);
  const handleCopy = () => {
    const content22 = (message == null ? void 0 : message.content) || "";
    if (content22 && onCopy) {
      navigator.clipboard.writeText(content22);
      setCopied(true);
      onCopy(content22);
      setTimeout(() => setCopied(false), 2e3);
    } else if (content22) {
      navigator.clipboard.writeText(content22);
      setCopied(true);
      setTimeout(() => setCopied(false), 2e3);
    }
  };
  const handleRegenerate = () => {
    if (onRegenerate)
      onRegenerate();
  };
  const handleThumbsUp = () => {
    if (onThumbsUp && message)
      onThumbsUp(message);
  };
  const handleThumbsDown = () => {
    if (onThumbsDown && message)
      onThumbsDown(message);
  };
  const LoadingIcon = () => (0, import_jsx_runtime19.jsx)("span", { children: icons.activityIcon });
  const content3 = (message == null ? void 0 : message.content) || "";
  const subComponent = (_a2 = message == null ? void 0 : message.generativeUI) == null ? void 0 : _a2.call(message);
  return (0, import_jsx_runtime19.jsxs)(import_jsx_runtime19.Fragment, { children: [
    content3 && (0, import_jsx_runtime19.jsxs)("div", { className: "copilotKitMessage copilotKitAssistantMessage", children: [
      content3 && (0, import_jsx_runtime19.jsx)(Markdown2, { content: content3, components: markdownTagRenderers }),
      content3 && !isLoading && (0, import_jsx_runtime19.jsxs)(
        "div",
        {
          className: `copilotKitMessageControls ${isCurrentMessage ? "currentMessage" : ""}`,
          children: [
            (0, import_jsx_runtime19.jsx)(
              "button",
              {
                className: "copilotKitMessageControlButton",
                onClick: handleRegenerate,
                "aria-label": labels.regenerateResponse,
                title: labels.regenerateResponse,
                children: icons.regenerateIcon
              }
            ),
            (0, import_jsx_runtime19.jsx)(
              "button",
              {
                className: "copilotKitMessageControlButton",
                onClick: handleCopy,
                "aria-label": labels.copyToClipboard,
                title: labels.copyToClipboard,
                children: copied ? (0, import_jsx_runtime19.jsx)("span", { style: { fontSize: "10px", fontWeight: "bold" }, children: "" }) : icons.copyIcon
              }
            ),
            onThumbsUp && (0, import_jsx_runtime19.jsx)(
              "button",
              {
                className: "copilotKitMessageControlButton",
                onClick: handleThumbsUp,
                "aria-label": labels.thumbsUp,
                title: labels.thumbsUp,
                children: icons.thumbsUpIcon
              }
            ),
            onThumbsDown && (0, import_jsx_runtime19.jsx)(
              "button",
              {
                className: "copilotKitMessageControlButton",
                onClick: handleThumbsDown,
                "aria-label": labels.thumbsDown,
                title: labels.thumbsDown,
                children: icons.thumbsDownIcon
              }
            )
          ]
        }
      )
    ] }),
    (0, import_jsx_runtime19.jsx)("div", { style: { marginBottom: "0.5rem" }, children: subComponent }),
    isLoading && (0, import_jsx_runtime19.jsx)(LoadingIcon, {})
  ] });
};

// node_modules/@copilotkit/react-ui/dist/chunk-DBKRAOH7.mjs
var import_react152 = __toESM(require_react(), 1);
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var ImageRenderer = ({ image: image3, content: content3, className = "" }) => {
  const [imageError, setImageError] = (0, import_react152.useState)(false);
  const imageSrc = `data:image/${image3.format};base64,${image3.bytes}`;
  const altText = content3 || "User uploaded image";
  const handleImageError = () => {
    setImageError(true);
  };
  if (imageError) {
    return (0, import_jsx_runtime20.jsxs)("div", { className: `copilotKitImageRendering copilotKitImageRenderingError ${className}`, children: [
      (0, import_jsx_runtime20.jsx)("div", { className: "copilotKitImageRenderingErrorMessage", children: "Failed to load image" }),
      content3 && (0, import_jsx_runtime20.jsx)("div", { className: "copilotKitImageRenderingContent", children: content3 })
    ] });
  }
  return (0, import_jsx_runtime20.jsxs)("div", { className: `copilotKitImageRendering ${className}`, children: [
    (0, import_jsx_runtime20.jsx)(
      "img",
      {
        src: imageSrc,
        alt: altText,
        className: "copilotKitImageRenderingImage",
        onError: handleImageError
      }
    ),
    content3 && (0, import_jsx_runtime20.jsx)("div", { className: "copilotKitImageRenderingContent", children: content3 })
  ] });
};

// node_modules/@copilotkit/react-ui/dist/chunk-VVL6JFCJ.mjs
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var UserMessage = (props) => {
  const { message, ImageRenderer: ImageRenderer2 } = props;
  const isImageMessage = message && "image" in message && message.image;
  if (isImageMessage) {
    const imageMessage = message;
    return (0, import_jsx_runtime21.jsx)("div", { className: "copilotKitMessage copilotKitUserMessage", children: (0, import_jsx_runtime21.jsx)(ImageRenderer2, { image: imageMessage.image, content: imageMessage.content }) });
  }
  return (0, import_jsx_runtime21.jsx)("div", { className: "copilotKitMessage copilotKitUserMessage", children: message == null ? void 0 : message.content });
};

// node_modules/@copilotkit/react-ui/dist/chunk-5XLGXUQI.mjs
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
function RenderMessage(_a2) {
  var _b = _a2, {
    UserMessage: UserMessage2 = UserMessage,
    AssistantMessage: AssistantMessage2 = AssistantMessage,
    ImageRenderer: ImageRenderer2 = ImageRenderer
  } = _b, props = __objRest(_b, [
    "UserMessage",
    "AssistantMessage",
    "ImageRenderer"
  ]);
  var _a22;
  const {
    message,
    inProgress,
    index: index4,
    isCurrentMessage,
    onRegenerate,
    onCopy,
    onThumbsUp,
    onThumbsDown,
    markdownTagRenderers
  } = props;
  switch (message.role) {
    case "user":
      return (0, import_jsx_runtime22.jsx)(
        UserMessage2,
        {
          rawData: message,
          "data-message-role": "user",
          message,
          ImageRenderer: ImageRenderer2
        },
        index4
      );
    case "assistant":
      return (0, import_jsx_runtime22.jsx)(
        AssistantMessage2,
        {
          "data-message-role": "assistant",
          subComponent: (_a22 = message.generativeUI) == null ? void 0 : _a22.call(message),
          rawData: message,
          message,
          isLoading: inProgress && isCurrentMessage && !message.content,
          isGenerating: inProgress && isCurrentMessage && !!message.content,
          isCurrentMessage,
          onRegenerate: () => onRegenerate == null ? void 0 : onRegenerate(message.id),
          onCopy,
          onThumbsUp,
          onThumbsDown,
          markdownTagRenderers,
          ImageRenderer: ImageRenderer2
        },
        index4
      );
  }
}

// node_modules/@copilotkit/react-ui/dist/chunk-2LIO4Z3E.mjs
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var LegacyRenderMessage = ({
  message,
  inProgress,
  index: index4,
  isCurrentMessage,
  actionResult,
  AssistantMessage: AssistantMessage2,
  UserMessage: UserMessage2,
  ImageRenderer: ImageRenderer2,
  onRegenerate,
  onCopy,
  onThumbsUp,
  onThumbsDown,
  markdownTagRenderers,
  legacyProps
}) => {
  var _a2;
  const {
    RenderTextMessage,
    RenderActionExecutionMessage,
    RenderAgentStateMessage,
    RenderResultMessage,
    RenderImageMessage
  } = legacyProps;
  const deprecatedMessage = (_a2 = aguiToGQL(message)[0]) != null ? _a2 : void 0;
  if (deprecatedMessage.isTextMessage() && RenderTextMessage) {
    return (0, import_jsx_runtime23.jsx)(
      RenderTextMessage,
      {
        message,
        inProgress,
        index: index4,
        isCurrentMessage,
        AssistantMessage: AssistantMessage2,
        UserMessage: UserMessage2,
        onRegenerate,
        onCopy,
        onThumbsUp,
        onThumbsDown,
        markdownTagRenderers
      }
    );
  }
  if (deprecatedMessage.isActionExecutionMessage() && RenderActionExecutionMessage) {
    return (0, import_jsx_runtime23.jsx)(
      RenderActionExecutionMessage,
      {
        message,
        inProgress,
        index: index4,
        isCurrentMessage,
        actionResult,
        AssistantMessage: AssistantMessage2,
        UserMessage: UserMessage2
      }
    );
  }
  if (deprecatedMessage.isAgentStateMessage() && RenderAgentStateMessage) {
    return (0, import_jsx_runtime23.jsx)(
      RenderAgentStateMessage,
      {
        message,
        inProgress,
        index: index4,
        isCurrentMessage,
        AssistantMessage: AssistantMessage2,
        UserMessage: UserMessage2
      }
    );
  }
  if (deprecatedMessage.isResultMessage() && RenderResultMessage) {
    return (0, import_jsx_runtime23.jsx)(
      RenderResultMessage,
      {
        message,
        inProgress,
        index: index4,
        isCurrentMessage,
        AssistantMessage: AssistantMessage2,
        UserMessage: UserMessage2
      }
    );
  }
  if (deprecatedMessage.isImageMessage() && RenderImageMessage) {
    return (0, import_jsx_runtime23.jsx)(
      RenderImageMessage,
      {
        message,
        inProgress,
        index: index4,
        isCurrentMessage,
        AssistantMessage: AssistantMessage2,
        UserMessage: UserMessage2
      }
    );
  }
  return (0, import_jsx_runtime23.jsx)(
    RenderMessage,
    {
      message,
      inProgress,
      index: index4,
      isCurrentMessage,
      AssistantMessage: AssistantMessage2,
      UserMessage: UserMessage2,
      ImageRenderer: ImageRenderer2,
      onRegenerate,
      onCopy,
      onThumbsUp,
      onThumbsDown,
      markdownTagRenderers
    }
  );
};

// node_modules/@copilotkit/react-ui/dist/chunk-W7ONZTSW.mjs
var import_react153 = __toESM(require_react(), 1);
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var Messages = ({
  inProgress,
  children,
  RenderMessage: RenderMessage2,
  AssistantMessage: AssistantMessage2,
  UserMessage: UserMessage2,
  ErrorMessage,
  ImageRenderer: ImageRenderer2,
  onRegenerate,
  onCopy,
  onThumbsUp,
  onThumbsDown,
  markdownTagRenderers,
  chatError,
  // Legacy props
  RenderTextMessage,
  RenderActionExecutionMessage,
  RenderAgentStateMessage,
  RenderResultMessage,
  RenderImageMessage
}) => {
  const { labels } = useChatContext();
  const { messages: visibleMessages, interrupt } = useCopilotChat();
  const initialMessages = (0, import_react153.useMemo)(() => makeInitialMessages(labels.initial), [labels.initial]);
  const messages = [...initialMessages, ...visibleMessages];
  const { messagesContainerRef, messagesEndRef } = useScrollToBottom(messages);
  const hasLegacyProps = !!(RenderTextMessage || RenderActionExecutionMessage || RenderAgentStateMessage || RenderResultMessage || RenderImageMessage);
  (0, import_react153.useEffect)(() => {
    if (hasLegacyProps) {
      console.warn(
        "[CopilotKit] Legacy message render props (RenderTextMessage, RenderActionExecutionMessage, etc.) are deprecated. Please use the unified 'RenderMessage' prop instead. See migration guide: https://docs.copilotkit.ai/migration/render-message"
      );
    }
  }, [hasLegacyProps]);
  const legacyProps = (0, import_react153.useMemo)(
    () => ({
      RenderTextMessage,
      RenderActionExecutionMessage,
      RenderAgentStateMessage,
      RenderResultMessage,
      RenderImageMessage
    }),
    [
      RenderTextMessage,
      RenderActionExecutionMessage,
      RenderAgentStateMessage,
      RenderResultMessage,
      RenderImageMessage
    ]
  );
  const MessageRenderer = hasLegacyProps ? (props) => (0, import_jsx_runtime24.jsx)(LegacyRenderMessage, __spreadProps(__spreadValues({}, props), { legacyProps })) : RenderMessage2;
  return (0, import_jsx_runtime24.jsxs)("div", { className: "copilotKitMessages", ref: messagesContainerRef, children: [
    (0, import_jsx_runtime24.jsxs)("div", { className: "copilotKitMessagesContainer", children: [
      messages.map((message, index4) => {
        const isCurrentMessage = index4 === messages.length - 1;
        return (0, import_jsx_runtime24.jsx)(
          MessageRenderer,
          {
            message,
            inProgress,
            index: index4,
            isCurrentMessage,
            AssistantMessage: AssistantMessage2,
            UserMessage: UserMessage2,
            ImageRenderer: ImageRenderer2,
            onRegenerate,
            onCopy,
            onThumbsUp,
            onThumbsDown,
            markdownTagRenderers
          },
          index4
        );
      }),
      interrupt,
      chatError && ErrorMessage && (0, import_jsx_runtime24.jsx)(ErrorMessage, { error: chatError, isCurrentMessage: true })
    ] }),
    (0, import_jsx_runtime24.jsx)("footer", { className: "copilotKitMessagesFooter", ref: messagesEndRef, children })
  ] });
};
function makeInitialMessages(initial) {
  if (!initial)
    return [];
  if (Array.isArray(initial)) {
    return initial.map((message) => {
      return {
        id: message,
        role: "assistant",
        content: message
      };
    });
  }
  return [
    {
      id: initial,
      role: "assistant",
      content: initial
    }
  ];
}
function useScrollToBottom(messages) {
  const messagesEndRef = (0, import_react153.useRef)(null);
  const messagesContainerRef = (0, import_react153.useRef)(null);
  const isProgrammaticScrollRef = (0, import_react153.useRef)(false);
  const isUserScrollUpRef = (0, import_react153.useRef)(false);
  const scrollToBottom = () => {
    if (messagesContainerRef.current && messagesEndRef.current) {
      isProgrammaticScrollRef.current = true;
      messagesContainerRef.current.scrollTop = messagesContainerRef.current.scrollHeight;
    }
  };
  const handleScroll = () => {
    if (isProgrammaticScrollRef.current) {
      isProgrammaticScrollRef.current = false;
      return;
    }
    if (messagesContainerRef.current) {
      const { scrollTop, scrollHeight, clientHeight } = messagesContainerRef.current;
      isUserScrollUpRef.current = scrollTop + clientHeight < scrollHeight;
    }
  };
  (0, import_react153.useEffect)(() => {
    const container = messagesContainerRef.current;
    if (container) {
      container.addEventListener("scroll", handleScroll);
    }
    return () => {
      if (container) {
        container.removeEventListener("scroll", handleScroll);
      }
    };
  }, []);
  (0, import_react153.useEffect)(() => {
    const container = messagesContainerRef.current;
    if (!container) {
      return;
    }
    const mutationObserver = new MutationObserver(() => {
      if (!isUserScrollUpRef.current) {
        scrollToBottom();
      }
    });
    mutationObserver.observe(container, {
      childList: true,
      subtree: true,
      characterData: true
    });
    return () => {
      mutationObserver.disconnect();
    };
  }, []);
  (0, import_react153.useEffect)(() => {
    isUserScrollUpRef.current = false;
    scrollToBottom();
  }, [messages.filter((m10) => m10.role === "user").length]);
  return { messagesEndRef, messagesContainerRef };
}

// node_modules/@copilotkit/react-ui/dist/chunk-ME2WM7IP.mjs
var import_react154 = __toESM(require_react(), 1);
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
function CopilotChat({
  instructions,
  suggestions = "auto",
  onSubmitMessage,
  makeSystemMessage,
  disableSystemMessage,
  onInProgress,
  onStopGeneration,
  onReloadMessages,
  onRegenerate,
  onCopy,
  onThumbsUp,
  onThumbsDown,
  markdownTagRenderers,
  Messages: Messages2 = Messages,
  RenderMessage: RenderMessage2 = RenderMessage,
  RenderSuggestionsList = Suggestions,
  Input: Input2 = Input,
  className,
  icons,
  labels,
  AssistantMessage: AssistantMessage2 = AssistantMessage,
  UserMessage: UserMessage2 = UserMessage,
  ImageRenderer: ImageRenderer2 = ImageRenderer,
  ErrorMessage,
  imageUploadsEnabled,
  inputFileAccept = "image/*",
  hideStopButton,
  observabilityHooks,
  renderError: renderError3,
  onError,
  // Legacy props - deprecated
  RenderTextMessage,
  RenderActionExecutionMessage,
  RenderAgentStateMessage,
  RenderResultMessage,
  RenderImageMessage
}) {
  const {
    additionalInstructions,
    setChatInstructions,
    copilotApiConfig,
    setBannerError,
    setInternalErrorHandler,
    removeInternalErrorHandler
  } = useCopilotContext();
  const { publicApiKey, chatApiEndpoint } = copilotApiConfig;
  const [selectedImages, setSelectedImages] = (0, import_react154.useState)([]);
  const [chatError, setChatError] = (0, import_react154.useState)(null);
  const fileInputRef = (0, import_react154.useRef)(null);
  const triggerObservabilityHook = (0, import_react154.useCallback)(
    (hookName, ...args) => {
      if (publicApiKey && (observabilityHooks == null ? void 0 : observabilityHooks[hookName])) {
        observabilityHooks[hookName](...args);
      }
      if ((observabilityHooks == null ? void 0 : observabilityHooks[hookName]) && !publicApiKey) {
        setBannerError(
          new CopilotKitError({
            message: "observabilityHooks requires a publicApiKey to function.",
            code: CopilotKitErrorCode.MISSING_PUBLIC_API_KEY_ERROR,
            severity: Severity.CRITICAL,
            visibility: ErrorVisibility.BANNER
          })
        );
        styledConsole.publicApiKeyRequired("observabilityHooks");
      }
    },
    [publicApiKey, observabilityHooks, setBannerError]
  );
  const triggerChatError = (0, import_react154.useCallback)(
    (error2, operation, originalError) => {
      const errorMessage = (error2 == null ? void 0 : error2.message) || (error2 == null ? void 0 : error2.toString()) || "An error occurred";
      setChatError({
        message: errorMessage,
        operation,
        timestamp: Date.now()
      });
      const errorEvent = {
        type: "error",
        timestamp: Date.now(),
        context: {
          source: "ui",
          request: {
            operation,
            url: chatApiEndpoint,
            startTime: Date.now()
          },
          technical: {
            environment: "browser",
            userAgent: typeof navigator !== "undefined" ? navigator.userAgent : void 0,
            stackTrace: originalError instanceof Error ? originalError.stack : void 0
          }
        },
        error: error2
      };
      if (onError) {
        onError(errorEvent);
      }
      if (publicApiKey && (observabilityHooks == null ? void 0 : observabilityHooks.onError)) {
        observabilityHooks.onError(errorEvent);
      }
      if ((observabilityHooks == null ? void 0 : observabilityHooks.onError) && !publicApiKey) {
        setBannerError(
          new CopilotKitError({
            message: "observabilityHooks.onError requires a publicApiKey to function.",
            code: CopilotKitErrorCode.MISSING_PUBLIC_API_KEY_ERROR,
            severity: Severity.CRITICAL,
            visibility: ErrorVisibility.BANNER
          })
        );
        styledConsole.publicApiKeyRequired("observabilityHooks.onError");
      }
    },
    [publicApiKey, chatApiEndpoint, observabilityHooks, setBannerError]
  );
  (0, import_react154.useEffect)(() => {
    const id = "chat-component";
    setInternalErrorHandler({
      [id]: (error2) => {
        if (!error2)
          return;
        triggerChatError(error2.error, "sendMessage");
      }
    });
    return () => {
      removeInternalErrorHandler == null ? void 0 : removeInternalErrorHandler(id);
    };
  }, [triggerChatError, setInternalErrorHandler, removeInternalErrorHandler]);
  (0, import_react154.useEffect)(() => {
    if (!imageUploadsEnabled)
      return;
    const handlePaste = (e9) => __async(this, null, function* () {
      var _a2, _b;
      const target = e9.target;
      if (!((_a2 = target.parentElement) == null ? void 0 : _a2.classList.contains("copilotKitInput")))
        return;
      const items = Array.from(((_b = e9.clipboardData) == null ? void 0 : _b.items) || []);
      const imageItems = items.filter((item) => item.type.startsWith("image/"));
      if (imageItems.length === 0)
        return;
      e9.preventDefault();
      const imagePromises = imageItems.map((item) => {
        const file = item.getAsFile();
        if (!file)
          return Promise.resolve(null);
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e22) => {
            var _a22, _b2;
            const base64String = (_b2 = (_a22 = e22.target) == null ? void 0 : _a22.result) == null ? void 0 : _b2.split(",")[1];
            if (base64String) {
              resolve({
                contentType: file.type,
                bytes: base64String
              });
            } else {
              resolve(null);
            }
          };
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      });
      try {
        const loadedImages = (yield Promise.all(imagePromises)).filter((img) => img !== null);
        setSelectedImages((prev) => [...prev, ...loadedImages]);
      } catch (error2) {
        triggerChatError(error2, "processClipboardImages", error2);
        console.error("Error processing pasted images:", error2);
      }
    });
    document.addEventListener("paste", handlePaste);
    return () => document.removeEventListener("paste", handlePaste);
  }, [imageUploadsEnabled, triggerChatError]);
  (0, import_react154.useEffect)(() => {
    if (!(additionalInstructions == null ? void 0 : additionalInstructions.length)) {
      setChatInstructions(instructions || "");
      return;
    }
    const combinedAdditionalInstructions = [
      instructions,
      "Additionally, follow these instructions:",
      ...additionalInstructions.map((instruction) => `- ${instruction}`)
    ];
    setChatInstructions(combinedAdditionalInstructions.join("\n") || "");
  }, [instructions, additionalInstructions]);
  const {
    messages,
    isLoading,
    sendMessage,
    stopGeneration,
    reloadMessages,
    suggestions: currentSuggestions
  } = useCopilotChatLogic(
    suggestions,
    makeSystemMessage,
    disableSystemMessage,
    onInProgress,
    onSubmitMessage,
    onStopGeneration,
    onReloadMessages
  );
  const prevIsLoading = (0, import_react154.useRef)(isLoading);
  (0, import_react154.useEffect)(() => {
    if (prevIsLoading.current !== isLoading) {
      if (isLoading) {
        triggerObservabilityHook("onChatStarted");
      } else {
        triggerObservabilityHook("onChatStopped");
      }
      prevIsLoading.current = isLoading;
    }
  }, [isLoading, triggerObservabilityHook]);
  const handleSendMessage = (text10) => {
    const images = selectedImages;
    setSelectedImages([]);
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
    triggerObservabilityHook("onMessageSent", text10);
    return sendMessage(text10, images);
  };
  const chatContext = import_react154.default.useContext(ChatContext);
  const isVisible = chatContext ? chatContext.open : true;
  const handleRegenerate = (messageId) => {
    if (onRegenerate) {
      onRegenerate(messageId);
    }
    triggerObservabilityHook("onMessageRegenerated", messageId);
    reloadMessages(messageId);
  };
  const handleCopy = (message) => {
    if (onCopy) {
      onCopy(message);
    }
    triggerObservabilityHook("onMessageCopied", message);
  };
  const handleImageUpload = (event) => __async(this, null, function* () {
    if (!event.target.files || event.target.files.length === 0) {
      return;
    }
    const files = Array.from(event.target.files).filter((file) => file.type.startsWith("image/"));
    if (files.length === 0)
      return;
    const fileReadPromises = files.map((file) => {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e9) => {
          var _a2, _b;
          const base64String = ((_b = (_a2 = e9.target) == null ? void 0 : _a2.result) == null ? void 0 : _b.split(",")[1]) || "";
          if (base64String) {
            resolve({
              contentType: file.type,
              bytes: base64String
            });
          }
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    });
    try {
      const loadedImages = yield Promise.all(fileReadPromises);
      setSelectedImages((prev) => [...prev, ...loadedImages]);
    } catch (error2) {
      triggerChatError(error2, "processUploadedImages", error2);
      console.error("Error reading files:", error2);
    }
  });
  const removeSelectedImage = (index4) => {
    setSelectedImages((prev) => prev.filter((_10, i16) => i16 !== index4));
  };
  const handleThumbsUp = (message) => {
    if (onThumbsUp) {
      onThumbsUp(message);
    }
    triggerObservabilityHook("onFeedbackGiven", message.id, "thumbsUp");
  };
  const handleThumbsDown = (message) => {
    if (onThumbsDown) {
      onThumbsDown(message);
    }
    triggerObservabilityHook("onFeedbackGiven", message.id, "thumbsDown");
  };
  return (0, import_jsx_runtime25.jsxs)(WrappedCopilotChat, { icons, labels, className, children: [
    chatError && renderError3 && renderError3(__spreadProps(__spreadValues({}, chatError), {
      onDismiss: () => setChatError(null),
      onRetry: () => {
        setChatError(null);
      }
    })),
    (0, import_jsx_runtime25.jsx)(
      Messages2,
      {
        AssistantMessage: AssistantMessage2,
        UserMessage: UserMessage2,
        RenderMessage: RenderMessage2,
        messages,
        inProgress: isLoading,
        onRegenerate: handleRegenerate,
        onCopy: handleCopy,
        onThumbsUp: handleThumbsUp,
        onThumbsDown: handleThumbsDown,
        markdownTagRenderers,
        ImageRenderer: ImageRenderer2,
        ErrorMessage,
        chatError,
        RenderTextMessage,
        RenderActionExecutionMessage,
        RenderAgentStateMessage,
        RenderResultMessage,
        RenderImageMessage,
        children: currentSuggestions.length > 0 && (0, import_jsx_runtime25.jsx)(
          RenderSuggestionsList,
          {
            onSuggestionClick: handleSendMessage,
            suggestions: currentSuggestions
          }
        )
      }
    ),
    imageUploadsEnabled && (0, import_jsx_runtime25.jsxs)(import_jsx_runtime25.Fragment, { children: [
      (0, import_jsx_runtime25.jsx)(ImageUploadQueue, { images: selectedImages, onRemoveImage: removeSelectedImage }),
      (0, import_jsx_runtime25.jsx)(
        "input",
        {
          type: "file",
          multiple: true,
          ref: fileInputRef,
          onChange: handleImageUpload,
          accept: inputFileAccept,
          style: { display: "none" }
        }
      )
    ] }),
    (0, import_jsx_runtime25.jsx)(
      Input2,
      {
        inProgress: isLoading,
        onSend: handleSendMessage,
        isVisible,
        onStop: stopGeneration,
        onUpload: imageUploadsEnabled ? () => {
          var _a2;
          return (_a2 = fileInputRef.current) == null ? void 0 : _a2.click();
        } : void 0,
        hideStopButton
      }
    )
  ] });
}
function WrappedCopilotChat({
  children,
  icons,
  labels,
  className
}) {
  const chatContext = import_react154.default.useContext(ChatContext);
  if (!chatContext) {
    return (0, import_jsx_runtime25.jsx)(ChatContextProvider, { icons, labels, open: true, setOpen: () => {
    }, children: (0, import_jsx_runtime25.jsx)("div", { className: `copilotKitChat ${className != null ? className : ""}`, children }) });
  }
  return (0, import_jsx_runtime25.jsx)(import_jsx_runtime25.Fragment, { children });
}
var useCopilotChatLogic = (chatSuggestions, makeSystemMessage, disableSystemMessage, onInProgress, onSubmitMessage, onStopGeneration, onReloadMessages) => {
  var _a2;
  const {
    messages,
    sendMessage,
    setMessages,
    reloadMessages: defaultReloadMessages,
    stopGeneration: defaultStopGeneration,
    runChatCompletion,
    isLoading,
    suggestions,
    setSuggestions,
    generateSuggestions,
    resetSuggestions: resetSuggestionsFromHook,
    isLoadingSuggestions
  } = useCopilotChat({
    makeSystemMessage,
    disableSystemMessage
  });
  const generalContext = useCopilotContext();
  const messagesContext = useCopilotMessagesContext();
  const { actions } = generalContext;
  const [suggestionsFailed, setSuggestionsFailed] = (0, import_react154.useState)(false);
  const hasGeneratedInitialSuggestions = (0, import_react154.useRef)(false);
  (0, import_react154.useEffect)(() => {
    if (Array.isArray(chatSuggestions)) {
      setSuggestions(chatSuggestions);
      hasGeneratedInitialSuggestions.current = true;
    }
  }, [JSON.stringify(chatSuggestions), setSuggestions]);
  const generateSuggestionsWithErrorHandling = (0, import_react154.useCallback)(
    (context) => __async(void 0, null, function* () {
      try {
        yield generateSuggestions();
      } catch (error2) {
        console.error("Failed to generate suggestions:", error2);
        setSuggestionsFailed(true);
      }
    }),
    [generateSuggestions]
  );
  (0, import_react154.useEffect)(() => {
    if (chatSuggestions !== "auto" || isLoadingSuggestions || suggestionsFailed) {
      return;
    }
    if (isLoading) {
      return;
    }
    if (Object.keys(generalContext.chatSuggestionConfiguration).length === 0) {
      return;
    }
    if (messages.length === 0 && !hasGeneratedInitialSuggestions.current) {
      hasGeneratedInitialSuggestions.current = true;
      generateSuggestionsWithErrorHandling("initial");
      return;
    }
    if (messages.length > 0 && suggestions.length === 0) {
      generateSuggestionsWithErrorHandling("post-message");
      return;
    }
  }, [
    chatSuggestions,
    isLoadingSuggestions,
    suggestionsFailed,
    messages.length,
    isLoading,
    suggestions.length,
    Object.keys(generalContext.chatSuggestionConfiguration).join(","),
    // Use stable string instead of object reference
    generateSuggestionsWithErrorHandling
  ]);
  (0, import_react154.useEffect)(() => {
    if (chatSuggestions !== "auto") {
      hasGeneratedInitialSuggestions.current = false;
      setSuggestionsFailed(false);
    }
  }, [chatSuggestions]);
  const stableContext = (0, import_react154.useMemo)(
    () => __spreadValues(__spreadValues({}, generalContext), messagesContext),
    [
      // Only include stable dependencies
      generalContext.actions,
      messagesContext.messages.length,
      generalContext.isLoading
    ]
  );
  const resetSuggestions = (0, import_react154.useCallback)(() => {
    resetSuggestionsFromHook();
    setSuggestionsFailed(false);
    hasGeneratedInitialSuggestions.current = false;
  }, [resetSuggestionsFromHook]);
  (0, import_react154.useEffect)(() => {
    onInProgress == null ? void 0 : onInProgress(isLoading);
  }, [onInProgress, isLoading]);
  const safelySendMessage = (messageContent, imagesToUse) => __async(void 0, null, function* () {
    const images = imagesToUse || [];
    if (chatSuggestions === "auto" || chatSuggestions === "manual") {
      setSuggestions([]);
    }
    let firstMessage = null;
    if (messageContent.trim().length > 0) {
      const textMessage = {
        id: randomId(),
        role: "user",
        content: messageContent
      };
      if (onSubmitMessage) {
        try {
          yield onSubmitMessage(messageContent);
        } catch (error2) {
          console.error("Error in onSubmitMessage:", error2);
        }
      }
      yield sendMessage(textMessage, {
        followUp: images.length === 0,
        clearSuggestions: chatSuggestions === "auto" || chatSuggestions === "manual"
      });
      if (!firstMessage) {
        firstMessage = textMessage;
      }
    }
    if (images.length > 0) {
      for (let i16 = 0; i16 < images.length; i16++) {
        const imageMessage = {
          id: randomId(),
          role: "user",
          image: {
            format: images[i16].contentType.replace("image/", ""),
            bytes: images[i16].bytes
          }
        };
        yield sendMessage(imageMessage, { followUp: i16 === images.length - 1 });
        if (!firstMessage) {
          firstMessage = imageMessage;
        }
      }
    }
    if (!firstMessage) {
      return { role: "user", content: "", id: randomId() };
    }
    return firstMessage;
  });
  const currentAgentName = (_a2 = generalContext.agentSession) == null ? void 0 : _a2.agentName;
  const restartCurrentAgent = (hint) => __async(void 0, null, function* () {
    if (generalContext.agentSession) {
      generalContext.setAgentSession(__spreadProps(__spreadValues({}, generalContext.agentSession), {
        nodeName: void 0,
        threadId: void 0
      }));
      generalContext.setCoagentStates((prevAgentStates) => {
        return __spreadProps(__spreadValues({}, prevAgentStates), {
          [generalContext.agentSession.agentName]: __spreadProps(__spreadValues({}, prevAgentStates[generalContext.agentSession.agentName]), {
            threadId: void 0,
            nodeName: void 0,
            runId: void 0
          })
        });
      });
    }
  });
  const runCurrentAgent = (hint) => __async(void 0, null, function* () {
    if (generalContext.agentSession) {
      yield runAgent(
        generalContext.agentSession.agentName,
        stableContext,
        messagesContext.messages,
        sendMessage,
        runChatCompletion
      );
    }
  });
  const stopCurrentAgent = () => {
    if (generalContext.agentSession) {
      stopAgent(generalContext.agentSession.agentName, stableContext);
    }
  };
  const setCurrentAgentState = (state) => {
    if (generalContext.agentSession) {
      generalContext.setCoagentStates((prevAgentStates) => {
        return __spreadProps(__spreadValues({}, prevAgentStates), {
          [generalContext.agentSession.agentName]: {
            state
          }
        });
      });
    }
  };
  function stopGeneration() {
    setSuggestions([]);
    if (onStopGeneration) {
      onStopGeneration({
        messages,
        setMessages,
        stopGeneration: defaultStopGeneration,
        currentAgentName,
        restartCurrentAgent,
        stopCurrentAgent,
        runCurrentAgent,
        setCurrentAgentState
      });
    } else {
      defaultStopGeneration();
    }
  }
  function reloadMessages(messageId) {
    if (onReloadMessages) {
      onReloadMessages({
        messages,
        setMessages,
        stopGeneration: defaultStopGeneration,
        currentAgentName,
        restartCurrentAgent,
        stopCurrentAgent,
        runCurrentAgent,
        setCurrentAgentState,
        messageId
      });
    } else {
      defaultReloadMessages(messageId);
    }
  }
  return {
    messages,
    isLoading,
    suggestions,
    sendMessage: safelySendMessage,
    stopGeneration,
    reloadMessages,
    resetSuggestions,
    context: stableContext,
    actions
  };
};

// node_modules/@copilotkit/react-ui/dist/chunk-H5Y4W7DM.mjs
var import_react155 = __toESM(require_react(), 1);
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var CopilotModalInner = (_a2) => {
  var _b = _a2, {
    observabilityHooks,
    onSetOpen,
    clickOutsideToClose,
    hitEscapeToClose,
    shortcut,
    className,
    children,
    Window: Window2,
    Button: Button2,
    Header: Header2
  } = _b, chatProps = __objRest(_b, [
    "observabilityHooks",
    "onSetOpen",
    "clickOutsideToClose",
    "hitEscapeToClose",
    "shortcut",
    "className",
    "children",
    "Window",
    "Button",
    "Header"
  ]);
  const { copilotApiConfig, setBannerError } = useCopilotContext();
  const { publicApiKey } = copilotApiConfig;
  const triggerObservabilityHook = (0, import_react155.useCallback)(
    (hookName, ...args) => {
      if (publicApiKey && (observabilityHooks == null ? void 0 : observabilityHooks[hookName])) {
        observabilityHooks[hookName](...args);
      }
      if ((observabilityHooks == null ? void 0 : observabilityHooks[hookName]) && !publicApiKey) {
        setBannerError(
          new CopilotKitError({
            message: "observabilityHooks requires a publicApiKey to function.",
            code: CopilotKitErrorCode.MISSING_PUBLIC_API_KEY_ERROR,
            severity: Severity.CRITICAL,
            visibility: ErrorVisibility.BANNER
          })
        );
        styledConsole.publicApiKeyRequired("observabilityHooks");
      }
    },
    [publicApiKey, observabilityHooks, setBannerError]
  );
  const { open: open2 } = useChatContext();
  const prevOpen = (0, import_react155.useRef)(open2);
  (0, import_react155.useEffect)(() => {
    if (prevOpen.current !== open2) {
      onSetOpen == null ? void 0 : onSetOpen(open2);
      if (open2) {
        triggerObservabilityHook("onChatExpanded");
      } else {
        triggerObservabilityHook("onChatMinimized");
      }
      prevOpen.current = open2;
    }
  }, [open2, onSetOpen, triggerObservabilityHook]);
  const memoizedHeader = (0, import_react155.useMemo)(() => (0, import_jsx_runtime26.jsx)(Header2, {}), [Header2]);
  const memoizedChildren = (0, import_react155.useMemo)(() => children, [children]);
  return (0, import_jsx_runtime26.jsxs)(import_jsx_runtime26.Fragment, { children: [
    memoizedChildren,
    (0, import_jsx_runtime26.jsxs)("div", { className, children: [
      (0, import_jsx_runtime26.jsx)(Button2, {}),
      (0, import_jsx_runtime26.jsxs)(
        Window2,
        {
          clickOutsideToClose,
          shortcut,
          hitEscapeToClose,
          children: [
            memoizedHeader,
            (0, import_jsx_runtime26.jsx)(CopilotChat, __spreadProps(__spreadValues({}, chatProps), { observabilityHooks }))
          ]
        }
      )
    ] })
  ] });
};
var CopilotModal = (_a2) => {
  var _b = _a2, {
    instructions,
    defaultOpen = false,
    clickOutsideToClose = true,
    hitEscapeToClose = true,
    onSetOpen,
    onSubmitMessage,
    onStopGeneration,
    onReloadMessages,
    shortcut = "/",
    icons,
    labels,
    makeSystemMessage,
    onInProgress,
    Window: Window2 = Window,
    Button: Button2 = Button,
    Header: Header2 = Header,
    Messages: Messages2 = Messages,
    Input: Input2 = Input,
    AssistantMessage: AssistantMessage2 = AssistantMessage,
    UserMessage: UserMessage2 = UserMessage,
    onThumbsUp,
    onThumbsDown,
    onCopy,
    onRegenerate,
    markdownTagRenderers,
    className,
    children,
    observabilityHooks
  } = _b, props = __objRest(_b, [
    "instructions",
    "defaultOpen",
    "clickOutsideToClose",
    "hitEscapeToClose",
    "onSetOpen",
    "onSubmitMessage",
    "onStopGeneration",
    "onReloadMessages",
    "shortcut",
    "icons",
    "labels",
    "makeSystemMessage",
    "onInProgress",
    "Window",
    "Button",
    "Header",
    "Messages",
    "Input",
    "AssistantMessage",
    "UserMessage",
    "onThumbsUp",
    "onThumbsDown",
    "onCopy",
    "onRegenerate",
    "markdownTagRenderers",
    "className",
    "children",
    "observabilityHooks"
  ]);
  const [openState, setOpenState] = import_react155.default.useState(defaultOpen);
  return (0, import_jsx_runtime26.jsx)(ChatContextProvider, { icons, labels, open: openState, setOpen: setOpenState, children: (0, import_jsx_runtime26.jsx)(
    CopilotModalInner,
    __spreadProps(__spreadValues({
      observabilityHooks,
      onSetOpen,
      clickOutsideToClose: clickOutsideToClose != null ? clickOutsideToClose : true,
      hitEscapeToClose: hitEscapeToClose != null ? hitEscapeToClose : true,
      shortcut: shortcut != null ? shortcut : "/",
      className,
      Window: Window2,
      Button: Button2,
      Header: Header2,
      instructions,
      onSubmitMessage,
      onStopGeneration,
      onReloadMessages,
      makeSystemMessage,
      onInProgress,
      Messages: Messages2,
      Input: Input2,
      AssistantMessage: AssistantMessage2,
      UserMessage: UserMessage2,
      onThumbsUp,
      onThumbsDown,
      onCopy,
      onRegenerate,
      markdownTagRenderers
    }, props), {
      children
    })
  ) });
};

// node_modules/@copilotkit/react-ui/dist/chunk-7RDGZ5JL.mjs
var import_react156 = __toESM(require_react(), 1);
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
function CopilotSidebar(props) {
  props = __spreadProps(__spreadValues({}, props), {
    className: props.className ? props.className + " copilotKitSidebar" : "copilotKitSidebar"
  });
  const [expandedClassName, setExpandedClassName] = (0, import_react156.useState)(
    props.defaultOpen ? "sidebarExpanded" : ""
  );
  const onSetOpen = (open2) => {
    var _a2;
    (_a2 = props.onSetOpen) == null ? void 0 : _a2.call(props, open2);
    setExpandedClassName(open2 ? "sidebarExpanded" : "");
  };
  return (0, import_jsx_runtime27.jsx)("div", { className: `copilotKitSidebarContentWrapper ${expandedClassName}`, children: (0, import_jsx_runtime27.jsx)(CopilotModal, __spreadProps(__spreadValues(__spreadValues({}, props), { onSetOpen }), { children: props.children })) });
}

// node_modules/@copilotkit/react-ui/dist/chunk-BAD2NFZ7.mjs
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
function CopilotPopup(props) {
  props = __spreadProps(__spreadValues({}, props), {
    className: props.className ? props.className + " copilotKitPopup" : "copilotKitPopup"
  });
  return (0, import_jsx_runtime28.jsx)(CopilotModal, __spreadProps(__spreadValues({}, props), { children: props.children }));
}

// node_modules/@copilotkit/react-ui/dist/chunk-EYRKZDP5.mjs
var import_react157 = __toESM(require_react(), 1);
function useCopilotChatSuggestions({
  available = "enabled",
  instructions,
  className,
  minSuggestions = 1,
  maxSuggestions = 3
}, dependencies = []) {
  const context = useCopilotContext();
  (0, import_react157.useEffect)(() => {
    if (available === "disabled")
      return;
    const id = randomId();
    context.addChatSuggestionConfiguration(id, {
      instructions,
      minSuggestions,
      maxSuggestions,
      className
    });
    return () => {
      context.removeChatSuggestionConfiguration(id);
    };
  }, [...dependencies, instructions, minSuggestions, maxSuggestions, className, available]);
}
export {
  AssistantMessage,
  CopilotChat,
  CopilotDevConsole,
  CopilotPopup,
  CopilotSidebar,
  ImageRenderer,
  Markdown2 as Markdown,
  Suggestion as RenderSuggestion,
  Suggestions as RenderSuggestionsList,
  UserMessage,
  shouldShowDevConsole,
  useChatContext,
  useCopilotChatSuggestions
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.3.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

react-syntax-highlighter/dist/esm/async-syntax-highlighter.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

react-syntax-highlighter/dist/esm/async-languages/create-language-async-loader.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)
*/
//# sourceMappingURL=@copilotkit_react-ui.js.map
